
vmm/guest/obj/net/ns:     formato del fichero elf64-x86-64


Desensamblado de la secci√≥n .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 1c 0e 00 00       	callq  800e5d <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>

0000000000800043 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800043:	55                   	push   %rbp
  800044:	48 89 e5             	mov    %rsp,%rbp
  800047:	48 83 ec 08          	sub    $0x8,%rsp
  80004b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800051:	8d 48 01             	lea    0x1(%rax),%ecx
  800054:	ba 67 66 66 66       	mov    $0x66666667,%edx
  800059:	89 c8                	mov    %ecx,%eax
  80005b:	f7 ea                	imul   %edx
  80005d:	c1 fa 03             	sar    $0x3,%edx
  800060:	89 c8                	mov    %ecx,%eax
  800062:	c1 f8 1f             	sar    $0x1f,%eax
  800065:	29 c2                	sub    %eax,%edx
  800067:	89 d0                	mov    %edx,%eax
  800069:	c1 e0 02             	shl    $0x2,%eax
  80006c:	01 d0                	add    %edx,%eax
  80006e:	c1 e0 02             	shl    $0x2,%eax
  800071:	29 c1                	sub    %eax,%ecx
  800073:	89 ca                	mov    %ecx,%edx
  800075:	89 d0                	mov    %edx,%eax
  800077:	c9                   	leaveq 
  800078:	c3                   	retq   

0000000000800079 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800079:	55                   	push   %rbp
  80007a:	48 89 e5             	mov    %rsp,%rbp
  80007d:	48 83 ec 08          	sub    $0x8,%rsp
  800081:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800084:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800088:	74 08                	je     800092 <prev_i+0x19>
  80008a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008d:	83 e8 01             	sub    $0x1,%eax
  800090:	eb 05                	jmp    800097 <prev_i+0x1e>
  800092:	b8 13 00 00 00       	mov    $0x13,%eax
  800097:	c9                   	leaveq 
  800098:	c3                   	retq   

0000000000800099 <get_buffer>:

static void *
get_buffer(void) {
  800099:	55                   	push   %rbp
  80009a:	48 89 e5             	mov    %rsp,%rbp
  80009d:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a8:	00 
  8000a9:	eb 22                	jmp    8000cd <get_buffer+0x34>
        if (!buse[i]) break;
  8000ab:	48 ba 70 80 82 00 00 	movabs $0x828070,%rdx
  8000b2:	00 00 00 
  8000b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000b9:	48 01 d0             	add    %rdx,%rax
  8000bc:	0f b6 00             	movzbl (%rax),%eax
  8000bf:	83 f0 01             	xor    $0x1,%eax
  8000c2:	84 c0                	test   %al,%al
  8000c4:	74 02                	je     8000c8 <get_buffer+0x2f>
  8000c6:	eb 0c                	jmp    8000d4 <get_buffer+0x3b>
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cd:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d2:	7e d7                	jle    8000ab <get_buffer+0x12>

    if (i == QUEUE_SIZE) {
  8000d4:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000d9:	75 2a                	jne    800105 <get_buffer+0x6c>
        panic("NS: buffer overflow");
  8000db:	48 ba 00 ff 81 00 00 	movabs $0x81ff00,%rdx
  8000e2:	00 00 00 
  8000e5:	be 3f 00 00 00       	mov    $0x3f,%esi
  8000ea:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  8000f1:	00 00 00 
  8000f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8000f9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  800100:	00 00 00 
  800103:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800109:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  80010f:	48 c1 e0 0c          	shl    $0xc,%rax
  800113:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800117:	48 ba 70 80 82 00 00 	movabs $0x828070,%rdx
  80011e:	00 00 00 
  800121:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800125:	48 01 d0             	add    %rdx,%rax
  800128:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80012f:	c9                   	leaveq 
  800130:	c3                   	retq   

0000000000800131 <put_buffer>:

static void
put_buffer(void *va) {
  800131:	55                   	push   %rbp
  800132:	48 89 e5             	mov    %rsp,%rbp
  800135:	48 83 ec 18          	sub    $0x18,%rsp
  800139:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800141:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800147:	48 c1 e8 0c          	shr    $0xc,%rax
  80014b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  80014f:	48 ba 70 80 82 00 00 	movabs $0x828070,%rdx
  800156:	00 00 00 
  800159:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015d:	48 01 d0             	add    %rdx,%rax
  800160:	c6 00 00             	movb   $0x0,(%rax)
}
  800163:	c9                   	leaveq 
  800164:	c3                   	retq   

0000000000800165 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800165:	55                   	push   %rbp
  800166:	48 89 e5             	mov    %rsp,%rbp
  800169:	48 83 ec 50          	sub    $0x50,%rsp
  80016d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800171:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800175:	89 55 bc             	mov    %edx,-0x44(%rbp)
  800178:	89 4d b8             	mov    %ecx,-0x48(%rbp)
  80017b:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  80017f:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800182:	89 45 f0             	mov    %eax,-0x10(%rbp)
    netmask.addr = init_mask;
  800185:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800188:	89 45 e0             	mov    %eax,-0x20(%rbp)
    gateway.addr = init_gw;
  80018b:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80018e:	89 45 d0             	mov    %eax,-0x30(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800191:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  800195:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800199:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80019d:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8001a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8001a5:	48 83 ec 08          	sub    $0x8,%rsp
  8001a9:	49 ba a6 02 81 00 00 	movabs $0x8102a6,%r10
  8001b0:	00 00 00 
  8001b3:	41 52                	push   %r10
  8001b5:	49 b9 b3 8d 81 00 00 	movabs $0x818db3,%r9
  8001bc:	00 00 00 
  8001bf:	49 89 f8             	mov    %rdi,%r8
  8001c2:	48 89 c7             	mov    %rax,%rdi
  8001c5:	48 b8 a9 c3 80 00 00 	movabs $0x80c3a9,%rax
  8001cc:	00 00 00 
  8001cf:	ff d0                	callq  *%rax
  8001d1:	48 83 c4 10          	add    $0x10,%rsp
  8001d5:	48 85 c0             	test   %rax,%rax
  8001d8:	75 2a                	jne    800204 <lwip_init+0x9f>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001da:	48 ba 20 ff 81 00 00 	movabs $0x81ff20,%rdx
  8001e1:	00 00 00 
  8001e4:	be 5c 00 00 00       	mov    $0x5c,%esi
  8001e9:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  8001f0:	00 00 00 
  8001f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8001f8:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8001ff:	00 00 00 
  800202:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  800204:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800208:	48 89 c7             	mov    %rax,%rdi
  80020b:	48 b8 a9 c7 80 00 00 	movabs $0x80c7a9,%rax
  800212:	00 00 00 
  800215:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800217:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80021b:	48 89 c7             	mov    %rax,%rdi
  80021e:	48 b8 c8 c7 80 00 00 	movabs $0x80c7c8,%rax
  800225:	00 00 00 
  800228:	ff d0                	callq  *%rax
}
  80022a:	c9                   	leaveq 
  80022b:	c3                   	retq   

000000000080022c <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022c:	55                   	push   %rbp
  80022d:	48 89 e5             	mov    %rsp,%rbp
  800230:	48 83 ec 20          	sub    $0x20,%rsp
  800234:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  800238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800240:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  800247:	00 00 00 
  80024a:	ff d0                	callq  *%rax
  80024c:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  80024f:	48 b8 27 7f 81 00 00 	movabs $0x817f27,%rax
  800256:	00 00 00 
  800259:	ff d0                	callq  *%rax
        t->func();
  80025b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80025f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800263:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800265:	48 b8 2d 7f 81 00 00 	movabs $0x817f2d,%rax
  80026c:	00 00 00 
  80026f:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800275:	8b 10                	mov    (%rax),%edx
  800277:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80027a:	01 d0                	add    %edx,%eax
  80027c:	89 c2                	mov    %eax,%edx
  80027e:	be 00 00 00 00       	mov    $0x0,%esi
  800283:	bf 00 00 00 00       	mov    $0x0,%edi
  800288:	48 b8 a2 80 81 00 00 	movabs $0x8180a2,%rax
  80028f:	00 00 00 
  800292:	ff d0                	callq  *%rax
    }
  800294:	eb aa                	jmp    800240 <net_timer+0x14>

0000000000800296 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800296:	55                   	push   %rbp
  800297:	48 89 e5             	mov    %rsp,%rbp
  80029a:	48 83 ec 30          	sub    $0x30,%rsp
  80029e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002aa:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002ad:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b4:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002be:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d6:	48 89 d1             	mov    %rdx,%rcx
  8002d9:	48 ba 2c 02 80 00 00 	movabs $0x80022c,%rdx
  8002e0:	00 00 00 
  8002e3:	48 89 c6             	mov    %rax,%rsi
  8002e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8002eb:	48 b8 17 83 81 00 00 	movabs $0x818317,%rax
  8002f2:	00 00 00 
  8002f5:	ff d0                	callq  *%rax
  8002f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8002fe:	79 3f                	jns    80033f <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800303:	89 c7                	mov    %eax,%edi
  800305:	48 b8 a5 89 81 00 00 	movabs $0x8189a5,%rax
  80030c:	00 00 00 
  80030f:	ff d0                	callq  *%rax
  800311:	48 89 c1             	mov    %rax,%rcx
  800314:	48 ba 40 ff 81 00 00 	movabs $0x81ff40,%rdx
  80031b:	00 00 00 
  80031e:	be 7a 00 00 00       	mov    $0x7a,%esi
  800323:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  80032a:	00 00 00 
  80032d:	b8 00 00 00 00       	mov    $0x0,%eax
  800332:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  800339:	00 00 00 
  80033c:	41 ff d0             	callq  *%r8
}
  80033f:	c9                   	leaveq 
  800340:	c3                   	retq   

0000000000800341 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800341:	55                   	push   %rbp
  800342:	48 89 e5             	mov    %rsp,%rbp
  800345:	48 83 ec 20          	sub    $0x20,%rsp
  800349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  80034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800351:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800359:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  80035f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800363:	48 89 c7             	mov    %rax,%rdi
  800366:	48 b8 4f 80 81 00 00 	movabs $0x81804f,%rax
  80036d:	00 00 00 
  800370:	ff d0                	callq  *%rax
}
  800372:	c9                   	leaveq 
  800373:	c3                   	retq   

0000000000800374 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800374:	55                   	push   %rbp
  800375:	48 89 e5             	mov    %rsp,%rbp
  800378:	48 83 ec 20          	sub    $0x20,%rsp
  80037c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80037f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800382:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  800385:	48 b8 27 7f 81 00 00 	movabs $0x817f27,%rax
  80038c:	00 00 00 
  80038f:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  800398:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80039c:	48 89 c6             	mov    %rax,%rsi
  80039f:	48 bf 41 03 80 00 00 	movabs $0x800341,%rdi
  8003a6:	00 00 00 
  8003a9:	48 b8 49 81 80 00 00 	movabs $0x808149,%rax
  8003b0:	00 00 00 
  8003b3:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003b5:	48 b8 2d 7f 81 00 00 	movabs $0x817f2d,%rax
  8003bc:	00 00 00 
  8003bf:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003c5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003ca:	be 00 00 00 00       	mov    $0x0,%esi
  8003cf:	48 89 c7             	mov    %rax,%rdi
  8003d2:	48 b8 a2 80 81 00 00 	movabs $0x8180a2,%rax
  8003d9:	00 00 00 
  8003dc:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003de:	48 b8 27 7f 81 00 00 	movabs $0x817f27,%rax
  8003e5:	00 00 00 
  8003e8:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f3:	41 89 c8             	mov    %ecx,%r8d
  8003f6:	89 d1                	mov    %edx,%ecx
  8003f8:	89 c2                	mov    %eax,%edx
  8003fa:	48 be 60 80 82 00 00 	movabs $0x828060,%rsi
  800401:	00 00 00 
  800404:	48 bf 00 66 b5 00 00 	movabs $0xb56600,%rdi
  80040b:	00 00 00 
  80040e:	48 b8 65 01 80 00 00 	movabs $0x800165,%rax
  800415:	00 00 00 
  800418:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041a:	b9 88 13 00 00       	mov    $0x1388,%ecx
  80041f:	48 ba 5f ff 81 00 00 	movabs $0x81ff5f,%rdx
  800426:	00 00 00 
  800429:	48 be 2a 4f 81 00 00 	movabs $0x814f2a,%rsi
  800430:	00 00 00 
  800433:	48 bf 00 80 82 00 00 	movabs $0x828000,%rdi
  80043a:	00 00 00 
  80043d:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800444:	00 00 00 
  800447:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800449:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  80044e:	48 ba 69 ff 81 00 00 	movabs $0x81ff69,%rdx
  800455:	00 00 00 
  800458:	48 be 31 f7 80 00 00 	movabs $0x80f731,%rsi
  80045f:	00 00 00 
  800462:	48 bf 20 80 82 00 00 	movabs $0x828020,%rdi
  800469:	00 00 00 
  80046c:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800473:	00 00 00 
  800476:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800478:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  80047d:	48 ba 75 ff 81 00 00 	movabs $0x81ff75,%rdx
  800484:	00 00 00 
  800487:	48 be f3 ee 80 00 00 	movabs $0x80eef3,%rsi
  80048e:	00 00 00 
  800491:	48 bf 40 80 82 00 00 	movabs $0x828040,%rdi
  800498:	00 00 00 
  80049b:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  8004a2:	00 00 00 
  8004a5:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004aa:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ad:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b0:	89 c7                	mov    %eax,%edi
  8004b2:	48 b8 19 23 81 00 00 	movabs $0x812319,%rax
  8004b9:	00 00 00 
  8004bc:	ff d0                	callq  *%rax
  8004be:	49 89 c1             	mov    %rax,%r9
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004c1:	48 b8 00 66 b5 00 00 	movabs $0xb56600,%rax
  8004c8:	00 00 00 
  8004cb:	0f b6 40 46          	movzbl 0x46(%rax),%eax
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004cf:	0f b6 f0             	movzbl %al,%esi
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004d2:	48 b8 00 66 b5 00 00 	movabs $0xb56600,%rax
  8004d9:	00 00 00 
  8004dc:	0f b6 40 45          	movzbl 0x45(%rax),%eax
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004e0:	44 0f b6 c0          	movzbl %al,%r8d
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e4:	48 b8 00 66 b5 00 00 	movabs $0xb56600,%rax
  8004eb:	00 00 00 
  8004ee:	0f b6 40 44          	movzbl 0x44(%rax),%eax
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004f2:	0f b6 f8             	movzbl %al,%edi
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004f5:	48 b8 00 66 b5 00 00 	movabs $0xb56600,%rax
  8004fc:	00 00 00 
  8004ff:	0f b6 40 43          	movzbl 0x43(%rax),%eax
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800503:	0f b6 c8             	movzbl %al,%ecx
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800506:	48 b8 00 66 b5 00 00 	movabs $0xb56600,%rax
  80050d:	00 00 00 
  800510:	0f b6 40 42          	movzbl 0x42(%rax),%eax
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800514:	0f b6 d0             	movzbl %al,%edx
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800517:	48 b8 00 66 b5 00 00 	movabs $0xb56600,%rax
  80051e:	00 00 00 
  800521:	0f b6 40 41          	movzbl 0x41(%rax),%eax
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800525:	0f b6 c0             	movzbl %al,%eax
  800528:	41 51                	push   %r9
  80052a:	56                   	push   %rsi
  80052b:	45 89 c1             	mov    %r8d,%r9d
  80052e:	41 89 f8             	mov    %edi,%r8d
  800531:	89 c6                	mov    %eax,%esi
  800533:	48 bf 88 ff 81 00 00 	movabs $0x81ff88,%rdi
  80053a:	00 00 00 
  80053d:	b8 00 00 00 00       	mov    $0x0,%eax
  800542:	49 ba 19 11 80 00 00 	movabs $0x801119,%r10
  800549:	00 00 00 
  80054c:	41 ff d2             	callq  *%r10
  80054f:	48 83 c4 10          	add    $0x10,%rsp
            inet_ntoa(ia));

    lwip_core_unlock();
  800553:	48 b8 2d 7f 81 00 00 	movabs $0x817f2d,%rax
  80055a:	00 00 00 
  80055d:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  80055f:	48 bf c1 ff 81 00 00 	movabs $0x81ffc1,%rdi
  800566:	00 00 00 
  800569:	b8 00 00 00 00       	mov    $0x0,%eax
  80056e:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  800575:	00 00 00 
  800578:	ff d2                	callq  *%rdx
}
  80057a:	c9                   	leaveq 
  80057b:	c3                   	retq   

000000000080057c <process_timer>:

static void
process_timer(envid_t envid) {
  80057c:	55                   	push   %rbp
  80057d:	48 89 e5             	mov    %rsp,%rbp
  800580:	48 83 ec 20          	sub    $0x20,%rsp
  800584:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  800587:	48 b8 58 80 82 00 00 	movabs $0x828058,%rax
  80058e:	00 00 00 
  800591:	8b 00                	mov    (%rax),%eax
  800593:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  800596:	74 22                	je     8005ba <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800598:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80059b:	89 c6                	mov    %eax,%esi
  80059d:	48 bf e0 ff 81 00 00 	movabs $0x81ffe0,%rdi
  8005a4:	00 00 00 
  8005a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8005ac:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8005b3:	00 00 00 
  8005b6:	ff d2                	callq  *%rdx
        return;
  8005b8:	eb 56                	jmp    800610 <process_timer+0x94>
    }

    start = sys_time_msec();
  8005ba:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  8005c1:	00 00 00 
  8005c4:	ff d0                	callq  *%rax
  8005c6:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005c9:	48 b8 9c 85 81 00 00 	movabs $0x81859c,%rax
  8005d0:	00 00 00 
  8005d3:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005d5:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  8005dc:	00 00 00 
  8005df:	ff d0                	callq  *%rax
  8005e1:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8005e7:	2b 45 f8             	sub    -0x8(%rbp),%eax
  8005ea:	05 fa 00 00 00       	add    $0xfa,%eax
  8005ef:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005f2:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005f8:	b9 00 00 00 00       	mov    $0x0,%ecx
  8005fd:	ba 00 00 00 00       	mov    $0x0,%edx
  800602:	89 c7                	mov    %eax,%edi
  800604:	48 b8 66 2a 80 00 00 	movabs $0x802a66,%rax
  80060b:	00 00 00 
  80060e:	ff d0                	callq  *%rax
}
  800610:	c9                   	leaveq 
  800611:	c3                   	retq   

0000000000800612 <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  800612:	55                   	push   %rbp
  800613:	48 89 e5             	mov    %rsp,%rbp
  800616:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80061d:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  800624:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80062b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  80062f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800633:	48 8b 40 08          	mov    0x8(%rax),%rax
  800637:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  80063b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80063f:	8b 00                	mov    (%rax),%eax
  800641:	83 f8 0a             	cmp    $0xa,%eax
  800644:	0f 87 d8 01 00 00    	ja     800822 <serve_thread+0x210>
  80064a:	89 c0                	mov    %eax,%eax
  80064c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800653:	00 
  800654:	48 b8 58 00 82 00 00 	movabs $0x820058,%rax
  80065b:	00 00 00 
  80065e:	48 01 d0             	add    %rdx,%rax
  800661:	48 8b 00             	mov    (%rax),%rax
  800664:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800666:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80066a:	8b 00                	mov    (%rax),%eax
  80066c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800670:	48 83 c2 10          	add    $0x10,%rdx
  800674:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800678:	48 89 ce             	mov    %rcx,%rsi
  80067b:	89 c7                	mov    %eax,%edi
  80067d:	48 b8 51 53 80 00 00 	movabs $0x805351,%rax
  800684:	00 00 00 
  800687:	ff d0                	callq  *%rax
  800689:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  80068c:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800690:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800694:	ba 14 00 00 00       	mov    $0x14,%edx
  800699:	48 89 ce             	mov    %rcx,%rsi
  80069c:	48 89 c7             	mov    %rax,%rdi
  80069f:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  8006a6:	00 00 00 
  8006a9:	ff d0                	callq  *%rax
                break;
  8006ab:	90                   	nop
  8006ac:	e9 a5 01 00 00       	jmpq   800856 <serve_thread+0x244>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b5:	8b 50 14             	mov    0x14(%rax),%edx
  8006b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006bc:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c4:	8b 00                	mov    (%rax),%eax
  8006c6:	48 89 ce             	mov    %rcx,%rsi
  8006c9:	89 c7                	mov    %eax,%edi
  8006cb:	48 b8 7e 56 80 00 00 	movabs $0x80567e,%rax
  8006d2:	00 00 00 
  8006d5:	ff d0                	callq  *%rax
  8006d7:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006da:	e9 77 01 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e3:	8b 50 04             	mov    0x4(%rax),%edx
  8006e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006ea:	8b 00                	mov    (%rax),%eax
  8006ec:	89 d6                	mov    %edx,%esi
  8006ee:	89 c7                	mov    %eax,%edi
  8006f0:	48 b8 f2 6d 80 00 00 	movabs $0x806df2,%rax
  8006f7:	00 00 00 
  8006fa:	ff d0                	callq  *%rax
  8006fc:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  8006ff:	e9 52 01 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  800704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800708:	8b 00                	mov    (%rax),%eax
  80070a:	89 c7                	mov    %eax,%edi
  80070c:	48 b8 b3 57 80 00 00 	movabs $0x8057b3,%rax
  800713:	00 00 00 
  800716:	ff d0                	callq  *%rax
  800718:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  80071b:	e9 36 01 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800720:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800724:	8b 50 14             	mov    0x14(%rax),%edx
  800727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80072b:	48 8d 48 04          	lea    0x4(%rax),%rcx
  80072f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800733:	8b 00                	mov    (%rax),%eax
  800735:	48 89 ce             	mov    %rcx,%rsi
  800738:	89 c7                	mov    %eax,%edi
  80073a:	48 b8 98 58 80 00 00 	movabs $0x805898,%rax
  800741:	00 00 00 
  800744:	ff d0                	callq  *%rax
  800746:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  800749:	e9 08 01 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80074e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800752:	8b 50 04             	mov    0x4(%rax),%edx
  800755:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800759:	8b 00                	mov    (%rax),%eax
  80075b:	89 d6                	mov    %edx,%esi
  80075d:	89 c7                	mov    %eax,%edi
  80075f:	48 b8 f4 59 80 00 00 	movabs $0x8059f4,%rax
  800766:	00 00 00 
  800769:	ff d0                	callq  *%rax
  80076b:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  80076e:	e9 e3 00 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800773:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800777:	8b 48 08             	mov    0x8(%rax),%ecx
  80077a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80077e:	8b 50 04             	mov    0x4(%rax),%edx
  800781:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800785:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800789:	8b 00                	mov    (%rax),%eax
  80078b:	89 c7                	mov    %eax,%edi
  80078d:	48 b8 f3 5e 80 00 00 	movabs $0x805ef3,%rax
  800794:	00 00 00 
  800797:	ff d0                	callq  *%rax
  800799:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  80079c:	e9 b5 00 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a5:	8b 48 08             	mov    0x8(%rax),%ecx
  8007a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007ac:	8b 50 04             	mov    0x4(%rax),%edx
  8007af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b3:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007bb:	8b 00                	mov    (%rax),%eax
  8007bd:	89 c7                	mov    %eax,%edi
  8007bf:	48 b8 31 5f 80 00 00 	movabs $0x805f31,%rax
  8007c6:	00 00 00 
  8007c9:	ff d0                	callq  *%rax
  8007cb:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007ce:	e9 83 00 00 00       	jmpq   800856 <serve_thread+0x244>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007d7:	8b 50 08             	mov    0x8(%rax),%edx
  8007da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007de:	8b 48 04             	mov    0x4(%rax),%ecx
  8007e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e5:	8b 00                	mov    (%rax),%eax
  8007e7:	89 ce                	mov    %ecx,%esi
  8007e9:	89 c7                	mov    %eax,%edi
  8007eb:	48 b8 51 62 80 00 00 	movabs $0x806251,%rax
  8007f2:	00 00 00 
  8007f5:	ff d0                	callq  *%rax
  8007f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  8007fa:	eb 5a                	jmp    800856 <serve_thread+0x244>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  8007fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800800:	48 89 c6             	mov    %rax,%rsi
  800803:	48 bf 00 66 b5 00 00 	movabs $0xb56600,%rdi
  80080a:	00 00 00 
  80080d:	48 b8 b8 8c 81 00 00 	movabs $0x818cb8,%rax
  800814:	00 00 00 
  800817:	ff d0                	callq  *%rax
            r = 0;
  800819:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  800820:	eb 34                	jmp    800856 <serve_thread+0x244>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800822:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800826:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80082a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082e:	8b 40 04             	mov    0x4(%rax),%eax
  800831:	89 c6                	mov    %eax,%esi
  800833:	48 bf 20 00 82 00 00 	movabs $0x820020,%rdi
  80083a:	00 00 00 
  80083d:	b8 00 00 00 00       	mov    $0x0,%eax
  800842:	48 b9 19 11 80 00 00 	movabs $0x801119,%rcx
  800849:	00 00 00 
  80084c:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  80084e:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  800855:	90                   	nop
    }

    if (r == -1) {
  800856:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80085a:	75 49                	jne    8008a5 <serve_thread+0x293>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80085c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800860:	8b 10                	mov    (%rax),%edx
  800862:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800869:	89 d1                	mov    %edx,%ecx
  80086b:	48 ba 43 00 82 00 00 	movabs $0x820043,%rdx
  800872:	00 00 00 
  800875:	be 64 00 00 00       	mov    $0x64,%esi
  80087a:	48 89 c7             	mov    %rax,%rdi
  80087d:	b8 00 00 00 00       	mov    $0x0,%eax
  800882:	49 b8 66 1b 80 00 00 	movabs $0x801b66,%r8
  800889:	00 00 00 
  80088c:	41 ff d0             	callq  *%r8
        perror(buf);
  80088f:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800896:	48 89 c7             	mov    %rax,%rdi
  800899:	48 b8 52 89 81 00 00 	movabs $0x818952,%rax
  8008a0:	00 00 00 
  8008a3:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008a9:	8b 00                	mov    (%rax),%eax
  8008ab:	83 f8 0a             	cmp    $0xa,%eax
  8008ae:	74 24                	je     8008d4 <serve_thread+0x2c2>
        ipc_send(args->whom, r, 0, 0);
  8008b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8008b3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8008b7:	8b 52 04             	mov    0x4(%rdx),%edx
  8008ba:	89 d7                	mov    %edx,%edi
  8008bc:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008c1:	ba 00 00 00 00       	mov    $0x0,%edx
  8008c6:	89 c6                	mov    %eax,%esi
  8008c8:	48 b8 66 2a 80 00 00 	movabs $0x802a66,%rax
  8008cf:	00 00 00 
  8008d2:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008dc:	48 89 c7             	mov    %rax,%rdi
  8008df:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8008e6:	00 00 00 
  8008e9:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008ef:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008f3:	48 89 c6             	mov    %rax,%rsi
  8008f6:	bf 00 00 00 00       	mov    $0x0,%edi
  8008fb:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  800902:	00 00 00 
  800905:	ff d0                	callq  *%rax
    free(args);
  800907:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80090b:	48 89 c7             	mov    %rax,%rdi
  80090e:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  800915:	00 00 00 
  800918:	ff d0                	callq  *%rax
}
  80091a:	c9                   	leaveq 
  80091b:	c3                   	retq   

000000000080091c <serve>:

void
serve(void) {
  80091c:	55                   	push   %rbp
  80091d:	48 89 e5             	mov    %rsp,%rbp
  800920:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800924:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80092b:	eb 10                	jmp    80093d <serve+0x21>
            thread_yield();
  80092d:	48 b8 9c 85 81 00 00 	movabs $0x81859c,%rax
  800934:	00 00 00 
  800937:	ff d0                	callq  *%rax
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800939:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80093d:	48 b8 80 81 81 00 00 	movabs $0x818180,%rax
  800944:	00 00 00 
  800947:	ff d0                	callq  *%rax
  800949:	85 c0                	test   %eax,%eax
  80094b:	74 06                	je     800953 <serve+0x37>
  80094d:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  800951:	7e da                	jle    80092d <serve+0x11>

        perm = 0;
  800953:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  80095a:	48 b8 99 00 80 00 00 	movabs $0x800099,%rax
  800961:	00 00 00 
  800964:	ff d0                	callq  *%rax
  800966:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80096a:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  80096e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800972:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  800976:	48 89 ce             	mov    %rcx,%rsi
  800979:	48 89 c7             	mov    %rax,%rdi
  80097c:	48 b8 28 2a 80 00 00 	movabs $0x802a28,%rax
  800983:	00 00 00 
  800986:	ff d0                	callq  *%rax
  800988:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  80098b:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  80098f:	75 29                	jne    8009ba <serve+0x9e>
            process_timer(whom);
  800991:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800994:	89 c7                	mov    %eax,%edi
  800996:	48 b8 7c 05 80 00 00 	movabs $0x80057c,%rax
  80099d:	00 00 00 
  8009a0:	ff d0                	callq  *%rax
            put_buffer(va);
  8009a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009a6:	48 89 c7             	mov    %rax,%rdi
  8009a9:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8009b0:	00 00 00 
  8009b3:	ff d0                	callq  *%rax
            continue;
  8009b5:	e9 cc 00 00 00       	jmpq   800a86 <serve+0x16a>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009ba:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009bd:	83 e0 01             	and    $0x1,%eax
  8009c0:	85 c0                	test   %eax,%eax
  8009c2:	75 25                	jne    8009e9 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009c4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009c7:	89 c6                	mov    %eax,%esi
  8009c9:	48 bf b0 00 82 00 00 	movabs $0x8200b0,%rdi
  8009d0:	00 00 00 
  8009d3:	b8 00 00 00 00       	mov    $0x0,%eax
  8009d8:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8009df:	00 00 00 
  8009e2:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009e4:	e9 9d 00 00 00       	jmpq   800a86 <serve+0x16a>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009e9:	bf 10 00 00 00       	mov    $0x10,%edi
  8009ee:	48 b8 31 43 80 00 00 	movabs $0x804331,%rax
  8009f5:	00 00 00 
  8009f8:	ff d0                	callq  *%rax
  8009fa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  8009fe:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800a03:	75 2a                	jne    800a2f <serve+0x113>
            panic("could not allocate thread args structure");
  800a05:	48 ba e0 00 82 00 00 	movabs $0x8200e0,%rdx
  800a0c:	00 00 00 
  800a0f:	be 26 01 00 00       	mov    $0x126,%esi
  800a14:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  800a1b:	00 00 00 
  800a1e:	b8 00 00 00 00       	mov    $0x0,%eax
  800a23:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  800a2a:	00 00 00 
  800a2d:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a33:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a36:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a38:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a3b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a3f:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a46:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a4a:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a52:	48 89 c1             	mov    %rax,%rcx
  800a55:	48 ba 12 06 80 00 00 	movabs $0x800612,%rdx
  800a5c:	00 00 00 
  800a5f:	48 be 09 01 82 00 00 	movabs $0x820109,%rsi
  800a66:	00 00 00 
  800a69:	bf 00 00 00 00       	mov    $0x0,%edi
  800a6e:	48 b8 17 83 81 00 00 	movabs $0x818317,%rax
  800a75:	00 00 00 
  800a78:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a7a:	48 b8 9c 85 81 00 00 	movabs $0x81859c,%rax
  800a81:	00 00 00 
  800a84:	ff d0                	callq  *%rax
    }
  800a86:	e9 99 fe ff ff       	jmpq   800924 <serve+0x8>

0000000000800a8b <tmain>:
}

static void
tmain(uint64_t arg) {
  800a8b:	55                   	push   %rbp
  800a8c:	48 89 e5             	mov    %rsp,%rbp
  800a8f:	41 54                	push   %r12
  800a91:	53                   	push   %rbx
  800a92:	48 83 ec 10          	sub    $0x10,%rsp
  800a96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800a9a:	48 bf 16 01 82 00 00 	movabs $0x820116,%rdi
  800aa1:	00 00 00 
  800aa4:	48 b8 36 20 81 00 00 	movabs $0x812036,%rax
  800aab:	00 00 00 
  800aae:	ff d0                	callq  *%rax
  800ab0:	41 89 c4             	mov    %eax,%r12d
  800ab3:	48 bf 1f 01 82 00 00 	movabs $0x82011f,%rdi
  800aba:	00 00 00 
  800abd:	48 b8 36 20 81 00 00 	movabs $0x812036,%rax
  800ac4:	00 00 00 
  800ac7:	ff d0                	callq  *%rax
  800ac9:	89 c3                	mov    %eax,%ebx
  800acb:	48 bf 2d 01 82 00 00 	movabs $0x82012d,%rdi
  800ad2:	00 00 00 
  800ad5:	48 b8 36 20 81 00 00 	movabs $0x812036,%rax
  800adc:	00 00 00 
  800adf:	ff d0                	callq  *%rax
  800ae1:	44 89 e2             	mov    %r12d,%edx
  800ae4:	89 de                	mov    %ebx,%esi
  800ae6:	89 c7                	mov    %eax,%edi
  800ae8:	48 b8 74 03 80 00 00 	movabs $0x800374,%rax
  800aef:	00 00 00 
  800af2:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800af4:	48 b8 1c 09 80 00 00 	movabs $0x80091c,%rax
  800afb:	00 00 00 
  800afe:	ff d0                	callq  *%rax
}
  800b00:	48 83 c4 10          	add    $0x10,%rsp
  800b04:	5b                   	pop    %rbx
  800b05:	41 5c                	pop    %r12
  800b07:	5d                   	pop    %rbp
  800b08:	c3                   	retq   

0000000000800b09 <umain>:

    void
umain(int argc, char **argv)
{
  800b09:	55                   	push   %rbp
  800b0a:	48 89 e5             	mov    %rsp,%rbp
  800b0d:	48 83 ec 20          	sub    $0x20,%rsp
  800b11:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800b14:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b18:	48 b8 68 25 80 00 00 	movabs $0x802568,%rax
  800b1f:	00 00 00 
  800b22:	ff d0                	callq  *%rax
  800b24:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns";
  800b27:	48 b8 00 70 82 00 00 	movabs $0x827000,%rax
  800b2e:	00 00 00 
  800b31:	48 be 37 01 82 00 00 	movabs $0x820137,%rsi
  800b38:	00 00 00 
  800b3b:	48 89 30             	mov    %rsi,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b3e:	48 b8 cc 29 80 00 00 	movabs $0x8029cc,%rax
  800b45:	00 00 00 
  800b48:	ff d0                	callq  *%rax
  800b4a:	89 c2                	mov    %eax,%edx
  800b4c:	48 b8 58 80 82 00 00 	movabs $0x828058,%rax
  800b53:	00 00 00 
  800b56:	89 10                	mov    %edx,(%rax)
    if (timer_envid < 0)
  800b58:	48 b8 58 80 82 00 00 	movabs $0x828058,%rax
  800b5f:	00 00 00 
  800b62:	8b 00                	mov    (%rax),%eax
  800b64:	85 c0                	test   %eax,%eax
  800b66:	79 2a                	jns    800b92 <umain+0x89>
        panic("error forking");
  800b68:	48 ba 3a 01 82 00 00 	movabs $0x82013a,%rdx
  800b6f:	00 00 00 
  800b72:	be 43 01 00 00       	mov    $0x143,%esi
  800b77:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  800b7e:	00 00 00 
  800b81:	b8 00 00 00 00       	mov    $0x0,%eax
  800b86:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  800b8d:	00 00 00 
  800b90:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b92:	48 b8 58 80 82 00 00 	movabs $0x828058,%rax
  800b99:	00 00 00 
  800b9c:	8b 00                	mov    (%rax),%eax
  800b9e:	85 c0                	test   %eax,%eax
  800ba0:	75 1b                	jne    800bbd <umain+0xb4>
        timer(ns_envid, TIMER_INTERVAL);
  800ba2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ba5:	be fa 00 00 00       	mov    $0xfa,%esi
  800baa:	89 c7                	mov    %eax,%edi
  800bac:	48 b8 f2 0c 80 00 00 	movabs $0x800cf2,%rax
  800bb3:	00 00 00 
  800bb6:	ff d0                	callq  *%rax
        return;
  800bb8:	e9 33 01 00 00       	jmpq   800cf0 <umain+0x1e7>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bbd:	48 b8 cc 29 80 00 00 	movabs $0x8029cc,%rax
  800bc4:	00 00 00 
  800bc7:	ff d0                	callq  *%rax
  800bc9:	89 c2                	mov    %eax,%edx
  800bcb:	48 b8 5c 80 82 00 00 	movabs $0x82805c,%rax
  800bd2:	00 00 00 
  800bd5:	89 10                	mov    %edx,(%rax)
    if (input_envid < 0)
  800bd7:	48 b8 5c 80 82 00 00 	movabs $0x82805c,%rax
  800bde:	00 00 00 
  800be1:	8b 00                	mov    (%rax),%eax
  800be3:	85 c0                	test   %eax,%eax
  800be5:	79 2a                	jns    800c11 <umain+0x108>
        panic("error forking");
  800be7:	48 ba 3a 01 82 00 00 	movabs $0x82013a,%rdx
  800bee:	00 00 00 
  800bf1:	be 4d 01 00 00       	mov    $0x14d,%esi
  800bf6:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  800bfd:	00 00 00 
  800c00:	b8 00 00 00 00       	mov    $0x0,%eax
  800c05:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  800c0c:	00 00 00 
  800c0f:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c11:	48 b8 5c 80 82 00 00 	movabs $0x82805c,%rax
  800c18:	00 00 00 
  800c1b:	8b 00                	mov    (%rax),%eax
  800c1d:	85 c0                	test   %eax,%eax
  800c1f:	75 16                	jne    800c37 <umain+0x12e>
        input(ns_envid);
  800c21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c24:	89 c7                	mov    %eax,%edi
  800c26:	48 b8 15 0e 80 00 00 	movabs $0x800e15,%rax
  800c2d:	00 00 00 
  800c30:	ff d0                	callq  *%rax
        return;
  800c32:	e9 b9 00 00 00       	jmpq   800cf0 <umain+0x1e7>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c37:	48 b8 cc 29 80 00 00 	movabs $0x8029cc,%rax
  800c3e:	00 00 00 
  800c41:	ff d0                	callq  *%rax
  800c43:	89 c2                	mov    %eax,%edx
  800c45:	48 b8 60 80 82 00 00 	movabs $0x828060,%rax
  800c4c:	00 00 00 
  800c4f:	89 10                	mov    %edx,(%rax)
    if (output_envid < 0)
  800c51:	48 b8 60 80 82 00 00 	movabs $0x828060,%rax
  800c58:	00 00 00 
  800c5b:	8b 00                	mov    (%rax),%eax
  800c5d:	85 c0                	test   %eax,%eax
  800c5f:	79 2a                	jns    800c8b <umain+0x182>
        panic("error forking");
  800c61:	48 ba 3a 01 82 00 00 	movabs $0x82013a,%rdx
  800c68:	00 00 00 
  800c6b:	be 57 01 00 00       	mov    $0x157,%esi
  800c70:	48 bf 14 ff 81 00 00 	movabs $0x81ff14,%rdi
  800c77:	00 00 00 
  800c7a:	b8 00 00 00 00       	mov    $0x0,%eax
  800c7f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  800c86:	00 00 00 
  800c89:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c8b:	48 b8 60 80 82 00 00 	movabs $0x828060,%rax
  800c92:	00 00 00 
  800c95:	8b 00                	mov    (%rax),%eax
  800c97:	85 c0                	test   %eax,%eax
  800c99:	75 13                	jne    800cae <umain+0x1a5>
        output(ns_envid);
  800c9b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c9e:	89 c7                	mov    %eax,%edi
  800ca0:	48 b8 39 0e 80 00 00 	movabs $0x800e39,%rax
  800ca7:	00 00 00 
  800caa:	ff d0                	callq  *%rax
        return;
  800cac:	eb 42                	jmp    800cf0 <umain+0x1e7>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800cae:	48 b8 0e 80 81 00 00 	movabs $0x81800e,%rax
  800cb5:	00 00 00 
  800cb8:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cba:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cbf:	48 ba 8b 0a 80 00 00 	movabs $0x800a8b,%rdx
  800cc6:	00 00 00 
  800cc9:	48 be 48 01 82 00 00 	movabs $0x820148,%rsi
  800cd0:	00 00 00 
  800cd3:	bf 00 00 00 00       	mov    $0x0,%edi
  800cd8:	48 b8 17 83 81 00 00 	movabs $0x818317,%rax
  800cdf:	00 00 00 
  800ce2:	ff d0                	callq  *%rax
    thread_yield();
  800ce4:	48 b8 9c 85 81 00 00 	movabs $0x81859c,%rax
  800ceb:	00 00 00 
  800cee:	ff d0                	callq  *%rax
    // never coming here!
}
  800cf0:	c9                   	leaveq 
  800cf1:	c3                   	retq   

0000000000800cf2 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cf2:	55                   	push   %rbp
  800cf3:	48 89 e5             	mov    %rsp,%rbp
  800cf6:	48 83 ec 20          	sub    $0x20,%rsp
  800cfa:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800cfd:	89 75 e8             	mov    %esi,-0x18(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800d00:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  800d07:	00 00 00 
  800d0a:	ff d0                	callq  *%rax
  800d0c:	89 c2                	mov    %eax,%edx
  800d0e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d11:	01 d0                	add    %edx,%eax
  800d13:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns_timer";
  800d16:	48 b8 00 70 82 00 00 	movabs $0x827000,%rax
  800d1d:	00 00 00 
  800d20:	48 b9 50 01 82 00 00 	movabs $0x820150,%rcx
  800d27:	00 00 00 
  800d2a:	48 89 08             	mov    %rcx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d2d:	eb 0c                	jmp    800d3b <timer+0x49>
            sys_yield();
  800d2f:	48 b8 a4 25 80 00 00 	movabs $0x8025a4,%rax
  800d36:	00 00 00 
  800d39:	ff d0                	callq  *%rax
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d3b:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  800d42:	00 00 00 
  800d45:	ff d0                	callq  *%rax
  800d47:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800d4a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d4d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800d50:	73 06                	jae    800d58 <timer+0x66>
  800d52:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d56:	79 d7                	jns    800d2f <timer+0x3d>
        }
        if (r < 0)
  800d58:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d5c:	79 30                	jns    800d8e <timer+0x9c>
            panic("sys_time_msec: %e", r);
  800d5e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d61:	89 c1                	mov    %eax,%ecx
  800d63:	48 ba 59 01 82 00 00 	movabs $0x820159,%rdx
  800d6a:	00 00 00 
  800d6d:	be 0f 00 00 00       	mov    $0xf,%esi
  800d72:	48 bf 6b 01 82 00 00 	movabs $0x82016b,%rdi
  800d79:	00 00 00 
  800d7c:	b8 00 00 00 00       	mov    $0x0,%eax
  800d81:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  800d88:	00 00 00 
  800d8b:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d8e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800d91:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d96:	ba 00 00 00 00       	mov    $0x0,%edx
  800d9b:	be 0c 00 00 00       	mov    $0xc,%esi
  800da0:	89 c7                	mov    %eax,%edi
  800da2:	48 b8 66 2a 80 00 00 	movabs $0x802a66,%rax
  800da9:	00 00 00 
  800dac:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800dae:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800db2:	ba 00 00 00 00       	mov    $0x0,%edx
  800db7:	be 00 00 00 00       	mov    $0x0,%esi
  800dbc:	48 89 c7             	mov    %rax,%rdi
  800dbf:	48 b8 28 2a 80 00 00 	movabs $0x802a28,%rax
  800dc6:	00 00 00 
  800dc9:	ff d0                	callq  *%rax
  800dcb:	89 45 f4             	mov    %eax,-0xc(%rbp)

            if (whom != ns_envid) {
  800dce:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800dd1:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800dd4:	39 c2                	cmp    %eax,%edx
  800dd6:	74 22                	je     800dfa <timer+0x108>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800dd8:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800ddb:	89 c6                	mov    %eax,%esi
  800ddd:	48 bf 78 01 82 00 00 	movabs $0x820178,%rdi
  800de4:	00 00 00 
  800de7:	b8 00 00 00 00       	mov    $0x0,%eax
  800dec:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  800df3:	00 00 00 
  800df6:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800df8:	eb b4                	jmp    800dae <timer+0xbc>
            stop = sys_time_msec() + to;
  800dfa:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  800e01:	00 00 00 
  800e04:	ff d0                	callq  *%rax
  800e06:	89 c2                	mov    %eax,%edx
  800e08:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800e0b:	01 d0                	add    %edx,%eax
  800e0d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    }
  800e10:	e9 18 ff ff ff       	jmpq   800d2d <timer+0x3b>

0000000000800e15 <input>:

extern union Nsipc nsipcbuf;

    void
input(envid_t ns_envid)
{
  800e15:	55                   	push   %rbp
  800e16:	48 89 e5             	mov    %rsp,%rbp
  800e19:	48 83 ec 08          	sub    $0x8,%rsp
  800e1d:	89 7d fc             	mov    %edi,-0x4(%rbp)
    binaryname = "ns_input";
  800e20:	48 b8 00 70 82 00 00 	movabs $0x827000,%rax
  800e27:	00 00 00 
  800e2a:	48 ba b3 01 82 00 00 	movabs $0x8201b3,%rdx
  800e31:	00 00 00 
  800e34:	48 89 10             	mov    %rdx,(%rax)
    // 	- read a packet from the device driver
    //	- send it to the network server
    // Hint: When you IPC a page to the network server, it will be
    // reading from it for a while, so don't immediately receive
    // another packet in to the same physical page.
}
  800e37:	c9                   	leaveq 
  800e38:	c3                   	retq   

0000000000800e39 <output>:

extern union Nsipc nsipcbuf;

    void
output(envid_t ns_envid)
{
  800e39:	55                   	push   %rbp
  800e3a:	48 89 e5             	mov    %rsp,%rbp
  800e3d:	48 83 ec 08          	sub    $0x8,%rsp
  800e41:	89 7d fc             	mov    %edi,-0x4(%rbp)
    binaryname = "ns_output";
  800e44:	48 b8 00 70 82 00 00 	movabs $0x827000,%rax
  800e4b:	00 00 00 
  800e4e:	48 ba bc 01 82 00 00 	movabs $0x8201bc,%rdx
  800e55:	00 00 00 
  800e58:	48 89 10             	mov    %rdx,(%rax)

    // LAB 6: Your code here:
    // 	- read a packet from the network server
    //	- send the packet to the device driver
}
  800e5b:	c9                   	leaveq 
  800e5c:	c3                   	retq   

0000000000800e5d <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  800e5d:	55                   	push   %rbp
  800e5e:	48 89 e5             	mov    %rsp,%rbp
  800e61:	48 83 ec 10          	sub    $0x10,%rsp
  800e65:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800e68:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = 0;
  800e6c:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  800e73:	00 00 00 
  800e76:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// save the name of the program so that panic() can use it
	if (argc > 0)
  800e7d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800e81:	7e 14                	jle    800e97 <libmain+0x3a>
		binaryname = argv[0];
  800e83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800e87:	48 8b 10             	mov    (%rax),%rdx
  800e8a:	48 b8 00 70 82 00 00 	movabs $0x827000,%rax
  800e91:	00 00 00 
  800e94:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  800e97:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800e9b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800e9e:	48 89 d6             	mov    %rdx,%rsi
  800ea1:	89 c7                	mov    %eax,%edi
  800ea3:	48 b8 09 0b 80 00 00 	movabs $0x800b09,%rax
  800eaa:	00 00 00 
  800ead:	ff d0                	callq  *%rax

	// exit gracefully
	exit();
  800eaf:	48 b8 bd 0e 80 00 00 	movabs $0x800ebd,%rax
  800eb6:	00 00 00 
  800eb9:	ff d0                	callq  *%rax
}
  800ebb:	c9                   	leaveq 
  800ebc:	c3                   	retq   

0000000000800ebd <exit>:

#include <inc/lib.h>

void
exit(void)
{
  800ebd:	55                   	push   %rbp
  800ebe:	48 89 e5             	mov    %rsp,%rbp
	close_all();
  800ec1:	48 b8 a8 2f 80 00 00 	movabs $0x802fa8,%rax
  800ec8:	00 00 00 
  800ecb:	ff d0                	callq  *%rax
	sys_env_destroy(0);
  800ecd:	bf 00 00 00 00       	mov    $0x0,%edi
  800ed2:	48 b8 22 25 80 00 00 	movabs $0x802522,%rax
  800ed9:	00 00 00 
  800edc:	ff d0                	callq  *%rax
}
  800ede:	5d                   	pop    %rbp
  800edf:	c3                   	retq   

0000000000800ee0 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  800ee0:	55                   	push   %rbp
  800ee1:	48 89 e5             	mov    %rsp,%rbp
  800ee4:	53                   	push   %rbx
  800ee5:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  800eec:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  800ef3:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  800ef9:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  800f00:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  800f07:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  800f0e:	84 c0                	test   %al,%al
  800f10:	74 23                	je     800f35 <_panic+0x55>
  800f12:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  800f19:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  800f1d:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  800f21:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  800f25:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  800f29:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  800f2d:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  800f31:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
  800f35:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800f3c:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  800f43:	00 00 00 
  800f46:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  800f4d:	00 00 00 
  800f50:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800f54:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800f5b:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  800f62:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  800f69:	48 b8 00 70 82 00 00 	movabs $0x827000,%rax
  800f70:	00 00 00 
  800f73:	48 8b 18             	mov    (%rax),%rbx
  800f76:	48 b8 68 25 80 00 00 	movabs $0x802568,%rax
  800f7d:	00 00 00 
  800f80:	ff d0                	callq  *%rax
  800f82:	89 c6                	mov    %eax,%esi
  800f84:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  800f8a:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800f91:	41 89 d0             	mov    %edx,%r8d
  800f94:	48 89 c1             	mov    %rax,%rcx
  800f97:	48 89 da             	mov    %rbx,%rdx
  800f9a:	48 bf d0 01 82 00 00 	movabs $0x8201d0,%rdi
  800fa1:	00 00 00 
  800fa4:	b8 00 00 00 00       	mov    $0x0,%eax
  800fa9:	49 b9 19 11 80 00 00 	movabs $0x801119,%r9
  800fb0:	00 00 00 
  800fb3:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  800fb6:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  800fbd:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800fc4:	48 89 d6             	mov    %rdx,%rsi
  800fc7:	48 89 c7             	mov    %rax,%rdi
  800fca:	48 b8 6d 10 80 00 00 	movabs $0x80106d,%rax
  800fd1:	00 00 00 
  800fd4:	ff d0                	callq  *%rax
	cprintf("\n");
  800fd6:	48 bf f3 01 82 00 00 	movabs $0x8201f3,%rdi
  800fdd:	00 00 00 
  800fe0:	b8 00 00 00 00       	mov    $0x0,%eax
  800fe5:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  800fec:	00 00 00 
  800fef:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800ff1:	cc                   	int3   
  800ff2:	eb fd                	jmp    800ff1 <_panic+0x111>

0000000000800ff4 <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  800ff4:	55                   	push   %rbp
  800ff5:	48 89 e5             	mov    %rsp,%rbp
  800ff8:	48 83 ec 10          	sub    $0x10,%rsp
  800ffc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800fff:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  801003:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801007:	8b 00                	mov    (%rax),%eax
  801009:	8d 48 01             	lea    0x1(%rax),%ecx
  80100c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801010:	89 0a                	mov    %ecx,(%rdx)
  801012:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801015:	89 d1                	mov    %edx,%ecx
  801017:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80101b:	48 98                	cltq   
  80101d:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
    if (b->idx == 256-1) {
  801021:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801025:	8b 00                	mov    (%rax),%eax
  801027:	3d ff 00 00 00       	cmp    $0xff,%eax
  80102c:	75 2c                	jne    80105a <putch+0x66>
        sys_cputs(b->buf, b->idx);
  80102e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801032:	8b 00                	mov    (%rax),%eax
  801034:	48 98                	cltq   
  801036:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80103a:	48 83 c2 08          	add    $0x8,%rdx
  80103e:	48 89 c6             	mov    %rax,%rsi
  801041:	48 89 d7             	mov    %rdx,%rdi
  801044:	48 b8 9a 24 80 00 00 	movabs $0x80249a,%rax
  80104b:	00 00 00 
  80104e:	ff d0                	callq  *%rax
        b->idx = 0;
  801050:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801054:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  80105a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80105e:	8b 40 04             	mov    0x4(%rax),%eax
  801061:	8d 50 01             	lea    0x1(%rax),%edx
  801064:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801068:	89 50 04             	mov    %edx,0x4(%rax)
}
  80106b:	c9                   	leaveq 
  80106c:	c3                   	retq   

000000000080106d <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  80106d:	55                   	push   %rbp
  80106e:	48 89 e5             	mov    %rsp,%rbp
  801071:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  801078:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  80107f:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  801086:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  80108d:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  801094:	48 8b 0a             	mov    (%rdx),%rcx
  801097:	48 89 08             	mov    %rcx,(%rax)
  80109a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80109e:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8010a2:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8010a6:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  8010aa:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  8010b1:	00 00 00 
    b.cnt = 0;
  8010b4:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  8010bb:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  8010be:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  8010c5:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  8010cc:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  8010d3:	48 89 c6             	mov    %rax,%rsi
  8010d6:	48 bf f4 0f 80 00 00 	movabs $0x800ff4,%rdi
  8010dd:	00 00 00 
  8010e0:	48 b8 b8 14 80 00 00 	movabs $0x8014b8,%rax
  8010e7:	00 00 00 
  8010ea:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  8010ec:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  8010f2:	48 98                	cltq   
  8010f4:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  8010fb:	48 83 c2 08          	add    $0x8,%rdx
  8010ff:	48 89 c6             	mov    %rax,%rsi
  801102:	48 89 d7             	mov    %rdx,%rdi
  801105:	48 b8 9a 24 80 00 00 	movabs $0x80249a,%rax
  80110c:	00 00 00 
  80110f:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  801111:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801117:	c9                   	leaveq 
  801118:	c3                   	retq   

0000000000801119 <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  801119:	55                   	push   %rbp
  80111a:	48 89 e5             	mov    %rsp,%rbp
  80111d:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  801124:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80112b:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  801132:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801139:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801140:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801147:	84 c0                	test   %al,%al
  801149:	74 20                	je     80116b <cprintf+0x52>
  80114b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80114f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801153:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801157:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80115b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80115f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801163:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801167:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80116b:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  801172:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  801179:	00 00 00 
  80117c:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801183:	00 00 00 
  801186:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80118a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801191:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801198:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  80119f:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8011a6:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8011ad:	48 8b 0a             	mov    (%rdx),%rcx
  8011b0:	48 89 08             	mov    %rcx,(%rax)
  8011b3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8011b7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8011bb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8011bf:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  8011c3:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8011ca:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8011d1:	48 89 d6             	mov    %rdx,%rsi
  8011d4:	48 89 c7             	mov    %rax,%rdi
  8011d7:	48 b8 6d 10 80 00 00 	movabs $0x80106d,%rax
  8011de:	00 00 00 
  8011e1:	ff d0                	callq  *%rax
  8011e3:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  8011e9:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8011ef:	c9                   	leaveq 
  8011f0:	c3                   	retq   

00000000008011f1 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  8011f1:	55                   	push   %rbp
  8011f2:	48 89 e5             	mov    %rsp,%rbp
  8011f5:	48 83 ec 30          	sub    $0x30,%rsp
  8011f9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8011fd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  801201:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801205:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  801208:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  80120c:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  801210:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  801213:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  801217:	77 42                	ja     80125b <printnum+0x6a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  801219:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80121c:	8d 78 ff             	lea    -0x1(%rax),%edi
  80121f:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  801222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801226:	ba 00 00 00 00       	mov    $0x0,%edx
  80122b:	48 f7 f6             	div    %rsi
  80122e:	49 89 c2             	mov    %rax,%r10
  801231:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  801234:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  801237:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80123b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80123f:	41 89 c9             	mov    %ecx,%r9d
  801242:	41 89 f8             	mov    %edi,%r8d
  801245:	89 d1                	mov    %edx,%ecx
  801247:	4c 89 d2             	mov    %r10,%rdx
  80124a:	48 89 c7             	mov    %rax,%rdi
  80124d:	48 b8 f1 11 80 00 00 	movabs $0x8011f1,%rax
  801254:	00 00 00 
  801257:	ff d0                	callq  *%rax
  801259:	eb 1e                	jmp    801279 <printnum+0x88>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80125b:	eb 12                	jmp    80126f <printnum+0x7e>
			putch(padc, putdat);
  80125d:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  801261:	8b 55 dc             	mov    -0x24(%rbp),%edx
  801264:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801268:	48 89 ce             	mov    %rcx,%rsi
  80126b:	89 d7                	mov    %edx,%edi
  80126d:	ff d0                	callq  *%rax
		while (--width > 0)
  80126f:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  801273:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  801277:	7f e4                	jg     80125d <printnum+0x6c>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  801279:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80127c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801280:	ba 00 00 00 00       	mov    $0x0,%edx
  801285:	48 f7 f1             	div    %rcx
  801288:	48 b8 f0 03 82 00 00 	movabs $0x8203f0,%rax
  80128f:	00 00 00 
  801292:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  801296:	0f be d0             	movsbl %al,%edx
  801299:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80129d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8012a1:	48 89 ce             	mov    %rcx,%rsi
  8012a4:	89 d7                	mov    %edx,%edi
  8012a6:	ff d0                	callq  *%rax
}
  8012a8:	c9                   	leaveq 
  8012a9:	c3                   	retq   

00000000008012aa <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  8012aa:	55                   	push   %rbp
  8012ab:	48 89 e5             	mov    %rsp,%rbp
  8012ae:	48 83 ec 20          	sub    $0x20,%rsp
  8012b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8012b6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  8012b9:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8012bd:	7e 4f                	jle    80130e <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  8012bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012c3:	8b 00                	mov    (%rax),%eax
  8012c5:	83 f8 30             	cmp    $0x30,%eax
  8012c8:	73 24                	jae    8012ee <getuint+0x44>
  8012ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012ce:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8012d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012d6:	8b 00                	mov    (%rax),%eax
  8012d8:	89 c0                	mov    %eax,%eax
  8012da:	48 01 d0             	add    %rdx,%rax
  8012dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8012e1:	8b 12                	mov    (%rdx),%edx
  8012e3:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8012e6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8012ea:	89 0a                	mov    %ecx,(%rdx)
  8012ec:	eb 14                	jmp    801302 <getuint+0x58>
  8012ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8012f6:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8012fa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8012fe:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801302:	48 8b 00             	mov    (%rax),%rax
  801305:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801309:	e9 9d 00 00 00       	jmpq   8013ab <getuint+0x101>
	else if (lflag)
  80130e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801312:	74 4c                	je     801360 <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  801314:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801318:	8b 00                	mov    (%rax),%eax
  80131a:	83 f8 30             	cmp    $0x30,%eax
  80131d:	73 24                	jae    801343 <getuint+0x99>
  80131f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801323:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801327:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80132b:	8b 00                	mov    (%rax),%eax
  80132d:	89 c0                	mov    %eax,%eax
  80132f:	48 01 d0             	add    %rdx,%rax
  801332:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801336:	8b 12                	mov    (%rdx),%edx
  801338:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80133b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80133f:	89 0a                	mov    %ecx,(%rdx)
  801341:	eb 14                	jmp    801357 <getuint+0xad>
  801343:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801347:	48 8b 40 08          	mov    0x8(%rax),%rax
  80134b:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80134f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801353:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801357:	48 8b 00             	mov    (%rax),%rax
  80135a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80135e:	eb 4b                	jmp    8013ab <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  801360:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801364:	8b 00                	mov    (%rax),%eax
  801366:	83 f8 30             	cmp    $0x30,%eax
  801369:	73 24                	jae    80138f <getuint+0xe5>
  80136b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80136f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801373:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801377:	8b 00                	mov    (%rax),%eax
  801379:	89 c0                	mov    %eax,%eax
  80137b:	48 01 d0             	add    %rdx,%rax
  80137e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801382:	8b 12                	mov    (%rdx),%edx
  801384:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801387:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80138b:	89 0a                	mov    %ecx,(%rdx)
  80138d:	eb 14                	jmp    8013a3 <getuint+0xf9>
  80138f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801393:	48 8b 40 08          	mov    0x8(%rax),%rax
  801397:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80139b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80139f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8013a3:	8b 00                	mov    (%rax),%eax
  8013a5:	89 c0                	mov    %eax,%eax
  8013a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8013ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8013af:	c9                   	leaveq 
  8013b0:	c3                   	retq   

00000000008013b1 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  8013b1:	55                   	push   %rbp
  8013b2:	48 89 e5             	mov    %rsp,%rbp
  8013b5:	48 83 ec 20          	sub    $0x20,%rsp
  8013b9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8013bd:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  8013c0:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8013c4:	7e 4f                	jle    801415 <getint+0x64>
		x=va_arg(*ap, long long);
  8013c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013ca:	8b 00                	mov    (%rax),%eax
  8013cc:	83 f8 30             	cmp    $0x30,%eax
  8013cf:	73 24                	jae    8013f5 <getint+0x44>
  8013d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013d5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8013d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013dd:	8b 00                	mov    (%rax),%eax
  8013df:	89 c0                	mov    %eax,%eax
  8013e1:	48 01 d0             	add    %rdx,%rax
  8013e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013e8:	8b 12                	mov    (%rdx),%edx
  8013ea:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8013ed:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013f1:	89 0a                	mov    %ecx,(%rdx)
  8013f3:	eb 14                	jmp    801409 <getint+0x58>
  8013f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013f9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8013fd:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801401:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801405:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801409:	48 8b 00             	mov    (%rax),%rax
  80140c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801410:	e9 9d 00 00 00       	jmpq   8014b2 <getint+0x101>
	else if (lflag)
  801415:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801419:	74 4c                	je     801467 <getint+0xb6>
		x=va_arg(*ap, long);
  80141b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80141f:	8b 00                	mov    (%rax),%eax
  801421:	83 f8 30             	cmp    $0x30,%eax
  801424:	73 24                	jae    80144a <getint+0x99>
  801426:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80142a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80142e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801432:	8b 00                	mov    (%rax),%eax
  801434:	89 c0                	mov    %eax,%eax
  801436:	48 01 d0             	add    %rdx,%rax
  801439:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80143d:	8b 12                	mov    (%rdx),%edx
  80143f:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801442:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801446:	89 0a                	mov    %ecx,(%rdx)
  801448:	eb 14                	jmp    80145e <getint+0xad>
  80144a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80144e:	48 8b 40 08          	mov    0x8(%rax),%rax
  801452:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801456:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80145a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80145e:	48 8b 00             	mov    (%rax),%rax
  801461:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801465:	eb 4b                	jmp    8014b2 <getint+0x101>
	else
		x=va_arg(*ap, int);
  801467:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80146b:	8b 00                	mov    (%rax),%eax
  80146d:	83 f8 30             	cmp    $0x30,%eax
  801470:	73 24                	jae    801496 <getint+0xe5>
  801472:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801476:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80147a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80147e:	8b 00                	mov    (%rax),%eax
  801480:	89 c0                	mov    %eax,%eax
  801482:	48 01 d0             	add    %rdx,%rax
  801485:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801489:	8b 12                	mov    (%rdx),%edx
  80148b:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80148e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801492:	89 0a                	mov    %ecx,(%rdx)
  801494:	eb 14                	jmp    8014aa <getint+0xf9>
  801496:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80149a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80149e:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8014a2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014a6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8014aa:	8b 00                	mov    (%rax),%eax
  8014ac:	48 98                	cltq   
  8014ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8014b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8014b6:	c9                   	leaveq 
  8014b7:	c3                   	retq   

00000000008014b8 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  8014b8:	55                   	push   %rbp
  8014b9:	48 89 e5             	mov    %rsp,%rbp
  8014bc:	41 54                	push   %r12
  8014be:	53                   	push   %rbx
  8014bf:	48 83 ec 60          	sub    $0x60,%rsp
  8014c3:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8014c7:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8014cb:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8014cf:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  8014d3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8014d7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8014db:	48 8b 0a             	mov    (%rdx),%rcx
  8014de:	48 89 08             	mov    %rcx,(%rax)
  8014e1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8014e5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8014e9:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8014ed:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  8014f1:	eb 17                	jmp    80150a <vprintfmt+0x52>
			if (ch == '\0')
  8014f3:	85 db                	test   %ebx,%ebx
  8014f5:	0f 84 c5 04 00 00    	je     8019c0 <vprintfmt+0x508>
				return;
			putch(ch, putdat);
  8014fb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8014ff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801503:	48 89 d6             	mov    %rdx,%rsi
  801506:	89 df                	mov    %ebx,%edi
  801508:	ff d0                	callq  *%rax
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80150a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80150e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801512:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801516:	0f b6 00             	movzbl (%rax),%eax
  801519:	0f b6 d8             	movzbl %al,%ebx
  80151c:	83 fb 25             	cmp    $0x25,%ebx
  80151f:	75 d2                	jne    8014f3 <vprintfmt+0x3b>
		}

		// Process a %-escape sequence
		padc = ' ';
  801521:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  801525:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  80152c:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  801533:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  80153a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  801541:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801545:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801549:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80154d:	0f b6 00             	movzbl (%rax),%eax
  801550:	0f b6 d8             	movzbl %al,%ebx
  801553:	8d 43 dd             	lea    -0x23(%rbx),%eax
  801556:	83 f8 55             	cmp    $0x55,%eax
  801559:	0f 87 2e 04 00 00    	ja     80198d <vprintfmt+0x4d5>
  80155f:	89 c0                	mov    %eax,%eax
  801561:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  801568:	00 
  801569:	48 b8 18 04 82 00 00 	movabs $0x820418,%rax
  801570:	00 00 00 
  801573:	48 01 d0             	add    %rdx,%rax
  801576:	48 8b 00             	mov    (%rax),%rax
  801579:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  80157b:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  80157f:	eb c0                	jmp    801541 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  801581:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  801585:	eb ba                	jmp    801541 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  801587:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  80158e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  801591:	89 d0                	mov    %edx,%eax
  801593:	c1 e0 02             	shl    $0x2,%eax
  801596:	01 d0                	add    %edx,%eax
  801598:	01 c0                	add    %eax,%eax
  80159a:	01 d8                	add    %ebx,%eax
  80159c:	83 e8 30             	sub    $0x30,%eax
  80159f:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8015a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8015a6:	0f b6 00             	movzbl (%rax),%eax
  8015a9:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  8015ac:	83 fb 2f             	cmp    $0x2f,%ebx
  8015af:	7e 0c                	jle    8015bd <vprintfmt+0x105>
  8015b1:	83 fb 39             	cmp    $0x39,%ebx
  8015b4:	7f 07                	jg     8015bd <vprintfmt+0x105>
			for (precision = 0; ; ++fmt) {
  8015b6:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
					break;
			}
  8015bb:	eb d1                	jmp    80158e <vprintfmt+0xd6>
			goto process_precision;
  8015bd:	eb 50                	jmp    80160f <vprintfmt+0x157>

		case '*':
			precision = va_arg(aq, int);
  8015bf:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8015c2:	83 f8 30             	cmp    $0x30,%eax
  8015c5:	73 17                	jae    8015de <vprintfmt+0x126>
  8015c7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8015cb:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8015ce:	89 d2                	mov    %edx,%edx
  8015d0:	48 01 d0             	add    %rdx,%rax
  8015d3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8015d6:	83 c2 08             	add    $0x8,%edx
  8015d9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8015dc:	eb 0c                	jmp    8015ea <vprintfmt+0x132>
  8015de:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8015e2:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8015e6:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8015ea:	8b 00                	mov    (%rax),%eax
  8015ec:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  8015ef:	eb 1e                	jmp    80160f <vprintfmt+0x157>

		case '.':
			if (width < 0)
  8015f1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8015f5:	79 07                	jns    8015fe <vprintfmt+0x146>
				width = 0;
  8015f7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  8015fe:	e9 3e ff ff ff       	jmpq   801541 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  801603:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  80160a:	e9 32 ff ff ff       	jmpq   801541 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  80160f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801613:	79 0d                	jns    801622 <vprintfmt+0x16a>
				width = precision, precision = -1;
  801615:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801618:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80161b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  801622:	e9 1a ff ff ff       	jmpq   801541 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  801627:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  80162b:	e9 11 ff ff ff       	jmpq   801541 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  801630:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801633:	83 f8 30             	cmp    $0x30,%eax
  801636:	73 17                	jae    80164f <vprintfmt+0x197>
  801638:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80163c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80163f:	89 d2                	mov    %edx,%edx
  801641:	48 01 d0             	add    %rdx,%rax
  801644:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801647:	83 c2 08             	add    $0x8,%edx
  80164a:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80164d:	eb 0c                	jmp    80165b <vprintfmt+0x1a3>
  80164f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801653:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801657:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80165b:	8b 10                	mov    (%rax),%edx
  80165d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  801661:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801665:	48 89 ce             	mov    %rcx,%rsi
  801668:	89 d7                	mov    %edx,%edi
  80166a:	ff d0                	callq  *%rax
			break;
  80166c:	e9 4a 03 00 00       	jmpq   8019bb <vprintfmt+0x503>

			// error message
		case 'e':
			err = va_arg(aq, int);
  801671:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801674:	83 f8 30             	cmp    $0x30,%eax
  801677:	73 17                	jae    801690 <vprintfmt+0x1d8>
  801679:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80167d:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801680:	89 d2                	mov    %edx,%edx
  801682:	48 01 d0             	add    %rdx,%rax
  801685:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801688:	83 c2 08             	add    $0x8,%edx
  80168b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80168e:	eb 0c                	jmp    80169c <vprintfmt+0x1e4>
  801690:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801694:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801698:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80169c:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  80169e:	85 db                	test   %ebx,%ebx
  8016a0:	79 02                	jns    8016a4 <vprintfmt+0x1ec>
				err = -err;
  8016a2:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  8016a4:	83 fb 15             	cmp    $0x15,%ebx
  8016a7:	7f 16                	jg     8016bf <vprintfmt+0x207>
  8016a9:	48 b8 40 03 82 00 00 	movabs $0x820340,%rax
  8016b0:	00 00 00 
  8016b3:	48 63 d3             	movslq %ebx,%rdx
  8016b6:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  8016ba:	4d 85 e4             	test   %r12,%r12
  8016bd:	75 2e                	jne    8016ed <vprintfmt+0x235>
				printfmt(putch, putdat, "error %d", err);
  8016bf:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8016c3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8016c7:	89 d9                	mov    %ebx,%ecx
  8016c9:	48 ba 01 04 82 00 00 	movabs $0x820401,%rdx
  8016d0:	00 00 00 
  8016d3:	48 89 c7             	mov    %rax,%rdi
  8016d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8016db:	49 b8 c9 19 80 00 00 	movabs $0x8019c9,%r8
  8016e2:	00 00 00 
  8016e5:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  8016e8:	e9 ce 02 00 00       	jmpq   8019bb <vprintfmt+0x503>
				printfmt(putch, putdat, "%s", p);
  8016ed:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8016f1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8016f5:	4c 89 e1             	mov    %r12,%rcx
  8016f8:	48 ba 0a 04 82 00 00 	movabs $0x82040a,%rdx
  8016ff:	00 00 00 
  801702:	48 89 c7             	mov    %rax,%rdi
  801705:	b8 00 00 00 00       	mov    $0x0,%eax
  80170a:	49 b8 c9 19 80 00 00 	movabs $0x8019c9,%r8
  801711:	00 00 00 
  801714:	41 ff d0             	callq  *%r8
			break;
  801717:	e9 9f 02 00 00       	jmpq   8019bb <vprintfmt+0x503>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  80171c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80171f:	83 f8 30             	cmp    $0x30,%eax
  801722:	73 17                	jae    80173b <vprintfmt+0x283>
  801724:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801728:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80172b:	89 d2                	mov    %edx,%edx
  80172d:	48 01 d0             	add    %rdx,%rax
  801730:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801733:	83 c2 08             	add    $0x8,%edx
  801736:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801739:	eb 0c                	jmp    801747 <vprintfmt+0x28f>
  80173b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80173f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801743:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801747:	4c 8b 20             	mov    (%rax),%r12
  80174a:	4d 85 e4             	test   %r12,%r12
  80174d:	75 0a                	jne    801759 <vprintfmt+0x2a1>
				p = "(null)";
  80174f:	49 bc 0d 04 82 00 00 	movabs $0x82040d,%r12
  801756:	00 00 00 
			if (width > 0 && padc != '-')
  801759:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80175d:	7e 3f                	jle    80179e <vprintfmt+0x2e6>
  80175f:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  801763:	74 39                	je     80179e <vprintfmt+0x2e6>
				for (width -= strnlen(p, precision); width > 0; width--)
  801765:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801768:	48 98                	cltq   
  80176a:	48 89 c6             	mov    %rax,%rsi
  80176d:	4c 89 e7             	mov    %r12,%rdi
  801770:	48 b8 75 1c 80 00 00 	movabs $0x801c75,%rax
  801777:	00 00 00 
  80177a:	ff d0                	callq  *%rax
  80177c:	29 45 dc             	sub    %eax,-0x24(%rbp)
  80177f:	eb 17                	jmp    801798 <vprintfmt+0x2e0>
					putch(padc, putdat);
  801781:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  801785:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  801789:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80178d:	48 89 ce             	mov    %rcx,%rsi
  801790:	89 d7                	mov    %edx,%edi
  801792:	ff d0                	callq  *%rax
				for (width -= strnlen(p, precision); width > 0; width--)
  801794:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801798:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80179c:	7f e3                	jg     801781 <vprintfmt+0x2c9>
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80179e:	eb 37                	jmp    8017d7 <vprintfmt+0x31f>
				if (altflag && (ch < ' ' || ch > '~'))
  8017a0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8017a4:	74 1e                	je     8017c4 <vprintfmt+0x30c>
  8017a6:	83 fb 1f             	cmp    $0x1f,%ebx
  8017a9:	7e 05                	jle    8017b0 <vprintfmt+0x2f8>
  8017ab:	83 fb 7e             	cmp    $0x7e,%ebx
  8017ae:	7e 14                	jle    8017c4 <vprintfmt+0x30c>
					putch('?', putdat);
  8017b0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8017b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8017b8:	48 89 d6             	mov    %rdx,%rsi
  8017bb:	bf 3f 00 00 00       	mov    $0x3f,%edi
  8017c0:	ff d0                	callq  *%rax
  8017c2:	eb 0f                	jmp    8017d3 <vprintfmt+0x31b>
				else
					putch(ch, putdat);
  8017c4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8017c8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8017cc:	48 89 d6             	mov    %rdx,%rsi
  8017cf:	89 df                	mov    %ebx,%edi
  8017d1:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8017d3:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8017d7:	4c 89 e0             	mov    %r12,%rax
  8017da:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8017de:	0f b6 00             	movzbl (%rax),%eax
  8017e1:	0f be d8             	movsbl %al,%ebx
  8017e4:	85 db                	test   %ebx,%ebx
  8017e6:	74 10                	je     8017f8 <vprintfmt+0x340>
  8017e8:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8017ec:	78 b2                	js     8017a0 <vprintfmt+0x2e8>
  8017ee:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  8017f2:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8017f6:	79 a8                	jns    8017a0 <vprintfmt+0x2e8>
			for (; width > 0; width--)
  8017f8:	eb 16                	jmp    801810 <vprintfmt+0x358>
				putch(' ', putdat);
  8017fa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8017fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801802:	48 89 d6             	mov    %rdx,%rsi
  801805:	bf 20 00 00 00       	mov    $0x20,%edi
  80180a:	ff d0                	callq  *%rax
			for (; width > 0; width--)
  80180c:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801810:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801814:	7f e4                	jg     8017fa <vprintfmt+0x342>
			break;
  801816:	e9 a0 01 00 00       	jmpq   8019bb <vprintfmt+0x503>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  80181b:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80181f:	be 03 00 00 00       	mov    $0x3,%esi
  801824:	48 89 c7             	mov    %rax,%rdi
  801827:	48 b8 b1 13 80 00 00 	movabs $0x8013b1,%rax
  80182e:	00 00 00 
  801831:	ff d0                	callq  *%rax
  801833:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  801837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80183b:	48 85 c0             	test   %rax,%rax
  80183e:	79 1d                	jns    80185d <vprintfmt+0x3a5>
				putch('-', putdat);
  801840:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801844:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801848:	48 89 d6             	mov    %rdx,%rsi
  80184b:	bf 2d 00 00 00       	mov    $0x2d,%edi
  801850:	ff d0                	callq  *%rax
				num = -(long long) num;
  801852:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801856:	48 f7 d8             	neg    %rax
  801859:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  80185d:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801864:	e9 e5 00 00 00       	jmpq   80194e <vprintfmt+0x496>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  801869:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80186d:	be 03 00 00 00       	mov    $0x3,%esi
  801872:	48 89 c7             	mov    %rax,%rdi
  801875:	48 b8 aa 12 80 00 00 	movabs $0x8012aa,%rax
  80187c:	00 00 00 
  80187f:	ff d0                	callq  *%rax
  801881:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  801885:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  80188c:	e9 bd 00 00 00       	jmpq   80194e <vprintfmt+0x496>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  801891:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801895:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801899:	48 89 d6             	mov    %rdx,%rsi
  80189c:	bf 58 00 00 00       	mov    $0x58,%edi
  8018a1:	ff d0                	callq  *%rax
			putch('X', putdat);
  8018a3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8018a7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018ab:	48 89 d6             	mov    %rdx,%rsi
  8018ae:	bf 58 00 00 00       	mov    $0x58,%edi
  8018b3:	ff d0                	callq  *%rax
			putch('X', putdat);
  8018b5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8018b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018bd:	48 89 d6             	mov    %rdx,%rsi
  8018c0:	bf 58 00 00 00       	mov    $0x58,%edi
  8018c5:	ff d0                	callq  *%rax
			break;
  8018c7:	e9 ef 00 00 00       	jmpq   8019bb <vprintfmt+0x503>

			// pointer
		case 'p':
			putch('0', putdat);
  8018cc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8018d0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018d4:	48 89 d6             	mov    %rdx,%rsi
  8018d7:	bf 30 00 00 00       	mov    $0x30,%edi
  8018dc:	ff d0                	callq  *%rax
			putch('x', putdat);
  8018de:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8018e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018e6:	48 89 d6             	mov    %rdx,%rsi
  8018e9:	bf 78 00 00 00       	mov    $0x78,%edi
  8018ee:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  8018f0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8018f3:	83 f8 30             	cmp    $0x30,%eax
  8018f6:	73 17                	jae    80190f <vprintfmt+0x457>
  8018f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8018fc:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8018ff:	89 d2                	mov    %edx,%edx
  801901:	48 01 d0             	add    %rdx,%rax
  801904:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801907:	83 c2 08             	add    $0x8,%edx
  80190a:	89 55 b8             	mov    %edx,-0x48(%rbp)
			num = (unsigned long long)
  80190d:	eb 0c                	jmp    80191b <vprintfmt+0x463>
				(uintptr_t) va_arg(aq, void *);
  80190f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801913:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801917:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80191b:	48 8b 00             	mov    (%rax),%rax
			num = (unsigned long long)
  80191e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801922:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  801929:	eb 23                	jmp    80194e <vprintfmt+0x496>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  80192b:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80192f:	be 03 00 00 00       	mov    $0x3,%esi
  801934:	48 89 c7             	mov    %rax,%rdi
  801937:	48 b8 aa 12 80 00 00 	movabs $0x8012aa,%rax
  80193e:	00 00 00 
  801941:	ff d0                	callq  *%rax
  801943:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801947:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  80194e:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  801953:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801956:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801959:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80195d:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801961:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801965:	45 89 c1             	mov    %r8d,%r9d
  801968:	41 89 f8             	mov    %edi,%r8d
  80196b:	48 89 c7             	mov    %rax,%rdi
  80196e:	48 b8 f1 11 80 00 00 	movabs $0x8011f1,%rax
  801975:	00 00 00 
  801978:	ff d0                	callq  *%rax
			break;
  80197a:	eb 3f                	jmp    8019bb <vprintfmt+0x503>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  80197c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801980:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801984:	48 89 d6             	mov    %rdx,%rsi
  801987:	89 df                	mov    %ebx,%edi
  801989:	ff d0                	callq  *%rax
			break;
  80198b:	eb 2e                	jmp    8019bb <vprintfmt+0x503>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80198d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801991:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801995:	48 89 d6             	mov    %rdx,%rsi
  801998:	bf 25 00 00 00       	mov    $0x25,%edi
  80199d:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  80199f:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  8019a4:	eb 05                	jmp    8019ab <vprintfmt+0x4f3>
  8019a6:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  8019ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8019af:	48 83 e8 01          	sub    $0x1,%rax
  8019b3:	0f b6 00             	movzbl (%rax),%eax
  8019b6:	3c 25                	cmp    $0x25,%al
  8019b8:	75 ec                	jne    8019a6 <vprintfmt+0x4ee>
				/* do nothing */;
			break;
  8019ba:	90                   	nop
		}
	}
  8019bb:	e9 31 fb ff ff       	jmpq   8014f1 <vprintfmt+0x39>
	va_end(aq);
}
  8019c0:	48 83 c4 60          	add    $0x60,%rsp
  8019c4:	5b                   	pop    %rbx
  8019c5:	41 5c                	pop    %r12
  8019c7:	5d                   	pop    %rbp
  8019c8:	c3                   	retq   

00000000008019c9 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  8019c9:	55                   	push   %rbp
  8019ca:	48 89 e5             	mov    %rsp,%rbp
  8019cd:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8019d4:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8019db:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  8019e2:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8019e9:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8019f0:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8019f7:	84 c0                	test   %al,%al
  8019f9:	74 20                	je     801a1b <printfmt+0x52>
  8019fb:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8019ff:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801a03:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801a07:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801a0b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801a0f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801a13:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801a17:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801a1b:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801a22:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801a29:	00 00 00 
  801a2c:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801a33:	00 00 00 
  801a36:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801a3a:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801a41:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801a48:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801a4f:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801a56:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801a5d:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801a64:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801a6b:	48 89 c7             	mov    %rax,%rdi
  801a6e:	48 b8 b8 14 80 00 00 	movabs $0x8014b8,%rax
  801a75:	00 00 00 
  801a78:	ff d0                	callq  *%rax
	va_end(ap);
}
  801a7a:	c9                   	leaveq 
  801a7b:	c3                   	retq   

0000000000801a7c <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801a7c:	55                   	push   %rbp
  801a7d:	48 89 e5             	mov    %rsp,%rbp
  801a80:	48 83 ec 10          	sub    $0x10,%rsp
  801a84:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801a87:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801a8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801a8f:	8b 40 10             	mov    0x10(%rax),%eax
  801a92:	8d 50 01             	lea    0x1(%rax),%edx
  801a95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801a99:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801a9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801aa0:	48 8b 10             	mov    (%rax),%rdx
  801aa3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801aa7:	48 8b 40 08          	mov    0x8(%rax),%rax
  801aab:	48 39 c2             	cmp    %rax,%rdx
  801aae:	73 17                	jae    801ac7 <sprintputch+0x4b>
		*b->buf++ = ch;
  801ab0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ab4:	48 8b 00             	mov    (%rax),%rax
  801ab7:	48 8d 48 01          	lea    0x1(%rax),%rcx
  801abb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801abf:	48 89 0a             	mov    %rcx,(%rdx)
  801ac2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801ac5:	88 10                	mov    %dl,(%rax)
}
  801ac7:	c9                   	leaveq 
  801ac8:	c3                   	retq   

0000000000801ac9 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801ac9:	55                   	push   %rbp
  801aca:	48 89 e5             	mov    %rsp,%rbp
  801acd:	48 83 ec 50          	sub    $0x50,%rsp
  801ad1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801ad5:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801ad8:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801adc:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801ae0:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801ae4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801ae8:	48 8b 0a             	mov    (%rdx),%rcx
  801aeb:	48 89 08             	mov    %rcx,(%rax)
  801aee:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801af2:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801af6:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801afa:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801afe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b02:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801b06:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801b09:	48 98                	cltq   
  801b0b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  801b0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b13:	48 01 d0             	add    %rdx,%rax
  801b16:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801b1a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801b21:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801b26:	74 06                	je     801b2e <vsnprintf+0x65>
  801b28:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801b2c:	7f 07                	jg     801b35 <vsnprintf+0x6c>
		return -E_INVAL;
  801b2e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801b33:	eb 2f                	jmp    801b64 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801b35:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801b39:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801b3d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801b41:	48 89 c6             	mov    %rax,%rsi
  801b44:	48 bf 7c 1a 80 00 00 	movabs $0x801a7c,%rdi
  801b4b:	00 00 00 
  801b4e:	48 b8 b8 14 80 00 00 	movabs $0x8014b8,%rax
  801b55:	00 00 00 
  801b58:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801b5a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801b5e:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801b61:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801b64:	c9                   	leaveq 
  801b65:	c3                   	retq   

0000000000801b66 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801b66:	55                   	push   %rbp
  801b67:	48 89 e5             	mov    %rsp,%rbp
  801b6a:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801b71:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801b78:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801b7e:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801b85:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801b8c:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801b93:	84 c0                	test   %al,%al
  801b95:	74 20                	je     801bb7 <snprintf+0x51>
  801b97:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801b9b:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801b9f:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801ba3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801ba7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801bab:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801baf:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801bb3:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801bb7:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801bbe:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801bc5:	00 00 00 
  801bc8:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801bcf:	00 00 00 
  801bd2:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801bd6:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801bdd:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801be4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801beb:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801bf2:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801bf9:	48 8b 0a             	mov    (%rdx),%rcx
  801bfc:	48 89 08             	mov    %rcx,(%rax)
  801bff:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801c03:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801c07:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801c0b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801c0f:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801c16:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801c1d:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801c23:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801c2a:	48 89 c7             	mov    %rax,%rdi
  801c2d:	48 b8 c9 1a 80 00 00 	movabs $0x801ac9,%rax
  801c34:	00 00 00 
  801c37:	ff d0                	callq  *%rax
  801c39:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801c3f:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801c45:	c9                   	leaveq 
  801c46:	c3                   	retq   

0000000000801c47 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801c47:	55                   	push   %rbp
  801c48:	48 89 e5             	mov    %rsp,%rbp
  801c4b:	48 83 ec 18          	sub    $0x18,%rsp
  801c4f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801c53:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801c5a:	eb 09                	jmp    801c65 <strlen+0x1e>
		n++;
  801c5c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	for (n = 0; *s != '\0'; s++)
  801c60:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801c65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801c69:	0f b6 00             	movzbl (%rax),%eax
  801c6c:	84 c0                	test   %al,%al
  801c6e:	75 ec                	jne    801c5c <strlen+0x15>
	return n;
  801c70:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801c73:	c9                   	leaveq 
  801c74:	c3                   	retq   

0000000000801c75 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801c75:	55                   	push   %rbp
  801c76:	48 89 e5             	mov    %rsp,%rbp
  801c79:	48 83 ec 20          	sub    $0x20,%rsp
  801c7d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801c81:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801c85:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801c8c:	eb 0e                	jmp    801c9c <strnlen+0x27>
		n++;
  801c8e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801c92:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801c97:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801c9c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801ca1:	74 0b                	je     801cae <strnlen+0x39>
  801ca3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ca7:	0f b6 00             	movzbl (%rax),%eax
  801caa:	84 c0                	test   %al,%al
  801cac:	75 e0                	jne    801c8e <strnlen+0x19>
	return n;
  801cae:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801cb1:	c9                   	leaveq 
  801cb2:	c3                   	retq   

0000000000801cb3 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801cb3:	55                   	push   %rbp
  801cb4:	48 89 e5             	mov    %rsp,%rbp
  801cb7:	48 83 ec 20          	sub    $0x20,%rsp
  801cbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801cbf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801cc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801cc7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801ccb:	90                   	nop
  801ccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801cd0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801cd4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801cd8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801cdc:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801ce0:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801ce4:	0f b6 12             	movzbl (%rdx),%edx
  801ce7:	88 10                	mov    %dl,(%rax)
  801ce9:	0f b6 00             	movzbl (%rax),%eax
  801cec:	84 c0                	test   %al,%al
  801cee:	75 dc                	jne    801ccc <strcpy+0x19>
		/* do nothing */;
	return ret;
  801cf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801cf4:	c9                   	leaveq 
  801cf5:	c3                   	retq   

0000000000801cf6 <strcat>:

char *
strcat(char *dst, const char *src)
{
  801cf6:	55                   	push   %rbp
  801cf7:	48 89 e5             	mov    %rsp,%rbp
  801cfa:	48 83 ec 20          	sub    $0x20,%rsp
  801cfe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801d02:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801d06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d0a:	48 89 c7             	mov    %rax,%rdi
  801d0d:	48 b8 47 1c 80 00 00 	movabs $0x801c47,%rax
  801d14:	00 00 00 
  801d17:	ff d0                	callq  *%rax
  801d19:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801d1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801d1f:	48 63 d0             	movslq %eax,%rdx
  801d22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d26:	48 01 c2             	add    %rax,%rdx
  801d29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801d2d:	48 89 c6             	mov    %rax,%rsi
  801d30:	48 89 d7             	mov    %rdx,%rdi
  801d33:	48 b8 b3 1c 80 00 00 	movabs $0x801cb3,%rax
  801d3a:	00 00 00 
  801d3d:	ff d0                	callq  *%rax
	return dst;
  801d3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801d43:	c9                   	leaveq 
  801d44:	c3                   	retq   

0000000000801d45 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801d45:	55                   	push   %rbp
  801d46:	48 89 e5             	mov    %rsp,%rbp
  801d49:	48 83 ec 28          	sub    $0x28,%rsp
  801d4d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801d51:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801d55:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801d59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d5d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801d61:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801d68:	00 
  801d69:	eb 2a                	jmp    801d95 <strncpy+0x50>
		*dst++ = *src;
  801d6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d6f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801d73:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801d77:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801d7b:	0f b6 12             	movzbl (%rdx),%edx
  801d7e:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801d80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801d84:	0f b6 00             	movzbl (%rax),%eax
  801d87:	84 c0                	test   %al,%al
  801d89:	74 05                	je     801d90 <strncpy+0x4b>
			src++;
  801d8b:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
	for (i = 0; i < size; i++) {
  801d90:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801d95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801d99:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801d9d:	72 cc                	jb     801d6b <strncpy+0x26>
	}
	return ret;
  801d9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801da3:	c9                   	leaveq 
  801da4:	c3                   	retq   

0000000000801da5 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801da5:	55                   	push   %rbp
  801da6:	48 89 e5             	mov    %rsp,%rbp
  801da9:	48 83 ec 28          	sub    $0x28,%rsp
  801dad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801db1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801db5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801db9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801dbd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801dc1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801dc6:	74 3d                	je     801e05 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  801dc8:	eb 1d                	jmp    801de7 <strlcpy+0x42>
			*dst++ = *src++;
  801dca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801dce:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801dd2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801dd6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801dda:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801dde:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801de2:	0f b6 12             	movzbl (%rdx),%edx
  801de5:	88 10                	mov    %dl,(%rax)
		while (--size > 0 && *src != '\0')
  801de7:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  801dec:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801df1:	74 0b                	je     801dfe <strlcpy+0x59>
  801df3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801df7:	0f b6 00             	movzbl (%rax),%eax
  801dfa:	84 c0                	test   %al,%al
  801dfc:	75 cc                	jne    801dca <strlcpy+0x25>
		*dst = '\0';
  801dfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e02:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  801e05:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801e09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e0d:	48 29 c2             	sub    %rax,%rdx
  801e10:	48 89 d0             	mov    %rdx,%rax
}
  801e13:	c9                   	leaveq 
  801e14:	c3                   	retq   

0000000000801e15 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  801e15:	55                   	push   %rbp
  801e16:	48 89 e5             	mov    %rsp,%rbp
  801e19:	48 83 ec 10          	sub    $0x10,%rsp
  801e1d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801e21:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  801e25:	eb 0a                	jmp    801e31 <strcmp+0x1c>
		p++, q++;
  801e27:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801e2c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (*p && *p == *q)
  801e31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e35:	0f b6 00             	movzbl (%rax),%eax
  801e38:	84 c0                	test   %al,%al
  801e3a:	74 12                	je     801e4e <strcmp+0x39>
  801e3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e40:	0f b6 10             	movzbl (%rax),%edx
  801e43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801e47:	0f b6 00             	movzbl (%rax),%eax
  801e4a:	38 c2                	cmp    %al,%dl
  801e4c:	74 d9                	je     801e27 <strcmp+0x12>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  801e4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e52:	0f b6 00             	movzbl (%rax),%eax
  801e55:	0f b6 d0             	movzbl %al,%edx
  801e58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801e5c:	0f b6 00             	movzbl (%rax),%eax
  801e5f:	0f b6 c0             	movzbl %al,%eax
  801e62:	29 c2                	sub    %eax,%edx
  801e64:	89 d0                	mov    %edx,%eax
}
  801e66:	c9                   	leaveq 
  801e67:	c3                   	retq   

0000000000801e68 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  801e68:	55                   	push   %rbp
  801e69:	48 89 e5             	mov    %rsp,%rbp
  801e6c:	48 83 ec 18          	sub    $0x18,%rsp
  801e70:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801e74:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  801e78:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  801e7c:	eb 0f                	jmp    801e8d <strncmp+0x25>
		n--, p++, q++;
  801e7e:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  801e83:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801e88:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (n > 0 && *p && *p == *q)
  801e8d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801e92:	74 1d                	je     801eb1 <strncmp+0x49>
  801e94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e98:	0f b6 00             	movzbl (%rax),%eax
  801e9b:	84 c0                	test   %al,%al
  801e9d:	74 12                	je     801eb1 <strncmp+0x49>
  801e9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ea3:	0f b6 10             	movzbl (%rax),%edx
  801ea6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801eaa:	0f b6 00             	movzbl (%rax),%eax
  801ead:	38 c2                	cmp    %al,%dl
  801eaf:	74 cd                	je     801e7e <strncmp+0x16>
	if (n == 0)
  801eb1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801eb6:	75 07                	jne    801ebf <strncmp+0x57>
		return 0;
  801eb8:	b8 00 00 00 00       	mov    $0x0,%eax
  801ebd:	eb 18                	jmp    801ed7 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801ebf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ec3:	0f b6 00             	movzbl (%rax),%eax
  801ec6:	0f b6 d0             	movzbl %al,%edx
  801ec9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ecd:	0f b6 00             	movzbl (%rax),%eax
  801ed0:	0f b6 c0             	movzbl %al,%eax
  801ed3:	29 c2                	sub    %eax,%edx
  801ed5:	89 d0                	mov    %edx,%eax
}
  801ed7:	c9                   	leaveq 
  801ed8:	c3                   	retq   

0000000000801ed9 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  801ed9:	55                   	push   %rbp
  801eda:	48 89 e5             	mov    %rsp,%rbp
  801edd:	48 83 ec 10          	sub    $0x10,%rsp
  801ee1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801ee5:	89 f0                	mov    %esi,%eax
  801ee7:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  801eea:	eb 17                	jmp    801f03 <strchr+0x2a>
		if (*s == c)
  801eec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ef0:	0f b6 00             	movzbl (%rax),%eax
  801ef3:	3a 45 f4             	cmp    -0xc(%rbp),%al
  801ef6:	75 06                	jne    801efe <strchr+0x25>
			return (char *) s;
  801ef8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801efc:	eb 15                	jmp    801f13 <strchr+0x3a>
	for (; *s; s++)
  801efe:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801f03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f07:	0f b6 00             	movzbl (%rax),%eax
  801f0a:	84 c0                	test   %al,%al
  801f0c:	75 de                	jne    801eec <strchr+0x13>
	return 0;
  801f0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801f13:	c9                   	leaveq 
  801f14:	c3                   	retq   

0000000000801f15 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  801f15:	55                   	push   %rbp
  801f16:	48 89 e5             	mov    %rsp,%rbp
  801f19:	48 83 ec 10          	sub    $0x10,%rsp
  801f1d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801f21:	89 f0                	mov    %esi,%eax
  801f23:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  801f26:	eb 13                	jmp    801f3b <strfind+0x26>
		if (*s == c)
  801f28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f2c:	0f b6 00             	movzbl (%rax),%eax
  801f2f:	3a 45 f4             	cmp    -0xc(%rbp),%al
  801f32:	75 02                	jne    801f36 <strfind+0x21>
			break;
  801f34:	eb 10                	jmp    801f46 <strfind+0x31>
	for (; *s; s++)
  801f36:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801f3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f3f:	0f b6 00             	movzbl (%rax),%eax
  801f42:	84 c0                	test   %al,%al
  801f44:	75 e2                	jne    801f28 <strfind+0x13>
	return (char *) s;
  801f46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801f4a:	c9                   	leaveq 
  801f4b:	c3                   	retq   

0000000000801f4c <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801f4c:	55                   	push   %rbp
  801f4d:	48 89 e5             	mov    %rsp,%rbp
  801f50:	48 83 ec 18          	sub    $0x18,%rsp
  801f54:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801f58:	89 75 f4             	mov    %esi,-0xc(%rbp)
  801f5b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  801f5f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801f64:	75 06                	jne    801f6c <memset+0x20>
		return v;
  801f66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f6a:	eb 69                	jmp    801fd5 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  801f6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f70:	83 e0 03             	and    $0x3,%eax
  801f73:	48 85 c0             	test   %rax,%rax
  801f76:	75 48                	jne    801fc0 <memset+0x74>
  801f78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f7c:	83 e0 03             	and    $0x3,%eax
  801f7f:	48 85 c0             	test   %rax,%rax
  801f82:	75 3c                	jne    801fc0 <memset+0x74>
		c &= 0xFF;
  801f84:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  801f8b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  801f8e:	c1 e0 18             	shl    $0x18,%eax
  801f91:	89 c2                	mov    %eax,%edx
  801f93:	8b 45 f4             	mov    -0xc(%rbp),%eax
  801f96:	c1 e0 10             	shl    $0x10,%eax
  801f99:	09 c2                	or     %eax,%edx
  801f9b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  801f9e:	c1 e0 08             	shl    $0x8,%eax
  801fa1:	09 d0                	or     %edx,%eax
  801fa3:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  801fa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801faa:	48 c1 e8 02          	shr    $0x2,%rax
  801fae:	48 89 c1             	mov    %rax,%rcx
		asm volatile("cld; rep stosl\n"
  801fb1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  801fb5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  801fb8:	48 89 d7             	mov    %rdx,%rdi
  801fbb:	fc                   	cld    
  801fbc:	f3 ab                	rep stos %eax,%es:(%rdi)
  801fbe:	eb 11                	jmp    801fd1 <memset+0x85>
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  801fc0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  801fc4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  801fc7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  801fcb:	48 89 d7             	mov    %rdx,%rdi
  801fce:	fc                   	cld    
  801fcf:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  801fd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801fd5:	c9                   	leaveq 
  801fd6:	c3                   	retq   

0000000000801fd7 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  801fd7:	55                   	push   %rbp
  801fd8:	48 89 e5             	mov    %rsp,%rbp
  801fdb:	48 83 ec 28          	sub    $0x28,%rsp
  801fdf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801fe3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801fe7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  801feb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801fef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  801ff3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ff7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  801ffb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fff:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802003:	0f 83 88 00 00 00    	jae    802091 <memmove+0xba>
  802009:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80200d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802011:	48 01 d0             	add    %rdx,%rax
  802014:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802018:	76 77                	jbe    802091 <memmove+0xba>
		s += n;
  80201a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80201e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  802022:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802026:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80202a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80202e:	83 e0 03             	and    $0x3,%eax
  802031:	48 85 c0             	test   %rax,%rax
  802034:	75 3b                	jne    802071 <memmove+0x9a>
  802036:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80203a:	83 e0 03             	and    $0x3,%eax
  80203d:	48 85 c0             	test   %rax,%rax
  802040:	75 2f                	jne    802071 <memmove+0x9a>
  802042:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802046:	83 e0 03             	and    $0x3,%eax
  802049:	48 85 c0             	test   %rax,%rax
  80204c:	75 23                	jne    802071 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80204e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802052:	48 83 e8 04          	sub    $0x4,%rax
  802056:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80205a:	48 83 ea 04          	sub    $0x4,%rdx
  80205e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802062:	48 c1 e9 02          	shr    $0x2,%rcx
			asm volatile("std; rep movsl\n"
  802066:	48 89 c7             	mov    %rax,%rdi
  802069:	48 89 d6             	mov    %rdx,%rsi
  80206c:	fd                   	std    
  80206d:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80206f:	eb 1d                	jmp    80208e <memmove+0xb7>
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  802071:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802075:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802079:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80207d:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
			asm volatile("std; rep movsb\n"
  802081:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802085:	48 89 d7             	mov    %rdx,%rdi
  802088:	48 89 c1             	mov    %rax,%rcx
  80208b:	fd                   	std    
  80208c:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80208e:	fc                   	cld    
  80208f:	eb 57                	jmp    8020e8 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  802091:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802095:	83 e0 03             	and    $0x3,%eax
  802098:	48 85 c0             	test   %rax,%rax
  80209b:	75 36                	jne    8020d3 <memmove+0xfc>
  80209d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020a1:	83 e0 03             	and    $0x3,%eax
  8020a4:	48 85 c0             	test   %rax,%rax
  8020a7:	75 2a                	jne    8020d3 <memmove+0xfc>
  8020a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8020ad:	83 e0 03             	and    $0x3,%eax
  8020b0:	48 85 c0             	test   %rax,%rax
  8020b3:	75 1e                	jne    8020d3 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8020b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8020b9:	48 c1 e8 02          	shr    $0x2,%rax
  8020bd:	48 89 c1             	mov    %rax,%rcx
			asm volatile("cld; rep movsl\n"
  8020c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020c4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8020c8:	48 89 c7             	mov    %rax,%rdi
  8020cb:	48 89 d6             	mov    %rdx,%rsi
  8020ce:	fc                   	cld    
  8020cf:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8020d1:	eb 15                	jmp    8020e8 <memmove+0x111>
		else
			asm volatile("cld; rep movsb\n"
  8020d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020d7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8020db:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8020df:	48 89 c7             	mov    %rax,%rdi
  8020e2:	48 89 d6             	mov    %rdx,%rsi
  8020e5:	fc                   	cld    
  8020e6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8020e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8020ec:	c9                   	leaveq 
  8020ed:	c3                   	retq   

00000000008020ee <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  8020ee:	55                   	push   %rbp
  8020ef:	48 89 e5             	mov    %rsp,%rbp
  8020f2:	48 83 ec 18          	sub    $0x18,%rsp
  8020f6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8020fa:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8020fe:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  802102:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802106:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80210a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80210e:	48 89 ce             	mov    %rcx,%rsi
  802111:	48 89 c7             	mov    %rax,%rdi
  802114:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  80211b:	00 00 00 
  80211e:	ff d0                	callq  *%rax
}
  802120:	c9                   	leaveq 
  802121:	c3                   	retq   

0000000000802122 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  802122:	55                   	push   %rbp
  802123:	48 89 e5             	mov    %rsp,%rbp
  802126:	48 83 ec 28          	sub    $0x28,%rsp
  80212a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80212e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802132:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  802136:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80213a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  80213e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802142:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  802146:	eb 36                	jmp    80217e <memcmp+0x5c>
		if (*s1 != *s2)
  802148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80214c:	0f b6 10             	movzbl (%rax),%edx
  80214f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802153:	0f b6 00             	movzbl (%rax),%eax
  802156:	38 c2                	cmp    %al,%dl
  802158:	74 1a                	je     802174 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  80215a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80215e:	0f b6 00             	movzbl (%rax),%eax
  802161:	0f b6 d0             	movzbl %al,%edx
  802164:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802168:	0f b6 00             	movzbl (%rax),%eax
  80216b:	0f b6 c0             	movzbl %al,%eax
  80216e:	29 c2                	sub    %eax,%edx
  802170:	89 d0                	mov    %edx,%eax
  802172:	eb 20                	jmp    802194 <memcmp+0x72>
		s1++, s2++;
  802174:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802179:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (n-- > 0) {
  80217e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802182:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802186:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80218a:	48 85 c0             	test   %rax,%rax
  80218d:	75 b9                	jne    802148 <memcmp+0x26>
	}

	return 0;
  80218f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802194:	c9                   	leaveq 
  802195:	c3                   	retq   

0000000000802196 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  802196:	55                   	push   %rbp
  802197:	48 89 e5             	mov    %rsp,%rbp
  80219a:	48 83 ec 28          	sub    $0x28,%rsp
  80219e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8021a2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8021a5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8021a9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8021ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8021b1:	48 01 d0             	add    %rdx,%rax
  8021b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8021b8:	eb 15                	jmp    8021cf <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  8021ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021be:	0f b6 00             	movzbl (%rax),%eax
  8021c1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8021c4:	38 d0                	cmp    %dl,%al
  8021c6:	75 02                	jne    8021ca <memfind+0x34>
			break;
  8021c8:	eb 0f                	jmp    8021d9 <memfind+0x43>
	for (; s < ends; s++)
  8021ca:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8021cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021d3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8021d7:	72 e1                	jb     8021ba <memfind+0x24>
	return (void *) s;
  8021d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8021dd:	c9                   	leaveq 
  8021de:	c3                   	retq   

00000000008021df <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8021df:	55                   	push   %rbp
  8021e0:	48 89 e5             	mov    %rsp,%rbp
  8021e3:	48 83 ec 38          	sub    $0x38,%rsp
  8021e7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8021eb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8021ef:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  8021f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  8021f9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  802200:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802201:	eb 05                	jmp    802208 <strtol+0x29>
		s++;
  802203:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	while (*s == ' ' || *s == '\t')
  802208:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80220c:	0f b6 00             	movzbl (%rax),%eax
  80220f:	3c 20                	cmp    $0x20,%al
  802211:	74 f0                	je     802203 <strtol+0x24>
  802213:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802217:	0f b6 00             	movzbl (%rax),%eax
  80221a:	3c 09                	cmp    $0x9,%al
  80221c:	74 e5                	je     802203 <strtol+0x24>

	// plus/minus sign
	if (*s == '+')
  80221e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802222:	0f b6 00             	movzbl (%rax),%eax
  802225:	3c 2b                	cmp    $0x2b,%al
  802227:	75 07                	jne    802230 <strtol+0x51>
		s++;
  802229:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80222e:	eb 17                	jmp    802247 <strtol+0x68>
	else if (*s == '-')
  802230:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802234:	0f b6 00             	movzbl (%rax),%eax
  802237:	3c 2d                	cmp    $0x2d,%al
  802239:	75 0c                	jne    802247 <strtol+0x68>
		s++, neg = 1;
  80223b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802240:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  802247:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80224b:	74 06                	je     802253 <strtol+0x74>
  80224d:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  802251:	75 28                	jne    80227b <strtol+0x9c>
  802253:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802257:	0f b6 00             	movzbl (%rax),%eax
  80225a:	3c 30                	cmp    $0x30,%al
  80225c:	75 1d                	jne    80227b <strtol+0x9c>
  80225e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802262:	48 83 c0 01          	add    $0x1,%rax
  802266:	0f b6 00             	movzbl (%rax),%eax
  802269:	3c 78                	cmp    $0x78,%al
  80226b:	75 0e                	jne    80227b <strtol+0x9c>
		s += 2, base = 16;
  80226d:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  802272:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  802279:	eb 2c                	jmp    8022a7 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  80227b:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80227f:	75 19                	jne    80229a <strtol+0xbb>
  802281:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802285:	0f b6 00             	movzbl (%rax),%eax
  802288:	3c 30                	cmp    $0x30,%al
  80228a:	75 0e                	jne    80229a <strtol+0xbb>
		s++, base = 8;
  80228c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802291:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  802298:	eb 0d                	jmp    8022a7 <strtol+0xc8>
	else if (base == 0)
  80229a:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80229e:	75 07                	jne    8022a7 <strtol+0xc8>
		base = 10;
  8022a0:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8022a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022ab:	0f b6 00             	movzbl (%rax),%eax
  8022ae:	3c 2f                	cmp    $0x2f,%al
  8022b0:	7e 1d                	jle    8022cf <strtol+0xf0>
  8022b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022b6:	0f b6 00             	movzbl (%rax),%eax
  8022b9:	3c 39                	cmp    $0x39,%al
  8022bb:	7f 12                	jg     8022cf <strtol+0xf0>
			dig = *s - '0';
  8022bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022c1:	0f b6 00             	movzbl (%rax),%eax
  8022c4:	0f be c0             	movsbl %al,%eax
  8022c7:	83 e8 30             	sub    $0x30,%eax
  8022ca:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8022cd:	eb 4e                	jmp    80231d <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8022cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022d3:	0f b6 00             	movzbl (%rax),%eax
  8022d6:	3c 60                	cmp    $0x60,%al
  8022d8:	7e 1d                	jle    8022f7 <strtol+0x118>
  8022da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022de:	0f b6 00             	movzbl (%rax),%eax
  8022e1:	3c 7a                	cmp    $0x7a,%al
  8022e3:	7f 12                	jg     8022f7 <strtol+0x118>
			dig = *s - 'a' + 10;
  8022e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022e9:	0f b6 00             	movzbl (%rax),%eax
  8022ec:	0f be c0             	movsbl %al,%eax
  8022ef:	83 e8 57             	sub    $0x57,%eax
  8022f2:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8022f5:	eb 26                	jmp    80231d <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  8022f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022fb:	0f b6 00             	movzbl (%rax),%eax
  8022fe:	3c 40                	cmp    $0x40,%al
  802300:	7e 48                	jle    80234a <strtol+0x16b>
  802302:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802306:	0f b6 00             	movzbl (%rax),%eax
  802309:	3c 5a                	cmp    $0x5a,%al
  80230b:	7f 3d                	jg     80234a <strtol+0x16b>
			dig = *s - 'A' + 10;
  80230d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802311:	0f b6 00             	movzbl (%rax),%eax
  802314:	0f be c0             	movsbl %al,%eax
  802317:	83 e8 37             	sub    $0x37,%eax
  80231a:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  80231d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802320:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  802323:	7c 02                	jl     802327 <strtol+0x148>
			break;
  802325:	eb 23                	jmp    80234a <strtol+0x16b>
		s++, val = (val * base) + dig;
  802327:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80232c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80232f:	48 98                	cltq   
  802331:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  802336:	48 89 c2             	mov    %rax,%rdx
  802339:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80233c:	48 98                	cltq   
  80233e:	48 01 d0             	add    %rdx,%rax
  802341:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  802345:	e9 5d ff ff ff       	jmpq   8022a7 <strtol+0xc8>

	if (endptr)
  80234a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80234f:	74 0b                	je     80235c <strtol+0x17d>
		*endptr = (char *) s;
  802351:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802355:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  802359:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  80235c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802360:	74 09                	je     80236b <strtol+0x18c>
  802362:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802366:	48 f7 d8             	neg    %rax
  802369:	eb 04                	jmp    80236f <strtol+0x190>
  80236b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80236f:	c9                   	leaveq 
  802370:	c3                   	retq   

0000000000802371 <strstr>:

char * strstr(const char *in, const char *str)
{
  802371:	55                   	push   %rbp
  802372:	48 89 e5             	mov    %rsp,%rbp
  802375:	48 83 ec 30          	sub    $0x30,%rsp
  802379:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80237d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  802381:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802385:	48 8d 50 01          	lea    0x1(%rax),%rdx
  802389:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80238d:	0f b6 00             	movzbl (%rax),%eax
  802390:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  802393:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  802397:	75 06                	jne    80239f <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  802399:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80239d:	eb 6b                	jmp    80240a <strstr+0x99>

	len = strlen(str);
  80239f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8023a3:	48 89 c7             	mov    %rax,%rdi
  8023a6:	48 b8 47 1c 80 00 00 	movabs $0x801c47,%rax
  8023ad:	00 00 00 
  8023b0:	ff d0                	callq  *%rax
  8023b2:	48 98                	cltq   
  8023b4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  8023b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023bc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8023c0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8023c4:	0f b6 00             	movzbl (%rax),%eax
  8023c7:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  8023ca:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8023ce:	75 07                	jne    8023d7 <strstr+0x66>
				return (char *) 0;
  8023d0:	b8 00 00 00 00       	mov    $0x0,%eax
  8023d5:	eb 33                	jmp    80240a <strstr+0x99>
		} while (sc != c);
  8023d7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8023db:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8023de:	75 d8                	jne    8023b8 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8023e0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8023e4:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8023e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023ec:	48 89 ce             	mov    %rcx,%rsi
  8023ef:	48 89 c7             	mov    %rax,%rdi
  8023f2:	48 b8 68 1e 80 00 00 	movabs $0x801e68,%rax
  8023f9:	00 00 00 
  8023fc:	ff d0                	callq  *%rax
  8023fe:	85 c0                	test   %eax,%eax
  802400:	75 b6                	jne    8023b8 <strstr+0x47>

	return (char *) (in - 1);
  802402:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802406:	48 83 e8 01          	sub    $0x1,%rax
}
  80240a:	c9                   	leaveq 
  80240b:	c3                   	retq   

000000000080240c <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  80240c:	55                   	push   %rbp
  80240d:	48 89 e5             	mov    %rsp,%rbp
  802410:	53                   	push   %rbx
  802411:	48 83 ec 48          	sub    $0x48,%rsp
  802415:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802418:	89 75 d8             	mov    %esi,-0x28(%rbp)
  80241b:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80241f:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  802423:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  802427:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80242b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80242e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  802432:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  802436:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  80243a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80243e:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  802442:	4c 89 c3             	mov    %r8,%rbx
  802445:	cd 30                	int    $0x30
  802447:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80244b:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80244f:	74 3e                	je     80248f <syscall+0x83>
  802451:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  802456:	7e 37                	jle    80248f <syscall+0x83>
		panic("syscall %d returned %d (> 0)", num, ret);
  802458:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80245c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80245f:	49 89 d0             	mov    %rdx,%r8
  802462:	89 c1                	mov    %eax,%ecx
  802464:	48 ba c8 06 82 00 00 	movabs $0x8206c8,%rdx
  80246b:	00 00 00 
  80246e:	be 23 00 00 00       	mov    $0x23,%esi
  802473:	48 bf e5 06 82 00 00 	movabs $0x8206e5,%rdi
  80247a:	00 00 00 
  80247d:	b8 00 00 00 00       	mov    $0x0,%eax
  802482:	49 b9 e0 0e 80 00 00 	movabs $0x800ee0,%r9
  802489:	00 00 00 
  80248c:	41 ff d1             	callq  *%r9

	return ret;
  80248f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802493:	48 83 c4 48          	add    $0x48,%rsp
  802497:	5b                   	pop    %rbx
  802498:	5d                   	pop    %rbp
  802499:	c3                   	retq   

000000000080249a <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  80249a:	55                   	push   %rbp
  80249b:	48 89 e5             	mov    %rsp,%rbp
  80249e:	48 83 ec 10          	sub    $0x10,%rsp
  8024a2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8024a6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  8024aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8024ae:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8024b2:	48 83 ec 08          	sub    $0x8,%rsp
  8024b6:	6a 00                	pushq  $0x0
  8024b8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8024be:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8024c4:	48 89 d1             	mov    %rdx,%rcx
  8024c7:	48 89 c2             	mov    %rax,%rdx
  8024ca:	be 00 00 00 00       	mov    $0x0,%esi
  8024cf:	bf 00 00 00 00       	mov    $0x0,%edi
  8024d4:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  8024db:	00 00 00 
  8024de:	ff d0                	callq  *%rax
  8024e0:	48 83 c4 10          	add    $0x10,%rsp
}
  8024e4:	c9                   	leaveq 
  8024e5:	c3                   	retq   

00000000008024e6 <sys_cgetc>:

int
sys_cgetc(void)
{
  8024e6:	55                   	push   %rbp
  8024e7:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  8024ea:	48 83 ec 08          	sub    $0x8,%rsp
  8024ee:	6a 00                	pushq  $0x0
  8024f0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8024f6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8024fc:	b9 00 00 00 00       	mov    $0x0,%ecx
  802501:	ba 00 00 00 00       	mov    $0x0,%edx
  802506:	be 00 00 00 00       	mov    $0x0,%esi
  80250b:	bf 01 00 00 00       	mov    $0x1,%edi
  802510:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802517:	00 00 00 
  80251a:	ff d0                	callq  *%rax
  80251c:	48 83 c4 10          	add    $0x10,%rsp
}
  802520:	c9                   	leaveq 
  802521:	c3                   	retq   

0000000000802522 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  802522:	55                   	push   %rbp
  802523:	48 89 e5             	mov    %rsp,%rbp
  802526:	48 83 ec 10          	sub    $0x10,%rsp
  80252a:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  80252d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802530:	48 98                	cltq   
  802532:	48 83 ec 08          	sub    $0x8,%rsp
  802536:	6a 00                	pushq  $0x0
  802538:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80253e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802544:	b9 00 00 00 00       	mov    $0x0,%ecx
  802549:	48 89 c2             	mov    %rax,%rdx
  80254c:	be 01 00 00 00       	mov    $0x1,%esi
  802551:	bf 03 00 00 00       	mov    $0x3,%edi
  802556:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  80255d:	00 00 00 
  802560:	ff d0                	callq  *%rax
  802562:	48 83 c4 10          	add    $0x10,%rsp
}
  802566:	c9                   	leaveq 
  802567:	c3                   	retq   

0000000000802568 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  802568:	55                   	push   %rbp
  802569:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  80256c:	48 83 ec 08          	sub    $0x8,%rsp
  802570:	6a 00                	pushq  $0x0
  802572:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802578:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80257e:	b9 00 00 00 00       	mov    $0x0,%ecx
  802583:	ba 00 00 00 00       	mov    $0x0,%edx
  802588:	be 00 00 00 00       	mov    $0x0,%esi
  80258d:	bf 02 00 00 00       	mov    $0x2,%edi
  802592:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802599:	00 00 00 
  80259c:	ff d0                	callq  *%rax
  80259e:	48 83 c4 10          	add    $0x10,%rsp
}
  8025a2:	c9                   	leaveq 
  8025a3:	c3                   	retq   

00000000008025a4 <sys_yield>:

void
sys_yield(void)
{
  8025a4:	55                   	push   %rbp
  8025a5:	48 89 e5             	mov    %rsp,%rbp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8025a8:	48 83 ec 08          	sub    $0x8,%rsp
  8025ac:	6a 00                	pushq  $0x0
  8025ae:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8025b4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8025ba:	b9 00 00 00 00       	mov    $0x0,%ecx
  8025bf:	ba 00 00 00 00       	mov    $0x0,%edx
  8025c4:	be 00 00 00 00       	mov    $0x0,%esi
  8025c9:	bf 0b 00 00 00       	mov    $0xb,%edi
  8025ce:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  8025d5:	00 00 00 
  8025d8:	ff d0                	callq  *%rax
  8025da:	48 83 c4 10          	add    $0x10,%rsp
}
  8025de:	c9                   	leaveq 
  8025df:	c3                   	retq   

00000000008025e0 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  8025e0:	55                   	push   %rbp
  8025e1:	48 89 e5             	mov    %rsp,%rbp
  8025e4:	48 83 ec 10          	sub    $0x10,%rsp
  8025e8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8025eb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8025ef:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  8025f2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8025f5:	48 63 c8             	movslq %eax,%rcx
  8025f8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8025fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8025ff:	48 98                	cltq   
  802601:	48 83 ec 08          	sub    $0x8,%rsp
  802605:	6a 00                	pushq  $0x0
  802607:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80260d:	49 89 c8             	mov    %rcx,%r8
  802610:	48 89 d1             	mov    %rdx,%rcx
  802613:	48 89 c2             	mov    %rax,%rdx
  802616:	be 01 00 00 00       	mov    $0x1,%esi
  80261b:	bf 04 00 00 00       	mov    $0x4,%edi
  802620:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802627:	00 00 00 
  80262a:	ff d0                	callq  *%rax
  80262c:	48 83 c4 10          	add    $0x10,%rsp
}
  802630:	c9                   	leaveq 
  802631:	c3                   	retq   

0000000000802632 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  802632:	55                   	push   %rbp
  802633:	48 89 e5             	mov    %rsp,%rbp
  802636:	48 83 ec 20          	sub    $0x20,%rsp
  80263a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80263d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802641:	89 55 f8             	mov    %edx,-0x8(%rbp)
  802644:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802648:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  80264c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80264f:	48 63 c8             	movslq %eax,%rcx
  802652:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  802656:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802659:	48 63 f0             	movslq %eax,%rsi
  80265c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802660:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802663:	48 98                	cltq   
  802665:	48 83 ec 08          	sub    $0x8,%rsp
  802669:	51                   	push   %rcx
  80266a:	49 89 f9             	mov    %rdi,%r9
  80266d:	49 89 f0             	mov    %rsi,%r8
  802670:	48 89 d1             	mov    %rdx,%rcx
  802673:	48 89 c2             	mov    %rax,%rdx
  802676:	be 01 00 00 00       	mov    $0x1,%esi
  80267b:	bf 05 00 00 00       	mov    $0x5,%edi
  802680:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802687:	00 00 00 
  80268a:	ff d0                	callq  *%rax
  80268c:	48 83 c4 10          	add    $0x10,%rsp
}
  802690:	c9                   	leaveq 
  802691:	c3                   	retq   

0000000000802692 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  802692:	55                   	push   %rbp
  802693:	48 89 e5             	mov    %rsp,%rbp
  802696:	48 83 ec 10          	sub    $0x10,%rsp
  80269a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80269d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  8026a1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026a5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8026a8:	48 98                	cltq   
  8026aa:	48 83 ec 08          	sub    $0x8,%rsp
  8026ae:	6a 00                	pushq  $0x0
  8026b0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8026b6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8026bc:	48 89 d1             	mov    %rdx,%rcx
  8026bf:	48 89 c2             	mov    %rax,%rdx
  8026c2:	be 01 00 00 00       	mov    $0x1,%esi
  8026c7:	bf 06 00 00 00       	mov    $0x6,%edi
  8026cc:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  8026d3:	00 00 00 
  8026d6:	ff d0                	callq  *%rax
  8026d8:	48 83 c4 10          	add    $0x10,%rsp
}
  8026dc:	c9                   	leaveq 
  8026dd:	c3                   	retq   

00000000008026de <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8026de:	55                   	push   %rbp
  8026df:	48 89 e5             	mov    %rsp,%rbp
  8026e2:	48 83 ec 10          	sub    $0x10,%rsp
  8026e6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8026e9:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  8026ec:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8026ef:	48 63 d0             	movslq %eax,%rdx
  8026f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8026f5:	48 98                	cltq   
  8026f7:	48 83 ec 08          	sub    $0x8,%rsp
  8026fb:	6a 00                	pushq  $0x0
  8026fd:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802703:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802709:	48 89 d1             	mov    %rdx,%rcx
  80270c:	48 89 c2             	mov    %rax,%rdx
  80270f:	be 01 00 00 00       	mov    $0x1,%esi
  802714:	bf 08 00 00 00       	mov    $0x8,%edi
  802719:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802720:	00 00 00 
  802723:	ff d0                	callq  *%rax
  802725:	48 83 c4 10          	add    $0x10,%rsp
}
  802729:	c9                   	leaveq 
  80272a:	c3                   	retq   

000000000080272b <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80272b:	55                   	push   %rbp
  80272c:	48 89 e5             	mov    %rsp,%rbp
  80272f:	48 83 ec 10          	sub    $0x10,%rsp
  802733:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802736:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  80273a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80273e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802741:	48 98                	cltq   
  802743:	48 83 ec 08          	sub    $0x8,%rsp
  802747:	6a 00                	pushq  $0x0
  802749:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80274f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802755:	48 89 d1             	mov    %rdx,%rcx
  802758:	48 89 c2             	mov    %rax,%rdx
  80275b:	be 01 00 00 00       	mov    $0x1,%esi
  802760:	bf 09 00 00 00       	mov    $0x9,%edi
  802765:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  80276c:	00 00 00 
  80276f:	ff d0                	callq  *%rax
  802771:	48 83 c4 10          	add    $0x10,%rsp
}
  802775:	c9                   	leaveq 
  802776:	c3                   	retq   

0000000000802777 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  802777:	55                   	push   %rbp
  802778:	48 89 e5             	mov    %rsp,%rbp
  80277b:	48 83 ec 10          	sub    $0x10,%rsp
  80277f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802782:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  802786:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80278a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80278d:	48 98                	cltq   
  80278f:	48 83 ec 08          	sub    $0x8,%rsp
  802793:	6a 00                	pushq  $0x0
  802795:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80279b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027a1:	48 89 d1             	mov    %rdx,%rcx
  8027a4:	48 89 c2             	mov    %rax,%rdx
  8027a7:	be 01 00 00 00       	mov    $0x1,%esi
  8027ac:	bf 0a 00 00 00       	mov    $0xa,%edi
  8027b1:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  8027b8:	00 00 00 
  8027bb:	ff d0                	callq  *%rax
  8027bd:	48 83 c4 10          	add    $0x10,%rsp
}
  8027c1:	c9                   	leaveq 
  8027c2:	c3                   	retq   

00000000008027c3 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  8027c3:	55                   	push   %rbp
  8027c4:	48 89 e5             	mov    %rsp,%rbp
  8027c7:	48 83 ec 20          	sub    $0x20,%rsp
  8027cb:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8027ce:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8027d2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8027d6:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  8027d9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8027dc:	48 63 f0             	movslq %eax,%rsi
  8027df:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8027e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8027e6:	48 98                	cltq   
  8027e8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8027ec:	48 83 ec 08          	sub    $0x8,%rsp
  8027f0:	6a 00                	pushq  $0x0
  8027f2:	49 89 f1             	mov    %rsi,%r9
  8027f5:	49 89 c8             	mov    %rcx,%r8
  8027f8:	48 89 d1             	mov    %rdx,%rcx
  8027fb:	48 89 c2             	mov    %rax,%rdx
  8027fe:	be 00 00 00 00       	mov    $0x0,%esi
  802803:	bf 0c 00 00 00       	mov    $0xc,%edi
  802808:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  80280f:	00 00 00 
  802812:	ff d0                	callq  *%rax
  802814:	48 83 c4 10          	add    $0x10,%rsp
}
  802818:	c9                   	leaveq 
  802819:	c3                   	retq   

000000000080281a <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80281a:	55                   	push   %rbp
  80281b:	48 89 e5             	mov    %rsp,%rbp
  80281e:	48 83 ec 10          	sub    $0x10,%rsp
  802822:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802826:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80282a:	48 83 ec 08          	sub    $0x8,%rsp
  80282e:	6a 00                	pushq  $0x0
  802830:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802836:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80283c:	b9 00 00 00 00       	mov    $0x0,%ecx
  802841:	48 89 c2             	mov    %rax,%rdx
  802844:	be 01 00 00 00       	mov    $0x1,%esi
  802849:	bf 0d 00 00 00       	mov    $0xd,%edi
  80284e:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802855:	00 00 00 
  802858:	ff d0                	callq  *%rax
  80285a:	48 83 c4 10          	add    $0x10,%rsp
}
  80285e:	c9                   	leaveq 
  80285f:	c3                   	retq   

0000000000802860 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  802860:	55                   	push   %rbp
  802861:	48 89 e5             	mov    %rsp,%rbp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  802864:	48 83 ec 08          	sub    $0x8,%rsp
  802868:	6a 00                	pushq  $0x0
  80286a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802870:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802876:	b9 00 00 00 00       	mov    $0x0,%ecx
  80287b:	ba 00 00 00 00       	mov    $0x0,%edx
  802880:	be 00 00 00 00       	mov    $0x0,%esi
  802885:	bf 0e 00 00 00       	mov    $0xe,%edi
  80288a:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  802891:	00 00 00 
  802894:	ff d0                	callq  *%rax
  802896:	48 83 c4 10          	add    $0x10,%rsp
}
  80289a:	c9                   	leaveq 
  80289b:	c3                   	retq   

000000000080289c <sys_ept_map>:


int
sys_ept_map(envid_t srcenvid, void *srcva, envid_t guest, void* guest_pa, int perm) 
{
  80289c:	55                   	push   %rbp
  80289d:	48 89 e5             	mov    %rsp,%rbp
  8028a0:	48 83 ec 20          	sub    $0x20,%rsp
  8028a4:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028a7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8028ab:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8028ae:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  8028b2:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_ept_map, 0, srcenvid, 
  8028b6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8028b9:	48 63 c8             	movslq %eax,%rcx
  8028bc:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8028c0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8028c3:	48 63 f0             	movslq %eax,%rsi
  8028c6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8028cd:	48 98                	cltq   
  8028cf:	48 83 ec 08          	sub    $0x8,%rsp
  8028d3:	51                   	push   %rcx
  8028d4:	49 89 f9             	mov    %rdi,%r9
  8028d7:	49 89 f0             	mov    %rsi,%r8
  8028da:	48 89 d1             	mov    %rdx,%rcx
  8028dd:	48 89 c2             	mov    %rax,%rdx
  8028e0:	be 00 00 00 00       	mov    $0x0,%esi
  8028e5:	bf 0f 00 00 00       	mov    $0xf,%edi
  8028ea:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  8028f1:	00 00 00 
  8028f4:	ff d0                	callq  *%rax
  8028f6:	48 83 c4 10          	add    $0x10,%rsp
		       (uint64_t)srcva, guest, (uint64_t)guest_pa, perm);
}
  8028fa:	c9                   	leaveq 
  8028fb:	c3                   	retq   

00000000008028fc <sys_env_mkguest>:

envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  8028fc:	55                   	push   %rbp
  8028fd:	48 89 e5             	mov    %rsp,%rbp
  802900:	48 83 ec 10          	sub    $0x10,%rsp
  802904:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802908:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return (envid_t) syscall(SYS_env_mkguest, 0, gphysz, gRIP, 0, 0, 0);
  80290c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802910:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802914:	48 83 ec 08          	sub    $0x8,%rsp
  802918:	6a 00                	pushq  $0x0
  80291a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802920:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802926:	48 89 d1             	mov    %rdx,%rcx
  802929:	48 89 c2             	mov    %rax,%rdx
  80292c:	be 00 00 00 00       	mov    $0x0,%esi
  802931:	bf 10 00 00 00       	mov    $0x10,%edi
  802936:	48 b8 0c 24 80 00 00 	movabs $0x80240c,%rax
  80293d:	00 00 00 
  802940:	ff d0                	callq  *%rax
  802942:	48 83 c4 10          	add    $0x10,%rsp
}
  802946:	c9                   	leaveq 
  802947:	c3                   	retq   

0000000000802948 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  802948:	55                   	push   %rbp
  802949:	48 89 e5             	mov    %rsp,%rbp
  80294c:	48 83 ec 20          	sub    $0x20,%rsp
  802950:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  802954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802958:	48 8b 00             	mov    (%rax),%rax
  80295b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t err = utf->utf_err;
  80295f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802963:	48 8b 40 08          	mov    0x8(%rax),%rax
  802967:	89 45 f4             	mov    %eax,-0xc(%rbp)
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.

	panic("pgfault not implemented");
  80296a:	48 ba f3 06 82 00 00 	movabs $0x8206f3,%rdx
  802971:	00 00 00 
  802974:	be 26 00 00 00       	mov    $0x26,%esi
  802979:	48 bf 0b 07 82 00 00 	movabs $0x82070b,%rdi
  802980:	00 00 00 
  802983:	b8 00 00 00 00       	mov    $0x0,%eax
  802988:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80298f:	00 00 00 
  802992:	ff d1                	callq  *%rcx

0000000000802994 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802994:	55                   	push   %rbp
  802995:	48 89 e5             	mov    %rsp,%rbp
  802998:	48 83 ec 10          	sub    $0x10,%rsp
  80299c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80299f:	89 75 f8             	mov    %esi,-0x8(%rbp)
	int r;

	// LAB 4: Your code here.
	panic("duppage not implemented");
  8029a2:	48 ba 16 07 82 00 00 	movabs $0x820716,%rdx
  8029a9:	00 00 00 
  8029ac:	be 3a 00 00 00       	mov    $0x3a,%esi
  8029b1:	48 bf 0b 07 82 00 00 	movabs $0x82070b,%rdi
  8029b8:	00 00 00 
  8029bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8029c0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8029c7:	00 00 00 
  8029ca:	ff d1                	callq  *%rcx

00000000008029cc <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  8029cc:	55                   	push   %rbp
  8029cd:	48 89 e5             	mov    %rsp,%rbp
	// LAB 4: Your code here.
	panic("fork not implemented");
  8029d0:	48 ba 2e 07 82 00 00 	movabs $0x82072e,%rdx
  8029d7:	00 00 00 
  8029da:	be 52 00 00 00       	mov    $0x52,%esi
  8029df:	48 bf 0b 07 82 00 00 	movabs $0x82070b,%rdi
  8029e6:	00 00 00 
  8029e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8029ee:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8029f5:	00 00 00 
  8029f8:	ff d1                	callq  *%rcx

00000000008029fa <sfork>:
}

// Challenge!
int
sfork(void)
{
  8029fa:	55                   	push   %rbp
  8029fb:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  8029fe:	48 ba 43 07 82 00 00 	movabs $0x820743,%rdx
  802a05:	00 00 00 
  802a08:	be 59 00 00 00       	mov    $0x59,%esi
  802a0d:	48 bf 0b 07 82 00 00 	movabs $0x82070b,%rdi
  802a14:	00 00 00 
  802a17:	b8 00 00 00 00       	mov    $0x0,%eax
  802a1c:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  802a23:	00 00 00 
  802a26:	ff d1                	callq  *%rcx

0000000000802a28 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  802a28:	55                   	push   %rbp
  802a29:	48 89 e5             	mov    %rsp,%rbp
  802a2c:	48 83 ec 20          	sub    $0x20,%rsp
  802a30:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802a34:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802a38:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// LAB 4: Your code here.
	panic("ipc_recv not implemented");
  802a3c:	48 ba 60 07 82 00 00 	movabs $0x820760,%rdx
  802a43:	00 00 00 
  802a46:	be 1d 00 00 00       	mov    $0x1d,%esi
  802a4b:	48 bf 79 07 82 00 00 	movabs $0x820779,%rdi
  802a52:	00 00 00 
  802a55:	b8 00 00 00 00       	mov    $0x0,%eax
  802a5a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  802a61:	00 00 00 
  802a64:	ff d1                	callq  *%rcx

0000000000802a66 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  802a66:	55                   	push   %rbp
  802a67:	48 89 e5             	mov    %rsp,%rbp
  802a6a:	48 83 ec 20          	sub    $0x20,%rsp
  802a6e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802a71:	89 75 f8             	mov    %esi,-0x8(%rbp)
  802a74:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  802a78:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	// LAB 4: Your code here.
	panic("ipc_send not implemented");
  802a7b:	48 ba 83 07 82 00 00 	movabs $0x820783,%rdx
  802a82:	00 00 00 
  802a85:	be 2d 00 00 00       	mov    $0x2d,%esi
  802a8a:	48 bf 79 07 82 00 00 	movabs $0x820779,%rdi
  802a91:	00 00 00 
  802a94:	b8 00 00 00 00       	mov    $0x0,%eax
  802a99:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  802aa0:	00 00 00 
  802aa3:	ff d1                	callq  *%rcx

0000000000802aa5 <ipc_host_recv>:
#ifdef VMM_GUEST

// Access to host IPC interface through VMCALL.
// Should behave similarly to ipc_recv, except replacing the system call with a vmcall.
int32_t
ipc_host_recv(void *pg) {
  802aa5:	55                   	push   %rbp
  802aa6:	48 89 e5             	mov    %rsp,%rbp
  802aa9:	53                   	push   %rbx
  802aaa:	48 83 ec 48          	sub    $0x48,%rsp
  802aae:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
	uint64_t a1;
	uint64_t a2;
	uint64_t a3;
	uint64_t a4;
	uint64_t a5;
	int ret = 0;
  802ab2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	int num = VMX_VMCALL_IPCRECV;
  802ab9:	c7 45 e8 03 00 00 00 	movl   $0x3,-0x18(%rbp)

	if(!pg)
  802ac0:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  802ac5:	75 0e                	jne    802ad5 <ipc_host_recv+0x30>
		pg = (void*) KERNBASE;
  802ac7:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  802ace:	00 00 00 
  802ad1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	a1 = (uint64_t) pg;
  802ad5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  802ad9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	a2 = (uint64_t) 0;
  802add:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  802ae4:	00 
	a3 = (uint64_t) 0;
  802ae5:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  802aec:	00 
	a4 = (uint64_t) 0;
  802aed:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  802af4:	00 
	a5 = 0;
  802af5:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  802afc:	00 

	//doubt : do we require what the site says ?

	asm volatile("vmcall\n"
  802afd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802b00:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  802b04:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802b08:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
  802b0c:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  802b10:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  802b14:	4c 89 c3             	mov    %r8,%rbx
  802b17:	0f 01 c1             	vmcall 
  802b1a:	89 45 ec             	mov    %eax,-0x14(%rbp)
			  "b" (a3),
			  "D" (a4),
			  "S" (a5)
			: "cc", "memory");

	if (ret > 0)
  802b1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802b21:	7e 36                	jle    802b59 <ipc_host_recv+0xb4>
	    panic("vmcall %d returned %d (> 0) in ipc_host_send", num, ret);
  802b23:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802b26:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802b29:	41 89 d0             	mov    %edx,%r8d
  802b2c:	89 c1                	mov    %eax,%ecx
  802b2e:	48 ba a0 07 82 00 00 	movabs $0x8207a0,%rdx
  802b35:	00 00 00 
  802b38:	be 54 00 00 00       	mov    $0x54,%esi
  802b3d:	48 bf 79 07 82 00 00 	movabs $0x820779,%rdi
  802b44:	00 00 00 
  802b47:	b8 00 00 00 00       	mov    $0x0,%eax
  802b4c:	49 b9 e0 0e 80 00 00 	movabs $0x800ee0,%r9
  802b53:	00 00 00 
  802b56:	41 ff d1             	callq  *%r9
	return ret;
  802b59:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  802b5c:	48 83 c4 48          	add    $0x48,%rsp
  802b60:	5b                   	pop    %rbx
  802b61:	5d                   	pop    %rbp
  802b62:	c3                   	retq   

0000000000802b63 <ipc_host_send>:
// Access to host IPC interface through VMCALL.
// Should behave similarly to ipc_send, except replacing the system call with a vmcall.
// This function should also convert pg from guest virtual to guest physical for the IPC call
void
ipc_host_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  802b63:	55                   	push   %rbp
  802b64:	48 89 e5             	mov    %rsp,%rbp
  802b67:	53                   	push   %rbx
  802b68:	48 83 ec 58          	sub    $0x58,%rsp
  802b6c:	89 7d b4             	mov    %edi,-0x4c(%rbp)
  802b6f:	89 75 b0             	mov    %esi,-0x50(%rbp)
  802b72:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  802b76:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
	uint64_t a1;
	uint64_t a2;
	uint64_t a3;
	uint64_t a4;
	uint64_t a5;
	int ret = 0;
  802b79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	int num = VMX_VMCALL_IPCSEND;
  802b80:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%rbp)

	if (!pg)
  802b87:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  802b8c:	75 0e                	jne    802b9c <ipc_host_send+0x39>
		pg = (void*)KERNBASE;
  802b8e:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  802b95:	00 00 00 
  802b98:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	a1 = (uint64_t)to_env;
  802b9c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  802b9f:	48 98                	cltq   
  802ba1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	a2 = (uint64_t)val;
  802ba5:	8b 45 b0             	mov    -0x50(%rbp),%eax
  802ba8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	a3 = (uint64_t)pg;
  802bac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  802bb0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	a4 = (uint64_t)perm;
  802bb4:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  802bb7:	48 98                	cltq   
  802bb9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	a5 = 0;
  802bbd:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  802bc4:	00 

	int r = -E_IPC_NOT_RECV;
  802bc5:	c7 45 c4 f8 ff ff ff 	movl   $0xfffffff8,-0x3c(%rbp)
	asm volatile("vmcall\n"
  802bcc:	8b 45 f0             	mov    -0x10(%rbp),%eax
  802bcf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802bd3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  802bd7:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
  802bdb:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  802bdf:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  802be3:	4c 89 c3             	mov    %r8,%rbx
  802be6:	0f 01 c1             	vmcall 
  802be9:	89 45 f4             	mov    %eax,-0xc(%rbp)
			       "D" (a4),
			       "S" (a5)
			     : "cc", "memory");


}
  802bec:	48 83 c4 58          	add    $0x58,%rsp
  802bf0:	5b                   	pop    %rbx
  802bf1:	5d                   	pop    %rbp
  802bf2:	c3                   	retq   

0000000000802bf3 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  802bf3:	55                   	push   %rbp
  802bf4:	48 89 e5             	mov    %rsp,%rbp
  802bf7:	48 83 ec 18          	sub    $0x18,%rsp
  802bfb:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  802bfe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  802c05:	eb 4e                	jmp    802c55 <ipc_find_env+0x62>
		if (envs[i].env_type == type)
  802c07:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  802c0e:	00 00 00 
  802c11:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802c14:	48 98                	cltq   
  802c16:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  802c1d:	48 01 d0             	add    %rdx,%rax
  802c20:	48 05 d0 00 00 00    	add    $0xd0,%rax
  802c26:	8b 00                	mov    (%rax),%eax
  802c28:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  802c2b:	75 24                	jne    802c51 <ipc_find_env+0x5e>
			return envs[i].env_id;
  802c2d:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  802c34:	00 00 00 
  802c37:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802c3a:	48 98                	cltq   
  802c3c:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  802c43:	48 01 d0             	add    %rdx,%rax
  802c46:	48 05 c0 00 00 00    	add    $0xc0,%rax
  802c4c:	8b 40 08             	mov    0x8(%rax),%eax
  802c4f:	eb 12                	jmp    802c63 <ipc_find_env+0x70>
	for (i = 0; i < NENV; i++) {
  802c51:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  802c55:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  802c5c:	7e a9                	jle    802c07 <ipc_find_env+0x14>
	}
	return 0;
  802c5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802c63:	c9                   	leaveq 
  802c64:	c3                   	retq   

0000000000802c65 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  802c65:	55                   	push   %rbp
  802c66:	48 89 e5             	mov    %rsp,%rbp
  802c69:	48 83 ec 08          	sub    $0x8,%rsp
  802c6d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  802c71:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802c75:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  802c7c:	ff ff ff 
  802c7f:	48 01 d0             	add    %rdx,%rax
  802c82:	48 c1 e8 0c          	shr    $0xc,%rax
}
  802c86:	c9                   	leaveq 
  802c87:	c3                   	retq   

0000000000802c88 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  802c88:	55                   	push   %rbp
  802c89:	48 89 e5             	mov    %rsp,%rbp
  802c8c:	48 83 ec 08          	sub    $0x8,%rsp
  802c90:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  802c94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802c98:	48 89 c7             	mov    %rax,%rdi
  802c9b:	48 b8 65 2c 80 00 00 	movabs $0x802c65,%rax
  802ca2:	00 00 00 
  802ca5:	ff d0                	callq  *%rax
  802ca7:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  802cad:	48 c1 e0 0c          	shl    $0xc,%rax
}
  802cb1:	c9                   	leaveq 
  802cb2:	c3                   	retq   

0000000000802cb3 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  802cb3:	55                   	push   %rbp
  802cb4:	48 89 e5             	mov    %rsp,%rbp
  802cb7:	48 83 ec 18          	sub    $0x18,%rsp
  802cbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  802cbf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  802cc6:	eb 6b                	jmp    802d33 <fd_alloc+0x80>
		fd = INDEX2FD(i);
  802cc8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802ccb:	48 98                	cltq   
  802ccd:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  802cd3:	48 c1 e0 0c          	shl    $0xc,%rax
  802cd7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  802cdb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802cdf:	48 c1 e8 15          	shr    $0x15,%rax
  802ce3:	48 89 c2             	mov    %rax,%rdx
  802ce6:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  802ced:	01 00 00 
  802cf0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802cf4:	83 e0 01             	and    $0x1,%eax
  802cf7:	48 85 c0             	test   %rax,%rax
  802cfa:	74 21                	je     802d1d <fd_alloc+0x6a>
  802cfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802d00:	48 c1 e8 0c          	shr    $0xc,%rax
  802d04:	48 89 c2             	mov    %rax,%rdx
  802d07:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802d0e:	01 00 00 
  802d11:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d15:	83 e0 01             	and    $0x1,%eax
  802d18:	48 85 c0             	test   %rax,%rax
  802d1b:	75 12                	jne    802d2f <fd_alloc+0x7c>
			*fd_store = fd;
  802d1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802d21:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802d25:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  802d28:	b8 00 00 00 00       	mov    $0x0,%eax
  802d2d:	eb 1a                	jmp    802d49 <fd_alloc+0x96>
	for (i = 0; i < MAXFD; i++) {
  802d2f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  802d33:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  802d37:	7e 8f                	jle    802cc8 <fd_alloc+0x15>
		}
	}
	*fd_store = 0;
  802d39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802d3d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  802d44:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  802d49:	c9                   	leaveq 
  802d4a:	c3                   	retq   

0000000000802d4b <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  802d4b:	55                   	push   %rbp
  802d4c:	48 89 e5             	mov    %rsp,%rbp
  802d4f:	48 83 ec 20          	sub    $0x20,%rsp
  802d53:	89 7d ec             	mov    %edi,-0x14(%rbp)
  802d56:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  802d5a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802d5e:	78 06                	js     802d66 <fd_lookup+0x1b>
  802d60:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  802d64:	7e 07                	jle    802d6d <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  802d66:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  802d6b:	eb 6c                	jmp    802dd9 <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  802d6d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802d70:	48 98                	cltq   
  802d72:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  802d78:	48 c1 e0 0c          	shl    $0xc,%rax
  802d7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  802d80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802d84:	48 c1 e8 15          	shr    $0x15,%rax
  802d88:	48 89 c2             	mov    %rax,%rdx
  802d8b:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  802d92:	01 00 00 
  802d95:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d99:	83 e0 01             	and    $0x1,%eax
  802d9c:	48 85 c0             	test   %rax,%rax
  802d9f:	74 21                	je     802dc2 <fd_lookup+0x77>
  802da1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802da5:	48 c1 e8 0c          	shr    $0xc,%rax
  802da9:	48 89 c2             	mov    %rax,%rdx
  802dac:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802db3:	01 00 00 
  802db6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802dba:	83 e0 01             	and    $0x1,%eax
  802dbd:	48 85 c0             	test   %rax,%rax
  802dc0:	75 07                	jne    802dc9 <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  802dc2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  802dc7:	eb 10                	jmp    802dd9 <fd_lookup+0x8e>
	}
	*fd_store = fd;
  802dc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802dcd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802dd1:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  802dd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802dd9:	c9                   	leaveq 
  802dda:	c3                   	retq   

0000000000802ddb <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  802ddb:	55                   	push   %rbp
  802ddc:	48 89 e5             	mov    %rsp,%rbp
  802ddf:	48 83 ec 30          	sub    $0x30,%rsp
  802de3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802de7:	89 f0                	mov    %esi,%eax
  802de9:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  802dec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802df0:	48 89 c7             	mov    %rax,%rdi
  802df3:	48 b8 65 2c 80 00 00 	movabs $0x802c65,%rax
  802dfa:	00 00 00 
  802dfd:	ff d0                	callq  *%rax
  802dff:	89 c2                	mov    %eax,%edx
  802e01:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  802e05:	48 89 c6             	mov    %rax,%rsi
  802e08:	89 d7                	mov    %edx,%edi
  802e0a:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  802e11:	00 00 00 
  802e14:	ff d0                	callq  *%rax
  802e16:	89 45 fc             	mov    %eax,-0x4(%rbp)
  802e19:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802e1d:	78 0a                	js     802e29 <fd_close+0x4e>
	    || fd != fd2)
  802e1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e23:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  802e27:	74 12                	je     802e3b <fd_close+0x60>
		return (must_exist ? r : 0);
  802e29:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  802e2d:	74 05                	je     802e34 <fd_close+0x59>
  802e2f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802e32:	eb 70                	jmp    802ea4 <fd_close+0xc9>
  802e34:	b8 00 00 00 00       	mov    $0x0,%eax
  802e39:	eb 69                	jmp    802ea4 <fd_close+0xc9>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  802e3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802e3f:	8b 00                	mov    (%rax),%eax
  802e41:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  802e45:	48 89 d6             	mov    %rdx,%rsi
  802e48:	89 c7                	mov    %eax,%edi
  802e4a:	48 b8 a6 2e 80 00 00 	movabs $0x802ea6,%rax
  802e51:	00 00 00 
  802e54:	ff d0                	callq  *%rax
  802e56:	89 45 fc             	mov    %eax,-0x4(%rbp)
  802e59:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802e5d:	78 2a                	js     802e89 <fd_close+0xae>
		if (dev->dev_close)
  802e5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802e63:	48 8b 40 20          	mov    0x20(%rax),%rax
  802e67:	48 85 c0             	test   %rax,%rax
  802e6a:	74 16                	je     802e82 <fd_close+0xa7>
			r = (*dev->dev_close)(fd);
  802e6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802e70:	48 8b 40 20          	mov    0x20(%rax),%rax
  802e74:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  802e78:	48 89 d7             	mov    %rdx,%rdi
  802e7b:	ff d0                	callq  *%rax
  802e7d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  802e80:	eb 07                	jmp    802e89 <fd_close+0xae>
		else
			r = 0;
  802e82:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  802e89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802e8d:	48 89 c6             	mov    %rax,%rsi
  802e90:	bf 00 00 00 00       	mov    $0x0,%edi
  802e95:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  802e9c:	00 00 00 
  802e9f:	ff d0                	callq  *%rax
	return r;
  802ea1:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  802ea4:	c9                   	leaveq 
  802ea5:	c3                   	retq   

0000000000802ea6 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  802ea6:	55                   	push   %rbp
  802ea7:	48 89 e5             	mov    %rsp,%rbp
  802eaa:	48 83 ec 20          	sub    $0x20,%rsp
  802eae:	89 7d ec             	mov    %edi,-0x14(%rbp)
  802eb1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  802eb5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  802ebc:	eb 41                	jmp    802eff <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  802ebe:	48 b8 20 70 82 00 00 	movabs $0x827020,%rax
  802ec5:	00 00 00 
  802ec8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  802ecb:	48 63 d2             	movslq %edx,%rdx
  802ece:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802ed2:	8b 00                	mov    (%rax),%eax
  802ed4:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  802ed7:	75 22                	jne    802efb <dev_lookup+0x55>
			*dev = devtab[i];
  802ed9:	48 b8 20 70 82 00 00 	movabs $0x827020,%rax
  802ee0:	00 00 00 
  802ee3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  802ee6:	48 63 d2             	movslq %edx,%rdx
  802ee9:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  802eed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802ef1:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  802ef4:	b8 00 00 00 00       	mov    $0x0,%eax
  802ef9:	eb 60                	jmp    802f5b <dev_lookup+0xb5>
	for (i = 0; devtab[i]; i++)
  802efb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  802eff:	48 b8 20 70 82 00 00 	movabs $0x827020,%rax
  802f06:	00 00 00 
  802f09:	8b 55 fc             	mov    -0x4(%rbp),%edx
  802f0c:	48 63 d2             	movslq %edx,%rdx
  802f0f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f13:	48 85 c0             	test   %rax,%rax
  802f16:	75 a6                	jne    802ebe <dev_lookup+0x18>
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  802f18:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  802f1f:	00 00 00 
  802f22:	48 8b 00             	mov    (%rax),%rax
  802f25:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  802f2b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802f2e:	89 c6                	mov    %eax,%esi
  802f30:	48 bf d0 07 82 00 00 	movabs $0x8207d0,%rdi
  802f37:	00 00 00 
  802f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  802f3f:	48 b9 19 11 80 00 00 	movabs $0x801119,%rcx
  802f46:	00 00 00 
  802f49:	ff d1                	callq  *%rcx
	*dev = 0;
  802f4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802f4f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  802f56:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  802f5b:	c9                   	leaveq 
  802f5c:	c3                   	retq   

0000000000802f5d <close>:

int
close(int fdnum)
{
  802f5d:	55                   	push   %rbp
  802f5e:	48 89 e5             	mov    %rsp,%rbp
  802f61:	48 83 ec 20          	sub    $0x20,%rsp
  802f65:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802f68:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  802f6c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802f6f:	48 89 d6             	mov    %rdx,%rsi
  802f72:	89 c7                	mov    %eax,%edi
  802f74:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  802f7b:	00 00 00 
  802f7e:	ff d0                	callq  *%rax
  802f80:	89 45 fc             	mov    %eax,-0x4(%rbp)
  802f83:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802f87:	79 05                	jns    802f8e <close+0x31>
		return r;
  802f89:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802f8c:	eb 18                	jmp    802fa6 <close+0x49>
	else
		return fd_close(fd, 1);
  802f8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802f92:	be 01 00 00 00       	mov    $0x1,%esi
  802f97:	48 89 c7             	mov    %rax,%rdi
  802f9a:	48 b8 db 2d 80 00 00 	movabs $0x802ddb,%rax
  802fa1:	00 00 00 
  802fa4:	ff d0                	callq  *%rax
}
  802fa6:	c9                   	leaveq 
  802fa7:	c3                   	retq   

0000000000802fa8 <close_all>:

void
close_all(void)
{
  802fa8:	55                   	push   %rbp
  802fa9:	48 89 e5             	mov    %rsp,%rbp
  802fac:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  802fb0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  802fb7:	eb 15                	jmp    802fce <close_all+0x26>
		close(i);
  802fb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802fbc:	89 c7                	mov    %eax,%edi
  802fbe:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  802fc5:	00 00 00 
  802fc8:	ff d0                	callq  *%rax
	for (i = 0; i < MAXFD; i++)
  802fca:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  802fce:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  802fd2:	7e e5                	jle    802fb9 <close_all+0x11>
}
  802fd4:	c9                   	leaveq 
  802fd5:	c3                   	retq   

0000000000802fd6 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  802fd6:	55                   	push   %rbp
  802fd7:	48 89 e5             	mov    %rsp,%rbp
  802fda:	48 83 ec 40          	sub    $0x40,%rsp
  802fde:	89 7d cc             	mov    %edi,-0x34(%rbp)
  802fe1:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  802fe4:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  802fe8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  802feb:	48 89 d6             	mov    %rdx,%rsi
  802fee:	89 c7                	mov    %eax,%edi
  802ff0:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  802ff7:	00 00 00 
  802ffa:	ff d0                	callq  *%rax
  802ffc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  802fff:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803003:	79 08                	jns    80300d <dup+0x37>
		return r;
  803005:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803008:	e9 70 01 00 00       	jmpq   80317d <dup+0x1a7>
	close(newfdnum);
  80300d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803010:	89 c7                	mov    %eax,%edi
  803012:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  803019:	00 00 00 
  80301c:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  80301e:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803021:	48 98                	cltq   
  803023:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  803029:	48 c1 e0 0c          	shl    $0xc,%rax
  80302d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  803031:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803035:	48 89 c7             	mov    %rax,%rdi
  803038:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  80303f:	00 00 00 
  803042:	ff d0                	callq  *%rax
  803044:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  803048:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80304c:	48 89 c7             	mov    %rax,%rdi
  80304f:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  803056:	00 00 00 
  803059:	ff d0                	callq  *%rax
  80305b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80305f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803063:	48 c1 e8 15          	shr    $0x15,%rax
  803067:	48 89 c2             	mov    %rax,%rdx
  80306a:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803071:	01 00 00 
  803074:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803078:	83 e0 01             	and    $0x1,%eax
  80307b:	48 85 c0             	test   %rax,%rax
  80307e:	74 73                	je     8030f3 <dup+0x11d>
  803080:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803084:	48 c1 e8 0c          	shr    $0xc,%rax
  803088:	48 89 c2             	mov    %rax,%rdx
  80308b:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803092:	01 00 00 
  803095:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803099:	83 e0 01             	and    $0x1,%eax
  80309c:	48 85 c0             	test   %rax,%rax
  80309f:	74 52                	je     8030f3 <dup+0x11d>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  8030a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8030a5:	48 c1 e8 0c          	shr    $0xc,%rax
  8030a9:	48 89 c2             	mov    %rax,%rdx
  8030ac:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8030b3:	01 00 00 
  8030b6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8030ba:	25 07 0e 00 00       	and    $0xe07,%eax
  8030bf:	89 c1                	mov    %eax,%ecx
  8030c1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8030c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8030c9:	41 89 c8             	mov    %ecx,%r8d
  8030cc:	48 89 d1             	mov    %rdx,%rcx
  8030cf:	ba 00 00 00 00       	mov    $0x0,%edx
  8030d4:	48 89 c6             	mov    %rax,%rsi
  8030d7:	bf 00 00 00 00       	mov    $0x0,%edi
  8030dc:	48 b8 32 26 80 00 00 	movabs $0x802632,%rax
  8030e3:	00 00 00 
  8030e6:	ff d0                	callq  *%rax
  8030e8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8030eb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8030ef:	79 02                	jns    8030f3 <dup+0x11d>
			goto err;
  8030f1:	eb 57                	jmp    80314a <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8030f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8030f7:	48 c1 e8 0c          	shr    $0xc,%rax
  8030fb:	48 89 c2             	mov    %rax,%rdx
  8030fe:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803105:	01 00 00 
  803108:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80310c:	25 07 0e 00 00       	and    $0xe07,%eax
  803111:	89 c1                	mov    %eax,%ecx
  803113:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803117:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80311b:	41 89 c8             	mov    %ecx,%r8d
  80311e:	48 89 d1             	mov    %rdx,%rcx
  803121:	ba 00 00 00 00       	mov    $0x0,%edx
  803126:	48 89 c6             	mov    %rax,%rsi
  803129:	bf 00 00 00 00       	mov    $0x0,%edi
  80312e:	48 b8 32 26 80 00 00 	movabs $0x802632,%rax
  803135:	00 00 00 
  803138:	ff d0                	callq  *%rax
  80313a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80313d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803141:	79 02                	jns    803145 <dup+0x16f>
		goto err;
  803143:	eb 05                	jmp    80314a <dup+0x174>

	return newfdnum;
  803145:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803148:	eb 33                	jmp    80317d <dup+0x1a7>

err:
	sys_page_unmap(0, newfd);
  80314a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80314e:	48 89 c6             	mov    %rax,%rsi
  803151:	bf 00 00 00 00       	mov    $0x0,%edi
  803156:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  80315d:	00 00 00 
  803160:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803162:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803166:	48 89 c6             	mov    %rax,%rsi
  803169:	bf 00 00 00 00       	mov    $0x0,%edi
  80316e:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  803175:	00 00 00 
  803178:	ff d0                	callq  *%rax
	return r;
  80317a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80317d:	c9                   	leaveq 
  80317e:	c3                   	retq   

000000000080317f <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80317f:	55                   	push   %rbp
  803180:	48 89 e5             	mov    %rsp,%rbp
  803183:	48 83 ec 40          	sub    $0x40,%rsp
  803187:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80318a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80318e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803192:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803196:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803199:	48 89 d6             	mov    %rdx,%rsi
  80319c:	89 c7                	mov    %eax,%edi
  80319e:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  8031a5:	00 00 00 
  8031a8:	ff d0                	callq  *%rax
  8031aa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8031ad:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8031b1:	78 24                	js     8031d7 <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8031b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8031b7:	8b 00                	mov    (%rax),%eax
  8031b9:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8031bd:	48 89 d6             	mov    %rdx,%rsi
  8031c0:	89 c7                	mov    %eax,%edi
  8031c2:	48 b8 a6 2e 80 00 00 	movabs $0x802ea6,%rax
  8031c9:	00 00 00 
  8031cc:	ff d0                	callq  *%rax
  8031ce:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8031d1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8031d5:	79 05                	jns    8031dc <read+0x5d>
		return r;
  8031d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8031da:	eb 76                	jmp    803252 <read+0xd3>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  8031dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8031e0:	8b 40 08             	mov    0x8(%rax),%eax
  8031e3:	83 e0 03             	and    $0x3,%eax
  8031e6:	83 f8 01             	cmp    $0x1,%eax
  8031e9:	75 3a                	jne    803225 <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  8031eb:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  8031f2:	00 00 00 
  8031f5:	48 8b 00             	mov    (%rax),%rax
  8031f8:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8031fe:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803201:	89 c6                	mov    %eax,%esi
  803203:	48 bf ef 07 82 00 00 	movabs $0x8207ef,%rdi
  80320a:	00 00 00 
  80320d:	b8 00 00 00 00       	mov    $0x0,%eax
  803212:	48 b9 19 11 80 00 00 	movabs $0x801119,%rcx
  803219:	00 00 00 
  80321c:	ff d1                	callq  *%rcx
		return -E_INVAL;
  80321e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803223:	eb 2d                	jmp    803252 <read+0xd3>
	}
	if (!dev->dev_read)
  803225:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803229:	48 8b 40 10          	mov    0x10(%rax),%rax
  80322d:	48 85 c0             	test   %rax,%rax
  803230:	75 07                	jne    803239 <read+0xba>
		return -E_NOT_SUPP;
  803232:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803237:	eb 19                	jmp    803252 <read+0xd3>
	return (*dev->dev_read)(fd, buf, n);
  803239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80323d:	48 8b 40 10          	mov    0x10(%rax),%rax
  803241:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803245:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803249:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80324d:	48 89 cf             	mov    %rcx,%rdi
  803250:	ff d0                	callq  *%rax
}
  803252:	c9                   	leaveq 
  803253:	c3                   	retq   

0000000000803254 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  803254:	55                   	push   %rbp
  803255:	48 89 e5             	mov    %rsp,%rbp
  803258:	48 83 ec 30          	sub    $0x30,%rsp
  80325c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80325f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803263:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803267:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80326e:	eb 49                	jmp    8032b9 <readn+0x65>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803270:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803273:	48 98                	cltq   
  803275:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803279:	48 29 c2             	sub    %rax,%rdx
  80327c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80327f:	48 63 c8             	movslq %eax,%rcx
  803282:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803286:	48 01 c1             	add    %rax,%rcx
  803289:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80328c:	48 89 ce             	mov    %rcx,%rsi
  80328f:	89 c7                	mov    %eax,%edi
  803291:	48 b8 7f 31 80 00 00 	movabs $0x80317f,%rax
  803298:	00 00 00 
  80329b:	ff d0                	callq  *%rax
  80329d:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  8032a0:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8032a4:	79 05                	jns    8032ab <readn+0x57>
			return m;
  8032a6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8032a9:	eb 1c                	jmp    8032c7 <readn+0x73>
		if (m == 0)
  8032ab:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8032af:	75 02                	jne    8032b3 <readn+0x5f>
			break;
  8032b1:	eb 11                	jmp    8032c4 <readn+0x70>
	for (tot = 0; tot < n; tot += m) {
  8032b3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8032b6:	01 45 fc             	add    %eax,-0x4(%rbp)
  8032b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8032bc:	48 98                	cltq   
  8032be:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8032c2:	72 ac                	jb     803270 <readn+0x1c>
	}
	return tot;
  8032c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8032c7:	c9                   	leaveq 
  8032c8:	c3                   	retq   

00000000008032c9 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8032c9:	55                   	push   %rbp
  8032ca:	48 89 e5             	mov    %rsp,%rbp
  8032cd:	48 83 ec 40          	sub    $0x40,%rsp
  8032d1:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8032d4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8032d8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8032dc:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8032e0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8032e3:	48 89 d6             	mov    %rdx,%rsi
  8032e6:	89 c7                	mov    %eax,%edi
  8032e8:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  8032ef:	00 00 00 
  8032f2:	ff d0                	callq  *%rax
  8032f4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8032f7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8032fb:	78 24                	js     803321 <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8032fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803301:	8b 00                	mov    (%rax),%eax
  803303:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803307:	48 89 d6             	mov    %rdx,%rsi
  80330a:	89 c7                	mov    %eax,%edi
  80330c:	48 b8 a6 2e 80 00 00 	movabs $0x802ea6,%rax
  803313:	00 00 00 
  803316:	ff d0                	callq  *%rax
  803318:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80331b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80331f:	79 05                	jns    803326 <write+0x5d>
		return r;
  803321:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803324:	eb 75                	jmp    80339b <write+0xd2>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803326:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80332a:	8b 40 08             	mov    0x8(%rax),%eax
  80332d:	83 e0 03             	and    $0x3,%eax
  803330:	85 c0                	test   %eax,%eax
  803332:	75 3a                	jne    80336e <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803334:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  80333b:	00 00 00 
  80333e:	48 8b 00             	mov    (%rax),%rax
  803341:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803347:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80334a:	89 c6                	mov    %eax,%esi
  80334c:	48 bf 0b 08 82 00 00 	movabs $0x82080b,%rdi
  803353:	00 00 00 
  803356:	b8 00 00 00 00       	mov    $0x0,%eax
  80335b:	48 b9 19 11 80 00 00 	movabs $0x801119,%rcx
  803362:	00 00 00 
  803365:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803367:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80336c:	eb 2d                	jmp    80339b <write+0xd2>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80336e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803372:	48 8b 40 18          	mov    0x18(%rax),%rax
  803376:	48 85 c0             	test   %rax,%rax
  803379:	75 07                	jne    803382 <write+0xb9>
		return -E_NOT_SUPP;
  80337b:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803380:	eb 19                	jmp    80339b <write+0xd2>
	return (*dev->dev_write)(fd, buf, n);
  803382:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803386:	48 8b 40 18          	mov    0x18(%rax),%rax
  80338a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80338e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803392:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803396:	48 89 cf             	mov    %rcx,%rdi
  803399:	ff d0                	callq  *%rax
}
  80339b:	c9                   	leaveq 
  80339c:	c3                   	retq   

000000000080339d <seek>:

int
seek(int fdnum, off_t offset)
{
  80339d:	55                   	push   %rbp
  80339e:	48 89 e5             	mov    %rsp,%rbp
  8033a1:	48 83 ec 18          	sub    $0x18,%rsp
  8033a5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8033a8:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8033ab:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8033af:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8033b2:	48 89 d6             	mov    %rdx,%rsi
  8033b5:	89 c7                	mov    %eax,%edi
  8033b7:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  8033be:	00 00 00 
  8033c1:	ff d0                	callq  *%rax
  8033c3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8033c6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8033ca:	79 05                	jns    8033d1 <seek+0x34>
		return r;
  8033cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033cf:	eb 0f                	jmp    8033e0 <seek+0x43>
	fd->fd_offset = offset;
  8033d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8033d5:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8033d8:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  8033db:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8033e0:	c9                   	leaveq 
  8033e1:	c3                   	retq   

00000000008033e2 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  8033e2:	55                   	push   %rbp
  8033e3:	48 89 e5             	mov    %rsp,%rbp
  8033e6:	48 83 ec 30          	sub    $0x30,%rsp
  8033ea:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8033ed:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8033f0:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8033f4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8033f7:	48 89 d6             	mov    %rdx,%rsi
  8033fa:	89 c7                	mov    %eax,%edi
  8033fc:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  803403:	00 00 00 
  803406:	ff d0                	callq  *%rax
  803408:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80340b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80340f:	78 24                	js     803435 <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803411:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803415:	8b 00                	mov    (%rax),%eax
  803417:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80341b:	48 89 d6             	mov    %rdx,%rsi
  80341e:	89 c7                	mov    %eax,%edi
  803420:	48 b8 a6 2e 80 00 00 	movabs $0x802ea6,%rax
  803427:	00 00 00 
  80342a:	ff d0                	callq  *%rax
  80342c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80342f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803433:	79 05                	jns    80343a <ftruncate+0x58>
		return r;
  803435:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803438:	eb 72                	jmp    8034ac <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80343a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80343e:	8b 40 08             	mov    0x8(%rax),%eax
  803441:	83 e0 03             	and    $0x3,%eax
  803444:	85 c0                	test   %eax,%eax
  803446:	75 3a                	jne    803482 <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803448:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  80344f:	00 00 00 
  803452:	48 8b 00             	mov    (%rax),%rax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803455:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80345b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80345e:	89 c6                	mov    %eax,%esi
  803460:	48 bf 28 08 82 00 00 	movabs $0x820828,%rdi
  803467:	00 00 00 
  80346a:	b8 00 00 00 00       	mov    $0x0,%eax
  80346f:	48 b9 19 11 80 00 00 	movabs $0x801119,%rcx
  803476:	00 00 00 
  803479:	ff d1                	callq  *%rcx
		return -E_INVAL;
  80347b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803480:	eb 2a                	jmp    8034ac <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803482:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803486:	48 8b 40 30          	mov    0x30(%rax),%rax
  80348a:	48 85 c0             	test   %rax,%rax
  80348d:	75 07                	jne    803496 <ftruncate+0xb4>
		return -E_NOT_SUPP;
  80348f:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803494:	eb 16                	jmp    8034ac <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803496:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80349a:	48 8b 40 30          	mov    0x30(%rax),%rax
  80349e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8034a2:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  8034a5:	89 ce                	mov    %ecx,%esi
  8034a7:	48 89 d7             	mov    %rdx,%rdi
  8034aa:	ff d0                	callq  *%rax
}
  8034ac:	c9                   	leaveq 
  8034ad:	c3                   	retq   

00000000008034ae <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  8034ae:	55                   	push   %rbp
  8034af:	48 89 e5             	mov    %rsp,%rbp
  8034b2:	48 83 ec 30          	sub    $0x30,%rsp
  8034b6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8034b9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8034bd:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8034c1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8034c4:	48 89 d6             	mov    %rdx,%rsi
  8034c7:	89 c7                	mov    %eax,%edi
  8034c9:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  8034d0:	00 00 00 
  8034d3:	ff d0                	callq  *%rax
  8034d5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8034d8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8034dc:	78 24                	js     803502 <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8034de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8034e2:	8b 00                	mov    (%rax),%eax
  8034e4:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8034e8:	48 89 d6             	mov    %rdx,%rsi
  8034eb:	89 c7                	mov    %eax,%edi
  8034ed:	48 b8 a6 2e 80 00 00 	movabs $0x802ea6,%rax
  8034f4:	00 00 00 
  8034f7:	ff d0                	callq  *%rax
  8034f9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8034fc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803500:	79 05                	jns    803507 <fstat+0x59>
		return r;
  803502:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803505:	eb 5e                	jmp    803565 <fstat+0xb7>
	if (!dev->dev_stat)
  803507:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80350b:	48 8b 40 28          	mov    0x28(%rax),%rax
  80350f:	48 85 c0             	test   %rax,%rax
  803512:	75 07                	jne    80351b <fstat+0x6d>
		return -E_NOT_SUPP;
  803514:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803519:	eb 4a                	jmp    803565 <fstat+0xb7>
	stat->st_name[0] = 0;
  80351b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80351f:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803522:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803526:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  80352d:	00 00 00 
	stat->st_isdir = 0;
  803530:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803534:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  80353b:	00 00 00 
	stat->st_dev = dev;
  80353e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803542:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803546:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  80354d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803551:	48 8b 40 28          	mov    0x28(%rax),%rax
  803555:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803559:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80355d:	48 89 ce             	mov    %rcx,%rsi
  803560:	48 89 d7             	mov    %rdx,%rdi
  803563:	ff d0                	callq  *%rax
}
  803565:	c9                   	leaveq 
  803566:	c3                   	retq   

0000000000803567 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803567:	55                   	push   %rbp
  803568:	48 89 e5             	mov    %rsp,%rbp
  80356b:	48 83 ec 20          	sub    $0x20,%rsp
  80356f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803573:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803577:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80357b:	be 00 00 00 00       	mov    $0x0,%esi
  803580:	48 89 c7             	mov    %rax,%rdi
  803583:	48 b8 57 36 80 00 00 	movabs $0x803657,%rax
  80358a:	00 00 00 
  80358d:	ff d0                	callq  *%rax
  80358f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803592:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803596:	79 05                	jns    80359d <stat+0x36>
		return fd;
  803598:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80359b:	eb 2f                	jmp    8035cc <stat+0x65>
	r = fstat(fd, stat);
  80359d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8035a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035a4:	48 89 d6             	mov    %rdx,%rsi
  8035a7:	89 c7                	mov    %eax,%edi
  8035a9:	48 b8 ae 34 80 00 00 	movabs $0x8034ae,%rax
  8035b0:	00 00 00 
  8035b3:	ff d0                	callq  *%rax
  8035b5:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  8035b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035bb:	89 c7                	mov    %eax,%edi
  8035bd:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  8035c4:	00 00 00 
  8035c7:	ff d0                	callq  *%rax
	return r;
  8035c9:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8035cc:	c9                   	leaveq 
  8035cd:	c3                   	retq   

00000000008035ce <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  8035ce:	55                   	push   %rbp
  8035cf:	48 89 e5             	mov    %rsp,%rbp
  8035d2:	48 83 ec 10          	sub    $0x10,%rsp
  8035d6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8035d9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  8035dd:	48 b8 84 80 82 00 00 	movabs $0x828084,%rax
  8035e4:	00 00 00 
  8035e7:	8b 00                	mov    (%rax),%eax
  8035e9:	85 c0                	test   %eax,%eax
  8035eb:	75 1f                	jne    80360c <fsipc+0x3e>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  8035ed:	bf 01 00 00 00       	mov    $0x1,%edi
  8035f2:	48 b8 f3 2b 80 00 00 	movabs $0x802bf3,%rax
  8035f9:	00 00 00 
  8035fc:	ff d0                	callq  *%rax
  8035fe:	89 c2                	mov    %eax,%edx
  803600:	48 b8 84 80 82 00 00 	movabs $0x828084,%rax
  803607:	00 00 00 
  80360a:	89 10                	mov    %edx,(%rax)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80360c:	48 b8 84 80 82 00 00 	movabs $0x828084,%rax
  803613:	00 00 00 
  803616:	8b 00                	mov    (%rax),%eax
  803618:	8b 75 fc             	mov    -0x4(%rbp),%esi
  80361b:	b9 07 00 00 00       	mov    $0x7,%ecx
  803620:	48 ba 00 70 b5 00 00 	movabs $0xb57000,%rdx
  803627:	00 00 00 
  80362a:	89 c7                	mov    %eax,%edi
  80362c:	48 b8 66 2a 80 00 00 	movabs $0x802a66,%rax
  803633:	00 00 00 
  803636:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803638:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80363c:	ba 00 00 00 00       	mov    $0x0,%edx
  803641:	48 89 c6             	mov    %rax,%rsi
  803644:	bf 00 00 00 00       	mov    $0x0,%edi
  803649:	48 b8 28 2a 80 00 00 	movabs $0x802a28,%rax
  803650:	00 00 00 
  803653:	ff d0                	callq  *%rax
}
  803655:	c9                   	leaveq 
  803656:	c3                   	retq   

0000000000803657 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803657:	55                   	push   %rbp
  803658:	48 89 e5             	mov    %rsp,%rbp
  80365b:	48 83 ec 10          	sub    $0x10,%rsp
  80365f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  803663:	89 75 f4             	mov    %esi,-0xc(%rbp)
	// Return the file descriptor index.
	// If any step after fd_alloc fails, use fd_close to free the
	// file descriptor.

	// LAB 5: Your code here
	panic ("open not implemented");
  803666:	48 ba 4e 08 82 00 00 	movabs $0x82084e,%rdx
  80366d:	00 00 00 
  803670:	be 4c 00 00 00       	mov    $0x4c,%esi
  803675:	48 bf 63 08 82 00 00 	movabs $0x820863,%rdi
  80367c:	00 00 00 
  80367f:	b8 00 00 00 00       	mov    $0x0,%eax
  803684:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80368b:	00 00 00 
  80368e:	ff d1                	callq  *%rcx

0000000000803690 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  803690:	55                   	push   %rbp
  803691:	48 89 e5             	mov    %rsp,%rbp
  803694:	48 83 ec 10          	sub    $0x10,%rsp
  803698:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80369c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8036a0:	8b 50 0c             	mov    0xc(%rax),%edx
  8036a3:	48 b8 00 70 b5 00 00 	movabs $0xb57000,%rax
  8036aa:	00 00 00 
  8036ad:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  8036af:	be 00 00 00 00       	mov    $0x0,%esi
  8036b4:	bf 06 00 00 00       	mov    $0x6,%edi
  8036b9:	48 b8 ce 35 80 00 00 	movabs $0x8035ce,%rax
  8036c0:	00 00 00 
  8036c3:	ff d0                	callq  *%rax
}
  8036c5:	c9                   	leaveq 
  8036c6:	c3                   	retq   

00000000008036c7 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  8036c7:	55                   	push   %rbp
  8036c8:	48 89 e5             	mov    %rsp,%rbp
  8036cb:	48 83 ec 20          	sub    $0x20,%rsp
  8036cf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8036d3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8036d7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Make an FSREQ_READ request to the file system server after
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
	panic("devfile_read not implemented");
  8036db:	48 ba 6e 08 82 00 00 	movabs $0x82086e,%rdx
  8036e2:	00 00 00 
  8036e5:	be 6b 00 00 00       	mov    $0x6b,%esi
  8036ea:	48 bf 63 08 82 00 00 	movabs $0x820863,%rdi
  8036f1:	00 00 00 
  8036f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8036f9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  803700:	00 00 00 
  803703:	ff d1                	callq  *%rcx

0000000000803705 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  803705:	55                   	push   %rbp
  803706:	48 89 e5             	mov    %rsp,%rbp
  803709:	48 83 ec 20          	sub    $0x20,%rsp
  80370d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  803711:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  803715:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Make an FSREQ_WRITE request to the file system server.  Be
	// careful: fsipcbuf.write.req_buf is only so large, but
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	panic("devfile_write not implemented");
  803719:	48 ba 8b 08 82 00 00 	movabs $0x82088b,%rdx
  803720:	00 00 00 
  803723:	be 7b 00 00 00       	mov    $0x7b,%esi
  803728:	48 bf 63 08 82 00 00 	movabs $0x820863,%rdi
  80372f:	00 00 00 
  803732:	b8 00 00 00 00       	mov    $0x0,%eax
  803737:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80373e:	00 00 00 
  803741:	ff d1                	callq  *%rcx

0000000000803743 <devfile_stat>:
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  803743:	55                   	push   %rbp
  803744:	48 89 e5             	mov    %rsp,%rbp
  803747:	48 83 ec 20          	sub    $0x20,%rsp
  80374b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80374f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  803753:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803757:	8b 50 0c             	mov    0xc(%rax),%edx
  80375a:	48 b8 00 70 b5 00 00 	movabs $0xb57000,%rax
  803761:	00 00 00 
  803764:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  803766:	be 00 00 00 00       	mov    $0x0,%esi
  80376b:	bf 05 00 00 00       	mov    $0x5,%edi
  803770:	48 b8 ce 35 80 00 00 	movabs $0x8035ce,%rax
  803777:	00 00 00 
  80377a:	ff d0                	callq  *%rax
  80377c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80377f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803783:	79 05                	jns    80378a <devfile_stat+0x47>
		return r;
  803785:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803788:	eb 56                	jmp    8037e0 <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80378a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80378e:	48 be 00 70 b5 00 00 	movabs $0xb57000,%rsi
  803795:	00 00 00 
  803798:	48 89 c7             	mov    %rax,%rdi
  80379b:	48 b8 b3 1c 80 00 00 	movabs $0x801cb3,%rax
  8037a2:	00 00 00 
  8037a5:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  8037a7:	48 b8 00 70 b5 00 00 	movabs $0xb57000,%rax
  8037ae:	00 00 00 
  8037b1:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  8037b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8037bb:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8037c1:	48 b8 00 70 b5 00 00 	movabs $0xb57000,%rax
  8037c8:	00 00 00 
  8037cb:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  8037d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8037d5:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  8037db:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8037e0:	c9                   	leaveq 
  8037e1:	c3                   	retq   

00000000008037e2 <devfile_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  8037e2:	55                   	push   %rbp
  8037e3:	48 89 e5             	mov    %rsp,%rbp
  8037e6:	48 83 ec 10          	sub    $0x10,%rsp
  8037ea:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8037ee:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  8037f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8037f5:	8b 50 0c             	mov    0xc(%rax),%edx
  8037f8:	48 b8 00 70 b5 00 00 	movabs $0xb57000,%rax
  8037ff:	00 00 00 
  803802:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = newsize;
  803804:	48 b8 00 70 b5 00 00 	movabs $0xb57000,%rax
  80380b:	00 00 00 
  80380e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  803811:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  803814:	be 00 00 00 00       	mov    $0x0,%esi
  803819:	bf 02 00 00 00       	mov    $0x2,%edi
  80381e:	48 b8 ce 35 80 00 00 	movabs $0x8035ce,%rax
  803825:	00 00 00 
  803828:	ff d0                	callq  *%rax
}
  80382a:	c9                   	leaveq 
  80382b:	c3                   	retq   

000000000080382c <remove>:

// Delete a file
int
remove(const char *path)
{
  80382c:	55                   	push   %rbp
  80382d:	48 89 e5             	mov    %rsp,%rbp
  803830:	48 83 ec 10          	sub    $0x10,%rsp
  803834:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (strlen(path) >= MAXPATHLEN)
  803838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80383c:	48 89 c7             	mov    %rax,%rdi
  80383f:	48 b8 47 1c 80 00 00 	movabs $0x801c47,%rax
  803846:	00 00 00 
  803849:	ff d0                	callq  *%rax
  80384b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803850:	7e 07                	jle    803859 <remove+0x2d>
		return -E_BAD_PATH;
  803852:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803857:	eb 33                	jmp    80388c <remove+0x60>
	strcpy(fsipcbuf.remove.req_path, path);
  803859:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80385d:	48 89 c6             	mov    %rax,%rsi
  803860:	48 bf 00 70 b5 00 00 	movabs $0xb57000,%rdi
  803867:	00 00 00 
  80386a:	48 b8 b3 1c 80 00 00 	movabs $0x801cb3,%rax
  803871:	00 00 00 
  803874:	ff d0                	callq  *%rax
	return fsipc(FSREQ_REMOVE, NULL);
  803876:	be 00 00 00 00       	mov    $0x0,%esi
  80387b:	bf 07 00 00 00       	mov    $0x7,%edi
  803880:	48 b8 ce 35 80 00 00 	movabs $0x8035ce,%rax
  803887:	00 00 00 
  80388a:	ff d0                	callq  *%rax
}
  80388c:	c9                   	leaveq 
  80388d:	c3                   	retq   

000000000080388e <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  80388e:	55                   	push   %rbp
  80388f:	48 89 e5             	mov    %rsp,%rbp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  803892:	be 00 00 00 00       	mov    $0x0,%esi
  803897:	bf 08 00 00 00       	mov    $0x8,%edi
  80389c:	48 b8 ce 35 80 00 00 	movabs $0x8035ce,%rax
  8038a3:	00 00 00 
  8038a6:	ff d0                	callq  *%rax
}
  8038a8:	5d                   	pop    %rbp
  8038a9:	c3                   	retq   

00000000008038aa <copy>:

//Copy a file from src to dest
int
copy(char *src, char *dest)
{
  8038aa:	55                   	push   %rbp
  8038ab:	48 89 e5             	mov    %rsp,%rbp
  8038ae:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  8038b5:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  8038bc:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
	int r;
	int fd_src, fd_dest;
	char buffer[512];	//keep this small
	ssize_t read_size;
	ssize_t write_size;
	fd_src = open(src, O_RDONLY);
  8038c3:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
  8038ca:	be 00 00 00 00       	mov    $0x0,%esi
  8038cf:	48 89 c7             	mov    %rax,%rdi
  8038d2:	48 b8 57 36 80 00 00 	movabs $0x803657,%rax
  8038d9:	00 00 00 
  8038dc:	ff d0                	callq  *%rax
  8038de:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (fd_src < 0) {	//error
  8038e1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038e5:	79 28                	jns    80390f <copy+0x65>
		cprintf("cp open src error:%e\n", fd_src);
  8038e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8038ea:	89 c6                	mov    %eax,%esi
  8038ec:	48 bf a9 08 82 00 00 	movabs $0x8208a9,%rdi
  8038f3:	00 00 00 
  8038f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8038fb:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  803902:	00 00 00 
  803905:	ff d2                	callq  *%rdx
		return fd_src;
  803907:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80390a:	e9 74 01 00 00       	jmpq   803a83 <copy+0x1d9>
	}
	
	fd_dest = open(dest, O_CREAT | O_WRONLY);
  80390f:	48 8b 85 e0 fd ff ff 	mov    -0x220(%rbp),%rax
  803916:	be 01 01 00 00       	mov    $0x101,%esi
  80391b:	48 89 c7             	mov    %rax,%rdi
  80391e:	48 b8 57 36 80 00 00 	movabs $0x803657,%rax
  803925:	00 00 00 
  803928:	ff d0                	callq  *%rax
  80392a:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd_dest < 0) {	//error
  80392d:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803931:	79 39                	jns    80396c <copy+0xc2>
		cprintf("cp create dest  error:%e\n", fd_dest);
  803933:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803936:	89 c6                	mov    %eax,%esi
  803938:	48 bf bf 08 82 00 00 	movabs $0x8208bf,%rdi
  80393f:	00 00 00 
  803942:	b8 00 00 00 00       	mov    $0x0,%eax
  803947:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  80394e:	00 00 00 
  803951:	ff d2                	callq  *%rdx
		close(fd_src);
  803953:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803956:	89 c7                	mov    %eax,%edi
  803958:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  80395f:	00 00 00 
  803962:	ff d0                	callq  *%rax
		return fd_dest;
  803964:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803967:	e9 17 01 00 00       	jmpq   803a83 <copy+0x1d9>
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  80396c:	eb 74                	jmp    8039e2 <copy+0x138>
		write_size = write(fd_dest, buffer, read_size);
  80396e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  803971:	48 63 d0             	movslq %eax,%rdx
  803974:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  80397b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80397e:	48 89 ce             	mov    %rcx,%rsi
  803981:	89 c7                	mov    %eax,%edi
  803983:	48 b8 c9 32 80 00 00 	movabs $0x8032c9,%rax
  80398a:	00 00 00 
  80398d:	ff d0                	callq  *%rax
  80398f:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (write_size < 0) {
  803992:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  803996:	79 4a                	jns    8039e2 <copy+0x138>
			cprintf("cp write error:%e\n", write_size);
  803998:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80399b:	89 c6                	mov    %eax,%esi
  80399d:	48 bf d9 08 82 00 00 	movabs $0x8208d9,%rdi
  8039a4:	00 00 00 
  8039a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8039ac:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8039b3:	00 00 00 
  8039b6:	ff d2                	callq  *%rdx
			close(fd_src);
  8039b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8039bb:	89 c7                	mov    %eax,%edi
  8039bd:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  8039c4:	00 00 00 
  8039c7:	ff d0                	callq  *%rax
			close(fd_dest);
  8039c9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8039cc:	89 c7                	mov    %eax,%edi
  8039ce:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  8039d5:	00 00 00 
  8039d8:	ff d0                	callq  *%rax
			return write_size;
  8039da:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8039dd:	e9 a1 00 00 00       	jmpq   803a83 <copy+0x1d9>
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  8039e2:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  8039e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8039ec:	ba 00 02 00 00       	mov    $0x200,%edx
  8039f1:	48 89 ce             	mov    %rcx,%rsi
  8039f4:	89 c7                	mov    %eax,%edi
  8039f6:	48 b8 7f 31 80 00 00 	movabs $0x80317f,%rax
  8039fd:	00 00 00 
  803a00:	ff d0                	callq  *%rax
  803a02:	89 45 f4             	mov    %eax,-0xc(%rbp)
  803a05:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  803a09:	0f 8f 5f ff ff ff    	jg     80396e <copy+0xc4>
		}		
	}
	if (read_size < 0) {
  803a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  803a13:	79 47                	jns    803a5c <copy+0x1b2>
		cprintf("cp read src error:%e\n", read_size);
  803a15:	8b 45 f4             	mov    -0xc(%rbp),%eax
  803a18:	89 c6                	mov    %eax,%esi
  803a1a:	48 bf ec 08 82 00 00 	movabs $0x8208ec,%rdi
  803a21:	00 00 00 
  803a24:	b8 00 00 00 00       	mov    $0x0,%eax
  803a29:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  803a30:	00 00 00 
  803a33:	ff d2                	callq  *%rdx
		close(fd_src);
  803a35:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a38:	89 c7                	mov    %eax,%edi
  803a3a:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  803a41:	00 00 00 
  803a44:	ff d0                	callq  *%rax
		close(fd_dest);
  803a46:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803a49:	89 c7                	mov    %eax,%edi
  803a4b:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  803a52:	00 00 00 
  803a55:	ff d0                	callq  *%rax
		return read_size;
  803a57:	8b 45 f4             	mov    -0xc(%rbp),%eax
  803a5a:	eb 27                	jmp    803a83 <copy+0x1d9>
	}
	close(fd_src);
  803a5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a5f:	89 c7                	mov    %eax,%edi
  803a61:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  803a68:	00 00 00 
  803a6b:	ff d0                	callq  *%rax
	close(fd_dest);
  803a6d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803a70:	89 c7                	mov    %eax,%edi
  803a72:	48 b8 5d 2f 80 00 00 	movabs $0x802f5d,%rax
  803a79:	00 00 00 
  803a7c:	ff d0                	callq  *%rax
	return 0;
  803a7e:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  803a83:	c9                   	leaveq 
  803a84:	c3                   	retq   

0000000000803a85 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  803a85:	55                   	push   %rbp
  803a86:	48 89 e5             	mov    %rsp,%rbp
  803a89:	48 83 ec 20          	sub    $0x20,%rsp
  803a8d:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  803a90:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803a94:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803a97:	48 89 d6             	mov    %rdx,%rsi
  803a9a:	89 c7                	mov    %eax,%edi
  803a9c:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  803aa3:	00 00 00 
  803aa6:	ff d0                	callq  *%rax
  803aa8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803aab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803aaf:	79 05                	jns    803ab6 <fd2sockid+0x31>
		return r;
  803ab1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ab4:	eb 24                	jmp    803ada <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  803ab6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803aba:	8b 10                	mov    (%rax),%edx
  803abc:	48 b8 a0 70 82 00 00 	movabs $0x8270a0,%rax
  803ac3:	00 00 00 
  803ac6:	8b 00                	mov    (%rax),%eax
  803ac8:	39 c2                	cmp    %eax,%edx
  803aca:	74 07                	je     803ad3 <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  803acc:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803ad1:	eb 07                	jmp    803ada <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  803ad3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ad7:	8b 40 0c             	mov    0xc(%rax),%eax
}
  803ada:	c9                   	leaveq 
  803adb:	c3                   	retq   

0000000000803adc <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  803adc:	55                   	push   %rbp
  803add:	48 89 e5             	mov    %rsp,%rbp
  803ae0:	48 83 ec 20          	sub    $0x20,%rsp
  803ae4:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  803ae7:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803aeb:	48 89 c7             	mov    %rax,%rdi
  803aee:	48 b8 b3 2c 80 00 00 	movabs $0x802cb3,%rax
  803af5:	00 00 00 
  803af8:	ff d0                	callq  *%rax
  803afa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803afd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b01:	78 26                	js     803b29 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  803b03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b07:	ba 07 04 00 00       	mov    $0x407,%edx
  803b0c:	48 89 c6             	mov    %rax,%rsi
  803b0f:	bf 00 00 00 00       	mov    $0x0,%edi
  803b14:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  803b1b:	00 00 00 
  803b1e:	ff d0                	callq  *%rax
  803b20:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b23:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b27:	79 16                	jns    803b3f <alloc_sockfd+0x63>
		nsipc_close(sockid);
  803b29:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803b2c:	89 c7                	mov    %eax,%edi
  803b2e:	48 b8 eb 3f 80 00 00 	movabs $0x803feb,%rax
  803b35:	00 00 00 
  803b38:	ff d0                	callq  *%rax
		return r;
  803b3a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b3d:	eb 3a                	jmp    803b79 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  803b3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b43:	48 ba a0 70 82 00 00 	movabs $0x8270a0,%rdx
  803b4a:	00 00 00 
  803b4d:	8b 12                	mov    (%rdx),%edx
  803b4f:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  803b51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b55:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  803b5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b60:	8b 55 ec             	mov    -0x14(%rbp),%edx
  803b63:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  803b66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b6a:	48 89 c7             	mov    %rax,%rdi
  803b6d:	48 b8 65 2c 80 00 00 	movabs $0x802c65,%rax
  803b74:	00 00 00 
  803b77:	ff d0                	callq  *%rax
}
  803b79:	c9                   	leaveq 
  803b7a:	c3                   	retq   

0000000000803b7b <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  803b7b:	55                   	push   %rbp
  803b7c:	48 89 e5             	mov    %rsp,%rbp
  803b7f:	48 83 ec 30          	sub    $0x30,%rsp
  803b83:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803b86:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803b8a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  803b8e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803b91:	89 c7                	mov    %eax,%edi
  803b93:	48 b8 85 3a 80 00 00 	movabs $0x803a85,%rax
  803b9a:	00 00 00 
  803b9d:	ff d0                	callq  *%rax
  803b9f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ba2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ba6:	79 05                	jns    803bad <accept+0x32>
		return r;
  803ba8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803bab:	eb 3b                	jmp    803be8 <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  803bad:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803bb1:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  803bb5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803bb8:	48 89 ce             	mov    %rcx,%rsi
  803bbb:	89 c7                	mov    %eax,%edi
  803bbd:	48 b8 c8 3e 80 00 00 	movabs $0x803ec8,%rax
  803bc4:	00 00 00 
  803bc7:	ff d0                	callq  *%rax
  803bc9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bcc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bd0:	79 05                	jns    803bd7 <accept+0x5c>
		return r;
  803bd2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803bd5:	eb 11                	jmp    803be8 <accept+0x6d>
	return alloc_sockfd(r);
  803bd7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803bda:	89 c7                	mov    %eax,%edi
  803bdc:	48 b8 dc 3a 80 00 00 	movabs $0x803adc,%rax
  803be3:	00 00 00 
  803be6:	ff d0                	callq  *%rax
}
  803be8:	c9                   	leaveq 
  803be9:	c3                   	retq   

0000000000803bea <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  803bea:	55                   	push   %rbp
  803beb:	48 89 e5             	mov    %rsp,%rbp
  803bee:	48 83 ec 20          	sub    $0x20,%rsp
  803bf2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803bf5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803bf9:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  803bfc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803bff:	89 c7                	mov    %eax,%edi
  803c01:	48 b8 85 3a 80 00 00 	movabs $0x803a85,%rax
  803c08:	00 00 00 
  803c0b:	ff d0                	callq  *%rax
  803c0d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c10:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c14:	79 05                	jns    803c1b <bind+0x31>
		return r;
  803c16:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c19:	eb 1b                	jmp    803c36 <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  803c1b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803c1e:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  803c22:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c25:	48 89 ce             	mov    %rcx,%rsi
  803c28:	89 c7                	mov    %eax,%edi
  803c2a:	48 b8 47 3f 80 00 00 	movabs $0x803f47,%rax
  803c31:	00 00 00 
  803c34:	ff d0                	callq  *%rax
}
  803c36:	c9                   	leaveq 
  803c37:	c3                   	retq   

0000000000803c38 <shutdown>:

int
shutdown(int s, int how)
{
  803c38:	55                   	push   %rbp
  803c39:	48 89 e5             	mov    %rsp,%rbp
  803c3c:	48 83 ec 20          	sub    $0x20,%rsp
  803c40:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803c43:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  803c46:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803c49:	89 c7                	mov    %eax,%edi
  803c4b:	48 b8 85 3a 80 00 00 	movabs $0x803a85,%rax
  803c52:	00 00 00 
  803c55:	ff d0                	callq  *%rax
  803c57:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c5a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c5e:	79 05                	jns    803c65 <shutdown+0x2d>
		return r;
  803c60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c63:	eb 16                	jmp    803c7b <shutdown+0x43>
	return nsipc_shutdown(r, how);
  803c65:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803c68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c6b:	89 d6                	mov    %edx,%esi
  803c6d:	89 c7                	mov    %eax,%edi
  803c6f:	48 b8 ab 3f 80 00 00 	movabs $0x803fab,%rax
  803c76:	00 00 00 
  803c79:	ff d0                	callq  *%rax
}
  803c7b:	c9                   	leaveq 
  803c7c:	c3                   	retq   

0000000000803c7d <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  803c7d:	55                   	push   %rbp
  803c7e:	48 89 e5             	mov    %rsp,%rbp
  803c81:	48 83 ec 10          	sub    $0x10,%rsp
  803c85:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  803c89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803c8d:	48 89 c7             	mov    %rax,%rdi
  803c90:	48 b8 8b 50 80 00 00 	movabs $0x80508b,%rax
  803c97:	00 00 00 
  803c9a:	ff d0                	callq  *%rax
  803c9c:	83 f8 01             	cmp    $0x1,%eax
  803c9f:	75 17                	jne    803cb8 <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  803ca1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803ca5:	8b 40 0c             	mov    0xc(%rax),%eax
  803ca8:	89 c7                	mov    %eax,%edi
  803caa:	48 b8 eb 3f 80 00 00 	movabs $0x803feb,%rax
  803cb1:	00 00 00 
  803cb4:	ff d0                	callq  *%rax
  803cb6:	eb 05                	jmp    803cbd <devsock_close+0x40>
	else
		return 0;
  803cb8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803cbd:	c9                   	leaveq 
  803cbe:	c3                   	retq   

0000000000803cbf <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  803cbf:	55                   	push   %rbp
  803cc0:	48 89 e5             	mov    %rsp,%rbp
  803cc3:	48 83 ec 20          	sub    $0x20,%rsp
  803cc7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803cca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803cce:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  803cd1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803cd4:	89 c7                	mov    %eax,%edi
  803cd6:	48 b8 85 3a 80 00 00 	movabs $0x803a85,%rax
  803cdd:	00 00 00 
  803ce0:	ff d0                	callq  *%rax
  803ce2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ce5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ce9:	79 05                	jns    803cf0 <connect+0x31>
		return r;
  803ceb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803cee:	eb 1b                	jmp    803d0b <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  803cf0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803cf3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  803cf7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803cfa:	48 89 ce             	mov    %rcx,%rsi
  803cfd:	89 c7                	mov    %eax,%edi
  803cff:	48 b8 18 40 80 00 00 	movabs $0x804018,%rax
  803d06:	00 00 00 
  803d09:	ff d0                	callq  *%rax
}
  803d0b:	c9                   	leaveq 
  803d0c:	c3                   	retq   

0000000000803d0d <listen>:

int
listen(int s, int backlog)
{
  803d0d:	55                   	push   %rbp
  803d0e:	48 89 e5             	mov    %rsp,%rbp
  803d11:	48 83 ec 20          	sub    $0x20,%rsp
  803d15:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803d18:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  803d1b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803d1e:	89 c7                	mov    %eax,%edi
  803d20:	48 b8 85 3a 80 00 00 	movabs $0x803a85,%rax
  803d27:	00 00 00 
  803d2a:	ff d0                	callq  *%rax
  803d2c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d2f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d33:	79 05                	jns    803d3a <listen+0x2d>
		return r;
  803d35:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d38:	eb 16                	jmp    803d50 <listen+0x43>
	return nsipc_listen(r, backlog);
  803d3a:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803d3d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d40:	89 d6                	mov    %edx,%esi
  803d42:	89 c7                	mov    %eax,%edi
  803d44:	48 b8 7c 40 80 00 00 	movabs $0x80407c,%rax
  803d4b:	00 00 00 
  803d4e:	ff d0                	callq  *%rax
}
  803d50:	c9                   	leaveq 
  803d51:	c3                   	retq   

0000000000803d52 <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  803d52:	55                   	push   %rbp
  803d53:	48 89 e5             	mov    %rsp,%rbp
  803d56:	48 83 ec 20          	sub    $0x20,%rsp
  803d5a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  803d5e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  803d62:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  803d66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d6a:	89 c2                	mov    %eax,%edx
  803d6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803d70:	8b 40 0c             	mov    0xc(%rax),%eax
  803d73:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  803d77:	b9 00 00 00 00       	mov    $0x0,%ecx
  803d7c:	89 c7                	mov    %eax,%edi
  803d7e:	48 b8 bc 40 80 00 00 	movabs $0x8040bc,%rax
  803d85:	00 00 00 
  803d88:	ff d0                	callq  *%rax
}
  803d8a:	c9                   	leaveq 
  803d8b:	c3                   	retq   

0000000000803d8c <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  803d8c:	55                   	push   %rbp
  803d8d:	48 89 e5             	mov    %rsp,%rbp
  803d90:	48 83 ec 20          	sub    $0x20,%rsp
  803d94:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  803d98:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  803d9c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  803da0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803da4:	89 c2                	mov    %eax,%edx
  803da6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803daa:	8b 40 0c             	mov    0xc(%rax),%eax
  803dad:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  803db1:	b9 00 00 00 00       	mov    $0x0,%ecx
  803db6:	89 c7                	mov    %eax,%edi
  803db8:	48 b8 88 41 80 00 00 	movabs $0x804188,%rax
  803dbf:	00 00 00 
  803dc2:	ff d0                	callq  *%rax
}
  803dc4:	c9                   	leaveq 
  803dc5:	c3                   	retq   

0000000000803dc6 <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  803dc6:	55                   	push   %rbp
  803dc7:	48 89 e5             	mov    %rsp,%rbp
  803dca:	48 83 ec 10          	sub    $0x10,%rsp
  803dce:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  803dd2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  803dd6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803dda:	48 be 07 09 82 00 00 	movabs $0x820907,%rsi
  803de1:	00 00 00 
  803de4:	48 89 c7             	mov    %rax,%rdi
  803de7:	48 b8 b3 1c 80 00 00 	movabs $0x801cb3,%rax
  803dee:	00 00 00 
  803df1:	ff d0                	callq  *%rax
	return 0;
  803df3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803df8:	c9                   	leaveq 
  803df9:	c3                   	retq   

0000000000803dfa <socket>:

int
socket(int domain, int type, int protocol)
{
  803dfa:	55                   	push   %rbp
  803dfb:	48 89 e5             	mov    %rsp,%rbp
  803dfe:	48 83 ec 20          	sub    $0x20,%rsp
  803e02:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803e05:	89 75 e8             	mov    %esi,-0x18(%rbp)
  803e08:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  803e0b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  803e0e:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  803e11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803e14:	89 ce                	mov    %ecx,%esi
  803e16:	89 c7                	mov    %eax,%edi
  803e18:	48 b8 40 42 80 00 00 	movabs $0x804240,%rax
  803e1f:	00 00 00 
  803e22:	ff d0                	callq  *%rax
  803e24:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803e27:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e2b:	79 05                	jns    803e32 <socket+0x38>
		return r;
  803e2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e30:	eb 11                	jmp    803e43 <socket+0x49>
	return alloc_sockfd(r);
  803e32:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e35:	89 c7                	mov    %eax,%edi
  803e37:	48 b8 dc 3a 80 00 00 	movabs $0x803adc,%rax
  803e3e:	00 00 00 
  803e41:	ff d0                	callq  *%rax
}
  803e43:	c9                   	leaveq 
  803e44:	c3                   	retq   

0000000000803e45 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  803e45:	55                   	push   %rbp
  803e46:	48 89 e5             	mov    %rsp,%rbp
  803e49:	48 83 ec 10          	sub    $0x10,%rsp
  803e4d:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  803e50:	48 b8 88 80 82 00 00 	movabs $0x828088,%rax
  803e57:	00 00 00 
  803e5a:	8b 00                	mov    (%rax),%eax
  803e5c:	85 c0                	test   %eax,%eax
  803e5e:	75 1f                	jne    803e7f <nsipc+0x3a>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  803e60:	bf 02 00 00 00       	mov    $0x2,%edi
  803e65:	48 b8 f3 2b 80 00 00 	movabs $0x802bf3,%rax
  803e6c:	00 00 00 
  803e6f:	ff d0                	callq  *%rax
  803e71:	89 c2                	mov    %eax,%edx
  803e73:	48 b8 88 80 82 00 00 	movabs $0x828088,%rax
  803e7a:	00 00 00 
  803e7d:	89 10                	mov    %edx,(%rax)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  803e7f:	48 b8 88 80 82 00 00 	movabs $0x828088,%rax
  803e86:	00 00 00 
  803e89:	8b 00                	mov    (%rax),%eax
  803e8b:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803e8e:	b9 07 00 00 00       	mov    $0x7,%ecx
  803e93:	48 ba 00 90 b5 00 00 	movabs $0xb59000,%rdx
  803e9a:	00 00 00 
  803e9d:	89 c7                	mov    %eax,%edi
  803e9f:	48 b8 66 2a 80 00 00 	movabs $0x802a66,%rax
  803ea6:	00 00 00 
  803ea9:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  803eab:	ba 00 00 00 00       	mov    $0x0,%edx
  803eb0:	be 00 00 00 00       	mov    $0x0,%esi
  803eb5:	bf 00 00 00 00       	mov    $0x0,%edi
  803eba:	48 b8 28 2a 80 00 00 	movabs $0x802a28,%rax
  803ec1:	00 00 00 
  803ec4:	ff d0                	callq  *%rax
}
  803ec6:	c9                   	leaveq 
  803ec7:	c3                   	retq   

0000000000803ec8 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  803ec8:	55                   	push   %rbp
  803ec9:	48 89 e5             	mov    %rsp,%rbp
  803ecc:	48 83 ec 30          	sub    $0x30,%rsp
  803ed0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803ed3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803ed7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  803edb:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803ee2:	00 00 00 
  803ee5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  803ee8:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  803eea:	bf 01 00 00 00       	mov    $0x1,%edi
  803eef:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  803ef6:	00 00 00 
  803ef9:	ff d0                	callq  *%rax
  803efb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803efe:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f02:	78 3e                	js     803f42 <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  803f04:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803f0b:	00 00 00 
  803f0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  803f12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f16:	8b 40 10             	mov    0x10(%rax),%eax
  803f19:	89 c2                	mov    %eax,%edx
  803f1b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  803f1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f23:	48 89 ce             	mov    %rcx,%rsi
  803f26:	48 89 c7             	mov    %rax,%rdi
  803f29:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  803f30:	00 00 00 
  803f33:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  803f35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f39:	8b 50 10             	mov    0x10(%rax),%edx
  803f3c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803f40:	89 10                	mov    %edx,(%rax)
	}
	return r;
  803f42:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803f45:	c9                   	leaveq 
  803f46:	c3                   	retq   

0000000000803f47 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  803f47:	55                   	push   %rbp
  803f48:	48 89 e5             	mov    %rsp,%rbp
  803f4b:	48 83 ec 10          	sub    $0x10,%rsp
  803f4f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803f52:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  803f56:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  803f59:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803f60:	00 00 00 
  803f63:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803f66:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  803f68:	8b 55 f8             	mov    -0x8(%rbp),%edx
  803f6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f6f:	48 89 c6             	mov    %rax,%rsi
  803f72:	48 bf 04 90 b5 00 00 	movabs $0xb59004,%rdi
  803f79:	00 00 00 
  803f7c:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  803f83:	00 00 00 
  803f86:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  803f88:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803f8f:	00 00 00 
  803f92:	8b 55 f8             	mov    -0x8(%rbp),%edx
  803f95:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  803f98:	bf 02 00 00 00       	mov    $0x2,%edi
  803f9d:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  803fa4:	00 00 00 
  803fa7:	ff d0                	callq  *%rax
}
  803fa9:	c9                   	leaveq 
  803faa:	c3                   	retq   

0000000000803fab <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  803fab:	55                   	push   %rbp
  803fac:	48 89 e5             	mov    %rsp,%rbp
  803faf:	48 83 ec 10          	sub    $0x10,%rsp
  803fb3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803fb6:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  803fb9:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803fc0:	00 00 00 
  803fc3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803fc6:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  803fc8:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803fcf:	00 00 00 
  803fd2:	8b 55 f8             	mov    -0x8(%rbp),%edx
  803fd5:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  803fd8:	bf 03 00 00 00       	mov    $0x3,%edi
  803fdd:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  803fe4:	00 00 00 
  803fe7:	ff d0                	callq  *%rax
}
  803fe9:	c9                   	leaveq 
  803fea:	c3                   	retq   

0000000000803feb <nsipc_close>:

int
nsipc_close(int s)
{
  803feb:	55                   	push   %rbp
  803fec:	48 89 e5             	mov    %rsp,%rbp
  803fef:	48 83 ec 10          	sub    $0x10,%rsp
  803ff3:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  803ff6:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  803ffd:	00 00 00 
  804000:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804003:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  804005:	bf 04 00 00 00       	mov    $0x4,%edi
  80400a:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  804011:	00 00 00 
  804014:	ff d0                	callq  *%rax
}
  804016:	c9                   	leaveq 
  804017:	c3                   	retq   

0000000000804018 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804018:	55                   	push   %rbp
  804019:	48 89 e5             	mov    %rsp,%rbp
  80401c:	48 83 ec 10          	sub    $0x10,%rsp
  804020:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804023:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804027:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  80402a:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804031:	00 00 00 
  804034:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804037:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  804039:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80403c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804040:	48 89 c6             	mov    %rax,%rsi
  804043:	48 bf 04 90 b5 00 00 	movabs $0xb59004,%rdi
  80404a:	00 00 00 
  80404d:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  804054:	00 00 00 
  804057:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  804059:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804060:	00 00 00 
  804063:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804066:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  804069:	bf 05 00 00 00       	mov    $0x5,%edi
  80406e:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  804075:	00 00 00 
  804078:	ff d0                	callq  *%rax
}
  80407a:	c9                   	leaveq 
  80407b:	c3                   	retq   

000000000080407c <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  80407c:	55                   	push   %rbp
  80407d:	48 89 e5             	mov    %rsp,%rbp
  804080:	48 83 ec 10          	sub    $0x10,%rsp
  804084:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804087:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  80408a:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804091:	00 00 00 
  804094:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804097:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804099:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  8040a0:	00 00 00 
  8040a3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8040a6:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  8040a9:	bf 06 00 00 00       	mov    $0x6,%edi
  8040ae:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  8040b5:	00 00 00 
  8040b8:	ff d0                	callq  *%rax
}
  8040ba:	c9                   	leaveq 
  8040bb:	c3                   	retq   

00000000008040bc <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8040bc:	55                   	push   %rbp
  8040bd:	48 89 e5             	mov    %rsp,%rbp
  8040c0:	48 83 ec 30          	sub    $0x30,%rsp
  8040c4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8040c7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8040cb:	89 55 e8             	mov    %edx,-0x18(%rbp)
  8040ce:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  8040d1:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  8040d8:	00 00 00 
  8040db:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8040de:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  8040e0:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  8040e7:	00 00 00 
  8040ea:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8040ed:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  8040f0:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  8040f7:	00 00 00 
  8040fa:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8040fd:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804100:	bf 07 00 00 00       	mov    $0x7,%edi
  804105:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  80410c:	00 00 00 
  80410f:	ff d0                	callq  *%rax
  804111:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804114:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804118:	78 69                	js     804183 <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  80411a:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  804121:	7f 08                	jg     80412b <nsipc_recv+0x6f>
  804123:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804126:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  804129:	7e 35                	jle    804160 <nsipc_recv+0xa4>
  80412b:	48 b9 0e 09 82 00 00 	movabs $0x82090e,%rcx
  804132:	00 00 00 
  804135:	48 ba 23 09 82 00 00 	movabs $0x820923,%rdx
  80413c:	00 00 00 
  80413f:	be 61 00 00 00       	mov    $0x61,%esi
  804144:	48 bf 38 09 82 00 00 	movabs $0x820938,%rdi
  80414b:	00 00 00 
  80414e:	b8 00 00 00 00       	mov    $0x0,%eax
  804153:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  80415a:	00 00 00 
  80415d:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  804160:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804163:	48 63 d0             	movslq %eax,%rdx
  804166:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80416a:	48 be 00 90 b5 00 00 	movabs $0xb59000,%rsi
  804171:	00 00 00 
  804174:	48 89 c7             	mov    %rax,%rdi
  804177:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  80417e:	00 00 00 
  804181:	ff d0                	callq  *%rax
	}

	return r;
  804183:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804186:	c9                   	leaveq 
  804187:	c3                   	retq   

0000000000804188 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804188:	55                   	push   %rbp
  804189:	48 89 e5             	mov    %rsp,%rbp
  80418c:	48 83 ec 20          	sub    $0x20,%rsp
  804190:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804193:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804197:	89 55 f8             	mov    %edx,-0x8(%rbp)
  80419a:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  80419d:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  8041a4:	00 00 00 
  8041a7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8041aa:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  8041ac:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  8041b3:	7e 35                	jle    8041ea <nsipc_send+0x62>
  8041b5:	48 b9 44 09 82 00 00 	movabs $0x820944,%rcx
  8041bc:	00 00 00 
  8041bf:	48 ba 23 09 82 00 00 	movabs $0x820923,%rdx
  8041c6:	00 00 00 
  8041c9:	be 6c 00 00 00       	mov    $0x6c,%esi
  8041ce:	48 bf 38 09 82 00 00 	movabs $0x820938,%rdi
  8041d5:	00 00 00 
  8041d8:	b8 00 00 00 00       	mov    $0x0,%eax
  8041dd:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  8041e4:	00 00 00 
  8041e7:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8041ea:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8041ed:	48 63 d0             	movslq %eax,%rdx
  8041f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8041f4:	48 89 c6             	mov    %rax,%rsi
  8041f7:	48 bf 0c 90 b5 00 00 	movabs $0xb5900c,%rdi
  8041fe:	00 00 00 
  804201:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  804208:	00 00 00 
  80420b:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  80420d:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804214:	00 00 00 
  804217:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80421a:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  80421d:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804224:	00 00 00 
  804227:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80422a:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  80422d:	bf 08 00 00 00       	mov    $0x8,%edi
  804232:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  804239:	00 00 00 
  80423c:	ff d0                	callq  *%rax
}
  80423e:	c9                   	leaveq 
  80423f:	c3                   	retq   

0000000000804240 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  804240:	55                   	push   %rbp
  804241:	48 89 e5             	mov    %rsp,%rbp
  804244:	48 83 ec 10          	sub    $0x10,%rsp
  804248:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80424b:	89 75 f8             	mov    %esi,-0x8(%rbp)
  80424e:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  804251:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804258:	00 00 00 
  80425b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80425e:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  804260:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804267:	00 00 00 
  80426a:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80426d:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  804270:	48 b8 00 90 b5 00 00 	movabs $0xb59000,%rax
  804277:	00 00 00 
  80427a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80427d:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804280:	bf 09 00 00 00       	mov    $0x9,%edi
  804285:	48 b8 45 3e 80 00 00 	movabs $0x803e45,%rax
  80428c:	00 00 00 
  80428f:	ff d0                	callq  *%rax
}
  804291:	c9                   	leaveq 
  804292:	c3                   	retq   

0000000000804293 <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804293:	55                   	push   %rbp
  804294:	48 89 e5             	mov    %rsp,%rbp
  804297:	48 83 ec 20          	sub    $0x20,%rsp
  80429b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80429f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  8042a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8042a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8042ab:	48 01 d0             	add    %rdx,%rax
  8042ae:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8042b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8042b6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8042ba:	eb 64                	jmp    804320 <isfree+0x8d>
		if (va >= (uintptr_t) mend
  8042bc:	48 b8 e0 70 82 00 00 	movabs $0x8270e0,%rax
  8042c3:	00 00 00 
  8042c6:	48 8b 00             	mov    (%rax),%rax
  8042c9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8042cd:	76 42                	jbe    804311 <isfree+0x7e>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8042cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8042d3:	48 c1 e8 15          	shr    $0x15,%rax
  8042d7:	48 89 c2             	mov    %rax,%rdx
  8042da:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8042e1:	01 00 00 
  8042e4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8042e8:	83 e0 01             	and    $0x1,%eax
  8042eb:	48 85 c0             	test   %rax,%rax
  8042ee:	74 28                	je     804318 <isfree+0x85>
  8042f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8042f4:	48 c1 e8 0c          	shr    $0xc,%rax
  8042f8:	48 89 c2             	mov    %rax,%rdx
  8042fb:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804302:	01 00 00 
  804305:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804309:	83 e0 01             	and    $0x1,%eax
  80430c:	48 85 c0             	test   %rax,%rax
  80430f:	74 07                	je     804318 <isfree+0x85>
			return 0;
  804311:	b8 00 00 00 00       	mov    $0x0,%eax
  804316:	eb 17                	jmp    80432f <isfree+0x9c>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804318:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80431f:	00 
  804320:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804324:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804328:	72 92                	jb     8042bc <isfree+0x29>
	return 1;
  80432a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80432f:	c9                   	leaveq 
  804330:	c3                   	retq   

0000000000804331 <malloc>:

void*
malloc(size_t n)
{
  804331:	55                   	push   %rbp
  804332:	48 89 e5             	mov    %rsp,%rbp
  804335:	48 83 ec 60          	sub    $0x60,%rsp
  804339:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  80433d:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804344:	00 00 00 
  804347:	48 8b 00             	mov    (%rax),%rax
  80434a:	48 85 c0             	test   %rax,%rax
  80434d:	75 1a                	jne    804369 <malloc+0x38>
		mptr = mbegin;
  80434f:	48 b8 d8 70 82 00 00 	movabs $0x8270d8,%rax
  804356:	00 00 00 
  804359:	48 8b 10             	mov    (%rax),%rdx
  80435c:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804363:	00 00 00 
  804366:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804369:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804370:	00 
  804371:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804375:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804379:	48 01 d0             	add    %rdx,%rax
  80437c:	48 83 e8 01          	sub    $0x1,%rax
  804380:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804384:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804388:	ba 00 00 00 00       	mov    $0x0,%edx
  80438d:	48 f7 75 f0          	divq   -0x10(%rbp)
  804391:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804395:	48 29 d0             	sub    %rdx,%rax
  804398:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	if (n >= MAXMALLOC)
  80439c:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  8043a3:	00 
  8043a4:	76 0a                	jbe    8043b0 <malloc+0x7f>
		return 0;
  8043a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8043ab:	e9 f1 02 00 00       	jmpq   8046a1 <malloc+0x370>

	if ((uintptr_t) mptr % PGSIZE){
  8043b0:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8043b7:	00 00 00 
  8043ba:	48 8b 00             	mov    (%rax),%rax
  8043bd:	25 ff 0f 00 00       	and    $0xfff,%eax
  8043c2:	48 85 c0             	test   %rax,%rax
  8043c5:	0f 84 0f 01 00 00    	je     8044da <malloc+0x1a9>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8043cb:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8043d2:	00 
  8043d3:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8043da:	00 00 00 
  8043dd:	48 8b 00             	mov    (%rax),%rax
  8043e0:	48 89 c2             	mov    %rax,%rdx
  8043e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8043e7:	48 01 d0             	add    %rdx,%rax
  8043ea:	48 83 e8 01          	sub    $0x1,%rax
  8043ee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8043f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8043f6:	ba 00 00 00 00       	mov    $0x0,%edx
  8043fb:	48 f7 75 e0          	divq   -0x20(%rbp)
  8043ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804403:	48 29 d0             	sub    %rdx,%rax
  804406:	48 83 e8 04          	sub    $0x4,%rax
  80440a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  80440e:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804415:	00 00 00 
  804418:	48 8b 00             	mov    (%rax),%rax
  80441b:	48 c1 e8 0c          	shr    $0xc,%rax
  80441f:	48 89 c1             	mov    %rax,%rcx
  804422:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804429:	00 00 00 
  80442c:	48 8b 00             	mov    (%rax),%rax
  80442f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804433:	48 83 c2 03          	add    $0x3,%rdx
  804437:	48 01 d0             	add    %rdx,%rax
  80443a:	48 c1 e8 0c          	shr    $0xc,%rax
  80443e:	48 39 c1             	cmp    %rax,%rcx
  804441:	75 4a                	jne    80448d <malloc+0x15c>
			(*ref)++;
  804443:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804447:	8b 00                	mov    (%rax),%eax
  804449:	8d 50 01             	lea    0x1(%rax),%edx
  80444c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804450:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804452:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804459:	00 00 00 
  80445c:	48 8b 00             	mov    (%rax),%rax
  80445f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804463:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  80446a:	00 00 00 
  80446d:	48 8b 10             	mov    (%rax),%rdx
  804470:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804474:	48 01 c2             	add    %rax,%rdx
  804477:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  80447e:	00 00 00 
  804481:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804484:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804488:	e9 14 02 00 00       	jmpq   8046a1 <malloc+0x370>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  80448d:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804494:	00 00 00 
  804497:	48 8b 00             	mov    (%rax),%rax
  80449a:	48 89 c7             	mov    %rax,%rdi
  80449d:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  8044a4:	00 00 00 
  8044a7:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8044a9:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8044b0:	00 00 00 
  8044b3:	48 8b 00             	mov    (%rax),%rax
  8044b6:	48 05 00 10 00 00    	add    $0x1000,%rax
  8044bc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8044c0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8044c4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8044ca:	48 89 c2             	mov    %rax,%rdx
  8044cd:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8044d4:	00 00 00 
  8044d7:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  8044da:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (1) {
		if (isfree(mptr, n + 4))
  8044e1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8044e5:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8044e9:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8044f0:	00 00 00 
  8044f3:	48 8b 00             	mov    (%rax),%rax
  8044f6:	48 89 d6             	mov    %rdx,%rsi
  8044f9:	48 89 c7             	mov    %rax,%rdi
  8044fc:	48 b8 93 42 80 00 00 	movabs $0x804293,%rax
  804503:	00 00 00 
  804506:	ff d0                	callq  *%rax
  804508:	85 c0                	test   %eax,%eax
  80450a:	74 0d                	je     804519 <malloc+0x1e8>
			break;
  80450c:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  80450d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804514:	e9 14 01 00 00       	jmpq   80462d <malloc+0x2fc>
		mptr += PGSIZE;
  804519:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804520:	00 00 00 
  804523:	48 8b 00             	mov    (%rax),%rax
  804526:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  80452d:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804534:	00 00 00 
  804537:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  80453a:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804541:	00 00 00 
  804544:	48 8b 10             	mov    (%rax),%rdx
  804547:	48 b8 e0 70 82 00 00 	movabs $0x8270e0,%rax
  80454e:	00 00 00 
  804551:	48 8b 00             	mov    (%rax),%rax
  804554:	48 39 c2             	cmp    %rax,%rdx
  804557:	75 2e                	jne    804587 <malloc+0x256>
			mptr = mbegin;
  804559:	48 b8 d8 70 82 00 00 	movabs $0x8270d8,%rax
  804560:	00 00 00 
  804563:	48 8b 10             	mov    (%rax),%rdx
  804566:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  80456d:	00 00 00 
  804570:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  804573:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  804577:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  80457b:	75 0a                	jne    804587 <malloc+0x256>
				return 0;	/* out of address space */
  80457d:	b8 00 00 00 00       	mov    $0x0,%eax
  804582:	e9 1a 01 00 00       	jmpq   8046a1 <malloc+0x370>
	}
  804587:	e9 55 ff ff ff       	jmpq   8044e1 <malloc+0x1b0>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  80458c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80458f:	05 00 10 00 00       	add    $0x1000,%eax
  804594:	48 98                	cltq   
  804596:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80459a:	48 83 c2 04          	add    $0x4,%rdx
  80459e:	48 39 d0             	cmp    %rdx,%rax
  8045a1:	73 07                	jae    8045aa <malloc+0x279>
  8045a3:	b8 00 04 00 00       	mov    $0x400,%eax
  8045a8:	eb 05                	jmp    8045af <malloc+0x27e>
  8045aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8045af:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8045b2:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8045b5:	83 c8 07             	or     $0x7,%eax
  8045b8:	89 c2                	mov    %eax,%edx
  8045ba:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8045c1:	00 00 00 
  8045c4:	48 8b 08             	mov    (%rax),%rcx
  8045c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045ca:	48 98                	cltq   
  8045cc:	48 01 c8             	add    %rcx,%rax
  8045cf:	48 89 c6             	mov    %rax,%rsi
  8045d2:	bf 00 00 00 00       	mov    $0x0,%edi
  8045d7:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  8045de:	00 00 00 
  8045e1:	ff d0                	callq  *%rax
  8045e3:	85 c0                	test   %eax,%eax
  8045e5:	79 3f                	jns    804626 <malloc+0x2f5>
			for (; i >= 0; i -= PGSIZE)
  8045e7:	eb 30                	jmp    804619 <malloc+0x2e8>
				sys_page_unmap(0, mptr + i);
  8045e9:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  8045f0:	00 00 00 
  8045f3:	48 8b 10             	mov    (%rax),%rdx
  8045f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045f9:	48 98                	cltq   
  8045fb:	48 01 d0             	add    %rdx,%rax
  8045fe:	48 89 c6             	mov    %rax,%rsi
  804601:	bf 00 00 00 00       	mov    $0x0,%edi
  804606:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  80460d:	00 00 00 
  804610:	ff d0                	callq  *%rax
			for (; i >= 0; i -= PGSIZE)
  804612:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  804619:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80461d:	79 ca                	jns    8045e9 <malloc+0x2b8>
			return 0;	/* out of physical memory */
  80461f:	b8 00 00 00 00       	mov    $0x0,%eax
  804624:	eb 7b                	jmp    8046a1 <malloc+0x370>
	for (i = 0; i < n + 4; i += PGSIZE){
  804626:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  80462d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804630:	48 98                	cltq   
  804632:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804636:	48 83 c2 04          	add    $0x4,%rdx
  80463a:	48 39 d0             	cmp    %rdx,%rax
  80463d:	0f 82 49 ff ff ff    	jb     80458c <malloc+0x25b>
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  804643:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  80464a:	00 00 00 
  80464d:	48 8b 00             	mov    (%rax),%rax
  804650:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804653:	48 63 d2             	movslq %edx,%rdx
  804656:	48 83 ea 04          	sub    $0x4,%rdx
  80465a:	48 01 d0             	add    %rdx,%rax
  80465d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  804661:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804665:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  80466b:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804672:	00 00 00 
  804675:	48 8b 00             	mov    (%rax),%rax
  804678:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  80467c:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804683:	00 00 00 
  804686:	48 8b 10             	mov    (%rax),%rdx
  804689:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80468d:	48 01 c2             	add    %rax,%rdx
  804690:	48 b8 90 80 82 00 00 	movabs $0x828090,%rax
  804697:	00 00 00 
  80469a:	48 89 10             	mov    %rdx,(%rax)
	return v;
  80469d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  8046a1:	c9                   	leaveq 
  8046a2:	c3                   	retq   

00000000008046a3 <free>:

void
free(void *v)
{
  8046a3:	55                   	push   %rbp
  8046a4:	48 89 e5             	mov    %rsp,%rbp
  8046a7:	48 83 ec 30          	sub    $0x30,%rsp
  8046ab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8046af:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8046b4:	75 05                	jne    8046bb <free+0x18>
		return;
  8046b6:	e9 54 01 00 00       	jmpq   80480f <free+0x16c>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8046bb:	48 b8 d8 70 82 00 00 	movabs $0x8270d8,%rax
  8046c2:	00 00 00 
  8046c5:	48 8b 00             	mov    (%rax),%rax
  8046c8:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8046cc:	77 13                	ja     8046e1 <free+0x3e>
  8046ce:	48 b8 e0 70 82 00 00 	movabs $0x8270e0,%rax
  8046d5:	00 00 00 
  8046d8:	48 8b 00             	mov    (%rax),%rax
  8046db:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8046df:	72 35                	jb     804716 <free+0x73>
  8046e1:	48 b9 50 09 82 00 00 	movabs $0x820950,%rcx
  8046e8:	00 00 00 
  8046eb:	48 ba 7e 09 82 00 00 	movabs $0x82097e,%rdx
  8046f2:	00 00 00 
  8046f5:	be 7a 00 00 00       	mov    $0x7a,%esi
  8046fa:	48 bf 93 09 82 00 00 	movabs $0x820993,%rdi
  804701:	00 00 00 
  804704:	b8 00 00 00 00       	mov    $0x0,%eax
  804709:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  804710:	00 00 00 
  804713:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  804716:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80471a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80471e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804722:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804728:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  80472c:	eb 7b                	jmp    8047a9 <free+0x106>
		sys_page_unmap(0, c);
  80472e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804732:	48 89 c6             	mov    %rax,%rsi
  804735:	bf 00 00 00 00       	mov    $0x0,%edi
  80473a:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  804741:	00 00 00 
  804744:	ff d0                	callq  *%rax
		c += PGSIZE;
  804746:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80474d:	00 
		assert(mbegin <= c && c < mend);
  80474e:	48 b8 d8 70 82 00 00 	movabs $0x8270d8,%rax
  804755:	00 00 00 
  804758:	48 8b 00             	mov    (%rax),%rax
  80475b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80475f:	77 13                	ja     804774 <free+0xd1>
  804761:	48 b8 e0 70 82 00 00 	movabs $0x8270e0,%rax
  804768:	00 00 00 
  80476b:	48 8b 00             	mov    (%rax),%rax
  80476e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804772:	72 35                	jb     8047a9 <free+0x106>
  804774:	48 b9 a0 09 82 00 00 	movabs $0x8209a0,%rcx
  80477b:	00 00 00 
  80477e:	48 ba 7e 09 82 00 00 	movabs $0x82097e,%rdx
  804785:	00 00 00 
  804788:	be 81 00 00 00       	mov    $0x81,%esi
  80478d:	48 bf 93 09 82 00 00 	movabs $0x820993,%rdi
  804794:	00 00 00 
  804797:	b8 00 00 00 00       	mov    $0x0,%eax
  80479c:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  8047a3:	00 00 00 
  8047a6:	41 ff d0             	callq  *%r8
	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8047a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047ad:	48 c1 e8 0c          	shr    $0xc,%rax
  8047b1:	48 89 c2             	mov    %rax,%rdx
  8047b4:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8047bb:	01 00 00 
  8047be:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8047c2:	25 00 04 00 00       	and    $0x400,%eax
  8047c7:	48 85 c0             	test   %rax,%rax
  8047ca:	0f 85 5e ff ff ff    	jne    80472e <free+0x8b>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  8047d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047d4:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  8047da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  8047de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8047e2:	8b 00                	mov    (%rax),%eax
  8047e4:	8d 50 ff             	lea    -0x1(%rax),%edx
  8047e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8047eb:	89 10                	mov    %edx,(%rax)
  8047ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8047f1:	8b 00                	mov    (%rax),%eax
  8047f3:	85 c0                	test   %eax,%eax
  8047f5:	75 18                	jne    80480f <free+0x16c>
		sys_page_unmap(0, c);
  8047f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047fb:	48 89 c6             	mov    %rax,%rsi
  8047fe:	bf 00 00 00 00       	mov    $0x0,%edi
  804803:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  80480a:	00 00 00 
  80480d:	ff d0                	callq  *%rax
}
  80480f:	c9                   	leaveq 
  804810:	c3                   	retq   

0000000000804811 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  804811:	55                   	push   %rbp
  804812:	48 89 e5             	mov    %rsp,%rbp
  804815:	53                   	push   %rbx
  804816:	48 83 ec 38          	sub    $0x38,%rsp
  80481a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  80481e:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  804822:	48 89 c7             	mov    %rax,%rdi
  804825:	48 b8 b3 2c 80 00 00 	movabs $0x802cb3,%rax
  80482c:	00 00 00 
  80482f:	ff d0                	callq  *%rax
  804831:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804834:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804838:	0f 88 bf 01 00 00    	js     8049fd <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  80483e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804842:	ba 07 04 00 00       	mov    $0x407,%edx
  804847:	48 89 c6             	mov    %rax,%rsi
  80484a:	bf 00 00 00 00       	mov    $0x0,%edi
  80484f:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  804856:	00 00 00 
  804859:	ff d0                	callq  *%rax
  80485b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80485e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804862:	0f 88 95 01 00 00    	js     8049fd <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  804868:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80486c:	48 89 c7             	mov    %rax,%rdi
  80486f:	48 b8 b3 2c 80 00 00 	movabs $0x802cb3,%rax
  804876:	00 00 00 
  804879:	ff d0                	callq  *%rax
  80487b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80487e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804882:	0f 88 5d 01 00 00    	js     8049e5 <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804888:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80488c:	ba 07 04 00 00       	mov    $0x407,%edx
  804891:	48 89 c6             	mov    %rax,%rsi
  804894:	bf 00 00 00 00       	mov    $0x0,%edi
  804899:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  8048a0:	00 00 00 
  8048a3:	ff d0                	callq  *%rax
  8048a5:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8048a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8048ac:	0f 88 33 01 00 00    	js     8049e5 <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  8048b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8048b6:	48 89 c7             	mov    %rax,%rdi
  8048b9:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  8048c0:	00 00 00 
  8048c3:	ff d0                	callq  *%rax
  8048c5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8048c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8048cd:	ba 07 04 00 00       	mov    $0x407,%edx
  8048d2:	48 89 c6             	mov    %rax,%rsi
  8048d5:	bf 00 00 00 00       	mov    $0x0,%edi
  8048da:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  8048e1:	00 00 00 
  8048e4:	ff d0                	callq  *%rax
  8048e6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8048e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8048ed:	79 05                	jns    8048f4 <pipe+0xe3>
		goto err2;
  8048ef:	e9 d9 00 00 00       	jmpq   8049cd <pipe+0x1bc>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8048f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8048f8:	48 89 c7             	mov    %rax,%rdi
  8048fb:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  804902:	00 00 00 
  804905:	ff d0                	callq  *%rax
  804907:	48 89 c2             	mov    %rax,%rdx
  80490a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80490e:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  804914:	48 89 d1             	mov    %rdx,%rcx
  804917:	ba 00 00 00 00       	mov    $0x0,%edx
  80491c:	48 89 c6             	mov    %rax,%rsi
  80491f:	bf 00 00 00 00       	mov    $0x0,%edi
  804924:	48 b8 32 26 80 00 00 	movabs $0x802632,%rax
  80492b:	00 00 00 
  80492e:	ff d0                	callq  *%rax
  804930:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804933:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804937:	79 1b                	jns    804954 <pipe+0x143>
		goto err3;
  804939:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  80493a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80493e:	48 89 c6             	mov    %rax,%rsi
  804941:	bf 00 00 00 00       	mov    $0x0,%edi
  804946:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  80494d:	00 00 00 
  804950:	ff d0                	callq  *%rax
  804952:	eb 79                	jmp    8049cd <pipe+0x1bc>
	fd0->fd_dev_id = devpipe.dev_id;
  804954:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804958:	48 ba 00 71 82 00 00 	movabs $0x827100,%rdx
  80495f:	00 00 00 
  804962:	8b 12                	mov    (%rdx),%edx
  804964:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  804966:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80496a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	fd1->fd_dev_id = devpipe.dev_id;
  804971:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804975:	48 ba 00 71 82 00 00 	movabs $0x827100,%rdx
  80497c:	00 00 00 
  80497f:	8b 12                	mov    (%rdx),%edx
  804981:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  804983:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804987:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
	pfd[0] = fd2num(fd0);
  80498e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804992:	48 89 c7             	mov    %rax,%rdi
  804995:	48 b8 65 2c 80 00 00 	movabs $0x802c65,%rax
  80499c:	00 00 00 
  80499f:	ff d0                	callq  *%rax
  8049a1:	89 c2                	mov    %eax,%edx
  8049a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8049a7:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  8049a9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8049ad:	48 8d 58 04          	lea    0x4(%rax),%rbx
  8049b1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8049b5:	48 89 c7             	mov    %rax,%rdi
  8049b8:	48 b8 65 2c 80 00 00 	movabs $0x802c65,%rax
  8049bf:	00 00 00 
  8049c2:	ff d0                	callq  *%rax
  8049c4:	89 03                	mov    %eax,(%rbx)
	return 0;
  8049c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8049cb:	eb 33                	jmp    804a00 <pipe+0x1ef>
err2:
	sys_page_unmap(0, fd1);
  8049cd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8049d1:	48 89 c6             	mov    %rax,%rsi
  8049d4:	bf 00 00 00 00       	mov    $0x0,%edi
  8049d9:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  8049e0:	00 00 00 
  8049e3:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  8049e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8049e9:	48 89 c6             	mov    %rax,%rsi
  8049ec:	bf 00 00 00 00       	mov    $0x0,%edi
  8049f1:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  8049f8:	00 00 00 
  8049fb:	ff d0                	callq  *%rax
err:
	return r;
  8049fd:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  804a00:	48 83 c4 38          	add    $0x38,%rsp
  804a04:	5b                   	pop    %rbx
  804a05:	5d                   	pop    %rbp
  804a06:	c3                   	retq   

0000000000804a07 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  804a07:	55                   	push   %rbp
  804a08:	48 89 e5             	mov    %rsp,%rbp
  804a0b:	53                   	push   %rbx
  804a0c:	48 83 ec 28          	sub    $0x28,%rsp
  804a10:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  804a14:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  804a18:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  804a1f:	00 00 00 
  804a22:	48 8b 00             	mov    (%rax),%rax
  804a25:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  804a2b:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  804a2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804a32:	48 89 c7             	mov    %rax,%rdi
  804a35:	48 b8 8b 50 80 00 00 	movabs $0x80508b,%rax
  804a3c:	00 00 00 
  804a3f:	ff d0                	callq  *%rax
  804a41:	89 c3                	mov    %eax,%ebx
  804a43:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804a47:	48 89 c7             	mov    %rax,%rdi
  804a4a:	48 b8 8b 50 80 00 00 	movabs $0x80508b,%rax
  804a51:	00 00 00 
  804a54:	ff d0                	callq  *%rax
  804a56:	39 c3                	cmp    %eax,%ebx
  804a58:	0f 94 c0             	sete   %al
  804a5b:	0f b6 c0             	movzbl %al,%eax
  804a5e:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  804a61:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  804a68:	00 00 00 
  804a6b:	48 8b 00             	mov    (%rax),%rax
  804a6e:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  804a74:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  804a77:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804a7a:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  804a7d:	75 05                	jne    804a84 <_pipeisclosed+0x7d>
			return ret;
  804a7f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  804a82:	eb 4a                	jmp    804ace <_pipeisclosed+0xc7>
		if (n != nn && ret == 1)
  804a84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804a87:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  804a8a:	74 3d                	je     804ac9 <_pipeisclosed+0xc2>
  804a8c:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  804a90:	75 37                	jne    804ac9 <_pipeisclosed+0xc2>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  804a92:	48 b8 50 66 b5 00 00 	movabs $0xb56650,%rax
  804a99:	00 00 00 
  804a9c:	48 8b 00             	mov    (%rax),%rax
  804a9f:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  804aa5:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  804aa8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804aab:	89 c6                	mov    %eax,%esi
  804aad:	48 bf bd 09 82 00 00 	movabs $0x8209bd,%rdi
  804ab4:	00 00 00 
  804ab7:	b8 00 00 00 00       	mov    $0x0,%eax
  804abc:	49 b8 19 11 80 00 00 	movabs $0x801119,%r8
  804ac3:	00 00 00 
  804ac6:	41 ff d0             	callq  *%r8
	}
  804ac9:	e9 4a ff ff ff       	jmpq   804a18 <_pipeisclosed+0x11>
}
  804ace:	48 83 c4 28          	add    $0x28,%rsp
  804ad2:	5b                   	pop    %rbx
  804ad3:	5d                   	pop    %rbp
  804ad4:	c3                   	retq   

0000000000804ad5 <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  804ad5:	55                   	push   %rbp
  804ad6:	48 89 e5             	mov    %rsp,%rbp
  804ad9:	48 83 ec 30          	sub    $0x30,%rsp
  804add:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  804ae0:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  804ae4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  804ae7:	48 89 d6             	mov    %rdx,%rsi
  804aea:	89 c7                	mov    %eax,%edi
  804aec:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  804af3:	00 00 00 
  804af6:	ff d0                	callq  *%rax
  804af8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804afb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804aff:	79 05                	jns    804b06 <pipeisclosed+0x31>
		return r;
  804b01:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804b04:	eb 31                	jmp    804b37 <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  804b06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804b0a:	48 89 c7             	mov    %rax,%rdi
  804b0d:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  804b14:	00 00 00 
  804b17:	ff d0                	callq  *%rax
  804b19:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  804b1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804b21:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  804b25:	48 89 d6             	mov    %rdx,%rsi
  804b28:	48 89 c7             	mov    %rax,%rdi
  804b2b:	48 b8 07 4a 80 00 00 	movabs $0x804a07,%rax
  804b32:	00 00 00 
  804b35:	ff d0                	callq  *%rax
}
  804b37:	c9                   	leaveq 
  804b38:	c3                   	retq   

0000000000804b39 <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  804b39:	55                   	push   %rbp
  804b3a:	48 89 e5             	mov    %rsp,%rbp
  804b3d:	48 83 ec 40          	sub    $0x40,%rsp
  804b41:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  804b45:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  804b49:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  804b4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804b51:	48 89 c7             	mov    %rax,%rdi
  804b54:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  804b5b:	00 00 00 
  804b5e:	ff d0                	callq  *%rax
  804b60:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  804b64:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804b68:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  804b6c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  804b73:	00 
  804b74:	e9 92 00 00 00       	jmpq   804c0b <devpipe_read+0xd2>
		while (p->p_rpos == p->p_wpos) {
  804b79:	eb 41                	jmp    804bbc <devpipe_read+0x83>
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  804b7b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  804b80:	74 09                	je     804b8b <devpipe_read+0x52>
				return i;
  804b82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804b86:	e9 92 00 00 00       	jmpq   804c1d <devpipe_read+0xe4>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  804b8b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  804b8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804b93:	48 89 d6             	mov    %rdx,%rsi
  804b96:	48 89 c7             	mov    %rax,%rdi
  804b99:	48 b8 07 4a 80 00 00 	movabs $0x804a07,%rax
  804ba0:	00 00 00 
  804ba3:	ff d0                	callq  *%rax
  804ba5:	85 c0                	test   %eax,%eax
  804ba7:	74 07                	je     804bb0 <devpipe_read+0x77>
				return 0;
  804ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  804bae:	eb 6d                	jmp    804c1d <devpipe_read+0xe4>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  804bb0:	48 b8 a4 25 80 00 00 	movabs $0x8025a4,%rax
  804bb7:	00 00 00 
  804bba:	ff d0                	callq  *%rax
		while (p->p_rpos == p->p_wpos) {
  804bbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804bc0:	8b 10                	mov    (%rax),%edx
  804bc2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804bc6:	8b 40 04             	mov    0x4(%rax),%eax
  804bc9:	39 c2                	cmp    %eax,%edx
  804bcb:	74 ae                	je     804b7b <devpipe_read+0x42>
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  804bcd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804bd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804bd5:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  804bd9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804bdd:	8b 00                	mov    (%rax),%eax
  804bdf:	99                   	cltd   
  804be0:	c1 ea 1b             	shr    $0x1b,%edx
  804be3:	01 d0                	add    %edx,%eax
  804be5:	83 e0 1f             	and    $0x1f,%eax
  804be8:	29 d0                	sub    %edx,%eax
  804bea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  804bee:	48 98                	cltq   
  804bf0:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  804bf5:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  804bf7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804bfb:	8b 00                	mov    (%rax),%eax
  804bfd:	8d 50 01             	lea    0x1(%rax),%edx
  804c00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804c04:	89 10                	mov    %edx,(%rax)
	for (i = 0; i < n; i++) {
  804c06:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  804c0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804c0f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  804c13:	0f 82 60 ff ff ff    	jb     804b79 <devpipe_read+0x40>
	}
	return i;
  804c19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  804c1d:	c9                   	leaveq 
  804c1e:	c3                   	retq   

0000000000804c1f <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  804c1f:	55                   	push   %rbp
  804c20:	48 89 e5             	mov    %rsp,%rbp
  804c23:	48 83 ec 40          	sub    $0x40,%rsp
  804c27:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  804c2b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  804c2f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  804c33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804c37:	48 89 c7             	mov    %rax,%rdi
  804c3a:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  804c41:	00 00 00 
  804c44:	ff d0                	callq  *%rax
  804c46:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  804c4a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804c4e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  804c52:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  804c59:	00 
  804c5a:	e9 91 00 00 00       	jmpq   804cf0 <devpipe_write+0xd1>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  804c5f:	eb 31                	jmp    804c92 <devpipe_write+0x73>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  804c61:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  804c65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804c69:	48 89 d6             	mov    %rdx,%rsi
  804c6c:	48 89 c7             	mov    %rax,%rdi
  804c6f:	48 b8 07 4a 80 00 00 	movabs $0x804a07,%rax
  804c76:	00 00 00 
  804c79:	ff d0                	callq  *%rax
  804c7b:	85 c0                	test   %eax,%eax
  804c7d:	74 07                	je     804c86 <devpipe_write+0x67>
				return 0;
  804c7f:	b8 00 00 00 00       	mov    $0x0,%eax
  804c84:	eb 7c                	jmp    804d02 <devpipe_write+0xe3>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  804c86:	48 b8 a4 25 80 00 00 	movabs $0x8025a4,%rax
  804c8d:	00 00 00 
  804c90:	ff d0                	callq  *%rax
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  804c92:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804c96:	8b 40 04             	mov    0x4(%rax),%eax
  804c99:	48 63 d0             	movslq %eax,%rdx
  804c9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804ca0:	8b 00                	mov    (%rax),%eax
  804ca2:	48 98                	cltq   
  804ca4:	48 83 c0 20          	add    $0x20,%rax
  804ca8:	48 39 c2             	cmp    %rax,%rdx
  804cab:	73 b4                	jae    804c61 <devpipe_write+0x42>
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  804cad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804cb1:	8b 40 04             	mov    0x4(%rax),%eax
  804cb4:	99                   	cltd   
  804cb5:	c1 ea 1b             	shr    $0x1b,%edx
  804cb8:	01 d0                	add    %edx,%eax
  804cba:	83 e0 1f             	and    $0x1f,%eax
  804cbd:	29 d0                	sub    %edx,%eax
  804cbf:	89 c6                	mov    %eax,%esi
  804cc1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804cc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804cc9:	48 01 d0             	add    %rdx,%rax
  804ccc:	0f b6 08             	movzbl (%rax),%ecx
  804ccf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  804cd3:	48 63 c6             	movslq %esi,%rax
  804cd6:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  804cda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804cde:	8b 40 04             	mov    0x4(%rax),%eax
  804ce1:	8d 50 01             	lea    0x1(%rax),%edx
  804ce4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804ce8:	89 50 04             	mov    %edx,0x4(%rax)
	for (i = 0; i < n; i++) {
  804ceb:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  804cf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804cf4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  804cf8:	0f 82 61 ff ff ff    	jb     804c5f <devpipe_write+0x40>
	}

	return i;
  804cfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  804d02:	c9                   	leaveq 
  804d03:	c3                   	retq   

0000000000804d04 <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  804d04:	55                   	push   %rbp
  804d05:	48 89 e5             	mov    %rsp,%rbp
  804d08:	48 83 ec 20          	sub    $0x20,%rsp
  804d0c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804d10:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  804d14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804d18:	48 89 c7             	mov    %rax,%rdi
  804d1b:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  804d22:	00 00 00 
  804d25:	ff d0                	callq  *%rax
  804d27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  804d2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d2f:	48 be d0 09 82 00 00 	movabs $0x8209d0,%rsi
  804d36:	00 00 00 
  804d39:	48 89 c7             	mov    %rax,%rdi
  804d3c:	48 b8 b3 1c 80 00 00 	movabs $0x801cb3,%rax
  804d43:	00 00 00 
  804d46:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  804d48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804d4c:	8b 50 04             	mov    0x4(%rax),%edx
  804d4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804d53:	8b 00                	mov    (%rax),%eax
  804d55:	29 c2                	sub    %eax,%edx
  804d57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d5b:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  804d61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d65:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  804d6c:	00 00 00 
	stat->st_dev = &devpipe;
  804d6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d73:	48 b9 00 71 82 00 00 	movabs $0x827100,%rcx
  804d7a:	00 00 00 
  804d7d:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
	return 0;
  804d84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804d89:	c9                   	leaveq 
  804d8a:	c3                   	retq   

0000000000804d8b <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  804d8b:	55                   	push   %rbp
  804d8c:	48 89 e5             	mov    %rsp,%rbp
  804d8f:	48 83 ec 10          	sub    $0x10,%rsp
  804d93:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	(void) sys_page_unmap(0, fd);
  804d97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804d9b:	48 89 c6             	mov    %rax,%rsi
  804d9e:	bf 00 00 00 00       	mov    $0x0,%edi
  804da3:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  804daa:	00 00 00 
  804dad:	ff d0                	callq  *%rax
	return sys_page_unmap(0, fd2data(fd));
  804daf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804db3:	48 89 c7             	mov    %rax,%rdi
  804db6:	48 b8 88 2c 80 00 00 	movabs $0x802c88,%rax
  804dbd:	00 00 00 
  804dc0:	ff d0                	callq  *%rax
  804dc2:	48 89 c6             	mov    %rax,%rsi
  804dc5:	bf 00 00 00 00       	mov    $0x0,%edi
  804dca:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  804dd1:	00 00 00 
  804dd4:	ff d0                	callq  *%rax
}
  804dd6:	c9                   	leaveq 
  804dd7:	c3                   	retq   

0000000000804dd8 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  804dd8:	55                   	push   %rbp
  804dd9:	48 89 e5             	mov    %rsp,%rbp
  804ddc:	48 83 ec 20          	sub    $0x20,%rsp
  804de0:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  804de3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804de6:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  804de9:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  804ded:	be 01 00 00 00       	mov    $0x1,%esi
  804df2:	48 89 c7             	mov    %rax,%rdi
  804df5:	48 b8 9a 24 80 00 00 	movabs $0x80249a,%rax
  804dfc:	00 00 00 
  804dff:	ff d0                	callq  *%rax
}
  804e01:	c9                   	leaveq 
  804e02:	c3                   	retq   

0000000000804e03 <getchar>:

int
getchar(void)
{
  804e03:	55                   	push   %rbp
  804e04:	48 89 e5             	mov    %rsp,%rbp
  804e07:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  804e0b:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  804e0f:	ba 01 00 00 00       	mov    $0x1,%edx
  804e14:	48 89 c6             	mov    %rax,%rsi
  804e17:	bf 00 00 00 00       	mov    $0x0,%edi
  804e1c:	48 b8 7f 31 80 00 00 	movabs $0x80317f,%rax
  804e23:	00 00 00 
  804e26:	ff d0                	callq  *%rax
  804e28:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  804e2b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804e2f:	79 05                	jns    804e36 <getchar+0x33>
		return r;
  804e31:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804e34:	eb 14                	jmp    804e4a <getchar+0x47>
	if (r < 1)
  804e36:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804e3a:	7f 07                	jg     804e43 <getchar+0x40>
		return -E_EOF;
  804e3c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804e41:	eb 07                	jmp    804e4a <getchar+0x47>
	return c;
  804e43:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  804e47:	0f b6 c0             	movzbl %al,%eax
}
  804e4a:	c9                   	leaveq 
  804e4b:	c3                   	retq   

0000000000804e4c <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  804e4c:	55                   	push   %rbp
  804e4d:	48 89 e5             	mov    %rsp,%rbp
  804e50:	48 83 ec 20          	sub    $0x20,%rsp
  804e54:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  804e57:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  804e5b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804e5e:	48 89 d6             	mov    %rdx,%rsi
  804e61:	89 c7                	mov    %eax,%edi
  804e63:	48 b8 4b 2d 80 00 00 	movabs $0x802d4b,%rax
  804e6a:	00 00 00 
  804e6d:	ff d0                	callq  *%rax
  804e6f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804e72:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804e76:	79 05                	jns    804e7d <iscons+0x31>
		return r;
  804e78:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804e7b:	eb 1a                	jmp    804e97 <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  804e7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804e81:	8b 10                	mov    (%rax),%edx
  804e83:	48 b8 40 71 82 00 00 	movabs $0x827140,%rax
  804e8a:	00 00 00 
  804e8d:	8b 00                	mov    (%rax),%eax
  804e8f:	39 c2                	cmp    %eax,%edx
  804e91:	0f 94 c0             	sete   %al
  804e94:	0f b6 c0             	movzbl %al,%eax
}
  804e97:	c9                   	leaveq 
  804e98:	c3                   	retq   

0000000000804e99 <opencons>:

int
opencons(void)
{
  804e99:	55                   	push   %rbp
  804e9a:	48 89 e5             	mov    %rsp,%rbp
  804e9d:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  804ea1:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  804ea5:	48 89 c7             	mov    %rax,%rdi
  804ea8:	48 b8 b3 2c 80 00 00 	movabs $0x802cb3,%rax
  804eaf:	00 00 00 
  804eb2:	ff d0                	callq  *%rax
  804eb4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804eb7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804ebb:	79 05                	jns    804ec2 <opencons+0x29>
		return r;
  804ebd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804ec0:	eb 5b                	jmp    804f1d <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  804ec2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804ec6:	ba 07 04 00 00       	mov    $0x407,%edx
  804ecb:	48 89 c6             	mov    %rax,%rsi
  804ece:	bf 00 00 00 00       	mov    $0x0,%edi
  804ed3:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  804eda:	00 00 00 
  804edd:	ff d0                	callq  *%rax
  804edf:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804ee2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804ee6:	79 05                	jns    804eed <opencons+0x54>
		return r;
  804ee8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804eeb:	eb 30                	jmp    804f1d <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  804eed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804ef1:	48 ba 40 71 82 00 00 	movabs $0x827140,%rdx
  804ef8:	00 00 00 
  804efb:	8b 12                	mov    (%rdx),%edx
  804efd:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  804eff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804f03:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  804f0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804f0e:	48 89 c7             	mov    %rax,%rdi
  804f11:	48 b8 65 2c 80 00 00 	movabs $0x802c65,%rax
  804f18:	00 00 00 
  804f1b:	ff d0                	callq  *%rax
}
  804f1d:	c9                   	leaveq 
  804f1e:	c3                   	retq   

0000000000804f1f <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  804f1f:	55                   	push   %rbp
  804f20:	48 89 e5             	mov    %rsp,%rbp
  804f23:	48 83 ec 30          	sub    $0x30,%rsp
  804f27:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804f2b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804f2f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  804f33:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  804f38:	75 07                	jne    804f41 <devcons_read+0x22>
		return 0;
  804f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  804f3f:	eb 4b                	jmp    804f8c <devcons_read+0x6d>

	while ((c = sys_cgetc()) == 0)
  804f41:	eb 0c                	jmp    804f4f <devcons_read+0x30>
		sys_yield();
  804f43:	48 b8 a4 25 80 00 00 	movabs $0x8025a4,%rax
  804f4a:	00 00 00 
  804f4d:	ff d0                	callq  *%rax
	while ((c = sys_cgetc()) == 0)
  804f4f:	48 b8 e6 24 80 00 00 	movabs $0x8024e6,%rax
  804f56:	00 00 00 
  804f59:	ff d0                	callq  *%rax
  804f5b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804f5e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804f62:	74 df                	je     804f43 <devcons_read+0x24>
	if (c < 0)
  804f64:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804f68:	79 05                	jns    804f6f <devcons_read+0x50>
		return c;
  804f6a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804f6d:	eb 1d                	jmp    804f8c <devcons_read+0x6d>
	if (c == 0x04)	// ctl-d is eof
  804f6f:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  804f73:	75 07                	jne    804f7c <devcons_read+0x5d>
		return 0;
  804f75:	b8 00 00 00 00       	mov    $0x0,%eax
  804f7a:	eb 10                	jmp    804f8c <devcons_read+0x6d>
	*(char*)vbuf = c;
  804f7c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804f7f:	89 c2                	mov    %eax,%edx
  804f81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804f85:	88 10                	mov    %dl,(%rax)
	return 1;
  804f87:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804f8c:	c9                   	leaveq 
  804f8d:	c3                   	retq   

0000000000804f8e <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  804f8e:	55                   	push   %rbp
  804f8f:	48 89 e5             	mov    %rsp,%rbp
  804f92:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  804f99:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  804fa0:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  804fa7:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  804fae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804fb5:	eb 76                	jmp    80502d <devcons_write+0x9f>
		m = n - tot;
  804fb7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  804fbe:	89 c2                	mov    %eax,%edx
  804fc0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804fc3:	29 c2                	sub    %eax,%edx
  804fc5:	89 d0                	mov    %edx,%eax
  804fc7:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  804fca:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804fcd:	83 f8 7f             	cmp    $0x7f,%eax
  804fd0:	76 07                	jbe    804fd9 <devcons_write+0x4b>
			m = sizeof(buf) - 1;
  804fd2:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  804fd9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804fdc:	48 63 d0             	movslq %eax,%rdx
  804fdf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804fe2:	48 63 c8             	movslq %eax,%rcx
  804fe5:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  804fec:	48 01 c1             	add    %rax,%rcx
  804fef:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  804ff6:	48 89 ce             	mov    %rcx,%rsi
  804ff9:	48 89 c7             	mov    %rax,%rdi
  804ffc:	48 b8 d7 1f 80 00 00 	movabs $0x801fd7,%rax
  805003:	00 00 00 
  805006:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  805008:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80500b:	48 63 d0             	movslq %eax,%rdx
  80500e:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805015:	48 89 d6             	mov    %rdx,%rsi
  805018:	48 89 c7             	mov    %rax,%rdi
  80501b:	48 b8 9a 24 80 00 00 	movabs $0x80249a,%rax
  805022:	00 00 00 
  805025:	ff d0                	callq  *%rax
	for (tot = 0; tot < n; tot += m) {
  805027:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80502a:	01 45 fc             	add    %eax,-0x4(%rbp)
  80502d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805030:	48 98                	cltq   
  805032:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  805039:	0f 82 78 ff ff ff    	jb     804fb7 <devcons_write+0x29>
	}
	return tot;
  80503f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  805042:	c9                   	leaveq 
  805043:	c3                   	retq   

0000000000805044 <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  805044:	55                   	push   %rbp
  805045:	48 89 e5             	mov    %rsp,%rbp
  805048:	48 83 ec 08          	sub    $0x8,%rsp
  80504c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  805050:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805055:	c9                   	leaveq 
  805056:	c3                   	retq   

0000000000805057 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  805057:	55                   	push   %rbp
  805058:	48 89 e5             	mov    %rsp,%rbp
  80505b:	48 83 ec 10          	sub    $0x10,%rsp
  80505f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  805063:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  805067:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80506b:	48 be dc 09 82 00 00 	movabs $0x8209dc,%rsi
  805072:	00 00 00 
  805075:	48 89 c7             	mov    %rax,%rdi
  805078:	48 b8 b3 1c 80 00 00 	movabs $0x801cb3,%rax
  80507f:	00 00 00 
  805082:	ff d0                	callq  *%rax
	return 0;
  805084:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805089:	c9                   	leaveq 
  80508a:	c3                   	retq   

000000000080508b <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  80508b:	55                   	push   %rbp
  80508c:	48 89 e5             	mov    %rsp,%rbp
  80508f:	48 83 ec 18          	sub    $0x18,%rsp
  805093:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  805097:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80509b:	48 c1 e8 15          	shr    $0x15,%rax
  80509f:	48 89 c2             	mov    %rax,%rdx
  8050a2:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8050a9:	01 00 00 
  8050ac:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8050b0:	83 e0 01             	and    $0x1,%eax
  8050b3:	48 85 c0             	test   %rax,%rax
  8050b6:	75 07                	jne    8050bf <pageref+0x34>
		return 0;
  8050b8:	b8 00 00 00 00       	mov    $0x0,%eax
  8050bd:	eb 53                	jmp    805112 <pageref+0x87>
	pte = uvpt[PGNUM(v)];
  8050bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8050c3:	48 c1 e8 0c          	shr    $0xc,%rax
  8050c7:	48 89 c2             	mov    %rax,%rdx
  8050ca:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8050d1:	01 00 00 
  8050d4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8050d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  8050dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8050e0:	83 e0 01             	and    $0x1,%eax
  8050e3:	48 85 c0             	test   %rax,%rax
  8050e6:	75 07                	jne    8050ef <pageref+0x64>
		return 0;
  8050e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8050ed:	eb 23                	jmp    805112 <pageref+0x87>
	return pages[PPN(pte)].pp_ref;
  8050ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8050f3:	48 c1 e8 0c          	shr    $0xc,%rax
  8050f7:	48 89 c2             	mov    %rax,%rdx
  8050fa:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  805101:	00 00 00 
  805104:	48 c1 e2 04          	shl    $0x4,%rdx
  805108:	48 01 d0             	add    %rdx,%rax
  80510b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80510f:	0f b7 c0             	movzwl %ax,%eax
}
  805112:	c9                   	leaveq 
  805113:	c3                   	retq   

0000000000805114 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805114:	55                   	push   %rbp
  805115:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805118:	bf 01 00 00 00       	mov    $0x1,%edi
  80511d:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  805124:	00 00 00 
  805127:	ff d0                	callq  *%rax
  805129:	89 c2                	mov    %eax,%edx
  80512b:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  805132:	00 00 00 
  805135:	89 10                	mov    %edx,(%rax)
  selectsem = sys_sem_new(1);
  805137:	bf 01 00 00 00       	mov    $0x1,%edi
  80513c:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  805143:	00 00 00 
  805146:	ff d0                	callq  *%rax
  805148:	89 c2                	mov    %eax,%edx
  80514a:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  805151:	00 00 00 
  805154:	89 10                	mov    %edx,(%rax)
}
  805156:	5d                   	pop    %rbp
  805157:	c3                   	retq   

0000000000805158 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805158:	55                   	push   %rbp
  805159:	48 89 e5             	mov    %rsp,%rbp
  80515c:	48 83 ec 18          	sub    $0x18,%rsp
  805160:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  805163:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805167:	78 06                	js     80516f <get_socket+0x17>
  805169:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  80516d:	7e 17                	jle    805186 <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  80516f:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805176:	00 00 00 
  805179:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  80517f:	b8 00 00 00 00       	mov    $0x0,%eax
  805184:	eb 44                	jmp    8051ca <get_socket+0x72>
  }

  sock = &sockets[s];
  805186:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805189:	48 98                	cltq   
  80518b:	48 c1 e0 05          	shl    $0x5,%rax
  80518f:	48 89 c2             	mov    %rax,%rdx
  805192:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  805199:	00 00 00 
  80519c:	48 01 d0             	add    %rdx,%rax
  80519f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  8051a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8051a7:	48 8b 00             	mov    (%rax),%rax
  8051aa:	48 85 c0             	test   %rax,%rax
  8051ad:	75 17                	jne    8051c6 <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  8051af:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8051b6:	00 00 00 
  8051b9:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  8051bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8051c4:	eb 04                	jmp    8051ca <get_socket+0x72>
  }

  return sock;
  8051c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8051ca:	c9                   	leaveq 
  8051cb:	c3                   	retq   

00000000008051cc <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  8051cc:	55                   	push   %rbp
  8051cd:	48 89 e5             	mov    %rsp,%rbp
  8051d0:	48 83 ec 20          	sub    $0x20,%rsp
  8051d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  8051d8:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  8051df:	00 00 00 
  8051e2:	8b 00                	mov    (%rax),%eax
  8051e4:	89 c7                	mov    %eax,%edi
  8051e6:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  8051ed:	00 00 00 
  8051f0:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  8051f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8051f9:	e9 28 01 00 00       	jmpq   805326 <alloc_socket+0x15a>
    if (!sockets[i].conn) {
  8051fe:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  805205:	00 00 00 
  805208:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80520b:	48 63 d2             	movslq %edx,%rdx
  80520e:	48 c1 e2 05          	shl    $0x5,%rdx
  805212:	48 01 d0             	add    %rdx,%rax
  805215:	48 8b 00             	mov    (%rax),%rax
  805218:	48 85 c0             	test   %rax,%rax
  80521b:	0f 85 01 01 00 00    	jne    805322 <alloc_socket+0x156>
      sockets[i].conn       = newconn;
  805221:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  805228:	00 00 00 
  80522b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80522e:	48 63 d2             	movslq %edx,%rdx
  805231:	48 c1 e2 05          	shl    $0x5,%rdx
  805235:	48 01 c2             	add    %rax,%rdx
  805238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80523c:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  80523f:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  805246:	00 00 00 
  805249:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80524c:	48 63 d2             	movslq %edx,%rdx
  80524f:	48 c1 e2 05          	shl    $0x5,%rdx
  805253:	48 01 d0             	add    %rdx,%rax
  805256:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80525d:	00 
      sockets[i].lastoffset = 0;
  80525e:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  805265:	00 00 00 
  805268:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80526b:	48 63 d2             	movslq %edx,%rdx
  80526e:	48 c1 e2 05          	shl    $0x5,%rdx
  805272:	48 01 d0             	add    %rdx,%rax
  805275:	48 83 c0 10          	add    $0x10,%rax
  805279:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  80527e:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  805285:	00 00 00 
  805288:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80528b:	48 63 d2             	movslq %edx,%rdx
  80528e:	48 c1 e2 05          	shl    $0x5,%rdx
  805292:	48 01 d0             	add    %rdx,%rax
  805295:	48 83 c0 10          	add    $0x10,%rax
  805299:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  80529f:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  8052a6:	00 00 00 
  8052a9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8052ac:	48 63 d2             	movslq %edx,%rdx
  8052af:	48 c1 e2 05          	shl    $0x5,%rdx
  8052b3:	48 01 d0             	add    %rdx,%rax
  8052b6:	48 83 c0 10          	add    $0x10,%rax
  8052ba:	66 c7 40 04 01 00    	movw   $0x1,0x4(%rax)
      sockets[i].flags      = 0;
  8052c0:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  8052c7:	00 00 00 
  8052ca:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8052cd:	48 63 d2             	movslq %edx,%rdx
  8052d0:	48 c1 e2 05          	shl    $0x5,%rdx
  8052d4:	48 01 d0             	add    %rdx,%rax
  8052d7:	48 83 c0 10          	add    $0x10,%rax
  8052db:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
      sockets[i].err        = 0;
  8052e1:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  8052e8:	00 00 00 
  8052eb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8052ee:	48 63 d2             	movslq %edx,%rdx
  8052f1:	48 c1 e2 05          	shl    $0x5,%rdx
  8052f5:	48 01 d0             	add    %rdx,%rax
  8052f8:	48 83 c0 10          	add    $0x10,%rax
  8052fc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      sys_sem_signal(socksem);
  805303:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  80530a:	00 00 00 
  80530d:	8b 00                	mov    (%rax),%eax
  80530f:	89 c7                	mov    %eax,%edi
  805311:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  805318:	00 00 00 
  80531b:	ff d0                	callq  *%rax
      return i;
  80531d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805320:	eb 2d                	jmp    80534f <alloc_socket+0x183>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805322:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805326:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80532a:	0f 8e ce fe ff ff    	jle    8051fe <alloc_socket+0x32>
    }
  }
  sys_sem_signal(socksem);
  805330:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  805337:	00 00 00 
  80533a:	8b 00                	mov    (%rax),%eax
  80533c:	89 c7                	mov    %eax,%edi
  80533e:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  805345:	00 00 00 
  805348:	ff d0                	callq  *%rax
  return -1;
  80534a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80534f:	c9                   	leaveq 
  805350:	c3                   	retq   

0000000000805351 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805351:	55                   	push   %rbp
  805352:	48 89 e5             	mov    %rsp,%rbp
  805355:	48 83 ec 70          	sub    $0x70,%rsp
  805359:	89 7d ac             	mov    %edi,-0x54(%rbp)
  80535c:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  805360:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805364:	8b 45 ac             	mov    -0x54(%rbp),%eax
  805367:	89 c7                	mov    %eax,%edi
  805369:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  805370:	00 00 00 
  805373:	ff d0                	callq  *%rax
  805375:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805379:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80537e:	75 0a                	jne    80538a <lwip_accept+0x39>
    return -1;
  805380:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805385:	e9 f2 02 00 00       	jmpq   80567c <lwip_accept+0x32b>

  newconn = netconn_accept(sock->conn);
  80538a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80538e:	48 8b 00             	mov    (%rax),%rax
  805391:	48 89 c7             	mov    %rax,%rdi
  805394:	48 b8 f5 93 81 00 00 	movabs $0x8193f5,%rax
  80539b:	00 00 00 
  80539e:	ff d0                	callq  *%rax
  8053a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!newconn) {
  8053a4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8053a9:	75 62                	jne    80540d <lwip_accept+0xbc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  8053ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8053af:	48 8b 00             	mov    (%rax),%rax
  8053b2:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8053b6:	0f be c0             	movsbl %al,%eax
  8053b9:	f7 d8                	neg    %eax
  8053bb:	83 f8 0e             	cmp    $0xe,%eax
  8053be:	77 24                	ja     8053e4 <lwip_accept+0x93>
  8053c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8053c4:	48 8b 00             	mov    (%rax),%rax
  8053c7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8053cb:	0f be c0             	movsbl %al,%eax
  8053ce:	f7 d8                	neg    %eax
  8053d0:	89 c2                	mov    %eax,%edx
  8053d2:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  8053d9:	00 00 00 
  8053dc:	48 63 d2             	movslq %edx,%rdx
  8053df:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8053e2:	eb 05                	jmp    8053e9 <lwip_accept+0x98>
  8053e4:	b8 05 00 00 00       	mov    $0x5,%eax
  8053e9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8053ed:	89 42 18             	mov    %eax,0x18(%rdx)
  8053f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8053f4:	8b 50 18             	mov    0x18(%rax),%edx
  8053f7:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8053fe:	00 00 00 
  805401:	89 10                	mov    %edx,(%rax)
    return -1;
  805403:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805408:	e9 6f 02 00 00       	jmpq   80567c <lwip_accept+0x32b>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  80540d:	48 8d 55 ce          	lea    -0x32(%rbp),%rdx
  805411:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  805415:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805419:	b9 00 00 00 00       	mov    $0x0,%ecx
  80541e:	48 89 c7             	mov    %rax,%rdi
  805421:	48 b8 06 91 81 00 00 	movabs $0x819106,%rax
  805428:	00 00 00 
  80542b:	ff d0                	callq  *%rax
  80542d:	88 45 ef             	mov    %al,-0x11(%rbp)
  if (err != ERR_OK) {
  805430:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  805434:	74 61                	je     805497 <lwip_accept+0x146>
    netconn_delete(newconn);
  805436:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80543a:	48 89 c7             	mov    %rax,%rdi
  80543d:	48 b8 58 90 81 00 00 	movabs $0x819058,%rax
  805444:	00 00 00 
  805447:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  805449:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  80544d:	f7 d8                	neg    %eax
  80544f:	83 f8 0e             	cmp    $0xe,%eax
  805452:	77 1a                	ja     80546e <lwip_accept+0x11d>
  805454:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805458:	f7 d8                	neg    %eax
  80545a:	89 c2                	mov    %eax,%edx
  80545c:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  805463:	00 00 00 
  805466:	48 63 d2             	movslq %edx,%rdx
  805469:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80546c:	eb 05                	jmp    805473 <lwip_accept+0x122>
  80546e:	b8 05 00 00 00       	mov    $0x5,%eax
  805473:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805477:	89 42 18             	mov    %eax,0x18(%rdx)
  80547a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80547e:	8b 50 18             	mov    0x18(%rax),%edx
  805481:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805488:	00 00 00 
  80548b:	89 10                	mov    %edx,(%rax)
    return -1;
  80548d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805492:	e9 e5 01 00 00       	jmpq   80567c <lwip_accept+0x32b>
  }

  memset(&sin, 0, sizeof(sin));
  805497:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  80549b:	ba 10 00 00 00       	mov    $0x10,%edx
  8054a0:	be 00 00 00 00       	mov    $0x0,%esi
  8054a5:	48 89 c7             	mov    %rax,%rdi
  8054a8:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8054af:	00 00 00 
  8054b2:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  8054b4:	c6 45 b0 10          	movb   $0x10,-0x50(%rbp)
  sin.sin_family = AF_INET;
  8054b8:	c6 45 b1 02          	movb   $0x2,-0x4f(%rbp)
  sin.sin_port = htons(port);
  8054bc:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
  8054c0:	0f b7 c0             	movzwl %ax,%eax
  8054c3:	89 c7                	mov    %eax,%edi
  8054c5:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8054cc:	00 00 00 
  8054cf:	ff d0                	callq  *%rax
  8054d1:	66 89 45 b2          	mov    %ax,-0x4e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  8054d5:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8054d8:	89 45 b4             	mov    %eax,-0x4c(%rbp)

  if (*addrlen > sizeof(sin))
  8054db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8054df:	8b 00                	mov    (%rax),%eax
  8054e1:	83 f8 10             	cmp    $0x10,%eax
  8054e4:	76 0a                	jbe    8054f0 <lwip_accept+0x19f>
    *addrlen = sizeof(sin);
  8054e6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8054ea:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  8054f0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8054f4:	8b 00                	mov    (%rax),%eax
  8054f6:	89 c2                	mov    %eax,%edx
  8054f8:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  8054fc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  805500:	48 89 ce             	mov    %rcx,%rsi
  805503:	48 89 c7             	mov    %rax,%rdi
  805506:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  80550d:	00 00 00 
  805510:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  805512:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805516:	48 89 c7             	mov    %rax,%rdi
  805519:	48 b8 cc 51 80 00 00 	movabs $0x8051cc,%rax
  805520:	00 00 00 
  805523:	ff d0                	callq  *%rax
  805525:	89 45 e8             	mov    %eax,-0x18(%rbp)
  if (newsock == -1) {
  805528:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%rbp)
  80552c:	75 3b                	jne    805569 <lwip_accept+0x218>
    netconn_delete(newconn);
  80552e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805532:	48 89 c7             	mov    %rax,%rdi
  805535:	48 b8 58 90 81 00 00 	movabs $0x819058,%rax
  80553c:	00 00 00 
  80553f:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  805541:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805545:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  80554c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805550:	8b 50 18             	mov    0x18(%rax),%edx
  805553:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80555a:	00 00 00 
  80555d:	89 10                	mov    %edx,(%rax)
    return -1;
  80555f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805564:	e9 13 01 00 00       	jmpq   80567c <lwip_accept+0x32b>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  805569:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80556d:	78 06                	js     805575 <lwip_accept+0x224>
  80556f:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  805573:	7e 2a                	jle    80559f <lwip_accept+0x24e>
  805575:	48 ba 3c 0a 82 00 00 	movabs $0x820a3c,%rdx
  80557c:	00 00 00 
  80557f:	be 25 01 00 00       	mov    $0x125,%esi
  805584:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  80558b:	00 00 00 
  80558e:	b8 00 00 00 00       	mov    $0x0,%eax
  805593:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80559a:	00 00 00 
  80559d:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  80559f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8055a3:	48 b9 17 6b 80 00 00 	movabs $0x806b17,%rcx
  8055aa:	00 00 00 
  8055ad:	48 89 48 38          	mov    %rcx,0x38(%rax)
  nsock = &sockets[newsock];
  8055b1:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8055b4:	48 98                	cltq   
  8055b6:	48 c1 e0 05          	shl    $0x5,%rax
  8055ba:	48 89 c2             	mov    %rax,%rdx
  8055bd:	48 b8 c0 80 82 00 00 	movabs $0x8280c0,%rax
  8055c4:	00 00 00 
  8055c7:	48 01 d0             	add    %rdx,%rax
  8055ca:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  8055ce:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8055d3:	75 2a                	jne    8055ff <lwip_accept+0x2ae>
  8055d5:	48 ba 68 0a 82 00 00 	movabs $0x820a68,%rdx
  8055dc:	00 00 00 
  8055df:	be 28 01 00 00       	mov    $0x128,%esi
  8055e4:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  8055eb:	00 00 00 
  8055ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8055f3:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8055fa:	00 00 00 
  8055fd:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  8055ff:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  805606:	00 00 00 
  805609:	8b 00                	mov    (%rax),%eax
  80560b:	89 c7                	mov    %eax,%edi
  80560d:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  805614:	00 00 00 
  805617:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  805619:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80561d:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  805621:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805625:	8b 40 20             	mov    0x20(%rax),%eax
  805628:	29 c2                	sub    %eax,%edx
  80562a:	89 d0                	mov    %edx,%eax
  80562c:	8d 50 ff             	lea    -0x1(%rax),%edx
  80562f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805633:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  805637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80563b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80563e:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  805641:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  805648:	00 00 00 
  80564b:	8b 00                	mov    (%rax),%eax
  80564d:	89 c7                	mov    %eax,%edi
  80564f:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  805656:	00 00 00 
  805659:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  80565b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80565f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805666:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80566a:	8b 50 18             	mov    0x18(%rax),%edx
  80566d:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805674:	00 00 00 
  805677:	89 10                	mov    %edx,(%rax)
  return newsock;
  805679:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  80567c:	c9                   	leaveq 
  80567d:	c3                   	retq   

000000000080567e <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80567e:	55                   	push   %rbp
  80567f:	48 89 e5             	mov    %rsp,%rbp
  805682:	48 83 ec 20          	sub    $0x20,%rsp
  805686:	89 7d ec             	mov    %edi,-0x14(%rbp)
  805689:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80568d:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  805690:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805693:	89 c7                	mov    %eax,%edi
  805695:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  80569c:	00 00 00 
  80569f:	ff d0                	callq  *%rax
  8056a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8056a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8056aa:	75 0a                	jne    8056b6 <lwip_bind+0x38>
    return -1;
  8056ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8056b1:	e9 fb 00 00 00       	jmpq   8057b1 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8056b6:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  8056ba:	75 0c                	jne    8056c8 <lwip_bind+0x4a>
  8056bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8056c0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8056c4:	3c 02                	cmp    $0x2,%al
  8056c6:	74 2a                	je     8056f2 <lwip_bind+0x74>
  8056c8:	48 ba 7f 0a 82 00 00 	movabs $0x820a7f,%rdx
  8056cf:	00 00 00 
  8056d2:	be 4a 01 00 00       	mov    $0x14a,%esi
  8056d7:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  8056de:	00 00 00 
  8056e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8056e6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8056ed:	00 00 00 
  8056f0:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8056f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8056f6:	8b 40 04             	mov    0x4(%rax),%eax
  8056f9:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  8056fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805700:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  805704:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  805708:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80570c:	89 c7                	mov    %eax,%edi
  80570e:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  805715:	00 00 00 
  805718:	ff d0                	callq  *%rax
  80571a:	0f b7 d0             	movzwl %ax,%edx
  80571d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805721:	48 8b 00             	mov    (%rax),%rax
  805724:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  805728:	48 89 ce             	mov    %rcx,%rsi
  80572b:	48 89 c7             	mov    %rax,%rdi
  80572e:	48 b8 fc 91 81 00 00 	movabs $0x8191fc,%rax
  805735:	00 00 00 
  805738:	ff d0                	callq  *%rax
  80573a:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  80573d:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  805741:	74 4b                	je     80578e <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  805743:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  805747:	f7 d8                	neg    %eax
  805749:	83 f8 0e             	cmp    $0xe,%eax
  80574c:	77 1a                	ja     805768 <lwip_bind+0xea>
  80574e:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  805752:	f7 d8                	neg    %eax
  805754:	89 c2                	mov    %eax,%edx
  805756:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  80575d:	00 00 00 
  805760:	48 63 d2             	movslq %edx,%rdx
  805763:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805766:	eb 05                	jmp    80576d <lwip_bind+0xef>
  805768:	b8 05 00 00 00       	mov    $0x5,%eax
  80576d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805771:	89 42 18             	mov    %eax,0x18(%rdx)
  805774:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805778:	8b 50 18             	mov    0x18(%rax),%edx
  80577b:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805782:	00 00 00 
  805785:	89 10                	mov    %edx,(%rax)
    return -1;
  805787:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80578c:	eb 23                	jmp    8057b1 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80578e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805792:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805799:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80579d:	8b 50 18             	mov    0x18(%rax),%edx
  8057a0:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8057a7:	00 00 00 
  8057aa:	89 10                	mov    %edx,(%rax)
  return 0;
  8057ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8057b1:	c9                   	leaveq 
  8057b2:	c3                   	retq   

00000000008057b3 <lwip_close>:

int
lwip_close(int s)
{
  8057b3:	55                   	push   %rbp
  8057b4:	48 89 e5             	mov    %rsp,%rbp
  8057b7:	48 83 ec 20          	sub    $0x20,%rsp
  8057bb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8057be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8057c1:	89 c7                	mov    %eax,%edi
  8057c3:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  8057ca:	00 00 00 
  8057cd:	ff d0                	callq  *%rax
  8057cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  8057d3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8057d8:	75 0a                	jne    8057e4 <lwip_close+0x31>
    return -1;
  8057da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8057df:	e9 b2 00 00 00       	jmpq   805896 <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  8057e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057e8:	48 8b 00             	mov    (%rax),%rax
  8057eb:	48 89 c7             	mov    %rax,%rdi
  8057ee:	48 b8 58 90 81 00 00 	movabs $0x819058,%rax
  8057f5:	00 00 00 
  8057f8:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  8057fa:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  805801:	00 00 00 
  805804:	8b 00                	mov    (%rax),%eax
  805806:	89 c7                	mov    %eax,%edi
  805808:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  80580f:	00 00 00 
  805812:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  805814:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805818:	48 8b 40 08          	mov    0x8(%rax),%rax
  80581c:	48 85 c0             	test   %rax,%rax
  80581f:	74 17                	je     805838 <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  805821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805825:	48 8b 40 08          	mov    0x8(%rax),%rax
  805829:	48 89 c7             	mov    %rax,%rdi
  80582c:	48 b8 b5 82 80 00 00 	movabs $0x8082b5,%rax
  805833:	00 00 00 
  805836:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  805838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80583c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805843:	00 
  sock->lastoffset = 0;
  805844:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805848:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  80584e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805852:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  805859:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80585d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805864:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805868:	8b 50 18             	mov    0x18(%rax),%edx
  80586b:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805872:	00 00 00 
  805875:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  805877:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  80587e:	00 00 00 
  805881:	8b 00                	mov    (%rax),%eax
  805883:	89 c7                	mov    %eax,%edi
  805885:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80588c:	00 00 00 
  80588f:	ff d0                	callq  *%rax
  return 0;
  805891:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805896:	c9                   	leaveq 
  805897:	c3                   	retq   

0000000000805898 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  805898:	55                   	push   %rbp
  805899:	48 89 e5             	mov    %rsp,%rbp
  80589c:	48 83 ec 30          	sub    $0x30,%rsp
  8058a0:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8058a3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8058a7:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8058aa:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8058ad:	89 c7                	mov    %eax,%edi
  8058af:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  8058b6:	00 00 00 
  8058b9:	ff d0                	callq  *%rax
  8058bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  8058bf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8058c4:	75 0a                	jne    8058d0 <lwip_connect+0x38>
    return -1;
  8058c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8058cb:	e9 22 01 00 00       	jmpq   8059f2 <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8058d0:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  8058d4:	75 0c                	jne    8058e2 <lwip_connect+0x4a>
  8058d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8058da:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8058de:	3c 02                	cmp    $0x2,%al
  8058e0:	74 2a                	je     80590c <lwip_connect+0x74>
  8058e2:	48 ba 9a 0a 82 00 00 	movabs $0x820a9a,%rdx
  8058e9:	00 00 00 
  8058ec:	be 86 01 00 00       	mov    $0x186,%esi
  8058f1:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  8058f8:	00 00 00 
  8058fb:	b8 00 00 00 00       	mov    $0x0,%eax
  805900:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  805907:	00 00 00 
  80590a:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  80590c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805910:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  805914:	84 c0                	test   %al,%al
  805916:	75 1b                	jne    805933 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  805918:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80591c:	48 8b 00             	mov    (%rax),%rax
  80591f:	48 89 c7             	mov    %rax,%rdi
  805922:	48 b8 10 93 81 00 00 	movabs $0x819310,%rax
  805929:	00 00 00 
  80592c:	ff d0                	callq  *%rax
  80592e:	88 45 ff             	mov    %al,-0x1(%rbp)
  805931:	eb 4b                	jmp    80597e <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  805933:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805937:	8b 40 04             	mov    0x4(%rax),%eax
  80593a:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  80593d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805941:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  805945:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  805949:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80594d:	89 c7                	mov    %eax,%edi
  80594f:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  805956:	00 00 00 
  805959:	ff d0                	callq  *%rax
  80595b:	0f b7 d0             	movzwl %ax,%edx
  80595e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805962:	48 8b 00             	mov    (%rax),%rax
  805965:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  805969:	48 89 ce             	mov    %rcx,%rsi
  80596c:	48 89 c7             	mov    %rax,%rdi
  80596f:	48 b8 86 92 81 00 00 	movabs $0x819286,%rax
  805976:	00 00 00 
  805979:	ff d0                	callq  *%rax
  80597b:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  80597e:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  805982:	74 4b                	je     8059cf <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  805984:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  805988:	f7 d8                	neg    %eax
  80598a:	83 f8 0e             	cmp    $0xe,%eax
  80598d:	77 1a                	ja     8059a9 <lwip_connect+0x111>
  80598f:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  805993:	f7 d8                	neg    %eax
  805995:	89 c2                	mov    %eax,%edx
  805997:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  80599e:	00 00 00 
  8059a1:	48 63 d2             	movslq %edx,%rdx
  8059a4:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8059a7:	eb 05                	jmp    8059ae <lwip_connect+0x116>
  8059a9:	b8 05 00 00 00       	mov    $0x5,%eax
  8059ae:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8059b2:	89 42 18             	mov    %eax,0x18(%rdx)
  8059b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059b9:	8b 50 18             	mov    0x18(%rax),%edx
  8059bc:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8059c3:	00 00 00 
  8059c6:	89 10                	mov    %edx,(%rax)
    return -1;
  8059c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8059cd:	eb 23                	jmp    8059f2 <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8059cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059d3:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8059da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059de:	8b 50 18             	mov    0x18(%rax),%edx
  8059e1:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8059e8:	00 00 00 
  8059eb:	89 10                	mov    %edx,(%rax)
  return 0;
  8059ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8059f2:	c9                   	leaveq 
  8059f3:	c3                   	retq   

00000000008059f4 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8059f4:	55                   	push   %rbp
  8059f5:	48 89 e5             	mov    %rsp,%rbp
  8059f8:	48 83 ec 20          	sub    $0x20,%rsp
  8059fc:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8059ff:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  805a02:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805a05:	89 c7                	mov    %eax,%edi
  805a07:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  805a0e:	00 00 00 
  805a11:	ff d0                	callq  *%rax
  805a13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805a17:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805a1c:	75 0a                	jne    805a28 <lwip_listen+0x34>
    return -1;
  805a1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805a23:	e9 b2 00 00 00       	jmpq   805ada <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  805a28:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  805a2c:	79 07                	jns    805a35 <lwip_listen+0x41>
    backlog = 0;
  805a2e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  805a35:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  805a3c:	7e 07                	jle    805a45 <lwip_listen+0x51>
    backlog = 0xff;
  805a3e:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  805a45:	8b 45 e8             	mov    -0x18(%rbp),%eax
  805a48:	0f b6 d0             	movzbl %al,%edx
  805a4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805a4f:	48 8b 00             	mov    (%rax),%rax
  805a52:	89 d6                	mov    %edx,%esi
  805a54:	48 89 c7             	mov    %rax,%rdi
  805a57:	48 b8 80 93 81 00 00 	movabs $0x819380,%rax
  805a5e:	00 00 00 
  805a61:	ff d0                	callq  *%rax
  805a63:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  805a66:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  805a6a:	74 4b                	je     805ab7 <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  805a6c:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  805a70:	f7 d8                	neg    %eax
  805a72:	83 f8 0e             	cmp    $0xe,%eax
  805a75:	77 1a                	ja     805a91 <lwip_listen+0x9d>
  805a77:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  805a7b:	f7 d8                	neg    %eax
  805a7d:	89 c2                	mov    %eax,%edx
  805a7f:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  805a86:	00 00 00 
  805a89:	48 63 d2             	movslq %edx,%rdx
  805a8c:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805a8f:	eb 05                	jmp    805a96 <lwip_listen+0xa2>
  805a91:	b8 05 00 00 00       	mov    $0x5,%eax
  805a96:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805a9a:	89 42 18             	mov    %eax,0x18(%rdx)
  805a9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805aa1:	8b 50 18             	mov    0x18(%rax),%edx
  805aa4:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805aab:	00 00 00 
  805aae:	89 10                	mov    %edx,(%rax)
    return -1;
  805ab0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805ab5:	eb 23                	jmp    805ada <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  805ab7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805abb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805ac2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805ac6:	8b 50 18             	mov    0x18(%rax),%edx
  805ac9:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805ad0:	00 00 00 
  805ad3:	89 10                	mov    %edx,(%rax)
  return 0;
  805ad5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805ada:	c9                   	leaveq 
  805adb:	c3                   	retq   

0000000000805adc <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  805adc:	55                   	push   %rbp
  805add:	48 89 e5             	mov    %rsp,%rbp
  805ae0:	48 83 ec 70          	sub    $0x70,%rsp
  805ae4:	89 7d bc             	mov    %edi,-0x44(%rbp)
  805ae7:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  805aeb:	89 55 b8             	mov    %edx,-0x48(%rbp)
  805aee:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  805af1:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  805af5:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  805af9:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  805aff:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  805b03:	8b 45 bc             	mov    -0x44(%rbp),%eax
  805b06:	89 c7                	mov    %eax,%edi
  805b08:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  805b0f:	00 00 00 
  805b12:	ff d0                	callq  *%rax
  805b14:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  805b18:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  805b1d:	75 0a                	jne    805b29 <lwip_recvfrom+0x4d>
    return -1;
  805b1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805b24:	e9 8b 03 00 00       	jmpq   805eb4 <lwip_recvfrom+0x3d8>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  805b29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b2d:	48 8b 40 08          	mov    0x8(%rax),%rax
  805b31:	48 85 c0             	test   %rax,%rax
  805b34:	74 11                	je     805b47 <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  805b36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b3a:	48 8b 40 08          	mov    0x8(%rax),%rax
  805b3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  805b42:	e9 0c 01 00 00       	jmpq   805c53 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  805b47:	8b 45 ac             	mov    -0x54(%rbp),%eax
  805b4a:	83 e0 08             	and    $0x8,%eax
  805b4d:	85 c0                	test   %eax,%eax
  805b4f:	75 14                	jne    805b65 <lwip_recvfrom+0x89>
  805b51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b55:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  805b59:	0f b7 c0             	movzwl %ax,%eax
  805b5c:	25 00 08 00 00       	and    $0x800,%eax
  805b61:	85 c0                	test   %eax,%eax
  805b63:	74 35                	je     805b9a <lwip_recvfrom+0xbe>
  805b65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b69:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  805b6d:	66 85 c0             	test   %ax,%ax
  805b70:	75 28                	jne    805b9a <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  805b72:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b76:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  805b7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b81:	8b 50 18             	mov    0x18(%rax),%edx
  805b84:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805b8b:	00 00 00 
  805b8e:	89 10                	mov    %edx,(%rax)
        return -1;
  805b90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805b95:	e9 1a 03 00 00       	jmpq   805eb4 <lwip_recvfrom+0x3d8>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  805b9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805b9e:	48 8b 00             	mov    (%rax),%rax
  805ba1:	48 89 c7             	mov    %rax,%rdi
  805ba4:	48 b8 b7 94 81 00 00 	movabs $0x8194b7,%rax
  805bab:	00 00 00 
  805bae:	ff d0                	callq  *%rax
  805bb0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  805bb4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805bb8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805bbc:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  805bc0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805bc5:	0f 85 88 00 00 00    	jne    805c53 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  805bcb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805bcf:	48 8b 00             	mov    (%rax),%rax
  805bd2:	48 8b 40 08          	mov    0x8(%rax),%rax
  805bd6:	48 85 c0             	test   %rax,%rax
  805bd9:	74 0f                	je     805bea <lwip_recvfrom+0x10e>
  805bdb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805bdf:	48 8b 00             	mov    (%rax),%rax
  805be2:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805be6:	84 c0                	test   %al,%al
  805be8:	74 40                	je     805c2a <lwip_recvfrom+0x14e>
  805bea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805bee:	48 8b 00             	mov    (%rax),%rax
  805bf1:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805bf5:	0f be c0             	movsbl %al,%eax
  805bf8:	f7 d8                	neg    %eax
  805bfa:	83 f8 0e             	cmp    $0xe,%eax
  805bfd:	77 24                	ja     805c23 <lwip_recvfrom+0x147>
  805bff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805c03:	48 8b 00             	mov    (%rax),%rax
  805c06:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805c0a:	0f be c0             	movsbl %al,%eax
  805c0d:	f7 d8                	neg    %eax
  805c0f:	89 c2                	mov    %eax,%edx
  805c11:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  805c18:	00 00 00 
  805c1b:	48 63 d2             	movslq %edx,%rdx
  805c1e:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805c21:	eb 0c                	jmp    805c2f <lwip_recvfrom+0x153>
  805c23:	b8 05 00 00 00       	mov    $0x5,%eax
  805c28:	eb 05                	jmp    805c2f <lwip_recvfrom+0x153>
  805c2a:	b8 6e 00 00 00       	mov    $0x6e,%eax
  805c2f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  805c33:	89 42 18             	mov    %eax,0x18(%rdx)
  805c36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805c3a:	8b 50 18             	mov    0x18(%rax),%edx
  805c3d:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805c44:	00 00 00 
  805c47:	89 10                	mov    %edx,(%rax)
        return 0;
  805c49:	b8 00 00 00 00       	mov    $0x0,%eax
  805c4e:	e9 61 02 00 00       	jmpq   805eb4 <lwip_recvfrom+0x3d8>
      }
    }

    buflen = netbuf_len(buf);
  805c53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c57:	48 8b 00             	mov    (%rax),%rax
  805c5a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  805c5e:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  805c62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805c66:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  805c6a:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  805c6e:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  805c72:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  805c75:	7d 0a                	jge    805c81 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  805c77:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  805c7b:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  805c7f:	eb 07                	jmp    805c88 <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  805c81:	8b 45 b8             	mov    -0x48(%rbp),%eax
  805c84:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  805c88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805c8c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  805c90:	0f b7 c8             	movzwl %ax,%ecx
  805c93:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  805c97:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  805c9b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  805c9f:	48 01 c6             	add    %rax,%rsi
  805ca2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805ca6:	48 8b 00             	mov    (%rax),%rax
  805ca9:	48 89 c7             	mov    %rax,%rdi
  805cac:	48 b8 6b d8 80 00 00 	movabs $0x80d86b,%rax
  805cb3:	00 00 00 
  805cb6:	ff d0                	callq  *%rax

    off += copylen;
  805cb8:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805cbc:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  805cc0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805cc4:	48 8b 00             	mov    (%rax),%rax
  805cc7:	48 89 c7             	mov    %rax,%rdi
  805cca:	48 b8 c1 90 81 00 00 	movabs $0x8190c1,%rax
  805cd1:	00 00 00 
  805cd4:	ff d0                	callq  *%rax
  805cd6:	83 f8 10             	cmp    $0x10,%eax
  805cd9:	75 35                	jne    805d10 <lwip_recvfrom+0x234>
      len -= copylen;
  805cdb:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805cdf:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  805ce2:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  805ce6:	7e 22                	jle    805d0a <lwip_recvfrom+0x22e>
  805ce8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805cec:	48 8b 00             	mov    (%rax),%rax
  805cef:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  805cf3:	0f b6 c0             	movzbl %al,%eax
  805cf6:	83 e0 01             	and    $0x1,%eax
  805cf9:	85 c0                	test   %eax,%eax
  805cfb:	75 0d                	jne    805d0a <lwip_recvfrom+0x22e>
  805cfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d01:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  805d05:	66 85 c0             	test   %ax,%ax
  805d08:	75 0a                	jne    805d14 <lwip_recvfrom+0x238>
        done = 1;
  805d0a:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  805d0e:	eb 04                	jmp    805d14 <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  805d10:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  805d14:	8b 45 ac             	mov    -0x54(%rbp),%eax
  805d17:	83 e0 01             	and    $0x1,%eax
  805d1a:	85 c0                	test   %eax,%eax
  805d1c:	75 6e                	jne    805d8c <lwip_recvfrom+0x2b0>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  805d1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d22:	48 8b 00             	mov    (%rax),%rax
  805d25:	8b 00                	mov    (%rax),%eax
  805d27:	83 f8 10             	cmp    $0x10,%eax
  805d2a:	75 35                	jne    805d61 <lwip_recvfrom+0x285>
  805d2c:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  805d30:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805d34:	29 c2                	sub    %eax,%edx
  805d36:	89 d0                	mov    %edx,%eax
  805d38:	85 c0                	test   %eax,%eax
  805d3a:	7e 25                	jle    805d61 <lwip_recvfrom+0x285>
        sock->lastdata = buf;
  805d3c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d40:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805d44:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  805d48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d4c:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  805d50:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805d54:	01 c2                	add    %eax,%edx
  805d56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d5a:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  805d5e:	90                   	nop
  805d5f:	eb 2f                	jmp    805d90 <lwip_recvfrom+0x2b4>
      } else {
        sock->lastdata = NULL;
  805d61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d65:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805d6c:	00 
        sock->lastoffset = 0;
  805d6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805d71:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  805d77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d7b:	48 89 c7             	mov    %rax,%rdi
  805d7e:	48 b8 b5 82 80 00 00 	movabs $0x8082b5,%rax
  805d85:	00 00 00 
  805d88:	ff d0                	callq  *%rax
  805d8a:	eb 04                	jmp    805d90 <lwip_recvfrom+0x2b4>
      }
    } else {
      done = 1;
  805d8c:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  805d90:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  805d94:	0f 84 8f fd ff ff    	je     805b29 <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  805d9a:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  805d9f:	0f 84 ed 00 00 00    	je     805e92 <lwip_recvfrom+0x3b6>
  805da5:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  805daa:	0f 84 e2 00 00 00    	je     805e92 <lwip_recvfrom+0x3b6>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  805db0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805db4:	48 8b 00             	mov    (%rax),%rax
  805db7:	48 89 c7             	mov    %rax,%rdi
  805dba:	48 b8 c1 90 81 00 00 	movabs $0x8190c1,%rax
  805dc1:	00 00 00 
  805dc4:	ff d0                	callq  *%rax
  805dc6:	83 f8 10             	cmp    $0x10,%eax
  805dc9:	75 31                	jne    805dfc <lwip_recvfrom+0x320>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  805dcb:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  805dcf:	48 83 c0 04          	add    $0x4,%rax
  805dd3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  805dd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805ddb:	48 8b 00             	mov    (%rax),%rax
  805dde:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  805de2:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  805de6:	b9 00 00 00 00       	mov    $0x0,%ecx
  805deb:	48 89 c7             	mov    %rax,%rdi
  805dee:	48 b8 06 91 81 00 00 	movabs $0x819106,%rax
  805df5:	00 00 00 
  805df8:	ff d0                	callq  *%rax
  805dfa:	eb 18                	jmp    805e14 <lwip_recvfrom+0x338>
    } else {
      addr = netbuf_fromaddr(buf);
  805dfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e00:	48 8b 40 10          	mov    0x10(%rax),%rax
  805e04:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  805e08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e0c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  805e10:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  805e14:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  805e18:	ba 10 00 00 00       	mov    $0x10,%edx
  805e1d:	be 00 00 00 00       	mov    $0x0,%esi
  805e22:	48 89 c7             	mov    %rax,%rdi
  805e25:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  805e2c:	00 00 00 
  805e2f:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  805e31:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  805e35:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  805e39:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  805e3d:	0f b7 c0             	movzwl %ax,%eax
  805e40:	89 c7                	mov    %eax,%edi
  805e42:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  805e49:	00 00 00 
  805e4c:	ff d0                	callq  *%rax
  805e4e:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  805e52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e56:	8b 00                	mov    (%rax),%eax
  805e58:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  805e5b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805e5f:	8b 00                	mov    (%rax),%eax
  805e61:	83 f8 10             	cmp    $0x10,%eax
  805e64:	76 0a                	jbe    805e70 <lwip_recvfrom+0x394>
      *fromlen = sizeof(sin);
  805e66:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805e6a:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  805e70:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805e74:	8b 00                	mov    (%rax),%eax
  805e76:	89 c2                	mov    %eax,%edx
  805e78:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  805e7c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  805e80:	48 89 ce             	mov    %rcx,%rsi
  805e83:	48 89 c7             	mov    %rax,%rdi
  805e86:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  805e8d:	00 00 00 
  805e90:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  805e92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805e96:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805e9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805ea1:	8b 50 18             	mov    0x18(%rax),%edx
  805ea4:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  805eab:	00 00 00 
  805eae:	89 10                	mov    %edx,(%rax)
  return off;
  805eb0:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  805eb4:	c9                   	leaveq 
  805eb5:	c3                   	retq   

0000000000805eb6 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  805eb6:	55                   	push   %rbp
  805eb7:	48 89 e5             	mov    %rsp,%rbp
  805eba:	48 83 ec 10          	sub    $0x10,%rsp
  805ebe:	89 7d fc             	mov    %edi,-0x4(%rbp)
  805ec1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  805ec5:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  805ec8:	8b 55 f8             	mov    -0x8(%rbp),%edx
  805ecb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  805ecf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805ed2:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  805ed8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  805ede:	b9 00 00 00 00       	mov    $0x0,%ecx
  805ee3:	89 c7                	mov    %eax,%edi
  805ee5:	48 b8 dc 5a 80 00 00 	movabs $0x805adc,%rax
  805eec:	00 00 00 
  805eef:	ff d0                	callq  *%rax
}
  805ef1:	c9                   	leaveq 
  805ef2:	c3                   	retq   

0000000000805ef3 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  805ef3:	55                   	push   %rbp
  805ef4:	48 89 e5             	mov    %rsp,%rbp
  805ef7:	48 83 ec 20          	sub    $0x20,%rsp
  805efb:	89 7d fc             	mov    %edi,-0x4(%rbp)
  805efe:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  805f02:	89 55 f8             	mov    %edx,-0x8(%rbp)
  805f05:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  805f08:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  805f0b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  805f0e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  805f12:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805f15:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  805f1b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  805f21:	89 c7                	mov    %eax,%edi
  805f23:	48 b8 dc 5a 80 00 00 	movabs $0x805adc,%rax
  805f2a:	00 00 00 
  805f2d:	ff d0                	callq  *%rax
}
  805f2f:	c9                   	leaveq 
  805f30:	c3                   	retq   

0000000000805f31 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  805f31:	55                   	push   %rbp
  805f32:	48 89 e5             	mov    %rsp,%rbp
  805f35:	48 83 ec 30          	sub    $0x30,%rsp
  805f39:	89 7d ec             	mov    %edi,-0x14(%rbp)
  805f3c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  805f40:	89 55 e8             	mov    %edx,-0x18(%rbp)
  805f43:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  805f46:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805f49:	89 c7                	mov    %eax,%edi
  805f4b:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  805f52:	00 00 00 
  805f55:	ff d0                	callq  *%rax
  805f57:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805f5b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805f60:	75 0a                	jne    805f6c <lwip_send+0x3b>
    return -1;
  805f62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f67:	e9 c5 00 00 00       	jmpq   806031 <lwip_send+0x100>

  if (sock->conn->type!=NETCONN_TCP) {
  805f6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f70:	48 8b 00             	mov    (%rax),%rax
  805f73:	8b 00                	mov    (%rax),%eax
  805f75:	83 f8 10             	cmp    $0x10,%eax
  805f78:	74 2c                	je     805fa6 <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  805f7a:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  805f7d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  805f80:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  805f84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805f87:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  805f8d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  805f93:	89 c7                	mov    %eax,%edi
  805f95:	48 b8 33 60 80 00 00 	movabs $0x806033,%rax
  805f9c:	00 00 00 
  805f9f:	ff d0                	callq  *%rax
  805fa1:	e9 8b 00 00 00       	jmpq   806031 <lwip_send+0x100>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  805fa6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  805fa9:	83 e0 10             	and    $0x10,%eax
  805fac:	85 c0                	test   %eax,%eax
  805fae:	74 07                	je     805fb7 <lwip_send+0x86>
  805fb0:	b9 03 00 00 00       	mov    $0x3,%ecx
  805fb5:	eb 05                	jmp    805fbc <lwip_send+0x8b>
  805fb7:	b9 01 00 00 00       	mov    $0x1,%ecx
  805fbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805fc0:	48 8b 00             	mov    (%rax),%rax
  805fc3:	8b 55 e8             	mov    -0x18(%rbp),%edx
  805fc6:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  805fca:	48 89 c7             	mov    %rax,%rdi
  805fcd:	48 b8 15 98 81 00 00 	movabs $0x819815,%rax
  805fd4:	00 00 00 
  805fd7:	ff d0                	callq  *%rax
  805fd9:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  805fdc:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  805fe0:	f7 d8                	neg    %eax
  805fe2:	83 f8 0e             	cmp    $0xe,%eax
  805fe5:	77 1a                	ja     806001 <lwip_send+0xd0>
  805fe7:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  805feb:	f7 d8                	neg    %eax
  805fed:	89 c2                	mov    %eax,%edx
  805fef:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  805ff6:	00 00 00 
  805ff9:	48 63 d2             	movslq %edx,%rdx
  805ffc:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805fff:	eb 05                	jmp    806006 <lwip_send+0xd5>
  806001:	b8 05 00 00 00       	mov    $0x5,%eax
  806006:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80600a:	89 42 18             	mov    %eax,0x18(%rdx)
  80600d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806011:	8b 50 18             	mov    0x18(%rax),%edx
  806014:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80601b:	00 00 00 
  80601e:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806020:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806024:	75 05                	jne    80602b <lwip_send+0xfa>
  806026:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806029:	eb 05                	jmp    806030 <lwip_send+0xff>
  80602b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806030:	90                   	nop
}
  806031:	c9                   	leaveq 
  806032:	c3                   	retq   

0000000000806033 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806033:	55                   	push   %rbp
  806034:	48 89 e5             	mov    %rsp,%rbp
  806037:	48 83 ec 60          	sub    $0x60,%rsp
  80603b:	89 7d bc             	mov    %edi,-0x44(%rbp)
  80603e:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806042:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806045:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806048:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  80604c:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806050:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806053:	89 c7                	mov    %eax,%edi
  806055:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  80605c:	00 00 00 
  80605f:	ff d0                	callq  *%rax
  806061:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  806065:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80606a:	75 0a                	jne    806076 <lwip_sendto+0x43>
    return -1;
  80606c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806071:	e9 d9 01 00 00       	jmpq   80624f <lwip_sendto+0x21c>

  if (sock->conn->type==NETCONN_TCP) {
  806076:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80607a:	48 8b 00             	mov    (%rax),%rax
  80607d:	8b 00                	mov    (%rax),%eax
  80607f:	83 f8 10             	cmp    $0x10,%eax
  806082:	75 20                	jne    8060a4 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806084:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  806087:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80608a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80608e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806091:	89 c7                	mov    %eax,%edi
  806093:	48 b8 31 5f 80 00 00 	movabs $0x805f31,%rax
  80609a:	00 00 00 
  80609d:	ff d0                	callq  *%rax
  80609f:	e9 ab 01 00 00       	jmpq   80624f <lwip_sendto+0x21c>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8060a4:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8060a8:	78 09                	js     8060b3 <lwip_sendto+0x80>
  8060aa:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  8060b1:	7e 2a                	jle    8060dd <lwip_sendto+0xaa>
  8060b3:	48 ba b8 0a 82 00 00 	movabs $0x820ab8,%rdx
  8060ba:	00 00 00 
  8060bd:	be 97 02 00 00       	mov    $0x297,%esi
  8060c2:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  8060c9:	00 00 00 
  8060cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8060d1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8060d8:	00 00 00 
  8060db:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8060dd:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8060e2:	75 06                	jne    8060ea <lwip_sendto+0xb7>
  8060e4:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  8060e8:	74 3c                	je     806126 <lwip_sendto+0xf3>
  8060ea:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  8060ee:	75 0c                	jne    8060fc <lwip_sendto+0xc9>
  8060f0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8060f4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8060f8:	3c 02                	cmp    $0x2,%al
  8060fa:	74 2a                	je     806126 <lwip_sendto+0xf3>
  8060fc:	48 ba dc 0a 82 00 00 	movabs $0x820adc,%rdx
  806103:	00 00 00 
  806106:	be 9b 02 00 00       	mov    $0x29b,%esi
  80610b:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  806112:	00 00 00 
  806115:	b8 00 00 00 00       	mov    $0x0,%eax
  80611a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  806121:	00 00 00 
  806124:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  806126:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80612d:	00 
  80612e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806132:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  806136:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  80613b:	74 39                	je     806176 <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80613d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806141:	8b 40 04             	mov    0x4(%rax),%eax
  806144:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  806147:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80614b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80614f:	0f b7 c0             	movzwl %ax,%eax
  806152:	89 c7                	mov    %eax,%edi
  806154:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  80615b:	00 00 00 
  80615e:	ff d0                	callq  *%rax
  806160:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806164:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806168:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  80616c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806170:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806174:	eb 1b                	jmp    806191 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  806176:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  80617d:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806183:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80618a:	00 
    buf.port         = 0;
  80618b:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806191:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806194:	0f b7 d0             	movzwl %ax,%edx
  806197:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80619b:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80619f:	48 89 ce             	mov    %rcx,%rsi
  8061a2:	48 89 c7             	mov    %rax,%rdi
  8061a5:	48 b8 90 84 80 00 00 	movabs $0x808490,%rax
  8061ac:	00 00 00 
  8061af:	ff d0                	callq  *%rax
  8061b1:	0f be c0             	movsbl %al,%eax
  8061b4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8061b7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8061bb:	75 23                	jne    8061e0 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  8061bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8061c1:	48 8b 00             	mov    (%rax),%rax
  8061c4:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  8061c8:	48 89 d6             	mov    %rdx,%rsi
  8061cb:	48 89 c7             	mov    %rax,%rdi
  8061ce:	48 b8 99 97 81 00 00 	movabs $0x819799,%rax
  8061d5:	00 00 00 
  8061d8:	ff d0                	callq  *%rax
  8061da:	0f be c0             	movsbl %al,%eax
  8061dd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8061e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8061e4:	48 85 c0             	test   %rax,%rax
  8061e7:	74 13                	je     8061fc <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  8061e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8061ed:	48 89 c7             	mov    %rax,%rdi
  8061f0:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8061f7:	00 00 00 
  8061fa:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  8061fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8061ff:	f7 d8                	neg    %eax
  806201:	83 f8 0e             	cmp    $0xe,%eax
  806204:	77 19                	ja     80621f <lwip_sendto+0x1ec>
  806206:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806209:	f7 d8                	neg    %eax
  80620b:	89 c2                	mov    %eax,%edx
  80620d:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  806214:	00 00 00 
  806217:	48 63 d2             	movslq %edx,%rdx
  80621a:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80621d:	eb 05                	jmp    806224 <lwip_sendto+0x1f1>
  80621f:	b8 05 00 00 00       	mov    $0x5,%eax
  806224:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806228:	89 42 18             	mov    %eax,0x18(%rdx)
  80622b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80622f:	8b 50 18             	mov    0x18(%rax),%edx
  806232:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  806239:	00 00 00 
  80623c:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  80623e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806242:	75 05                	jne    806249 <lwip_sendto+0x216>
  806244:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806247:	eb 05                	jmp    80624e <lwip_sendto+0x21b>
  806249:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80624e:	90                   	nop
}
  80624f:	c9                   	leaveq 
  806250:	c3                   	retq   

0000000000806251 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806251:	55                   	push   %rbp
  806252:	48 89 e5             	mov    %rsp,%rbp
  806255:	48 83 ec 20          	sub    $0x20,%rsp
  806259:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80625c:	89 75 e8             	mov    %esi,-0x18(%rbp)
  80625f:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806262:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806265:	83 f8 02             	cmp    $0x2,%eax
  806268:	74 38                	je     8062a2 <lwip_socket+0x51>
  80626a:	83 f8 03             	cmp    $0x3,%eax
  80626d:	74 0a                	je     806279 <lwip_socket+0x28>
  80626f:	83 f8 01             	cmp    $0x1,%eax
  806272:	74 66                	je     8062da <lwip_socket+0x89>
  806274:	e9 87 00 00 00       	jmpq   806300 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806279:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80627c:	0f b6 c0             	movzbl %al,%eax
  80627f:	48 ba 17 6b 80 00 00 	movabs $0x806b17,%rdx
  806286:	00 00 00 
  806289:	89 c6                	mov    %eax,%esi
  80628b:	bf 40 00 00 00       	mov    $0x40,%edi
  806290:	48 b8 b5 8e 81 00 00 	movabs $0x818eb5,%rax
  806297:	00 00 00 
  80629a:	ff d0                	callq  *%rax
  80629c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8062a0:	eb 78                	jmp    80631a <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8062a2:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  8062a9:	75 07                	jne    8062b2 <lwip_socket+0x61>
  8062ab:	b8 21 00 00 00       	mov    $0x21,%eax
  8062b0:	eb 05                	jmp    8062b7 <lwip_socket+0x66>
  8062b2:	b8 20 00 00 00       	mov    $0x20,%eax
  8062b7:	48 ba 17 6b 80 00 00 	movabs $0x806b17,%rdx
  8062be:	00 00 00 
  8062c1:	be 00 00 00 00       	mov    $0x0,%esi
  8062c6:	89 c7                	mov    %eax,%edi
  8062c8:	48 b8 b5 8e 81 00 00 	movabs $0x818eb5,%rax
  8062cf:	00 00 00 
  8062d2:	ff d0                	callq  *%rax
  8062d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8062d8:	eb 40                	jmp    80631a <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8062da:	48 ba 17 6b 80 00 00 	movabs $0x806b17,%rdx
  8062e1:	00 00 00 
  8062e4:	be 00 00 00 00       	mov    $0x0,%esi
  8062e9:	bf 10 00 00 00       	mov    $0x10,%edi
  8062ee:	48 b8 b5 8e 81 00 00 	movabs $0x818eb5,%rax
  8062f5:	00 00 00 
  8062f8:	ff d0                	callq  *%rax
  8062fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8062fe:	eb 1a                	jmp    80631a <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806300:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  806307:	00 00 00 
  80630a:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806310:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806315:	e9 81 00 00 00       	jmpq   80639b <lwip_socket+0x14a>
  }

  if (!conn) {
  80631a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80631f:	75 17                	jne    806338 <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806321:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  806328:	00 00 00 
  80632b:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806331:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806336:	eb 63                	jmp    80639b <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80633c:	48 89 c7             	mov    %rax,%rdi
  80633f:	48 b8 cc 51 80 00 00 	movabs $0x8051cc,%rax
  806346:	00 00 00 
  806349:	ff d0                	callq  *%rax
  80634b:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  80634e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806352:	75 2a                	jne    80637e <lwip_socket+0x12d>
    netconn_delete(conn);
  806354:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806358:	48 89 c7             	mov    %rax,%rdi
  80635b:	48 b8 58 90 81 00 00 	movabs $0x819058,%rax
  806362:	00 00 00 
  806365:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806367:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80636e:	00 00 00 
  806371:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806377:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80637c:	eb 1d                	jmp    80639b <lwip_socket+0x14a>
  }
  conn->socket = i;
  80637e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806382:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806385:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806388:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80638f:	00 00 00 
  806392:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806398:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  80639b:	c9                   	leaveq 
  80639c:	c3                   	retq   

000000000080639d <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  80639d:	55                   	push   %rbp
  80639e:	48 89 e5             	mov    %rsp,%rbp
  8063a1:	48 83 ec 10          	sub    $0x10,%rsp
  8063a5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8063a8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8063ac:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  8063af:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8063b2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8063b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8063b9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8063be:	89 c7                	mov    %eax,%edi
  8063c0:	48 b8 31 5f 80 00 00 	movabs $0x805f31,%rax
  8063c7:	00 00 00 
  8063ca:	ff d0                	callq  *%rax
}
  8063cc:	c9                   	leaveq 
  8063cd:	c3                   	retq   

00000000008063ce <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  8063ce:	55                   	push   %rbp
  8063cf:	48 89 e5             	mov    %rsp,%rbp
  8063d2:	48 83 ec 60          	sub    $0x60,%rsp
  8063d6:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8063d9:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8063dd:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8063e1:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
  int i, nready = 0;
  8063e5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  8063ec:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8063f0:	ba 04 00 00 00       	mov    $0x4,%edx
  8063f5:	be 00 00 00 00       	mov    $0x0,%esi
  8063fa:	48 89 c7             	mov    %rax,%rdi
  8063fd:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806404:	00 00 00 
  806407:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  806409:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80640d:	ba 04 00 00 00       	mov    $0x4,%edx
  806412:	be 00 00 00 00       	mov    $0x0,%esi
  806417:	48 89 c7             	mov    %rax,%rdi
  80641a:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806421:	00 00 00 
  806424:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  806426:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80642a:	ba 04 00 00 00       	mov    $0x4,%edx
  80642f:	be 00 00 00 00       	mov    $0x0,%esi
  806434:	48 89 c7             	mov    %rax,%rdi
  806437:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80643e:	00 00 00 
  806441:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806443:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80644a:	e9 33 01 00 00       	jmpq   806582 <lwip_selscan+0x1b4>
    if (FD_ISSET(i, readset)) {
  80644f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806452:	8d 50 07             	lea    0x7(%rax),%edx
  806455:	85 c0                	test   %eax,%eax
  806457:	0f 48 c2             	cmovs  %edx,%eax
  80645a:	c1 f8 03             	sar    $0x3,%eax
  80645d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  806461:	48 98                	cltq   
  806463:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806467:	0f b6 d0             	movzbl %al,%edx
  80646a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80646d:	83 e0 07             	and    $0x7,%eax
  806470:	89 c1                	mov    %eax,%ecx
  806472:	d3 fa                	sar    %cl,%edx
  806474:	89 d0                	mov    %edx,%eax
  806476:	83 e0 01             	and    $0x1,%eax
  806479:	85 c0                	test   %eax,%eax
  80647b:	74 70                	je     8064ed <lwip_selscan+0x11f>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  80647d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806480:	89 c7                	mov    %eax,%edi
  806482:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  806489:	00 00 00 
  80648c:	ff d0                	callq  *%rax
  80648e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  806492:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806497:	74 54                	je     8064ed <lwip_selscan+0x11f>
  806499:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80649d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8064a1:	48 85 c0             	test   %rax,%rax
  8064a4:	75 0d                	jne    8064b3 <lwip_selscan+0xe5>
  8064a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8064aa:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8064ae:	66 85 c0             	test   %ax,%ax
  8064b1:	74 3a                	je     8064ed <lwip_selscan+0x11f>
        FD_SET(i, &lreadset);
  8064b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8064b6:	8d 50 07             	lea    0x7(%rax),%edx
  8064b9:	85 c0                	test   %eax,%eax
  8064bb:	0f 48 c2             	cmovs  %edx,%eax
  8064be:	c1 f8 03             	sar    $0x3,%eax
  8064c1:	89 c2                	mov    %eax,%edx
  8064c3:	48 63 c2             	movslq %edx,%rax
  8064c6:	0f b6 44 05 e0       	movzbl -0x20(%rbp,%rax,1),%eax
  8064cb:	89 c6                	mov    %eax,%esi
  8064cd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8064d0:	83 e0 07             	and    $0x7,%eax
  8064d3:	bf 01 00 00 00       	mov    $0x1,%edi
  8064d8:	89 c1                	mov    %eax,%ecx
  8064da:	d3 e7                	shl    %cl,%edi
  8064dc:	89 f8                	mov    %edi,%eax
  8064de:	09 f0                	or     %esi,%eax
  8064e0:	89 c1                	mov    %eax,%ecx
  8064e2:	48 63 c2             	movslq %edx,%rax
  8064e5:	88 4c 05 e0          	mov    %cl,-0x20(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8064e9:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  8064ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8064f0:	8d 50 07             	lea    0x7(%rax),%edx
  8064f3:	85 c0                	test   %eax,%eax
  8064f5:	0f 48 c2             	cmovs  %edx,%eax
  8064f8:	c1 f8 03             	sar    $0x3,%eax
  8064fb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8064ff:	48 98                	cltq   
  806501:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806505:	0f b6 d0             	movzbl %al,%edx
  806508:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80650b:	83 e0 07             	and    $0x7,%eax
  80650e:	89 c1                	mov    %eax,%ecx
  806510:	d3 fa                	sar    %cl,%edx
  806512:	89 d0                	mov    %edx,%eax
  806514:	83 e0 01             	and    $0x1,%eax
  806517:	85 c0                	test   %eax,%eax
  806519:	74 63                	je     80657e <lwip_selscan+0x1b0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  80651b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80651e:	89 c7                	mov    %eax,%edi
  806520:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  806527:	00 00 00 
  80652a:	ff d0                	callq  *%rax
  80652c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && p_sock->sendevent) {
  806530:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806535:	74 47                	je     80657e <lwip_selscan+0x1b0>
  806537:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80653b:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  80653f:	66 85 c0             	test   %ax,%ax
  806542:	74 3a                	je     80657e <lwip_selscan+0x1b0>
        FD_SET(i, &lwriteset);
  806544:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806547:	8d 50 07             	lea    0x7(%rax),%edx
  80654a:	85 c0                	test   %eax,%eax
  80654c:	0f 48 c2             	cmovs  %edx,%eax
  80654f:	c1 f8 03             	sar    $0x3,%eax
  806552:	89 c2                	mov    %eax,%edx
  806554:	48 63 c2             	movslq %edx,%rax
  806557:	0f b6 44 05 d0       	movzbl -0x30(%rbp,%rax,1),%eax
  80655c:	89 c6                	mov    %eax,%esi
  80655e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806561:	83 e0 07             	and    $0x7,%eax
  806564:	bf 01 00 00 00       	mov    $0x1,%edi
  806569:	89 c1                	mov    %eax,%ecx
  80656b:	d3 e7                	shl    %cl,%edi
  80656d:	89 f8                	mov    %edi,%eax
  80656f:	09 f0                	or     %esi,%eax
  806571:	89 c1                	mov    %eax,%ecx
  806573:	48 63 c2             	movslq %edx,%rax
  806576:	88 4c 05 d0          	mov    %cl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  80657a:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  for(i = 0; i < maxfdp1; i++) {
  80657e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  806582:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806585:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  806588:	0f 8c c1 fe ff ff    	jl     80644f <lwip_selscan+0x81>
      }
    }
  }
  *readset = lreadset;
  80658e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  806592:	8b 55 e0             	mov    -0x20(%rbp),%edx
  806595:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  806597:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80659b:	8b 55 d0             	mov    -0x30(%rbp),%edx
  80659e:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  8065a0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8065a4:	ba 04 00 00 00       	mov    $0x4,%edx
  8065a9:	be 00 00 00 00       	mov    $0x0,%esi
  8065ae:	48 89 c7             	mov    %rax,%rdi
  8065b1:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8065b8:	00 00 00 
  8065bb:	ff d0                	callq  *%rax
  
  return nready;
  8065bd:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8065c0:	c9                   	leaveq 
  8065c1:	c3                   	retq   

00000000008065c2 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  8065c2:	55                   	push   %rbp
  8065c3:	48 89 e5             	mov    %rsp,%rbp
  8065c6:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8065cd:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  8065d0:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8065d4:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8065db:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8065e2:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  8065e9:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8065f0:	00 
  select_cb.readset = readset;
  8065f1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8065f5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  8065f9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806600:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  806604:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80660b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  80660f:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  806616:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  80661d:	00 00 00 
  806620:	8b 00                	mov    (%rax),%eax
  806622:	89 c7                	mov    %eax,%edi
  806624:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  80662b:	00 00 00 
  80662e:	ff d0                	callq  *%rax

  if (readset)
  806630:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806635:	74 0b                	je     806642 <lwip_select+0x80>
    lreadset = *readset;
  806637:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80663b:	8b 00                	mov    (%rax),%eax
  80663d:	89 45 e0             	mov    %eax,-0x20(%rbp)
  806640:	eb 1d                	jmp    80665f <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  806642:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806646:	ba 04 00 00 00       	mov    $0x4,%edx
  80664b:	be 00 00 00 00       	mov    $0x0,%esi
  806650:	48 89 c7             	mov    %rax,%rdi
  806653:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80665a:	00 00 00 
  80665d:	ff d0                	callq  *%rax
  if (writeset)
  80665f:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806666:	00 
  806667:	74 0e                	je     806677 <lwip_select+0xb5>
    lwriteset = *writeset;
  806669:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806670:	8b 00                	mov    (%rax),%eax
  806672:	89 45 d0             	mov    %eax,-0x30(%rbp)
  806675:	eb 1d                	jmp    806694 <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  806677:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80667b:	ba 04 00 00 00       	mov    $0x4,%edx
  806680:	be 00 00 00 00       	mov    $0x0,%esi
  806685:	48 89 c7             	mov    %rax,%rdi
  806688:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80668f:	00 00 00 
  806692:	ff d0                	callq  *%rax
  if (exceptset)
  806694:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80669b:	00 
  80669c:	74 0e                	je     8066ac <lwip_select+0xea>
    lexceptset = *exceptset;
  80669e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8066a5:	8b 00                	mov    (%rax),%eax
  8066a7:	89 45 c0             	mov    %eax,-0x40(%rbp)
  8066aa:	eb 1d                	jmp    8066c9 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  8066ac:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8066b0:	ba 04 00 00 00       	mov    $0x4,%edx
  8066b5:	be 00 00 00 00       	mov    $0x0,%esi
  8066ba:	48 89 c7             	mov    %rax,%rdi
  8066bd:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8066c4:	00 00 00 
  8066c7:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8066c9:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8066cd:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8066d1:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8066d5:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8066d8:	89 c7                	mov    %eax,%edi
  8066da:	48 b8 ce 63 80 00 00 	movabs $0x8063ce,%rax
  8066e1:	00 00 00 
  8066e4:	ff d0                	callq  *%rax
  8066e6:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8066e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8066ed:	0f 85 b9 03 00 00    	jne    806aac <lwip_select+0x4ea>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8066f3:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8066fa:	00 
  8066fb:	0f 84 d3 00 00 00    	je     8067d4 <lwip_select+0x212>
  806701:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806708:	48 8b 00             	mov    (%rax),%rax
  80670b:	48 85 c0             	test   %rax,%rax
  80670e:	0f 85 c0 00 00 00    	jne    8067d4 <lwip_select+0x212>
  806714:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80671b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80671f:	48 85 c0             	test   %rax,%rax
  806722:	0f 85 ac 00 00 00    	jne    8067d4 <lwip_select+0x212>
      sys_sem_signal(selectsem);
  806728:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  80672f:	00 00 00 
  806732:	8b 00                	mov    (%rax),%eax
  806734:	89 c7                	mov    %eax,%edi
  806736:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80673d:	00 00 00 
  806740:	ff d0                	callq  *%rax
      if (readset)
  806742:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806747:	74 1d                	je     806766 <lwip_select+0x1a4>
        FD_ZERO(readset);
  806749:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80674d:	ba 04 00 00 00       	mov    $0x4,%edx
  806752:	be 00 00 00 00       	mov    $0x0,%esi
  806757:	48 89 c7             	mov    %rax,%rdi
  80675a:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806761:	00 00 00 
  806764:	ff d0                	callq  *%rax
      if (writeset)
  806766:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80676d:	00 
  80676e:	74 20                	je     806790 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  806770:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806777:	ba 04 00 00 00       	mov    $0x4,%edx
  80677c:	be 00 00 00 00       	mov    $0x0,%esi
  806781:	48 89 c7             	mov    %rax,%rdi
  806784:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80678b:	00 00 00 
  80678e:	ff d0                	callq  *%rax
      if (exceptset)
  806790:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806797:	00 
  806798:	74 20                	je     8067ba <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  80679a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8067a1:	ba 04 00 00 00       	mov    $0x4,%edx
  8067a6:	be 00 00 00 00       	mov    $0x0,%esi
  8067ab:	48 89 c7             	mov    %rax,%rdi
  8067ae:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8067b5:	00 00 00 
  8067b8:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  8067ba:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8067c1:	00 00 00 
  8067c4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8067ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8067cf:	e9 41 03 00 00       	jmpq   806b15 <lwip_select+0x553>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8067d4:	bf 00 00 00 00       	mov    $0x0,%edi
  8067d9:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  8067e0:	00 00 00 
  8067e3:	ff d0                	callq  *%rax
  8067e5:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8067e8:	48 b8 c0 84 82 00 00 	movabs $0x8284c0,%rax
  8067ef:	00 00 00 
  8067f2:	48 8b 00             	mov    (%rax),%rax
  8067f5:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  8067f9:	48 b8 c0 84 82 00 00 	movabs $0x8284c0,%rax
  806800:	00 00 00 
  806803:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  806807:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  80680a:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806811:	00 00 00 
  806814:	8b 00                	mov    (%rax),%eax
  806816:	89 c7                	mov    %eax,%edi
  806818:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80681f:	00 00 00 
  806822:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  806824:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  80682b:	00 
  80682c:	75 09                	jne    806837 <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  80682e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  806835:	eb 55                	jmp    80688c <lwip_select+0x2ca>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  806837:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80683e:	48 8b 00             	mov    (%rax),%rax
  806841:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  806847:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80684e:	48 8b 40 08          	mov    0x8(%rax),%rax
  806852:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  806859:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  806860:	9b c4 20 
  806863:	48 89 c8             	mov    %rcx,%rax
  806866:	48 f7 ea             	imul   %rdx
  806869:	48 c1 fa 07          	sar    $0x7,%rdx
  80686d:	48 89 c8             	mov    %rcx,%rax
  806870:	48 c1 f8 3f          	sar    $0x3f,%rax
  806874:	48 29 c2             	sub    %rax,%rdx
  806877:	48 89 d0             	mov    %rdx,%rax
  80687a:	01 f0                	add    %esi,%eax
  80687c:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  80687f:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  806883:	75 07                	jne    80688c <lwip_select+0x2ca>
        msectimeout = 1;
  806885:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  80688c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80688f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806892:	89 d6                	mov    %edx,%esi
  806894:	89 c7                	mov    %eax,%edi
  806896:	48 b8 6d df 80 00 00 	movabs $0x80df6d,%rax
  80689d:	00 00 00 
  8068a0:	ff d0                	callq  *%rax
  8068a2:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  8068a5:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  8068ac:	00 00 00 
  8068af:	8b 00                	mov    (%rax),%eax
  8068b1:	89 c7                	mov    %eax,%edi
  8068b3:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  8068ba:	00 00 00 
  8068bd:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  8068bf:	48 b8 c0 84 82 00 00 	movabs $0x8284c0,%rax
  8068c6:	00 00 00 
  8068c9:	48 8b 10             	mov    (%rax),%rdx
  8068cc:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8068d0:	48 39 c2             	cmp    %rax,%rdx
  8068d3:	75 13                	jne    8068e8 <lwip_select+0x326>
      select_cb_list = select_cb.next;
  8068d5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8068d9:	48 b8 c0 84 82 00 00 	movabs $0x8284c0,%rax
  8068e0:	00 00 00 
  8068e3:	48 89 10             	mov    %rdx,(%rax)
  8068e6:	eb 42                	jmp    80692a <lwip_select+0x368>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8068e8:	48 b8 c0 84 82 00 00 	movabs $0x8284c0,%rax
  8068ef:	00 00 00 
  8068f2:	48 8b 00             	mov    (%rax),%rax
  8068f5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8068f9:	eb 28                	jmp    806923 <lwip_select+0x361>
        if (p_selcb->next == &select_cb) {
  8068fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8068ff:	48 8b 10             	mov    (%rax),%rdx
  806902:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  806906:	48 39 c2             	cmp    %rax,%rdx
  806909:	75 0d                	jne    806918 <lwip_select+0x356>
          p_selcb->next = select_cb.next;
  80690b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80690f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806913:	48 89 10             	mov    %rdx,(%rax)
          break;
  806916:	eb 12                	jmp    80692a <lwip_select+0x368>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  806918:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80691c:	48 8b 00             	mov    (%rax),%rax
  80691f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  806923:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806928:	75 d1                	jne    8068fb <lwip_select+0x339>
        }
      }
    
    sys_sem_signal(selectsem);
  80692a:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806931:	00 00 00 
  806934:	8b 00                	mov    (%rax),%eax
  806936:	89 c7                	mov    %eax,%edi
  806938:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80693f:	00 00 00 
  806942:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  806944:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  806947:	89 c7                	mov    %eax,%edi
  806949:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  806950:	00 00 00 
  806953:	ff d0                	callq  *%rax
    if (i == 0)  {
  806955:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  806959:	0f 85 92 00 00 00    	jne    8069f1 <lwip_select+0x42f>
      /* Timeout */
      if (readset)
  80695f:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806964:	74 1d                	je     806983 <lwip_select+0x3c1>
        FD_ZERO(readset);
  806966:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80696a:	ba 04 00 00 00       	mov    $0x4,%edx
  80696f:	be 00 00 00 00       	mov    $0x0,%esi
  806974:	48 89 c7             	mov    %rax,%rdi
  806977:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80697e:	00 00 00 
  806981:	ff d0                	callq  *%rax
      if (writeset)
  806983:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80698a:	00 
  80698b:	74 20                	je     8069ad <lwip_select+0x3eb>
        FD_ZERO(writeset);
  80698d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806994:	ba 04 00 00 00       	mov    $0x4,%edx
  806999:	be 00 00 00 00       	mov    $0x0,%esi
  80699e:	48 89 c7             	mov    %rax,%rdi
  8069a1:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8069a8:	00 00 00 
  8069ab:	ff d0                	callq  *%rax
      if (exceptset)
  8069ad:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8069b4:	00 
  8069b5:	74 20                	je     8069d7 <lwip_select+0x415>
        FD_ZERO(exceptset);
  8069b7:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8069be:	ba 04 00 00 00       	mov    $0x4,%edx
  8069c3:	be 00 00 00 00       	mov    $0x0,%esi
  8069c8:	48 89 c7             	mov    %rax,%rdi
  8069cb:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8069d2:	00 00 00 
  8069d5:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8069d7:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8069de:	00 00 00 
  8069e1:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8069e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8069ec:	e9 24 01 00 00       	jmpq   806b15 <lwip_select+0x553>
    }
    
    if (readset)
  8069f1:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8069f6:	74 0b                	je     806a03 <lwip_select+0x441>
      lreadset = *readset;
  8069f8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8069fc:	8b 00                	mov    (%rax),%eax
  8069fe:	89 45 e0             	mov    %eax,-0x20(%rbp)
  806a01:	eb 1d                	jmp    806a20 <lwip_select+0x45e>
    else
      FD_ZERO(&lreadset);
  806a03:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806a07:	ba 04 00 00 00       	mov    $0x4,%edx
  806a0c:	be 00 00 00 00       	mov    $0x0,%esi
  806a11:	48 89 c7             	mov    %rax,%rdi
  806a14:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806a1b:	00 00 00 
  806a1e:	ff d0                	callq  *%rax
    if (writeset)
  806a20:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806a27:	00 
  806a28:	74 0e                	je     806a38 <lwip_select+0x476>
      lwriteset = *writeset;
  806a2a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806a31:	8b 00                	mov    (%rax),%eax
  806a33:	89 45 d0             	mov    %eax,-0x30(%rbp)
  806a36:	eb 1d                	jmp    806a55 <lwip_select+0x493>
    else
      FD_ZERO(&lwriteset);
  806a38:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806a3c:	ba 04 00 00 00       	mov    $0x4,%edx
  806a41:	be 00 00 00 00       	mov    $0x0,%esi
  806a46:	48 89 c7             	mov    %rax,%rdi
  806a49:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806a50:	00 00 00 
  806a53:	ff d0                	callq  *%rax
    if (exceptset)
  806a55:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806a5c:	00 
  806a5d:	74 0e                	je     806a6d <lwip_select+0x4ab>
      lexceptset = *exceptset;
  806a5f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806a66:	8b 00                	mov    (%rax),%eax
  806a68:	89 45 c0             	mov    %eax,-0x40(%rbp)
  806a6b:	eb 1d                	jmp    806a8a <lwip_select+0x4c8>
    else
      FD_ZERO(&lexceptset);
  806a6d:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806a71:	ba 04 00 00 00       	mov    $0x4,%edx
  806a76:	be 00 00 00 00       	mov    $0x0,%esi
  806a7b:	48 89 c7             	mov    %rax,%rdi
  806a7e:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806a85:	00 00 00 
  806a88:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  806a8a:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806a8e:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  806a92:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  806a96:	8b 45 8c             	mov    -0x74(%rbp),%eax
  806a99:	89 c7                	mov    %eax,%edi
  806a9b:	48 b8 ce 63 80 00 00 	movabs $0x8063ce,%rax
  806aa2:	00 00 00 
  806aa5:	ff d0                	callq  *%rax
  806aa7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  806aaa:	eb 1a                	jmp    806ac6 <lwip_select+0x504>
  } else
    sys_sem_signal(selectsem);
  806aac:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806ab3:	00 00 00 
  806ab6:	8b 00                	mov    (%rax),%eax
  806ab8:	89 c7                	mov    %eax,%edi
  806aba:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806ac1:	00 00 00 
  806ac4:	ff d0                	callq  *%rax
  
  if (readset)
  806ac6:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806acb:	74 09                	je     806ad6 <lwip_select+0x514>
    *readset = lreadset;
  806acd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806ad1:	8b 55 e0             	mov    -0x20(%rbp),%edx
  806ad4:	89 10                	mov    %edx,(%rax)
  if (writeset)
  806ad6:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806add:	00 
  806ade:	74 0c                	je     806aec <lwip_select+0x52a>
    *writeset = lwriteset;
  806ae0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806ae7:	8b 55 d0             	mov    -0x30(%rbp),%edx
  806aea:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  806aec:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806af3:	00 
  806af4:	74 0c                	je     806b02 <lwip_select+0x540>
    *exceptset = lexceptset;
  806af6:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806afd:	8b 55 c0             	mov    -0x40(%rbp),%edx
  806b00:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  806b02:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  806b09:	00 00 00 
  806b0c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  806b12:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  806b15:	c9                   	leaveq 
  806b16:	c3                   	retq   

0000000000806b17 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  806b17:	55                   	push   %rbp
  806b18:	48 89 e5             	mov    %rsp,%rbp
  806b1b:	48 83 ec 30          	sub    $0x30,%rsp
  806b1f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  806b23:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  806b26:	89 d0                	mov    %edx,%eax
  806b28:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  806b2c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806b31:	0f 84 a6 00 00 00    	je     806bdd <event_callback+0xc6>
    s = conn->socket;
  806b37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806b3b:	8b 40 20             	mov    0x20(%rax),%eax
  806b3e:	89 45 f4             	mov    %eax,-0xc(%rbp)
    if (s < 0) {
  806b41:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  806b45:	79 75                	jns    806bbc <event_callback+0xa5>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  806b47:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  806b4e:	00 00 00 
  806b51:	8b 00                	mov    (%rax),%eax
  806b53:	89 c7                	mov    %eax,%edi
  806b55:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  806b5c:	00 00 00 
  806b5f:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  806b61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806b65:	8b 40 20             	mov    0x20(%rax),%eax
  806b68:	85 c0                	test   %eax,%eax
  806b6a:	79 36                	jns    806ba2 <event_callback+0x8b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  806b6c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  806b70:	75 11                	jne    806b83 <event_callback+0x6c>
          conn->socket--;
  806b72:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806b76:	8b 40 20             	mov    0x20(%rax),%eax
  806b79:	8d 50 ff             	lea    -0x1(%rax),%edx
  806b7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806b80:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  806b83:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  806b8a:	00 00 00 
  806b8d:	8b 00                	mov    (%rax),%eax
  806b8f:	89 c7                	mov    %eax,%edi
  806b91:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806b98:	00 00 00 
  806b9b:	ff d0                	callq  *%rax
        return;
  806b9d:	e9 4e 02 00 00       	jmpq   806df0 <event_callback+0x2d9>
      }
      sys_sem_signal(socksem);
  806ba2:	48 b8 c8 84 82 00 00 	movabs $0x8284c8,%rax
  806ba9:	00 00 00 
  806bac:	8b 00                	mov    (%rax),%eax
  806bae:	89 c7                	mov    %eax,%edi
  806bb0:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806bb7:	00 00 00 
  806bba:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  806bbc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  806bbf:	89 c7                	mov    %eax,%edi
  806bc1:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  806bc8:	00 00 00 
  806bcb:	ff d0                	callq  *%rax
  806bcd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (!sock) {
  806bd1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  806bd6:	75 0a                	jne    806be2 <event_callback+0xcb>
      return;
  806bd8:	e9 13 02 00 00       	jmpq   806df0 <event_callback+0x2d9>
    }
  } else {
    return;
  806bdd:	e9 0e 02 00 00       	jmpq   806df0 <event_callback+0x2d9>
  }

  sys_sem_wait(selectsem);
  806be2:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806be9:	00 00 00 
  806bec:	8b 00                	mov    (%rax),%eax
  806bee:	89 c7                	mov    %eax,%edi
  806bf0:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  806bf7:	00 00 00 
  806bfa:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  806bfc:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  806bff:	83 f8 01             	cmp    $0x1,%eax
  806c02:	74 26                	je     806c2a <event_callback+0x113>
  806c04:	83 f8 01             	cmp    $0x1,%eax
  806c07:	72 0c                	jb     806c15 <event_callback+0xfe>
  806c09:	83 f8 02             	cmp    $0x2,%eax
  806c0c:	74 31                	je     806c3f <event_callback+0x128>
  806c0e:	83 f8 03             	cmp    $0x3,%eax
  806c11:	74 38                	je     806c4b <event_callback+0x134>
  806c13:	eb 42                	jmp    806c57 <event_callback+0x140>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  806c15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806c19:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806c1d:	8d 50 01             	lea    0x1(%rax),%edx
  806c20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806c24:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  806c28:	eb 57                	jmp    806c81 <event_callback+0x16a>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  806c2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806c2e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806c32:	8d 50 ff             	lea    -0x1(%rax),%edx
  806c35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806c39:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  806c3d:	eb 42                	jmp    806c81 <event_callback+0x16a>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  806c3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806c43:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  806c49:	eb 36                	jmp    806c81 <event_callback+0x16a>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  806c4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806c4f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  806c55:	eb 2a                	jmp    806c81 <event_callback+0x16a>
    default:
      LWIP_ASSERT("unknown event", 0);
  806c57:	48 ba f9 0a 82 00 00 	movabs $0x820af9,%rdx
  806c5e:	00 00 00 
  806c61:	be 17 04 00 00       	mov    $0x417,%esi
  806c66:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  806c6d:	00 00 00 
  806c70:	b8 00 00 00 00       	mov    $0x0,%eax
  806c75:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  806c7c:	00 00 00 
  806c7f:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  806c81:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806c88:	00 00 00 
  806c8b:	8b 00                	mov    (%rax),%eax
  806c8d:	89 c7                	mov    %eax,%edi
  806c8f:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806c96:	00 00 00 
  806c99:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  806c9b:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806ca2:	00 00 00 
  806ca5:	8b 00                	mov    (%rax),%eax
  806ca7:	89 c7                	mov    %eax,%edi
  806ca9:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  806cb0:	00 00 00 
  806cb3:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  806cb5:	48 b8 c0 84 82 00 00 	movabs $0x8284c0,%rax
  806cbc:	00 00 00 
  806cbf:	48 8b 00             	mov    (%rax),%rax
  806cc2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806cc6:	e9 b6 00 00 00       	jmpq   806d81 <event_callback+0x26a>
      if (scb->sem_signalled == 0) {
  806ccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806ccf:	8b 40 20             	mov    0x20(%rax),%eax
  806cd2:	85 c0                	test   %eax,%eax
  806cd4:	0f 85 9c 00 00 00    	jne    806d76 <event_callback+0x25f>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  806cda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806cde:	48 8b 40 08          	mov    0x8(%rax),%rax
  806ce2:	48 85 c0             	test   %rax,%rax
  806ce5:	74 41                	je     806d28 <event_callback+0x211>
  806ce7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806ceb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  806cef:	8b 45 f4             	mov    -0xc(%rbp),%eax
  806cf2:	8d 48 07             	lea    0x7(%rax),%ecx
  806cf5:	85 c0                	test   %eax,%eax
  806cf7:	0f 48 c1             	cmovs  %ecx,%eax
  806cfa:	c1 f8 03             	sar    $0x3,%eax
  806cfd:	48 98                	cltq   
  806cff:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806d03:	0f b6 d0             	movzbl %al,%edx
  806d06:	8b 45 f4             	mov    -0xc(%rbp),%eax
  806d09:	83 e0 07             	and    $0x7,%eax
  806d0c:	89 c1                	mov    %eax,%ecx
  806d0e:	d3 fa                	sar    %cl,%edx
  806d10:	89 d0                	mov    %edx,%eax
  806d12:	83 e0 01             	and    $0x1,%eax
  806d15:	85 c0                	test   %eax,%eax
  806d17:	74 0f                	je     806d28 <event_callback+0x211>
          if (sock->rcvevent)
  806d19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806d1d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806d21:	66 85 c0             	test   %ax,%ax
  806d24:	74 02                	je     806d28 <event_callback+0x211>
            break;
  806d26:	eb 64                	jmp    806d8c <event_callback+0x275>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  806d28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806d2c:	48 8b 40 10          	mov    0x10(%rax),%rax
  806d30:	48 85 c0             	test   %rax,%rax
  806d33:	74 41                	je     806d76 <event_callback+0x25f>
  806d35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806d39:	48 8b 50 10          	mov    0x10(%rax),%rdx
  806d3d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  806d40:	8d 48 07             	lea    0x7(%rax),%ecx
  806d43:	85 c0                	test   %eax,%eax
  806d45:	0f 48 c1             	cmovs  %ecx,%eax
  806d48:	c1 f8 03             	sar    $0x3,%eax
  806d4b:	48 98                	cltq   
  806d4d:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806d51:	0f b6 d0             	movzbl %al,%edx
  806d54:	8b 45 f4             	mov    -0xc(%rbp),%eax
  806d57:	83 e0 07             	and    $0x7,%eax
  806d5a:	89 c1                	mov    %eax,%ecx
  806d5c:	d3 fa                	sar    %cl,%edx
  806d5e:	89 d0                	mov    %edx,%eax
  806d60:	83 e0 01             	and    $0x1,%eax
  806d63:	85 c0                	test   %eax,%eax
  806d65:	74 0f                	je     806d76 <event_callback+0x25f>
          if (sock->sendevent)
  806d67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806d6b:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  806d6f:	66 85 c0             	test   %ax,%ax
  806d72:	74 02                	je     806d76 <event_callback+0x25f>
            break;
  806d74:	eb 16                	jmp    806d8c <event_callback+0x275>
    for (scb = select_cb_list; scb; scb = scb->next) {
  806d76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806d7a:	48 8b 00             	mov    (%rax),%rax
  806d7d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806d81:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806d86:	0f 85 3f ff ff ff    	jne    806ccb <event_callback+0x1b4>
      }
    }
    if (scb) {
  806d8c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806d91:	74 3c                	je     806dcf <event_callback+0x2b8>
      scb->sem_signalled = 1;
  806d93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806d97:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  806d9e:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806da5:	00 00 00 
  806da8:	8b 00                	mov    (%rax),%eax
  806daa:	89 c7                	mov    %eax,%edi
  806dac:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806db3:	00 00 00 
  806db6:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  806db8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806dbc:	8b 40 24             	mov    0x24(%rax),%eax
  806dbf:	89 c7                	mov    %eax,%edi
  806dc1:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806dc8:	00 00 00 
  806dcb:	ff d0                	callq  *%rax
  806dcd:	eb 1c                	jmp    806deb <event_callback+0x2d4>
    } else {
      sys_sem_signal(selectsem);
  806dcf:	48 b8 cc 84 82 00 00 	movabs $0x8284cc,%rax
  806dd6:	00 00 00 
  806dd9:	8b 00                	mov    (%rax),%eax
  806ddb:	89 c7                	mov    %eax,%edi
  806ddd:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  806de4:	00 00 00 
  806de7:	ff d0                	callq  *%rax
      break;
  806de9:	eb 05                	jmp    806df0 <event_callback+0x2d9>
    }
  }
  806deb:	e9 ab fe ff ff       	jmpq   806c9b <event_callback+0x184>
}
  806df0:	c9                   	leaveq 
  806df1:	c3                   	retq   

0000000000806df2 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  806df2:	55                   	push   %rbp
  806df3:	48 89 e5             	mov    %rsp,%rbp
  806df6:	48 83 ec 10          	sub    $0x10,%rsp
  806dfa:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806dfd:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  806e00:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e03:	89 c7                	mov    %eax,%edi
  806e05:	48 b8 b3 57 80 00 00 	movabs $0x8057b3,%rax
  806e0c:	00 00 00 
  806e0f:	ff d0                	callq  *%rax
}
  806e11:	c9                   	leaveq 
  806e12:	c3                   	retq   

0000000000806e13 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  806e13:	55                   	push   %rbp
  806e14:	48 89 e5             	mov    %rsp,%rbp
  806e17:	48 83 ec 50          	sub    $0x50,%rsp
  806e1b:	89 7d cc             	mov    %edi,-0x34(%rbp)
  806e1e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  806e22:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  806e26:	89 c8                	mov    %ecx,%eax
  806e28:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  806e2b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  806e2e:	89 c7                	mov    %eax,%edi
  806e30:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  806e37:	00 00 00 
  806e3a:	ff d0                	callq  *%rax
  806e3c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806e40:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806e45:	75 0a                	jne    806e51 <lwip_getaddrname+0x3e>
    return -1;
  806e47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806e4c:	e9 c9 00 00 00       	jmpq   806f1a <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  806e51:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806e55:	ba 10 00 00 00       	mov    $0x10,%edx
  806e5a:	be 00 00 00 00       	mov    $0x0,%esi
  806e5f:	48 89 c7             	mov    %rax,%rdi
  806e62:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  806e69:	00 00 00 
  806e6c:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  806e6e:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  806e72:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  806e76:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  806e7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806e7e:	48 8b 00             	mov    (%rax),%rax
  806e81:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  806e85:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  806e89:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  806e8d:	89 d1                	mov    %edx,%ecx
  806e8f:	48 89 fa             	mov    %rdi,%rdx
  806e92:	48 89 c7             	mov    %rax,%rdi
  806e95:	48 b8 06 91 81 00 00 	movabs $0x819106,%rax
  806e9c:	00 00 00 
  806e9f:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  806ea1:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  806ea5:	0f b7 c0             	movzwl %ax,%eax
  806ea8:	89 c7                	mov    %eax,%edi
  806eaa:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  806eb1:	00 00 00 
  806eb4:	ff d0                	callq  *%rax
  806eb6:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  806eba:	8b 45 d0             	mov    -0x30(%rbp),%eax
  806ebd:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  806ec0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  806ec4:	8b 00                	mov    (%rax),%eax
  806ec6:	83 f8 10             	cmp    $0x10,%eax
  806ec9:	76 0a                	jbe    806ed5 <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  806ecb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  806ecf:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  806ed5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  806ed9:	8b 00                	mov    (%rax),%eax
  806edb:	89 c2                	mov    %eax,%edx
  806edd:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  806ee1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806ee5:	48 89 ce             	mov    %rcx,%rsi
  806ee8:	48 89 c7             	mov    %rax,%rdi
  806eeb:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  806ef2:	00 00 00 
  806ef5:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  806ef7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806efb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806f02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f06:	8b 50 18             	mov    0x18(%rax),%edx
  806f09:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  806f10:	00 00 00 
  806f13:	89 10                	mov    %edx,(%rax)
  return 0;
  806f15:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806f1a:	c9                   	leaveq 
  806f1b:	c3                   	retq   

0000000000806f1c <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  806f1c:	55                   	push   %rbp
  806f1d:	48 89 e5             	mov    %rsp,%rbp
  806f20:	48 83 ec 20          	sub    $0x20,%rsp
  806f24:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806f27:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806f2b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  806f2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  806f33:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806f37:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806f3a:	b9 00 00 00 00       	mov    $0x0,%ecx
  806f3f:	89 c7                	mov    %eax,%edi
  806f41:	48 b8 13 6e 80 00 00 	movabs $0x806e13,%rax
  806f48:	00 00 00 
  806f4b:	ff d0                	callq  *%rax
}
  806f4d:	c9                   	leaveq 
  806f4e:	c3                   	retq   

0000000000806f4f <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  806f4f:	55                   	push   %rbp
  806f50:	48 89 e5             	mov    %rsp,%rbp
  806f53:	48 83 ec 20          	sub    $0x20,%rsp
  806f57:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806f5a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806f5e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  806f62:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  806f66:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806f6a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806f6d:	b9 01 00 00 00       	mov    $0x1,%ecx
  806f72:	89 c7                	mov    %eax,%edi
  806f74:	48 b8 13 6e 80 00 00 	movabs $0x806e13,%rax
  806f7b:	00 00 00 
  806f7e:	ff d0                	callq  *%rax
}
  806f80:	c9                   	leaveq 
  806f81:	c3                   	retq   

0000000000806f82 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  806f82:	55                   	push   %rbp
  806f83:	48 89 e5             	mov    %rsp,%rbp
  806f86:	48 83 ec 60          	sub    $0x60,%rsp
  806f8a:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806f8d:	89 75 b8             	mov    %esi,-0x48(%rbp)
  806f90:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  806f93:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  806f97:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  806f9b:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  806f9f:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806fa2:	89 c7                	mov    %eax,%edi
  806fa4:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  806fab:	00 00 00 
  806fae:	ff d0                	callq  *%rax
  806fb0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  806fb4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806fb9:	75 0a                	jne    806fc5 <lwip_getsockopt+0x43>
    return -1;
  806fbb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806fc0:	e9 16 02 00 00       	jmpq   8071db <lwip_getsockopt+0x259>

  if ((NULL == optval) || (NULL == optlen)) {
  806fc5:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  806fca:	74 07                	je     806fd3 <lwip_getsockopt+0x51>
  806fcc:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806fd1:	75 28                	jne    806ffb <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  806fd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806fd7:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  806fde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806fe2:	8b 50 18             	mov    0x18(%rax),%edx
  806fe5:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  806fec:	00 00 00 
  806fef:	89 10                	mov    %edx,(%rax)
    return -1;
  806ff1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806ff6:	e9 e0 01 00 00       	jmpq   8071db <lwip_getsockopt+0x259>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  806ffb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806ffe:	83 f8 06             	cmp    $0x6,%eax
  807001:	0f 84 c3 00 00 00    	je     8070ca <lwip_getsockopt+0x148>
  807007:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  80700c:	74 0d                	je     80701b <lwip_getsockopt+0x99>
  80700e:	85 c0                	test   %eax,%eax
  807010:	0f 84 8e 00 00 00    	je     8070a4 <lwip_getsockopt+0x122>
  807016:	e9 ec 00 00 00       	jmpq   807107 <lwip_getsockopt+0x185>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80701b:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80701e:	83 f8 20             	cmp    $0x20,%eax
  807021:	74 28                	je     80704b <lwip_getsockopt+0xc9>
  807023:	83 f8 20             	cmp    $0x20,%eax
  807026:	7f 0c                	jg     807034 <lwip_getsockopt+0xb2>
  807028:	83 f8 02             	cmp    $0x2,%eax
  80702b:	74 1e                	je     80704b <lwip_getsockopt+0xc9>
  80702d:	83 f8 08             	cmp    $0x8,%eax
  807030:	74 19                	je     80704b <lwip_getsockopt+0xc9>
  807032:	eb 68                	jmp    80709c <lwip_getsockopt+0x11a>
  807034:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807039:	7c 61                	jl     80709c <lwip_getsockopt+0x11a>
  80703b:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807040:	7e 09                	jle    80704b <lwip_getsockopt+0xc9>
  807042:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807047:	74 15                	je     80705e <lwip_getsockopt+0xdc>
  807049:	eb 51                	jmp    80709c <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  80704b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80704f:	8b 00                	mov    (%rax),%eax
  807051:	83 f8 03             	cmp    $0x3,%eax
  807054:	77 06                	ja     80705c <lwip_getsockopt+0xda>
        err = EINVAL;
  807056:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  80705a:	eb 46                	jmp    8070a2 <lwip_getsockopt+0x120>
  80705c:	eb 44                	jmp    8070a2 <lwip_getsockopt+0x120>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  80705e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807062:	8b 00                	mov    (%rax),%eax
  807064:	83 f8 03             	cmp    $0x3,%eax
  807067:	77 04                	ja     80706d <lwip_getsockopt+0xeb>
        err = EINVAL;
  807069:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80706d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807071:	48 8b 00             	mov    (%rax),%rax
  807074:	8b 00                	mov    (%rax),%eax
  807076:	83 f8 20             	cmp    $0x20,%eax
  807079:	75 19                	jne    807094 <lwip_getsockopt+0x112>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  80707b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80707f:	48 8b 00             	mov    (%rax),%rax
  807082:	48 8b 40 08          	mov    0x8(%rax),%rax
  807086:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80708a:	0f b6 c0             	movzbl %al,%eax
  80708d:	83 e0 02             	and    $0x2,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  807090:	85 c0                	test   %eax,%eax
  807092:	74 06                	je     80709a <lwip_getsockopt+0x118>
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807094:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807098:	eb 08                	jmp    8070a2 <lwip_getsockopt+0x120>
  80709a:	eb 06                	jmp    8070a2 <lwip_getsockopt+0x120>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  80709c:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8070a0:	eb 69                	jmp    80710b <lwip_getsockopt+0x189>
  8070a2:	eb 67                	jmp    80710b <lwip_getsockopt+0x189>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8070a4:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8070a7:	83 e8 01             	sub    $0x1,%eax
  8070aa:	83 f8 01             	cmp    $0x1,%eax
  8070ad:	77 13                	ja     8070c2 <lwip_getsockopt+0x140>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8070af:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8070b3:	8b 00                	mov    (%rax),%eax
  8070b5:	83 f8 03             	cmp    $0x3,%eax
  8070b8:	77 06                	ja     8070c0 <lwip_getsockopt+0x13e>
        err = EINVAL;
  8070ba:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  8070be:	eb 08                	jmp    8070c8 <lwip_getsockopt+0x146>
  8070c0:	eb 06                	jmp    8070c8 <lwip_getsockopt+0x146>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8070c2:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8070c6:	eb 43                	jmp    80710b <lwip_getsockopt+0x189>
  8070c8:	eb 41                	jmp    80710b <lwip_getsockopt+0x189>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8070ca:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8070ce:	8b 00                	mov    (%rax),%eax
  8070d0:	83 f8 03             	cmp    $0x3,%eax
  8070d3:	77 06                	ja     8070db <lwip_getsockopt+0x159>
      err = EINVAL;
  8070d5:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  8070d9:	eb 30                	jmp    80710b <lwip_getsockopt+0x189>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8070db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070df:	48 8b 00             	mov    (%rax),%rax
  8070e2:	8b 00                	mov    (%rax),%eax
  8070e4:	83 f8 10             	cmp    $0x10,%eax
  8070e7:	74 0a                	je     8070f3 <lwip_getsockopt+0x171>
      return 0;
  8070e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8070ee:	e9 e8 00 00 00       	jmpq   8071db <lwip_getsockopt+0x259>

    switch (optname) {
  8070f3:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8070f6:	83 e8 01             	sub    $0x1,%eax
  8070f9:	83 f8 01             	cmp    $0x1,%eax
  8070fc:	76 06                	jbe    807104 <lwip_getsockopt+0x182>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8070fe:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807102:	eb 07                	jmp    80710b <lwip_getsockopt+0x189>
      break;
  807104:	90                   	nop
    break;
  807105:	eb 04                	jmp    80710b <lwip_getsockopt+0x189>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  807107:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  80710b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80710f:	74 28                	je     807139 <lwip_getsockopt+0x1b7>
    sock_set_errno(sock, err);
  807111:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807115:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807119:	89 50 18             	mov    %edx,0x18(%rax)
  80711c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807120:	8b 50 18             	mov    0x18(%rax),%edx
  807123:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80712a:	00 00 00 
  80712d:	89 10                	mov    %edx,(%rax)
    return -1;
  80712f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807134:	e9 a2 00 00 00       	jmpq   8071db <lwip_getsockopt+0x259>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  807139:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80713d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807141:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807144:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807147:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80714a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  80714d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807151:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807155:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807159:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  80715d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807161:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807164:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807168:	ba 01 00 00 00       	mov    $0x1,%edx
  80716d:	48 89 c6             	mov    %rax,%rsi
  807170:	48 bf dd 71 80 00 00 	movabs $0x8071dd,%rdi
  807177:	00 00 00 
  80717a:	48 b8 41 7f 80 00 00 	movabs $0x807f41,%rax
  807181:	00 00 00 
  807184:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807186:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80718a:	48 8b 00             	mov    (%rax),%rax
  80718d:	8b 40 14             	mov    0x14(%rax),%eax
  807190:	be 00 00 00 00       	mov    $0x0,%esi
  807195:	89 c7                	mov    %eax,%edi
  807197:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  80719e:	00 00 00 
  8071a1:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  8071a3:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8071a7:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  8071aa:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  8071ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8071b2:	89 50 18             	mov    %edx,0x18(%rax)
  8071b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8071b9:	8b 50 18             	mov    0x18(%rax),%edx
  8071bc:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8071c3:	00 00 00 
  8071c6:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  8071c8:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8071cc:	74 07                	je     8071d5 <lwip_getsockopt+0x253>
  8071ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8071d3:	eb 05                	jmp    8071da <lwip_getsockopt+0x258>
  8071d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8071da:	90                   	nop
}
  8071db:	c9                   	leaveq 
  8071dc:	c3                   	retq   

00000000008071dd <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  8071dd:	55                   	push   %rbp
  8071de:	48 89 e5             	mov    %rsp,%rbp
  8071e1:	48 83 ec 40          	sub    $0x40,%rsp
  8071e5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8071e9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8071ee:	75 2a                	jne    80721a <lwip_getsockopt_internal+0x3d>
  8071f0:	48 ba 07 0b 82 00 00 	movabs $0x820b07,%rdx
  8071f7:	00 00 00 
  8071fa:	be 38 05 00 00       	mov    $0x538,%esi
  8071ff:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  807206:	00 00 00 
  807209:	b8 00 00 00 00       	mov    $0x0,%eax
  80720e:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  807215:	00 00 00 
  807218:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  80721a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80721e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807226:	48 8b 00             	mov    (%rax),%rax
  807229:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  80722d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807231:	8b 40 08             	mov    0x8(%rax),%eax
  807234:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807237:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80723b:	8b 40 0c             	mov    0xc(%rax),%eax
  80723e:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807241:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807245:	8b 40 10             	mov    0x10(%rax),%eax
  807248:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  80724b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80724f:	48 8b 40 18          	mov    0x18(%rax),%rax
  807253:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807257:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80725a:	83 f8 06             	cmp    $0x6,%eax
  80725d:	0f 84 b7 01 00 00    	je     80741a <lwip_getsockopt_internal+0x23d>
  807263:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807268:	74 0d                	je     807277 <lwip_getsockopt_internal+0x9a>
  80726a:	85 c0                	test   %eax,%eax
  80726c:	0f 84 64 01 00 00    	je     8073d6 <lwip_getsockopt_internal+0x1f9>
  807272:	e9 ec 01 00 00       	jmpq   807463 <lwip_getsockopt_internal+0x286>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807277:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80727a:	83 f8 20             	cmp    $0x20,%eax
  80727d:	74 36                	je     8072b5 <lwip_getsockopt_internal+0xd8>
  80727f:	83 f8 20             	cmp    $0x20,%eax
  807282:	7f 0f                	jg     807293 <lwip_getsockopt_internal+0xb6>
  807284:	83 f8 02             	cmp    $0x2,%eax
  807287:	74 2c                	je     8072b5 <lwip_getsockopt_internal+0xd8>
  807289:	83 f8 08             	cmp    $0x8,%eax
  80728c:	74 27                	je     8072b5 <lwip_getsockopt_internal+0xd8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  80728e:	e9 d0 01 00 00       	jmpq   807463 <lwip_getsockopt_internal+0x286>
    switch (optname) {
  807293:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807298:	74 3d                	je     8072d7 <lwip_getsockopt_internal+0xfa>
  80729a:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80729f:	0f 84 08 01 00 00    	je     8073ad <lwip_getsockopt_internal+0x1d0>
  8072a5:	3d 07 10 00 00       	cmp    $0x1007,%eax
  8072aa:	0f 84 80 00 00 00    	je     807330 <lwip_getsockopt_internal+0x153>
    break;
  8072b0:	e9 ae 01 00 00       	jmpq   807463 <lwip_getsockopt_internal+0x286>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  8072b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8072b9:	48 8b 00             	mov    (%rax),%rax
  8072bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8072c0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8072c4:	0f b7 c0             	movzwl %ax,%eax
  8072c7:	23 45 e4             	and    -0x1c(%rbp),%eax
  8072ca:	89 c2                	mov    %eax,%edx
  8072cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8072d0:	89 10                	mov    %edx,(%rax)
      break;
  8072d2:	e9 fa 00 00 00       	jmpq   8073d1 <lwip_getsockopt_internal+0x1f4>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  8072d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8072db:	48 8b 00             	mov    (%rax),%rax
  8072de:	8b 00                	mov    (%rax),%eax
  8072e0:	25 f0 00 00 00       	and    $0xf0,%eax
  8072e5:	83 f8 20             	cmp    $0x20,%eax
  8072e8:	74 24                	je     80730e <lwip_getsockopt_internal+0x131>
  8072ea:	83 f8 40             	cmp    $0x40,%eax
  8072ed:	74 07                	je     8072f6 <lwip_getsockopt_internal+0x119>
  8072ef:	83 f8 10             	cmp    $0x10,%eax
  8072f2:	74 0e                	je     807302 <lwip_getsockopt_internal+0x125>
  8072f4:	eb 24                	jmp    80731a <lwip_getsockopt_internal+0x13d>
        *(int*)optval = SOCK_RAW;
  8072f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8072fa:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807300:	eb 29                	jmp    80732b <lwip_getsockopt_internal+0x14e>
        *(int*)optval = SOCK_STREAM;
  807302:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807306:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  80730c:	eb 1d                	jmp    80732b <lwip_getsockopt_internal+0x14e>
        *(int*)optval = SOCK_DGRAM;
  80730e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807312:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807318:	eb 11                	jmp    80732b <lwip_getsockopt_internal+0x14e>
        *(int*)optval = sock->conn->type;
  80731a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80731e:	48 8b 00             	mov    (%rax),%rax
  807321:	8b 00                	mov    (%rax),%eax
  807323:	89 c2                	mov    %eax,%edx
  807325:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807329:	89 10                	mov    %edx,(%rax)
      break;
  80732b:	e9 a1 00 00 00       	jmpq   8073d1 <lwip_getsockopt_internal+0x1f4>
      if (sock->err == 0) {
  807330:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807334:	8b 40 18             	mov    0x18(%rax),%eax
  807337:	85 c0                	test   %eax,%eax
  807339:	75 58                	jne    807393 <lwip_getsockopt_internal+0x1b6>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  80733b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80733f:	48 8b 00             	mov    (%rax),%rax
  807342:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807346:	0f be c0             	movsbl %al,%eax
  807349:	f7 d8                	neg    %eax
  80734b:	83 f8 0e             	cmp    $0xe,%eax
  80734e:	77 24                	ja     807374 <lwip_getsockopt_internal+0x197>
  807350:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807354:	48 8b 00             	mov    (%rax),%rax
  807357:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  80735b:	0f be c0             	movsbl %al,%eax
  80735e:	f7 d8                	neg    %eax
  807360:	89 c2                	mov    %eax,%edx
  807362:	48 b8 00 0a 82 00 00 	movabs $0x820a00,%rax
  807369:	00 00 00 
  80736c:	48 63 d2             	movslq %edx,%rdx
  80736f:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807372:	eb 05                	jmp    807379 <lwip_getsockopt_internal+0x19c>
  807374:	b8 05 00 00 00       	mov    $0x5,%eax
  807379:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80737d:	89 42 18             	mov    %eax,0x18(%rdx)
  807380:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807384:	8b 50 18             	mov    0x18(%rax),%edx
  807387:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80738e:	00 00 00 
  807391:	89 10                	mov    %edx,(%rax)
      *(int *)optval = sock->err;
  807393:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807397:	8b 50 18             	mov    0x18(%rax),%edx
  80739a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80739e:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  8073a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8073a4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      break;
  8073ab:	eb 24                	jmp    8073d1 <lwip_getsockopt_internal+0x1f4>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  8073ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8073b1:	48 8b 00             	mov    (%rax),%rax
  8073b4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8073b8:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8073bc:	0f b6 c0             	movzbl %al,%eax
  8073bf:	83 e0 01             	and    $0x1,%eax
  8073c2:	85 c0                	test   %eax,%eax
  8073c4:	0f 95 c0             	setne  %al
  8073c7:	0f b6 d0             	movzbl %al,%edx
  8073ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8073ce:	89 10                	mov    %edx,(%rax)
      break;
  8073d0:	90                   	nop
    break;
  8073d1:	e9 8d 00 00 00       	jmpq   807463 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8073d6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8073d9:	83 f8 01             	cmp    $0x1,%eax
  8073dc:	74 21                	je     8073ff <lwip_getsockopt_internal+0x222>
  8073de:	83 f8 02             	cmp    $0x2,%eax
  8073e1:	74 02                	je     8073e5 <lwip_getsockopt_internal+0x208>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  8073e3:	eb 7e                	jmp    807463 <lwip_getsockopt_internal+0x286>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  8073e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8073e9:	48 8b 00             	mov    (%rax),%rax
  8073ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  8073f0:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8073f4:	0f b6 d0             	movzbl %al,%edx
  8073f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8073fb:	89 10                	mov    %edx,(%rax)
      break;
  8073fd:	eb 19                	jmp    807418 <lwip_getsockopt_internal+0x23b>
      *(int*)optval = sock->conn->pcb.ip->tos;
  8073ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807403:	48 8b 00             	mov    (%rax),%rax
  807406:	48 8b 40 08          	mov    0x8(%rax),%rax
  80740a:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  80740e:	0f b6 d0             	movzbl %al,%edx
  807411:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807415:	89 10                	mov    %edx,(%rax)
      break;
  807417:	90                   	nop
    break;
  807418:	eb 49                	jmp    807463 <lwip_getsockopt_internal+0x286>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  80741a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80741d:	83 f8 01             	cmp    $0x1,%eax
  807420:	74 07                	je     807429 <lwip_getsockopt_internal+0x24c>
  807422:	83 f8 02             	cmp    $0x2,%eax
  807425:	74 21                	je     807448 <lwip_getsockopt_internal+0x26b>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807427:	eb 39                	jmp    807462 <lwip_getsockopt_internal+0x285>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  807429:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80742d:	48 8b 00             	mov    (%rax),%rax
  807430:	48 8b 40 08          	mov    0x8(%rax),%rax
  807434:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  807438:	0f b6 c0             	movzbl %al,%eax
  80743b:	83 e0 40             	and    $0x40,%eax
  80743e:	89 c2                	mov    %eax,%edx
  807440:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807444:	89 10                	mov    %edx,(%rax)
      break;
  807446:	eb 1a                	jmp    807462 <lwip_getsockopt_internal+0x285>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  807448:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80744c:	48 8b 00             	mov    (%rax),%rax
  80744f:	48 8b 40 08          	mov    0x8(%rax),%rax
  807453:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  807459:	89 c2                	mov    %eax,%edx
  80745b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80745f:	89 10                	mov    %edx,(%rax)
      break;
  807461:	90                   	nop
    break;
  807462:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  807463:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807467:	48 8b 00             	mov    (%rax),%rax
  80746a:	8b 40 14             	mov    0x14(%rax),%eax
  80746d:	89 c7                	mov    %eax,%edi
  80746f:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  807476:	00 00 00 
  807479:	ff d0                	callq  *%rax
}
  80747b:	c9                   	leaveq 
  80747c:	c3                   	retq   

000000000080747d <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  80747d:	55                   	push   %rbp
  80747e:	48 89 e5             	mov    %rsp,%rbp
  807481:	48 83 ec 60          	sub    $0x60,%rsp
  807485:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807488:	89 75 b8             	mov    %esi,-0x48(%rbp)
  80748b:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  80748e:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807492:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807496:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807499:	89 c7                	mov    %eax,%edi
  80749b:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  8074a2:	00 00 00 
  8074a5:	ff d0                	callq  *%rax
  8074a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  8074ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8074b2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8074b7:	75 0a                	jne    8074c3 <lwip_setsockopt+0x46>
    return -1;
  8074b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8074be:	e9 fe 01 00 00       	jmpq   8076c1 <lwip_setsockopt+0x244>

  if (NULL == optval) {
  8074c3:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8074c8:	75 28                	jne    8074f2 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  8074ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8074ce:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  8074d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8074d9:	8b 50 18             	mov    0x18(%rax),%edx
  8074dc:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8074e3:	00 00 00 
  8074e6:	89 10                	mov    %edx,(%rax)
    return -1;
  8074e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8074ed:	e9 cf 01 00 00       	jmpq   8076c1 <lwip_setsockopt+0x244>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8074f2:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8074f5:	83 f8 06             	cmp    $0x6,%eax
  8074f8:	0f 84 ac 00 00 00    	je     8075aa <lwip_setsockopt+0x12d>
  8074fe:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807503:	74 09                	je     80750e <lwip_setsockopt+0x91>
  807505:	85 c0                	test   %eax,%eax
  807507:	74 78                	je     807581 <lwip_setsockopt+0x104>
  807509:	e9 dc 00 00 00       	jmpq   8075ea <lwip_setsockopt+0x16d>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80750e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807511:	83 f8 20             	cmp    $0x20,%eax
  807514:	74 0c                	je     807522 <lwip_setsockopt+0xa5>
  807516:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80751b:	74 18                	je     807535 <lwip_setsockopt+0xb8>
  80751d:	83 f8 08             	cmp    $0x8,%eax
  807520:	75 54                	jne    807576 <lwip_setsockopt+0xf9>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  807522:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807525:	83 f8 03             	cmp    $0x3,%eax
  807528:	77 09                	ja     807533 <lwip_setsockopt+0xb6>
        err = EINVAL;
  80752a:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807531:	eb 4c                	jmp    80757f <lwip_setsockopt+0x102>
  807533:	eb 4a                	jmp    80757f <lwip_setsockopt+0x102>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  807535:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807538:	83 f8 03             	cmp    $0x3,%eax
  80753b:	77 07                	ja     807544 <lwip_setsockopt+0xc7>
        err = EINVAL;
  80753d:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807544:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807548:	48 8b 00             	mov    (%rax),%rax
  80754b:	8b 00                	mov    (%rax),%eax
  80754d:	83 f8 20             	cmp    $0x20,%eax
  807550:	75 19                	jne    80756b <lwip_setsockopt+0xee>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807552:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807556:	48 8b 00             	mov    (%rax),%rax
  807559:	48 8b 40 08          	mov    0x8(%rax),%rax
  80755d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807561:	0f b6 c0             	movzbl %al,%eax
  807564:	83 e0 02             	and    $0x2,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  807567:	85 c0                	test   %eax,%eax
  807569:	74 09                	je     807574 <lwip_setsockopt+0xf7>
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  80756b:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807572:	eb 0b                	jmp    80757f <lwip_setsockopt+0x102>
  807574:	eb 09                	jmp    80757f <lwip_setsockopt+0x102>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807576:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  80757d:	eb 72                	jmp    8075f1 <lwip_setsockopt+0x174>
  80757f:	eb 70                	jmp    8075f1 <lwip_setsockopt+0x174>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807581:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807584:	83 e8 01             	sub    $0x1,%eax
  807587:	83 f8 01             	cmp    $0x1,%eax
  80758a:	77 13                	ja     80759f <lwip_setsockopt+0x122>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  80758c:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80758f:	83 f8 03             	cmp    $0x3,%eax
  807592:	77 09                	ja     80759d <lwip_setsockopt+0x120>
        err = EINVAL;
  807594:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  80759b:	eb 0b                	jmp    8075a8 <lwip_setsockopt+0x12b>
  80759d:	eb 09                	jmp    8075a8 <lwip_setsockopt+0x12b>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  80759f:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8075a6:	eb 49                	jmp    8075f1 <lwip_setsockopt+0x174>
  8075a8:	eb 47                	jmp    8075f1 <lwip_setsockopt+0x174>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  8075aa:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8075ad:	83 f8 03             	cmp    $0x3,%eax
  8075b0:	77 09                	ja     8075bb <lwip_setsockopt+0x13e>
      err = EINVAL;
  8075b2:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  8075b9:	eb 36                	jmp    8075f1 <lwip_setsockopt+0x174>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8075bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8075bf:	48 8b 00             	mov    (%rax),%rax
  8075c2:	8b 00                	mov    (%rax),%eax
  8075c4:	83 f8 10             	cmp    $0x10,%eax
  8075c7:	74 0a                	je     8075d3 <lwip_setsockopt+0x156>
      return 0;
  8075c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8075ce:	e9 ee 00 00 00       	jmpq   8076c1 <lwip_setsockopt+0x244>

    switch (optname) {
  8075d3:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8075d6:	83 e8 01             	sub    $0x1,%eax
  8075d9:	83 f8 01             	cmp    $0x1,%eax
  8075dc:	76 09                	jbe    8075e7 <lwip_setsockopt+0x16a>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8075de:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8075e5:	eb 0a                	jmp    8075f1 <lwip_setsockopt+0x174>
      break;
  8075e7:	90                   	nop
    break;
  8075e8:	eb 07                	jmp    8075f1 <lwip_setsockopt+0x174>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  8075ea:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  8075f1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8075f5:	74 27                	je     80761e <lwip_setsockopt+0x1a1>
    sock_set_errno(sock, err);
  8075f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8075fb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8075fe:	89 50 18             	mov    %edx,0x18(%rax)
  807601:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807605:	8b 50 18             	mov    0x18(%rax),%edx
  807608:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80760f:	00 00 00 
  807612:	89 10                	mov    %edx,(%rax)
    return -1;
  807614:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807619:	e9 a3 00 00 00       	jmpq   8076c1 <lwip_setsockopt+0x244>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  80761e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807622:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807626:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807629:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  80762c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80762f:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  807632:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807636:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  80763a:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  80763e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807642:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807645:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  807648:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80764c:	ba 01 00 00 00       	mov    $0x1,%edx
  807651:	48 89 c6             	mov    %rax,%rsi
  807654:	48 bf c3 76 80 00 00 	movabs $0x8076c3,%rdi
  80765b:	00 00 00 
  80765e:	48 b8 41 7f 80 00 00 	movabs $0x807f41,%rax
  807665:	00 00 00 
  807668:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80766a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80766e:	48 8b 00             	mov    (%rax),%rax
  807671:	8b 40 14             	mov    0x14(%rax),%eax
  807674:	be 00 00 00 00       	mov    $0x0,%esi
  807679:	89 c7                	mov    %eax,%edi
  80767b:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  807682:	00 00 00 
  807685:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  807687:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  80768b:	0f be c0             	movsbl %al,%eax
  80768e:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  807691:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807695:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807698:	89 50 18             	mov    %edx,0x18(%rax)
  80769b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80769f:	8b 50 18             	mov    0x18(%rax),%edx
  8076a2:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8076a9:	00 00 00 
  8076ac:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  8076ae:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8076b2:	74 07                	je     8076bb <lwip_setsockopt+0x23e>
  8076b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8076b9:	eb 05                	jmp    8076c0 <lwip_setsockopt+0x243>
  8076bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8076c0:	90                   	nop
}
  8076c1:	c9                   	leaveq 
  8076c2:	c3                   	retq   

00000000008076c3 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  8076c3:	55                   	push   %rbp
  8076c4:	48 89 e5             	mov    %rsp,%rbp
  8076c7:	48 83 ec 40          	sub    $0x40,%rsp
  8076cb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8076cf:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8076d4:	75 2a                	jne    807700 <lwip_setsockopt_internal+0x3d>
  8076d6:	48 ba 07 0b 82 00 00 	movabs $0x820b07,%rdx
  8076dd:	00 00 00 
  8076e0:	be ae 06 00 00       	mov    $0x6ae,%esi
  8076e5:	48 bf 51 0a 82 00 00 	movabs $0x820a51,%rdi
  8076ec:	00 00 00 
  8076ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8076f4:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8076fb:	00 00 00 
  8076fe:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807700:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807704:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807708:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80770c:	48 8b 00             	mov    (%rax),%rax
  80770f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807717:	8b 40 08             	mov    0x8(%rax),%eax
  80771a:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  80771d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807721:	8b 40 0c             	mov    0xc(%rax),%eax
  807724:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807727:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80772b:	8b 40 10             	mov    0x10(%rax),%eax
  80772e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807735:	48 8b 40 18          	mov    0x18(%rax),%rax
  807739:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  80773d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807740:	83 f8 06             	cmp    $0x6,%eax
  807743:	0f 84 18 01 00 00    	je     807861 <lwip_setsockopt_internal+0x19e>
  807749:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  80774e:	74 0d                	je     80775d <lwip_setsockopt_internal+0x9a>
  807750:	85 c0                	test   %eax,%eax
  807752:	0f 84 ca 00 00 00    	je     807822 <lwip_setsockopt_internal+0x15f>
  807758:	e9 7a 01 00 00       	jmpq   8078d7 <lwip_setsockopt_internal+0x214>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80775d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807760:	83 f8 20             	cmp    $0x20,%eax
  807763:	74 11                	je     807776 <lwip_setsockopt_internal+0xb3>
  807765:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80776a:	74 64                	je     8077d0 <lwip_setsockopt_internal+0x10d>
  80776c:	83 f8 08             	cmp    $0x8,%eax
  80776f:	74 05                	je     807776 <lwip_setsockopt_internal+0xb3>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  807771:	e9 61 01 00 00       	jmpq   8078d7 <lwip_setsockopt_internal+0x214>
      if (*(int*)optval) {
  807776:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80777a:	8b 00                	mov    (%rax),%eax
  80777c:	85 c0                	test   %eax,%eax
  80777e:	74 27                	je     8077a7 <lwip_setsockopt_internal+0xe4>
        sock->conn->pcb.ip->so_options |= optname;
  807780:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807784:	48 8b 00             	mov    (%rax),%rax
  807787:	48 8b 40 08          	mov    0x8(%rax),%rax
  80778b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80778f:	48 8b 12             	mov    (%rdx),%rdx
  807792:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807796:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  80779a:	89 d1                	mov    %edx,%ecx
  80779c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80779f:	09 ca                	or     %ecx,%edx
  8077a1:	66 89 50 08          	mov    %dx,0x8(%rax)
      break;
  8077a5:	eb 76                	jmp    80781d <lwip_setsockopt_internal+0x15a>
        sock->conn->pcb.ip->so_options &= ~optname;
  8077a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8077ab:	48 8b 00             	mov    (%rax),%rax
  8077ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  8077b2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8077b6:	48 8b 12             	mov    (%rdx),%rdx
  8077b9:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8077bd:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  8077c1:	89 d1                	mov    %edx,%ecx
  8077c3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8077c6:	f7 d2                	not    %edx
  8077c8:	21 ca                	and    %ecx,%edx
  8077ca:	66 89 50 08          	mov    %dx,0x8(%rax)
      break;
  8077ce:	eb 4d                	jmp    80781d <lwip_setsockopt_internal+0x15a>
      if (*(int*)optval) {
  8077d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8077d4:	8b 00                	mov    (%rax),%eax
  8077d6:	85 c0                	test   %eax,%eax
  8077d8:	74 22                	je     8077fc <lwip_setsockopt_internal+0x139>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8077da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8077de:	48 8b 00             	mov    (%rax),%rax
  8077e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8077e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8077e9:	48 8b 12             	mov    (%rdx),%rdx
  8077ec:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8077f0:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8077f4:	83 ca 01             	or     $0x1,%edx
  8077f7:	88 50 18             	mov    %dl,0x18(%rax)
      break;
  8077fa:	eb 20                	jmp    80781c <lwip_setsockopt_internal+0x159>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  8077fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807800:	48 8b 00             	mov    (%rax),%rax
  807803:	48 8b 40 08          	mov    0x8(%rax),%rax
  807807:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80780b:	48 8b 12             	mov    (%rdx),%rdx
  80780e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807812:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  807816:	83 e2 fe             	and    $0xfffffffe,%edx
  807819:	88 50 18             	mov    %dl,0x18(%rax)
      break;
  80781c:	90                   	nop
    break;
  80781d:	e9 b5 00 00 00       	jmpq   8078d7 <lwip_setsockopt_internal+0x214>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807822:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807825:	83 f8 01             	cmp    $0x1,%eax
  807828:	74 20                	je     80784a <lwip_setsockopt_internal+0x187>
  80782a:	83 f8 02             	cmp    $0x2,%eax
  80782d:	74 05                	je     807834 <lwip_setsockopt_internal+0x171>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  80782f:	e9 a3 00 00 00       	jmpq   8078d7 <lwip_setsockopt_internal+0x214>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  807834:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807838:	48 8b 00             	mov    (%rax),%rax
  80783b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80783f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  807843:	8b 12                	mov    (%rdx),%edx
  807845:	88 50 0b             	mov    %dl,0xb(%rax)
      break;
  807848:	eb 15                	jmp    80785f <lwip_setsockopt_internal+0x19c>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  80784a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80784e:	48 8b 00             	mov    (%rax),%rax
  807851:	48 8b 40 08          	mov    0x8(%rax),%rax
  807855:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  807859:	8b 12                	mov    (%rdx),%edx
  80785b:	88 50 0a             	mov    %dl,0xa(%rax)
      break;
  80785e:	90                   	nop
    break;
  80785f:	eb 76                	jmp    8078d7 <lwip_setsockopt_internal+0x214>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807861:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807864:	83 f8 01             	cmp    $0x1,%eax
  807867:	74 07                	je     807870 <lwip_setsockopt_internal+0x1ad>
  807869:	83 f8 02             	cmp    $0x2,%eax
  80786c:	74 50                	je     8078be <lwip_setsockopt_internal+0x1fb>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  80786e:	eb 66                	jmp    8078d6 <lwip_setsockopt_internal+0x213>
      if (*(int*)optval) {
  807870:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807874:	8b 00                	mov    (%rax),%eax
  807876:	85 c0                	test   %eax,%eax
  807878:	74 22                	je     80789c <lwip_setsockopt_internal+0x1d9>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80787a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80787e:	48 8b 00             	mov    (%rax),%rax
  807881:	48 8b 40 08          	mov    0x8(%rax),%rax
  807885:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807889:	48 8b 12             	mov    (%rdx),%rdx
  80788c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807890:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  807894:	83 ca 40             	or     $0x40,%edx
  807897:	88 50 2c             	mov    %dl,0x2c(%rax)
      break;
  80789a:	eb 3a                	jmp    8078d6 <lwip_setsockopt_internal+0x213>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80789c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078a0:	48 8b 00             	mov    (%rax),%rax
  8078a3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8078a7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8078ab:	48 8b 12             	mov    (%rdx),%rdx
  8078ae:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8078b2:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  8078b6:	83 e2 bf             	and    $0xffffffbf,%edx
  8078b9:	88 50 2c             	mov    %dl,0x2c(%rax)
      break;
  8078bc:	eb 18                	jmp    8078d6 <lwip_setsockopt_internal+0x213>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8078be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078c2:	48 8b 00             	mov    (%rax),%rax
  8078c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8078c9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8078cd:	8b 12                	mov    (%rdx),%edx
  8078cf:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      break;
  8078d5:	90                   	nop
    break;
  8078d6:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8078d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078db:	48 8b 00             	mov    (%rax),%rax
  8078de:	8b 40 14             	mov    0x14(%rax),%eax
  8078e1:	89 c7                	mov    %eax,%edi
  8078e3:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  8078ea:	00 00 00 
  8078ed:	ff d0                	callq  *%rax
}
  8078ef:	c9                   	leaveq 
  8078f0:	c3                   	retq   

00000000008078f1 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8078f1:	55                   	push   %rbp
  8078f2:	48 89 e5             	mov    %rsp,%rbp
  8078f5:	48 83 ec 28          	sub    $0x28,%rsp
  8078f9:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8078fc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  807900:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807904:	8b 45 ec             	mov    -0x14(%rbp),%eax
  807907:	89 c7                	mov    %eax,%edi
  807909:	48 b8 58 51 80 00 00 	movabs $0x805158,%rax
  807910:	00 00 00 
  807913:	ff d0                	callq  *%rax
  807915:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  807919:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  80791f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807924:	75 0a                	jne    807930 <lwip_ioctl+0x3f>
    return -1;
  807926:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80792b:	e9 4d 01 00 00       	jmpq   807a7d <lwip_ioctl+0x18c>

  switch (cmd) {
  807930:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  807934:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  80793a:	74 13                	je     80794f <lwip_ioctl+0x5e>
  80793c:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  807941:	48 39 d0             	cmp    %rdx,%rax
  807944:	0f 84 ae 00 00 00    	je     8079f8 <lwip_ioctl+0x107>
  80794a:	e9 0b 01 00 00       	jmpq   807a5a <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  80794f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  807954:	75 28                	jne    80797e <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  807956:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80795a:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  807961:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807965:	8b 50 18             	mov    0x18(%rax),%edx
  807968:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  80796f:	00 00 00 
  807972:	89 10                	mov    %edx,(%rax)
      return -1;
  807974:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807979:	e9 ff 00 00 00       	jmpq   807a7d <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80797e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807982:	48 8b 00             	mov    (%rax),%rax
  807985:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  807989:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80798d:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  807990:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807994:	48 8b 40 08          	mov    0x8(%rax),%rax
  807998:	48 85 c0             	test   %rax,%rax
  80799b:	74 33                	je     8079d0 <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  80799d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079a1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8079a5:	48 8b 00             	mov    (%rax),%rax
  8079a8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8079ac:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  8079b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079b4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8079b8:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  8079bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8079c0:	0f b7 10             	movzwl (%rax),%edx
  8079c3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8079c7:	01 c2                	add    %eax,%edx
  8079c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8079cd:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8079d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079d4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8079db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079df:	8b 50 18             	mov    0x18(%rax),%edx
  8079e2:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  8079e9:	00 00 00 
  8079ec:	89 10                	mov    %edx,(%rax)
    return 0;
  8079ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8079f3:	e9 85 00 00 00       	jmpq   807a7d <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8079f8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8079fd:	74 21                	je     807a20 <lwip_ioctl+0x12f>
  8079ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807a03:	8b 00                	mov    (%rax),%eax
  807a05:	85 c0                	test   %eax,%eax
  807a07:	74 17                	je     807a20 <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  807a09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a0d:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  807a11:	80 cc 08             	or     $0x8,%ah
  807a14:	89 c2                	mov    %eax,%edx
  807a16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a1a:	66 89 50 16          	mov    %dx,0x16(%rax)
  807a1e:	eb 15                	jmp    807a35 <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  807a20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a24:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  807a28:	80 e4 f7             	and    $0xf7,%ah
  807a2b:	89 c2                	mov    %eax,%edx
  807a2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a31:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  807a35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a39:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  807a40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a44:	8b 50 18             	mov    0x18(%rax),%edx
  807a47:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  807a4e:	00 00 00 
  807a51:	89 10                	mov    %edx,(%rax)
    return 0;
  807a53:	b8 00 00 00 00       	mov    $0x0,%eax
  807a58:	eb 23                	jmp    807a7d <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  807a5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a5e:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  807a65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a69:	8b 50 18             	mov    0x18(%rax),%edx
  807a6c:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  807a73:	00 00 00 
  807a76:	89 10                	mov    %edx,(%rax)
    return -1;
  807a78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  807a7d:	c9                   	leaveq 
  807a7e:	c3                   	retq   

0000000000807a7f <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  807a7f:	55                   	push   %rbp
  807a80:	48 89 e5             	mov    %rsp,%rbp
  807a83:	48 83 ec 10          	sub    $0x10,%rsp
  807a87:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  807a8b:	48 b8 3b e0 80 00 00 	movabs $0x80e03b,%rax
  807a92:	00 00 00 
  807a95:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  807a97:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  807a9e:	00 00 00 
  807aa1:	48 8b 00             	mov    (%rax),%rax
  807aa4:	48 85 c0             	test   %rax,%rax
  807aa7:	75 12                	jne    807abb <tcpip_tcp_timer+0x3c>
  807aa9:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  807ab0:	00 00 00 
  807ab3:	48 8b 00             	mov    (%rax),%rax
  807ab6:	48 85 c0             	test   %rax,%rax
  807ab9:	74 22                	je     807add <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  807abb:	ba 00 00 00 00       	mov    $0x0,%edx
  807ac0:	48 be 7f 7a 80 00 00 	movabs $0x807a7f,%rsi
  807ac7:	00 00 00 
  807aca:	bf fa 00 00 00       	mov    $0xfa,%edi
  807acf:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807ad6:	00 00 00 
  807ad9:	ff d0                	callq  *%rax
  807adb:	eb 10                	jmp    807aed <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  807add:	48 b8 e0 84 82 00 00 	movabs $0x8284e0,%rax
  807ae4:	00 00 00 
  807ae7:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  807aed:	c9                   	leaveq 
  807aee:	c3                   	retq   

0000000000807aef <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  807aef:	55                   	push   %rbp
  807af0:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  807af3:	48 b8 e0 84 82 00 00 	movabs $0x8284e0,%rax
  807afa:	00 00 00 
  807afd:	8b 00                	mov    (%rax),%eax
  807aff:	85 c0                	test   %eax,%eax
  807b01:	75 54                	jne    807b57 <tcp_timer_needed+0x68>
  807b03:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  807b0a:	00 00 00 
  807b0d:	48 8b 00             	mov    (%rax),%rax
  807b10:	48 85 c0             	test   %rax,%rax
  807b13:	75 12                	jne    807b27 <tcp_timer_needed+0x38>
  807b15:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  807b1c:	00 00 00 
  807b1f:	48 8b 00             	mov    (%rax),%rax
  807b22:	48 85 c0             	test   %rax,%rax
  807b25:	74 30                	je     807b57 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  807b27:	48 b8 e0 84 82 00 00 	movabs $0x8284e0,%rax
  807b2e:	00 00 00 
  807b31:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  807b37:	ba 00 00 00 00       	mov    $0x0,%edx
  807b3c:	48 be 7f 7a 80 00 00 	movabs $0x807a7f,%rsi
  807b43:	00 00 00 
  807b46:	bf fa 00 00 00       	mov    $0xfa,%edi
  807b4b:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807b52:	00 00 00 
  807b55:	ff d0                	callq  *%rax
  }
}
  807b57:	5d                   	pop    %rbp
  807b58:	c3                   	retq   

0000000000807b59 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  807b59:	55                   	push   %rbp
  807b5a:	48 89 e5             	mov    %rsp,%rbp
  807b5d:	48 83 ec 10          	sub    $0x10,%rsp
  807b61:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  807b65:	48 b8 70 0a 81 00 00 	movabs $0x810a70,%rax
  807b6c:	00 00 00 
  807b6f:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  807b71:	ba 00 00 00 00       	mov    $0x0,%edx
  807b76:	48 be 59 7b 80 00 00 	movabs $0x807b59,%rsi
  807b7d:	00 00 00 
  807b80:	bf e8 03 00 00       	mov    $0x3e8,%edi
  807b85:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807b8c:	00 00 00 
  807b8f:	ff d0                	callq  *%rax
}
  807b91:	c9                   	leaveq 
  807b92:	c3                   	retq   

0000000000807b93 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  807b93:	55                   	push   %rbp
  807b94:	48 89 e5             	mov    %rsp,%rbp
  807b97:	48 83 ec 10          	sub    $0x10,%rsp
  807b9b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  807b9f:	48 b8 2a 4f 81 00 00 	movabs $0x814f2a,%rax
  807ba6:	00 00 00 
  807ba9:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  807bab:	ba 00 00 00 00       	mov    $0x0,%edx
  807bb0:	48 be 93 7b 80 00 00 	movabs $0x807b93,%rsi
  807bb7:	00 00 00 
  807bba:	bf 88 13 00 00       	mov    $0x1388,%edi
  807bbf:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807bc6:	00 00 00 
  807bc9:	ff d0                	callq  *%rax
}
  807bcb:	c9                   	leaveq 
  807bcc:	c3                   	retq   

0000000000807bcd <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  807bcd:	55                   	push   %rbp
  807bce:	48 89 e5             	mov    %rsp,%rbp
  807bd1:	48 83 ec 10          	sub    $0x10,%rsp
  807bd5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  807bd9:	48 b8 08 8d 80 00 00 	movabs $0x808d08,%rax
  807be0:	00 00 00 
  807be3:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  807be5:	ba 00 00 00 00       	mov    $0x0,%edx
  807bea:	48 be cd 7b 80 00 00 	movabs $0x807bcd,%rsi
  807bf1:	00 00 00 
  807bf4:	bf 60 ea 00 00       	mov    $0xea60,%edi
  807bf9:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807c00:	00 00 00 
  807c03:	ff d0                	callq  *%rax
}
  807c05:	c9                   	leaveq 
  807c06:	c3                   	retq   

0000000000807c07 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  807c07:	55                   	push   %rbp
  807c08:	48 89 e5             	mov    %rsp,%rbp
  807c0b:	48 83 ec 10          	sub    $0x10,%rsp
  807c0f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  807c13:	48 b8 9e 8d 80 00 00 	movabs $0x808d9e,%rax
  807c1a:	00 00 00 
  807c1d:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  807c1f:	ba 00 00 00 00       	mov    $0x0,%edx
  807c24:	48 be 07 7c 80 00 00 	movabs $0x807c07,%rsi
  807c2b:	00 00 00 
  807c2e:	bf f4 01 00 00       	mov    $0x1f4,%edi
  807c33:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807c3a:	00 00 00 
  807c3d:	ff d0                	callq  *%rax
}
  807c3f:	c9                   	leaveq 
  807c40:	c3                   	retq   

0000000000807c41 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  807c41:	55                   	push   %rbp
  807c42:	48 89 e5             	mov    %rsp,%rbp
  807c45:	48 83 ec 20          	sub    $0x20,%rsp
  807c49:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  807c4d:	ba 00 00 00 00       	mov    $0x0,%edx
  807c52:	48 be 59 7b 80 00 00 	movabs $0x807b59,%rsi
  807c59:	00 00 00 
  807c5c:	bf e8 03 00 00       	mov    $0x3e8,%edi
  807c61:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807c68:	00 00 00 
  807c6b:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  807c6d:	ba 00 00 00 00       	mov    $0x0,%edx
  807c72:	48 be 93 7b 80 00 00 	movabs $0x807b93,%rsi
  807c79:	00 00 00 
  807c7c:	bf 88 13 00 00       	mov    $0x1388,%edi
  807c81:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807c88:	00 00 00 
  807c8b:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  807c8d:	ba 00 00 00 00       	mov    $0x0,%edx
  807c92:	48 be cd 7b 80 00 00 	movabs $0x807bcd,%rsi
  807c99:	00 00 00 
  807c9c:	bf 60 ea 00 00       	mov    $0xea60,%edi
  807ca1:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807ca8:	00 00 00 
  807cab:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  807cad:	ba 00 00 00 00       	mov    $0x0,%edx
  807cb2:	48 be 07 7c 80 00 00 	movabs $0x807c07,%rsi
  807cb9:	00 00 00 
  807cbc:	bf f4 01 00 00       	mov    $0x1f4,%edi
  807cc1:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807cc8:	00 00 00 
  807ccb:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  807ccd:	48 b8 d0 84 82 00 00 	movabs $0x8284d0,%rax
  807cd4:	00 00 00 
  807cd7:	48 8b 00             	mov    (%rax),%rax
  807cda:	48 85 c0             	test   %rax,%rax
  807cdd:	74 1f                	je     807cfe <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  807cdf:	48 b8 d0 84 82 00 00 	movabs $0x8284d0,%rax
  807ce6:	00 00 00 
  807ce9:	48 8b 00             	mov    (%rax),%rax
  807cec:	48 ba d8 84 82 00 00 	movabs $0x8284d8,%rdx
  807cf3:	00 00 00 
  807cf6:	48 8b 12             	mov    (%rdx),%rdx
  807cf9:	48 89 d7             	mov    %rdx,%rdi
  807cfc:	ff d0                	callq  *%rax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  807cfe:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  807d05:	00 00 00 
  807d08:	8b 00                	mov    (%rax),%eax
  807d0a:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  807d0e:	48 89 d6             	mov    %rdx,%rsi
  807d11:	89 c7                	mov    %eax,%edi
  807d13:	48 b8 cf d9 80 00 00 	movabs $0x80d9cf,%rax
  807d1a:	00 00 00 
  807d1d:	ff d0                	callq  *%rax
    switch (msg->type) {
  807d1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d23:	8b 00                	mov    (%rax),%eax
  807d25:	83 f8 01             	cmp    $0x1,%eax
  807d28:	74 3d                	je     807d67 <tcpip_thread+0x126>
  807d2a:	83 f8 01             	cmp    $0x1,%eax
  807d2d:	72 17                	jb     807d46 <tcpip_thread+0x105>
  807d2f:	83 f8 02             	cmp    $0x2,%eax
  807d32:	0f 84 a8 00 00 00    	je     807de0 <tcpip_thread+0x19f>
  807d38:	83 f8 03             	cmp    $0x3,%eax
  807d3b:	0f 84 ce 00 00 00    	je     807e0f <tcpip_thread+0x1ce>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    default:
      break;
  807d41:	e9 3a 01 00 00       	jmpq   807e80 <tcpip_thread+0x23f>
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  807d46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d4a:	48 8b 40 10          	mov    0x10(%rax),%rax
  807d4e:	48 8b 00             	mov    (%rax),%rax
  807d51:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  807d55:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  807d59:	48 83 c2 08          	add    $0x8,%rdx
  807d5d:	48 89 d7             	mov    %rdx,%rdi
  807d60:	ff d0                	callq  *%rax
      break;
  807d62:	e9 19 01 00 00       	jmpq   807e80 <tcpip_thread+0x23f>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  807d67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d6b:	48 8b 40 18          	mov    0x18(%rax),%rax
  807d6f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  807d73:	0f b6 c0             	movzbl %al,%eax
  807d76:	83 e0 20             	and    $0x20,%eax
  807d79:	85 c0                	test   %eax,%eax
  807d7b:	74 24                	je     807da1 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  807d7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d81:	48 8b 50 18          	mov    0x18(%rax),%rdx
  807d85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d89:	48 8b 40 10          	mov    0x10(%rax),%rax
  807d8d:	48 89 d6             	mov    %rdx,%rsi
  807d90:	48 89 c7             	mov    %rax,%rdi
  807d93:	48 b8 da 67 81 00 00 	movabs $0x8167da,%rax
  807d9a:	00 00 00 
  807d9d:	ff d0                	callq  *%rax
  807d9f:	eb 22                	jmp    807dc3 <tcpip_thread+0x182>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  807da1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807da5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  807da9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807dad:	48 8b 40 10          	mov    0x10(%rax),%rax
  807db1:	48 89 d6             	mov    %rdx,%rsi
  807db4:	48 89 c7             	mov    %rax,%rdi
  807db7:	48 b8 a6 02 81 00 00 	movabs $0x8102a6,%rax
  807dbe:	00 00 00 
  807dc1:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  807dc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807dc7:	48 89 c6             	mov    %rax,%rsi
  807dca:	bf 09 00 00 00       	mov    $0x9,%edi
  807dcf:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  807dd6:	00 00 00 
  807dd9:	ff d0                	callq  *%rax
      break;
  807ddb:	e9 a0 00 00 00       	jmpq   807e80 <tcpip_thread+0x23f>
      msg->msg.cb.f(msg->msg.cb.ctx);
  807de0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807de4:	48 8b 40 10          	mov    0x10(%rax),%rax
  807de8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  807dec:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  807df0:	48 89 d7             	mov    %rdx,%rdi
  807df3:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  807df5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807df9:	48 89 c6             	mov    %rax,%rsi
  807dfc:	bf 08 00 00 00       	mov    $0x8,%edi
  807e01:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  807e08:	00 00 00 
  807e0b:	ff d0                	callq  *%rax
      break;
  807e0d:	eb 71                	jmp    807e80 <tcpip_thread+0x23f>
      if(msg->msg.tmo.msecs != 0xffffffff)
  807e0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e13:	8b 40 10             	mov    0x10(%rax),%eax
  807e16:	83 f8 ff             	cmp    $0xffffffff,%eax
  807e19:	74 2a                	je     807e45 <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  807e1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e1f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  807e23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e27:	48 8b 48 18          	mov    0x18(%rax),%rcx
  807e2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e2f:	8b 40 10             	mov    0x10(%rax),%eax
  807e32:	48 89 ce             	mov    %rcx,%rsi
  807e35:	89 c7                	mov    %eax,%edi
  807e37:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  807e3e:	00 00 00 
  807e41:	ff d0                	callq  *%rax
  807e43:	eb 22                	jmp    807e67 <tcpip_thread+0x226>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  807e45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e49:	48 8b 50 20          	mov    0x20(%rax),%rdx
  807e4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e51:	48 8b 40 18          	mov    0x18(%rax),%rax
  807e55:	48 89 d6             	mov    %rdx,%rsi
  807e58:	48 89 c7             	mov    %rax,%rdi
  807e5b:	48 b8 0b de 80 00 00 	movabs $0x80de0b,%rax
  807e62:	00 00 00 
  807e65:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  807e67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e6b:	48 89 c6             	mov    %rax,%rsi
  807e6e:	bf 08 00 00 00       	mov    $0x8,%edi
  807e73:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  807e7a:	00 00 00 
  807e7d:	ff d0                	callq  *%rax
      break;
  807e7f:	90                   	nop
    }
  }
  807e80:	e9 79 fe ff ff       	jmpq   807cfe <tcpip_thread+0xbd>

0000000000807e85 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  807e85:	55                   	push   %rbp
  807e86:	48 89 e5             	mov    %rsp,%rbp
  807e89:	48 83 ec 20          	sub    $0x20,%rsp
  807e8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  807e91:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  807e95:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  807e9c:	00 00 00 
  807e9f:	8b 00                	mov    (%rax),%eax
  807ea1:	83 f8 ff             	cmp    $0xffffffff,%eax
  807ea4:	0f 84 90 00 00 00    	je     807f3a <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  807eaa:	bf 09 00 00 00       	mov    $0x9,%edi
  807eaf:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  807eb6:	00 00 00 
  807eb9:	ff d0                	callq  *%rax
  807ebb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  807ebf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807ec4:	75 07                	jne    807ecd <tcpip_input+0x48>
      return ERR_MEM;
  807ec6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ecb:	eb 72                	jmp    807f3f <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  807ecd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807ed1:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  807ed7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807edb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807edf:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  807ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807ee7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  807eeb:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  807eef:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  807ef6:	00 00 00 
  807ef9:	8b 00                	mov    (%rax),%eax
  807efb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  807eff:	48 89 d6             	mov    %rdx,%rsi
  807f02:	89 c7                	mov    %eax,%edi
  807f04:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  807f0b:	00 00 00 
  807f0e:	ff d0                	callq  *%rax
  807f10:	84 c0                	test   %al,%al
  807f12:	74 1f                	je     807f33 <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  807f14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f18:	48 89 c6             	mov    %rax,%rsi
  807f1b:	bf 09 00 00 00       	mov    $0x9,%edi
  807f20:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  807f27:	00 00 00 
  807f2a:	ff d0                	callq  *%rax
      return ERR_MEM;
  807f2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f31:	eb 0c                	jmp    807f3f <tcpip_input+0xba>
    }
    return ERR_OK;
  807f33:	b8 00 00 00 00       	mov    $0x0,%eax
  807f38:	eb 05                	jmp    807f3f <tcpip_input+0xba>
  }
  return ERR_VAL;
  807f3a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  807f3f:	c9                   	leaveq 
  807f40:	c3                   	retq   

0000000000807f41 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  807f41:	55                   	push   %rbp
  807f42:	48 89 e5             	mov    %rsp,%rbp
  807f45:	48 83 ec 30          	sub    $0x30,%rsp
  807f49:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  807f4d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  807f51:	89 d0                	mov    %edx,%eax
  807f53:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  807f56:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  807f5d:	00 00 00 
  807f60:	8b 00                	mov    (%rax),%eax
  807f62:	83 f8 ff             	cmp    $0xffffffff,%eax
  807f65:	0f 84 bc 00 00 00    	je     808027 <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  807f6b:	bf 08 00 00 00       	mov    $0x8,%edi
  807f70:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  807f77:	00 00 00 
  807f7a:	ff d0                	callq  *%rax
  807f7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  807f80:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807f85:	75 0a                	jne    807f91 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  807f87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f8c:	e9 9b 00 00 00       	jmpq   80802c <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  807f91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f95:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  807f9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f9f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807fa3:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  807fa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fab:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  807faf:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  807fb3:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  807fb7:	74 23                	je     807fdc <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  807fb9:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  807fc0:	00 00 00 
  807fc3:	8b 00                	mov    (%rax),%eax
  807fc5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  807fc9:	48 89 d6             	mov    %rdx,%rsi
  807fcc:	89 c7                	mov    %eax,%edi
  807fce:	48 b8 a3 6f 81 00 00 	movabs $0x816fa3,%rax
  807fd5:	00 00 00 
  807fd8:	ff d0                	callq  *%rax
  807fda:	eb 44                	jmp    808020 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  807fdc:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  807fe3:	00 00 00 
  807fe6:	8b 00                	mov    (%rax),%eax
  807fe8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  807fec:	48 89 d6             	mov    %rdx,%rsi
  807fef:	89 c7                	mov    %eax,%edi
  807ff1:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  807ff8:	00 00 00 
  807ffb:	ff d0                	callq  *%rax
  807ffd:	84 c0                	test   %al,%al
  807fff:	74 1f                	je     808020 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  808001:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808005:	48 89 c6             	mov    %rax,%rsi
  808008:	bf 08 00 00 00       	mov    $0x8,%edi
  80800d:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  808014:	00 00 00 
  808017:	ff d0                	callq  *%rax
        return ERR_MEM;
  808019:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80801e:	eb 0c                	jmp    80802c <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808020:	b8 00 00 00 00       	mov    $0x0,%eax
  808025:	eb 05                	jmp    80802c <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  808027:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80802c:	c9                   	leaveq 
  80802d:	c3                   	retq   

000000000080802e <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80802e:	55                   	push   %rbp
  80802f:	48 89 e5             	mov    %rsp,%rbp
  808032:	48 83 ec 30          	sub    $0x30,%rsp
  808036:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808039:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80803d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808041:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  808048:	00 00 00 
  80804b:	8b 00                	mov    (%rax),%eax
  80804d:	83 f8 ff             	cmp    $0xffffffff,%eax
  808050:	74 77                	je     8080c9 <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808052:	bf 08 00 00 00       	mov    $0x8,%edi
  808057:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80805e:	00 00 00 
  808061:	ff d0                	callq  *%rax
  808063:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808067:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80806c:	75 07                	jne    808075 <tcpip_timeout+0x47>
      return ERR_MEM;
  80806e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808073:	eb 59                	jmp    8080ce <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  808075:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808079:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  80807f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808083:	8b 55 ec             	mov    -0x14(%rbp),%edx
  808086:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808089:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80808d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808091:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  808095:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808099:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80809d:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  8080a1:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  8080a8:	00 00 00 
  8080ab:	8b 00                	mov    (%rax),%eax
  8080ad:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8080b1:	48 89 d6             	mov    %rdx,%rsi
  8080b4:	89 c7                	mov    %eax,%edi
  8080b6:	48 b8 a3 6f 81 00 00 	movabs $0x816fa3,%rax
  8080bd:	00 00 00 
  8080c0:	ff d0                	callq  *%rax
    return ERR_OK;
  8080c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8080c7:	eb 05                	jmp    8080ce <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  8080c9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8080ce:	c9                   	leaveq 
  8080cf:	c3                   	retq   

00000000008080d0 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8080d0:	55                   	push   %rbp
  8080d1:	48 89 e5             	mov    %rsp,%rbp
  8080d4:	48 83 ec 40          	sub    $0x40,%rsp
  8080d8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8080dc:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  8080e3:	00 00 00 
  8080e6:	8b 00                	mov    (%rax),%eax
  8080e8:	83 f8 ff             	cmp    $0xffffffff,%eax
  8080eb:	74 55                	je     808142 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  8080ed:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  8080f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8080f8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  8080fc:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  808103:	00 00 00 
  808106:	8b 00                	mov    (%rax),%eax
  808108:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80810c:	48 89 d6             	mov    %rdx,%rsi
  80810f:	89 c7                	mov    %eax,%edi
  808111:	48 b8 a3 6f 81 00 00 	movabs $0x816fa3,%rax
  808118:	00 00 00 
  80811b:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80811d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808121:	48 8b 40 08          	mov    0x8(%rax),%rax
  808125:	8b 40 14             	mov    0x14(%rax),%eax
  808128:	be 00 00 00 00       	mov    $0x0,%esi
  80812d:	89 c7                	mov    %eax,%edi
  80812f:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  808136:	00 00 00 
  808139:	ff d0                	callq  *%rax
    return ERR_OK;
  80813b:	b8 00 00 00 00       	mov    $0x0,%eax
  808140:	eb 05                	jmp    808147 <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808142:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808147:	c9                   	leaveq 
  808148:	c3                   	retq   

0000000000808149 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808149:	55                   	push   %rbp
  80814a:	48 89 e5             	mov    %rsp,%rbp
  80814d:	48 83 ec 10          	sub    $0x10,%rsp
  808151:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808155:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808159:	48 b8 fc 87 80 00 00 	movabs $0x8087fc,%rax
  808160:	00 00 00 
  808163:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  808165:	48 b8 d0 84 82 00 00 	movabs $0x8284d0,%rax
  80816c:	00 00 00 
  80816f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808173:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  808176:	48 b8 d8 84 82 00 00 	movabs $0x8284d8,%rax
  80817d:	00 00 00 
  808180:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808184:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  808187:	bf 00 00 00 00       	mov    $0x0,%edi
  80818c:	48 b8 76 6b 81 00 00 	movabs $0x816b76,%rax
  808193:	00 00 00 
  808196:	ff d0                	callq  *%rax
  808198:	89 c2                	mov    %eax,%edx
  80819a:	48 b8 78 71 82 00 00 	movabs $0x827178,%rax
  8081a1:	00 00 00 
  8081a4:	89 10                	mov    %edx,(%rax)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8081a6:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8081ac:	b9 00 00 00 00       	mov    $0x0,%ecx
  8081b1:	ba 00 00 00 00       	mov    $0x0,%edx
  8081b6:	48 be 41 7c 80 00 00 	movabs $0x807c41,%rsi
  8081bd:	00 00 00 
  8081c0:	48 bf 13 0b 82 00 00 	movabs $0x820b13,%rdi
  8081c7:	00 00 00 
  8081ca:	48 b8 03 7b 81 00 00 	movabs $0x817b03,%rax
  8081d1:	00 00 00 
  8081d4:	ff d0                	callq  *%rax
}
  8081d6:	c9                   	leaveq 
  8081d7:	c3                   	retq   

00000000008081d8 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8081d8:	55                   	push   %rbp
  8081d9:	48 89 e5             	mov    %rsp,%rbp
  8081dc:	48 83 ec 20          	sub    $0x20,%rsp
  8081e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  8081e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8081e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  8081ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081f0:	48 89 c7             	mov    %rax,%rdi
  8081f3:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8081fa:	00 00 00 
  8081fd:	ff d0                	callq  *%rax
}
  8081ff:	c9                   	leaveq 
  808200:	c3                   	retq   

0000000000808201 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808201:	55                   	push   %rbp
  808202:	48 89 e5             	mov    %rsp,%rbp
  808205:	48 83 ec 10          	sub    $0x10,%rsp
  808209:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  80820d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808211:	ba 00 00 00 00       	mov    $0x0,%edx
  808216:	48 89 c6             	mov    %rax,%rsi
  808219:	48 bf d8 81 80 00 00 	movabs $0x8081d8,%rdi
  808220:	00 00 00 
  808223:	48 b8 41 7f 80 00 00 	movabs $0x807f41,%rax
  80822a:	00 00 00 
  80822d:	ff d0                	callq  *%rax
}
  80822f:	c9                   	leaveq 
  808230:	c3                   	retq   

0000000000808231 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808231:	55                   	push   %rbp
  808232:	48 89 e5             	mov    %rsp,%rbp
  808235:	48 83 ec 10          	sub    $0x10,%rsp
  808239:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  80823d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808241:	ba 00 00 00 00       	mov    $0x0,%edx
  808246:	48 89 c6             	mov    %rax,%rsi
  808249:	48 bf 1f b9 80 00 00 	movabs $0x80b91f,%rdi
  808250:	00 00 00 
  808253:	48 b8 41 7f 80 00 00 	movabs $0x807f41,%rax
  80825a:	00 00 00 
  80825d:	ff d0                	callq  *%rax
}
  80825f:	c9                   	leaveq 
  808260:	c3                   	retq   

0000000000808261 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808261:	55                   	push   %rbp
  808262:	48 89 e5             	mov    %rsp,%rbp
  808265:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808269:	bf 06 00 00 00       	mov    $0x6,%edi
  80826e:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  808275:	00 00 00 
  808278:	ff d0                	callq  *%rax
  80827a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  80827e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808283:	74 29                	je     8082ae <netbuf_new+0x4d>
    buf->p = NULL;
  808285:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808289:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808290:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808294:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80829b:	00 
    buf->addr = NULL;
  80829c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082a0:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8082a7:	00 
    return buf;
  8082a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082ac:	eb 05                	jmp    8082b3 <netbuf_new+0x52>
  } else {
    return NULL;
  8082ae:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  8082b3:	c9                   	leaveq 
  8082b4:	c3                   	retq   

00000000008082b5 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8082b5:	55                   	push   %rbp
  8082b6:	48 89 e5             	mov    %rsp,%rbp
  8082b9:	48 83 ec 10          	sub    $0x10,%rsp
  8082bd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  8082c1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8082c6:	74 55                	je     80831d <netbuf_delete+0x68>
    if (buf->p != NULL) {
  8082c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082cc:	48 8b 00             	mov    (%rax),%rax
  8082cf:	48 85 c0             	test   %rax,%rax
  8082d2:	74 31                	je     808305 <netbuf_delete+0x50>
      pbuf_free(buf->p);
  8082d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082d8:	48 8b 00             	mov    (%rax),%rax
  8082db:	48 89 c7             	mov    %rax,%rdi
  8082de:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8082e5:	00 00 00 
  8082e8:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  8082ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082ee:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8082f5:	00 
  8082f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082fa:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8082fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808302:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808309:	48 89 c6             	mov    %rax,%rsi
  80830c:	bf 06 00 00 00       	mov    $0x6,%edi
  808311:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  808318:	00 00 00 
  80831b:	ff d0                	callq  *%rax
  }
}
  80831d:	c9                   	leaveq 
  80831e:	c3                   	retq   

000000000080831f <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80831f:	55                   	push   %rbp
  808320:	48 89 e5             	mov    %rsp,%rbp
  808323:	48 83 ec 10          	sub    $0x10,%rsp
  808327:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80832b:	89 f0                	mov    %esi,%eax
  80832d:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808331:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808336:	75 2a                	jne    808362 <netbuf_alloc+0x43>
  808338:	48 ba 20 0b 82 00 00 	movabs $0x820b20,%rdx
  80833f:	00 00 00 
  808342:	be 63 00 00 00       	mov    $0x63,%esi
  808347:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  80834e:	00 00 00 
  808351:	b8 00 00 00 00       	mov    $0x0,%eax
  808356:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80835d:	00 00 00 
  808360:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808362:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808366:	48 8b 00             	mov    (%rax),%rax
  808369:	48 85 c0             	test   %rax,%rax
  80836c:	74 16                	je     808384 <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  80836e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808372:	48 8b 00             	mov    (%rax),%rax
  808375:	48 89 c7             	mov    %rax,%rdi
  808378:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80837f:	00 00 00 
  808382:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808384:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808388:	ba 00 00 00 00       	mov    $0x0,%edx
  80838d:	89 c6                	mov    %eax,%esi
  80838f:	bf 00 00 00 00       	mov    $0x0,%edi
  808394:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  80839b:	00 00 00 
  80839e:	ff d0                	callq  *%rax
  8083a0:	48 89 c2             	mov    %rax,%rdx
  8083a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083a7:	48 89 10             	mov    %rdx,(%rax)
  if (buf->p == NULL) {
  8083aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083ae:	48 8b 00             	mov    (%rax),%rax
  8083b1:	48 85 c0             	test   %rax,%rax
  8083b4:	75 07                	jne    8083bd <netbuf_alloc+0x9e>
     return NULL;
  8083b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8083bb:	eb 55                	jmp    808412 <netbuf_alloc+0xf3>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8083bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083c1:	48 8b 00             	mov    (%rax),%rax
  8083c4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8083c8:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  8083cc:	73 2a                	jae    8083f8 <netbuf_alloc+0xd9>
  8083ce:	48 ba 50 0b 82 00 00 	movabs $0x820b50,%rdx
  8083d5:	00 00 00 
  8083d8:	be 6e 00 00 00       	mov    $0x6e,%esi
  8083dd:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  8083e4:	00 00 00 
  8083e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8083ec:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8083f3:	00 00 00 
  8083f6:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8083f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083fc:	48 8b 10             	mov    (%rax),%rdx
  8083ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808403:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  808407:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80840b:	48 8b 00             	mov    (%rax),%rax
  80840e:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  808412:	c9                   	leaveq 
  808413:	c3                   	retq   

0000000000808414 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  808414:	55                   	push   %rbp
  808415:	48 89 e5             	mov    %rsp,%rbp
  808418:	48 83 ec 10          	sub    $0x10,%rsp
  80841c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808420:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808425:	75 2a                	jne    808451 <netbuf_free+0x3d>
  808427:	48 ba 74 0b 82 00 00 	movabs $0x820b74,%rdx
  80842e:	00 00 00 
  808431:	be 7b 00 00 00       	mov    $0x7b,%esi
  808436:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  80843d:	00 00 00 
  808440:	b8 00 00 00 00       	mov    $0x0,%eax
  808445:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80844c:	00 00 00 
  80844f:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808455:	48 8b 00             	mov    (%rax),%rax
  808458:	48 85 c0             	test   %rax,%rax
  80845b:	74 16                	je     808473 <netbuf_free+0x5f>
    pbuf_free(buf->p);
  80845d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808461:	48 8b 00             	mov    (%rax),%rax
  808464:	48 89 c7             	mov    %rax,%rdi
  808467:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80846e:	00 00 00 
  808471:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  808473:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808477:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80847e:	00 
  80847f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808483:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808487:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80848b:	48 89 10             	mov    %rdx,(%rax)
}
  80848e:	c9                   	leaveq 
  80848f:	c3                   	retq   

0000000000808490 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  808490:	55                   	push   %rbp
  808491:	48 89 e5             	mov    %rsp,%rbp
  808494:	48 83 ec 20          	sub    $0x20,%rsp
  808498:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80849c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8084a0:	89 d0                	mov    %edx,%eax
  8084a2:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8084a6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8084ab:	75 2a                	jne    8084d7 <netbuf_ref+0x47>
  8084ad:	48 ba 8d 0b 82 00 00 	movabs $0x820b8d,%rdx
  8084b4:	00 00 00 
  8084b7:	be 8e 00 00 00       	mov    $0x8e,%esi
  8084bc:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  8084c3:	00 00 00 
  8084c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8084cb:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8084d2:	00 00 00 
  8084d5:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  8084d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084db:	48 8b 00             	mov    (%rax),%rax
  8084de:	48 85 c0             	test   %rax,%rax
  8084e1:	74 16                	je     8084f9 <netbuf_ref+0x69>
    pbuf_free(buf->p);
  8084e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084e7:	48 8b 00             	mov    (%rax),%rax
  8084ea:	48 89 c7             	mov    %rax,%rdi
  8084ed:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8084f4:	00 00 00 
  8084f7:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8084f9:	ba 02 00 00 00       	mov    $0x2,%edx
  8084fe:	be 00 00 00 00       	mov    $0x0,%esi
  808503:	bf 00 00 00 00       	mov    $0x0,%edi
  808508:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  80850f:	00 00 00 
  808512:	ff d0                	callq  *%rax
  808514:	48 89 c2             	mov    %rax,%rdx
  808517:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80851b:	48 89 10             	mov    %rdx,(%rax)
  if (buf->p == NULL) {
  80851e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808522:	48 8b 00             	mov    (%rax),%rax
  808525:	48 85 c0             	test   %rax,%rax
  808528:	75 13                	jne    80853d <netbuf_ref+0xad>
    buf->ptr = NULL;
  80852a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80852e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808535:	00 
    return ERR_MEM;
  808536:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80853b:	eb 41                	jmp    80857e <netbuf_ref+0xee>
  }
  buf->p->payload = (void*)dataptr;
  80853d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808541:	48 8b 00             	mov    (%rax),%rax
  808544:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808548:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  80854c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808550:	48 8b 10             	mov    (%rax),%rdx
  808553:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808557:	48 8b 00             	mov    (%rax),%rax
  80855a:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  80855e:	66 89 48 10          	mov    %cx,0x10(%rax)
  808562:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808566:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  80856a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80856e:	48 8b 10             	mov    (%rax),%rdx
  808571:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808575:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  808579:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80857e:	c9                   	leaveq 
  80857f:	c3                   	retq   

0000000000808580 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  808580:	55                   	push   %rbp
  808581:	48 89 e5             	mov    %rsp,%rbp
  808584:	48 83 ec 10          	sub    $0x10,%rsp
  808588:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80858c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  808590:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808595:	75 2a                	jne    8085c1 <netbuf_chain+0x41>
  808597:	48 ba a5 0b 82 00 00 	movabs $0x820ba5,%rdx
  80859e:	00 00 00 
  8085a1:	be a6 00 00 00       	mov    $0xa6,%esi
  8085a6:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  8085ad:	00 00 00 
  8085b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8085b5:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8085bc:	00 00 00 
  8085bf:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8085c1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8085c6:	75 2a                	jne    8085f2 <netbuf_chain+0x72>
  8085c8:	48 ba be 0b 82 00 00 	movabs $0x820bbe,%rdx
  8085cf:	00 00 00 
  8085d2:	be a7 00 00 00       	mov    $0xa7,%esi
  8085d7:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  8085de:	00 00 00 
  8085e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8085e6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8085ed:	00 00 00 
  8085f0:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  8085f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8085f6:	48 8b 10             	mov    (%rax),%rdx
  8085f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085fd:	48 8b 00             	mov    (%rax),%rax
  808600:	48 89 d6             	mov    %rdx,%rsi
  808603:	48 89 c7             	mov    %rax,%rdi
  808606:	48 b8 87 d4 80 00 00 	movabs $0x80d487,%rax
  80860d:	00 00 00 
  808610:	ff d0                	callq  *%rax
  head->ptr = head->p;
  808612:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808616:	48 8b 10             	mov    (%rax),%rdx
  808619:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80861d:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  808621:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808625:	48 89 c6             	mov    %rax,%rsi
  808628:	bf 06 00 00 00       	mov    $0x6,%edi
  80862d:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  808634:	00 00 00 
  808637:	ff d0                	callq  *%rax
}
  808639:	c9                   	leaveq 
  80863a:	c3                   	retq   

000000000080863b <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80863b:	55                   	push   %rbp
  80863c:	48 89 e5             	mov    %rsp,%rbp
  80863f:	48 83 ec 20          	sub    $0x20,%rsp
  808643:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808647:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80864b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80864f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808654:	75 2a                	jne    808680 <netbuf_data+0x45>
  808656:	48 ba d9 0b 82 00 00 	movabs $0x820bd9,%rdx
  80865d:	00 00 00 
  808660:	be b9 00 00 00       	mov    $0xb9,%esi
  808665:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  80866c:	00 00 00 
  80866f:	b8 00 00 00 00       	mov    $0x0,%eax
  808674:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80867b:	00 00 00 
  80867e:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  808680:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808685:	75 2a                	jne    8086b1 <netbuf_data+0x76>
  808687:	48 ba f2 0b 82 00 00 	movabs $0x820bf2,%rdx
  80868e:	00 00 00 
  808691:	be ba 00 00 00       	mov    $0xba,%esi
  808696:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  80869d:	00 00 00 
  8086a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8086a5:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8086ac:	00 00 00 
  8086af:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8086b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8086b6:	75 2a                	jne    8086e2 <netbuf_data+0xa7>
  8086b8:	48 ba 0f 0c 82 00 00 	movabs $0x820c0f,%rdx
  8086bf:	00 00 00 
  8086c2:	be bb 00 00 00       	mov    $0xbb,%esi
  8086c7:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  8086ce:	00 00 00 
  8086d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8086d6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8086dd:	00 00 00 
  8086e0:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  8086e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8086ea:	48 85 c0             	test   %rax,%rax
  8086ed:	75 07                	jne    8086f6 <netbuf_data+0xbb>
    return ERR_BUF;
  8086ef:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8086f4:	eb 2b                	jmp    808721 <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  8086f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8086fe:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808702:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808706:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  808709:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80870d:	48 8b 40 08          	mov    0x8(%rax),%rax
  808711:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  808715:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808719:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  80871c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808721:	c9                   	leaveq 
  808722:	c3                   	retq   

0000000000808723 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  808723:	55                   	push   %rbp
  808724:	48 89 e5             	mov    %rsp,%rbp
  808727:	48 83 ec 10          	sub    $0x10,%rsp
  80872b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80872f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808734:	75 2a                	jne    808760 <netbuf_next+0x3d>
  808736:	48 ba 74 0b 82 00 00 	movabs $0x820b74,%rdx
  80873d:	00 00 00 
  808740:	be d2 00 00 00       	mov    $0xd2,%esi
  808745:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  80874c:	00 00 00 
  80874f:	b8 00 00 00 00       	mov    $0x0,%eax
  808754:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80875b:	00 00 00 
  80875e:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  808760:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808764:	48 8b 40 08          	mov    0x8(%rax),%rax
  808768:	48 8b 00             	mov    (%rax),%rax
  80876b:	48 85 c0             	test   %rax,%rax
  80876e:	75 07                	jne    808777 <netbuf_next+0x54>
    return -1;
  808770:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808775:	eb 2f                	jmp    8087a6 <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  808777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80877b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80877f:	48 8b 10             	mov    (%rax),%rdx
  808782:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808786:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  80878a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80878e:	48 8b 40 08          	mov    0x8(%rax),%rax
  808792:	48 8b 00             	mov    (%rax),%rax
  808795:	48 85 c0             	test   %rax,%rax
  808798:	75 07                	jne    8087a1 <netbuf_next+0x7e>
    return 1;
  80879a:	b8 01 00 00 00       	mov    $0x1,%eax
  80879f:	eb 05                	jmp    8087a6 <netbuf_next+0x83>
  }
  return 0;
  8087a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8087a6:	c9                   	leaveq 
  8087a7:	c3                   	retq   

00000000008087a8 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8087a8:	55                   	push   %rbp
  8087a9:	48 89 e5             	mov    %rsp,%rbp
  8087ac:	48 83 ec 10          	sub    $0x10,%rsp
  8087b0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8087b4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8087b9:	75 2a                	jne    8087e5 <netbuf_first+0x3d>
  8087bb:	48 ba 74 0b 82 00 00 	movabs $0x820b74,%rdx
  8087c2:	00 00 00 
  8087c5:	be e7 00 00 00       	mov    $0xe7,%esi
  8087ca:	48 bf 3a 0b 82 00 00 	movabs $0x820b3a,%rdi
  8087d1:	00 00 00 
  8087d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8087d9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8087e0:	00 00 00 
  8087e3:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  8087e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087e9:	48 8b 10             	mov    (%rax),%rdx
  8087ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087f0:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  8087f4:	c9                   	leaveq 
  8087f5:	c3                   	retq   

00000000008087f6 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  8087f6:	55                   	push   %rbp
  8087f7:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  8087fa:	5d                   	pop    %rbp
  8087fb:	c3                   	retq   

00000000008087fc <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8087fc:	55                   	push   %rbp
  8087fd:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  808800:	48 b8 f6 87 80 00 00 	movabs $0x8087f6,%rax
  808807:	00 00 00 
  80880a:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  80880c:	48 b8 ec 68 81 00 00 	movabs $0x8168ec,%rax
  808813:	00 00 00 
  808816:	ff d0                	callq  *%rax
  mem_init();
  808818:	48 b8 33 b8 80 00 00 	movabs $0x80b833,%rax
  80881f:	00 00 00 
  808822:	ff d0                	callq  *%rax
  memp_init();
  808824:	48 b8 98 c1 80 00 00 	movabs $0x80c198,%rax
  80882b:	00 00 00 
  80882e:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  808830:	48 b8 14 51 80 00 00 	movabs $0x805114,%rax
  808837:	00 00 00 
  80883a:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80883c:	5d                   	pop    %rbp
  80883d:	c3                   	retq   

000000000080883e <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  80883e:	55                   	push   %rbp
  80883f:	48 89 e5             	mov    %rsp,%rbp
  808842:	48 83 ec 20          	sub    $0x20,%rsp
  808846:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80884a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80884e:	48 8b 40 38          	mov    0x38(%rax),%rax
  808852:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  808856:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80885a:	48 89 c7             	mov    %rax,%rdi
  80885d:	48 b8 31 c8 80 00 00 	movabs $0x80c831,%rax
  808864:	00 00 00 
  808867:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  808869:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80886d:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  808874:	00 00 00 
  808877:	48 89 c7             	mov    %rax,%rdi
  80887a:	48 b8 49 c6 80 00 00 	movabs $0x80c649,%rax
  808881:	00 00 00 
  808884:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  808886:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80888a:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  808891:	00 00 00 
  808894:	48 89 c7             	mov    %rax,%rdi
  808897:	48 b8 4f c7 80 00 00 	movabs $0x80c74f,%rax
  80889e:	00 00 00 
  8088a1:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8088a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8088a7:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  8088ae:	00 00 00 
  8088b1:	48 89 c7             	mov    %rax,%rdi
  8088b4:	48 b8 7c c7 80 00 00 	movabs $0x80c77c,%rax
  8088bb:	00 00 00 
  8088be:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8088c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088c4:	be 0c 00 00 00       	mov    $0xc,%esi
  8088c9:	48 89 c7             	mov    %rax,%rdi
  8088cc:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  8088d3:	00 00 00 
  8088d6:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  8088d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8088dc:	48 89 c7             	mov    %rax,%rdi
  8088df:	48 b8 02 9a 80 00 00 	movabs $0x809a02,%rax
  8088e6:	00 00 00 
  8088e9:	ff d0                	callq  *%rax
}
  8088eb:	c9                   	leaveq 
  8088ec:	c3                   	retq   

00000000008088ed <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8088ed:	55                   	push   %rbp
  8088ee:	48 89 e5             	mov    %rsp,%rbp
  8088f1:	48 83 ec 20          	sub    $0x20,%rsp
  8088f5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8088f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8088fd:	48 8b 40 38          	mov    0x38(%rax),%rax
  808901:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  808905:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808909:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  80890d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808911:	ba 00 00 00 00       	mov    $0x0,%edx
  808916:	48 89 ce             	mov    %rcx,%rsi
  808919:	48 89 c7             	mov    %rax,%rdi
  80891c:	48 b8 88 60 81 00 00 	movabs $0x816088,%rax
  808923:	00 00 00 
  808926:	ff d0                	callq  *%rax
  808928:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  80892b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80892f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808933:	8d 50 01             	lea    0x1(%rax),%edx
  808936:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80893a:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  80893d:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  808943:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808947:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80894d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808952:	89 c8                	mov    %ecx,%eax
  808954:	f7 ea                	imul   %edx
  808956:	c1 fa 05             	sar    $0x5,%edx
  808959:	89 c8                	mov    %ecx,%eax
  80895b:	c1 f8 1f             	sar    $0x1f,%eax
  80895e:	29 c2                	sub    %eax,%edx
  808960:	89 d0                	mov    %edx,%eax
  808962:	89 c2                	mov    %eax,%edx
  808964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808968:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80896c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808970:	be 08 00 00 00       	mov    $0x8,%esi
  808975:	48 89 c7             	mov    %rax,%rdi
  808978:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  80897f:	00 00 00 
  808982:	ff d0                	callq  *%rax
}
  808984:	c9                   	leaveq 
  808985:	c3                   	retq   

0000000000808986 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  808986:	55                   	push   %rbp
  808987:	48 89 e5             	mov    %rsp,%rbp
  80898a:	48 83 ec 20          	sub    $0x20,%rsp
  80898e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808996:	48 8b 40 38          	mov    0x38(%rax),%rax
  80899a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80899e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089a2:	be 36 00 00 00       	mov    $0x36,%esi
  8089a7:	48 89 c7             	mov    %rax,%rdi
  8089aa:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  8089b1:	00 00 00 
  8089b4:	ff d0                	callq  *%rax
  8089b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  8089ba:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8089bf:	74 6b                	je     808a2c <dhcp_handle_offer+0xa6>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8089c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8089c5:	48 83 c0 02          	add    $0x2,%rax
  8089c9:	48 89 c7             	mov    %rax,%rdi
  8089cc:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  8089d3:	00 00 00 
  8089d6:	ff d0                	callq  *%rax
  8089d8:	89 c7                	mov    %eax,%edi
  8089da:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  8089e1:	00 00 00 
  8089e4:	ff d0                	callq  *%rax
  8089e6:	89 c2                	mov    %eax,%edx
  8089e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089ec:	89 50 48             	mov    %edx,0x48(%rax)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8089ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089f3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8089f7:	48 83 c0 10          	add    $0x10,%rax
  8089fb:	48 85 c0             	test   %rax,%rax
  8089fe:	74 0d                	je     808a0d <dhcp_handle_offer+0x87>
  808a00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a04:	48 8b 40 18          	mov    0x18(%rax),%rax
  808a08:	8b 40 10             	mov    0x10(%rax),%eax
  808a0b:	eb 05                	jmp    808a12 <dhcp_handle_offer+0x8c>
  808a0d:	b8 00 00 00 00       	mov    $0x0,%eax
  808a12:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808a16:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  808a19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808a1d:	48 89 c7             	mov    %rax,%rdi
  808a20:	48 b8 2e 8a 80 00 00 	movabs $0x808a2e,%rax
  808a27:	00 00 00 
  808a2a:	ff d0                	callq  *%rax
  }
}
  808a2c:	c9                   	leaveq 
  808a2d:	c3                   	retq   

0000000000808a2e <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  808a2e:	55                   	push   %rbp
  808a2f:	48 89 e5             	mov    %rsp,%rbp
  808a32:	48 83 ec 20          	sub    $0x20,%rsp
  808a36:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808a3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808a3e:	48 8b 40 38          	mov    0x38(%rax),%rax
  808a42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  808a46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808a4a:	48 89 c7             	mov    %rax,%rdi
  808a4d:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  808a54:	00 00 00 
  808a57:	ff d0                	callq  *%rax
  808a59:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  808a5c:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  808a60:	0f 85 3a 02 00 00    	jne    808ca0 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  808a66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a6a:	ba 01 00 00 00       	mov    $0x1,%edx
  808a6f:	be 35 00 00 00       	mov    $0x35,%esi
  808a74:	48 89 c7             	mov    %rax,%rdi
  808a77:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  808a7e:	00 00 00 
  808a81:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  808a83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a87:	be 03 00 00 00       	mov    $0x3,%esi
  808a8c:	48 89 c7             	mov    %rax,%rdi
  808a8f:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  808a96:	00 00 00 
  808a99:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  808a9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a9f:	ba 02 00 00 00       	mov    $0x2,%edx
  808aa4:	be 39 00 00 00       	mov    $0x39,%esi
  808aa9:	48 89 c7             	mov    %rax,%rdi
  808aac:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  808ab3:	00 00 00 
  808ab6:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  808ab8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808abc:	be 40 02 00 00       	mov    $0x240,%esi
  808ac1:	48 89 c7             	mov    %rax,%rdi
  808ac4:	48 b8 3f a7 80 00 00 	movabs $0x80a73f,%rax
  808acb:	00 00 00 
  808ace:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  808ad0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ad4:	ba 04 00 00 00       	mov    $0x4,%edx
  808ad9:	be 32 00 00 00       	mov    $0x32,%esi
  808ade:	48 89 c7             	mov    %rax,%rdi
  808ae1:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  808ae8:	00 00 00 
  808aeb:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  808aed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808af1:	8b 40 4c             	mov    0x4c(%rax),%eax
  808af4:	89 c7                	mov    %eax,%edi
  808af6:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  808afd:	00 00 00 
  808b00:	ff d0                	callq  *%rax
  808b02:	89 c2                	mov    %eax,%edx
  808b04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b08:	89 d6                	mov    %edx,%esi
  808b0a:	48 89 c7             	mov    %rax,%rdi
  808b0d:	48 b8 ea a7 80 00 00 	movabs $0x80a7ea,%rax
  808b14:	00 00 00 
  808b17:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  808b19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b1d:	ba 04 00 00 00       	mov    $0x4,%edx
  808b22:	be 36 00 00 00       	mov    $0x36,%esi
  808b27:	48 89 c7             	mov    %rax,%rdi
  808b2a:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  808b31:	00 00 00 
  808b34:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  808b36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b3a:	8b 40 48             	mov    0x48(%rax),%eax
  808b3d:	89 c7                	mov    %eax,%edi
  808b3f:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  808b46:	00 00 00 
  808b49:	ff d0                	callq  *%rax
  808b4b:	89 c2                	mov    %eax,%edx
  808b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b51:	89 d6                	mov    %edx,%esi
  808b53:	48 89 c7             	mov    %rax,%rdi
  808b56:	48 b8 ea a7 80 00 00 	movabs $0x80a7ea,%rax
  808b5d:	00 00 00 
  808b60:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  808b62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b66:	ba 04 00 00 00       	mov    $0x4,%edx
  808b6b:	be 37 00 00 00       	mov    $0x37,%esi
  808b70:	48 89 c7             	mov    %rax,%rdi
  808b73:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  808b7a:	00 00 00 
  808b7d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  808b7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b83:	be 01 00 00 00       	mov    $0x1,%esi
  808b88:	48 89 c7             	mov    %rax,%rdi
  808b8b:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  808b92:	00 00 00 
  808b95:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  808b97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b9b:	be 03 00 00 00       	mov    $0x3,%esi
  808ba0:	48 89 c7             	mov    %rax,%rdi
  808ba3:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  808baa:	00 00 00 
  808bad:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  808baf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bb3:	be 1c 00 00 00       	mov    $0x1c,%esi
  808bb8:	48 89 c7             	mov    %rax,%rdi
  808bbb:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  808bc2:	00 00 00 
  808bc5:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  808bc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bcb:	be 06 00 00 00       	mov    $0x6,%esi
  808bd0:	48 89 c7             	mov    %rax,%rdi
  808bd3:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  808bda:	00 00 00 
  808bdd:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  808bdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808be3:	48 89 c7             	mov    %rax,%rdi
  808be6:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  808bed:	00 00 00 
  808bf0:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  808bf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bf6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  808bfa:	66 05 f0 00          	add    $0xf0,%ax
  808bfe:	0f b7 d0             	movzwl %ax,%edx
  808c01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c05:	48 8b 40 30          	mov    0x30(%rax),%rax
  808c09:	89 d6                	mov    %edx,%esi
  808c0b:	48 89 c7             	mov    %rax,%rdi
  808c0e:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  808c15:	00 00 00 
  808c18:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  808c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c1e:	48 8b 70 30          	mov    0x30(%rax),%rsi
  808c22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c26:	48 8b 40 08          	mov    0x8(%rax),%rax
  808c2a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808c2e:	49 89 d0             	mov    %rdx,%r8
  808c31:	b9 43 00 00 00       	mov    $0x43,%ecx
  808c36:	48 ba 2c 1a 82 00 00 	movabs $0x821a2c,%rdx
  808c3d:	00 00 00 
  808c40:	48 89 c7             	mov    %rax,%rdi
  808c43:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  808c4a:	00 00 00 
  808c4d:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  808c4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c53:	48 8b 40 08          	mov    0x8(%rax),%rax
  808c57:	ba 43 00 00 00       	mov    $0x43,%edx
  808c5c:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  808c63:	00 00 00 
  808c66:	48 89 c7             	mov    %rax,%rdi
  808c69:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  808c70:	00 00 00 
  808c73:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  808c75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808c79:	48 89 c7             	mov    %rax,%rdi
  808c7c:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  808c83:	00 00 00 
  808c86:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  808c88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c8c:	be 01 00 00 00       	mov    $0x1,%esi
  808c91:	48 89 c7             	mov    %rax,%rdi
  808c94:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  808c9b:	00 00 00 
  808c9e:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  808ca0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ca4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808ca8:	8d 50 01             	lea    0x1(%rax),%edx
  808cab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808caf:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  808cb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cb6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808cba:	3c 03                	cmp    $0x3,%al
  808cbc:	77 12                	ja     808cd0 <dhcp_select+0x2a2>
  808cbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cc2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808cc6:	0f b6 c0             	movzbl %al,%eax
  808cc9:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  808cce:	eb 05                	jmp    808cd5 <dhcp_select+0x2a7>
  808cd0:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  808cd5:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  808cd9:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808cdd:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  808ce3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808ce8:	89 c8                	mov    %ecx,%eax
  808cea:	f7 ea                	imul   %edx
  808cec:	c1 fa 05             	sar    $0x5,%edx
  808cef:	89 c8                	mov    %ecx,%eax
  808cf1:	c1 f8 1f             	sar    $0x1f,%eax
  808cf4:	29 c2                	sub    %eax,%edx
  808cf6:	89 d0                	mov    %edx,%eax
  808cf8:	89 c2                	mov    %eax,%edx
  808cfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cfe:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  808d02:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  808d06:	c9                   	leaveq 
  808d07:	c3                   	retq   

0000000000808d08 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  808d08:	55                   	push   %rbp
  808d09:	48 89 e5             	mov    %rsp,%rbp
  808d0c:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  808d10:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  808d17:	00 00 00 
  808d1a:	48 8b 00             	mov    (%rax),%rax
  808d1d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  808d21:	eb 72                	jmp    808d95 <dhcp_coarse_tmr+0x8d>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  808d23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d27:	48 8b 40 38          	mov    0x38(%rax),%rax
  808d2b:	48 85 c0             	test   %rax,%rax
  808d2e:	74 5a                	je     808d8a <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  808d30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d34:	48 8b 40 38          	mov    0x38(%rax),%rax
  808d38:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  808d3c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  808d3f:	66 89 48 46          	mov    %cx,0x46(%rax)
  808d43:	66 83 fa 01          	cmp    $0x1,%dx
  808d47:	75 15                	jne    808d5e <dhcp_coarse_tmr+0x56>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  808d49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d4d:	48 89 c7             	mov    %rax,%rdi
  808d50:	48 b8 df 8f 80 00 00 	movabs $0x808fdf,%rax
  808d57:	00 00 00 
  808d5a:	ff d0                	callq  *%rax
  808d5c:	eb 2c                	jmp    808d8a <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  808d5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d62:	48 8b 40 38          	mov    0x38(%rax),%rax
  808d66:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  808d6a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  808d6d:	66 89 48 44          	mov    %cx,0x44(%rax)
  808d71:	66 83 fa 01          	cmp    $0x1,%dx
  808d75:	75 13                	jne    808d8a <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  808d77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d7b:	48 89 c7             	mov    %rax,%rdi
  808d7e:	48 b8 91 8f 80 00 00 	movabs $0x808f91,%rax
  808d85:	00 00 00 
  808d88:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  808d8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d8e:	48 8b 00             	mov    (%rax),%rax
  808d91:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (netif != NULL) {
  808d95:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808d9a:	75 87                	jne    808d23 <dhcp_coarse_tmr+0x1b>
  }
}
  808d9c:	c9                   	leaveq 
  808d9d:	c3                   	retq   

0000000000808d9e <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  808d9e:	55                   	push   %rbp
  808d9f:	48 89 e5             	mov    %rsp,%rbp
  808da2:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  808da6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  808dad:	00 00 00 
  808db0:	48 8b 00             	mov    (%rax),%rax
  808db3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  808db7:	eb 77                	jmp    808e30 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  808db9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dbd:	48 8b 40 38          	mov    0x38(%rax),%rax
  808dc1:	48 85 c0             	test   %rax,%rax
  808dc4:	74 5f                	je     808e25 <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  808dc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dca:	48 8b 40 38          	mov    0x38(%rax),%rax
  808dce:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  808dd2:	66 83 f8 01          	cmp    $0x1,%ax
  808dd6:	76 15                	jbe    808ded <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  808dd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ddc:	48 8b 40 38          	mov    0x38(%rax),%rax
  808de0:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  808de4:	83 ea 01             	sub    $0x1,%edx
  808de7:	66 89 50 42          	mov    %dx,0x42(%rax)
  808deb:	eb 38                	jmp    808e25 <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  808ded:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808df1:	48 8b 40 38          	mov    0x38(%rax),%rax
  808df5:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  808df9:	66 83 f8 01          	cmp    $0x1,%ax
  808dfd:	75 26                	jne    808e25 <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  808dff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e03:	48 8b 40 38          	mov    0x38(%rax),%rax
  808e07:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  808e0b:	83 ea 01             	sub    $0x1,%edx
  808e0e:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  808e12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e16:	48 89 c7             	mov    %rax,%rdi
  808e19:	48 b8 39 8e 80 00 00 	movabs $0x808e39,%rax
  808e20:	00 00 00 
  808e23:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  808e25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e29:	48 8b 00             	mov    (%rax),%rax
  808e2c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (netif != NULL) {
  808e30:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e35:	75 82                	jne    808db9 <dhcp_fine_tmr+0x1b>
  }
}
  808e37:	c9                   	leaveq 
  808e38:	c3                   	retq   

0000000000808e39 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  808e39:	55                   	push   %rbp
  808e3a:	48 89 e5             	mov    %rsp,%rbp
  808e3d:	48 83 ec 20          	sub    $0x20,%rsp
  808e41:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808e45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e49:	48 8b 40 38          	mov    0x38(%rax),%rax
  808e4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  808e51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e55:	0f b6 00             	movzbl (%rax),%eax
  808e58:	3c 0c                	cmp    $0xc,%al
  808e5a:	74 0b                	je     808e67 <dhcp_timeout+0x2e>
  808e5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e60:	0f b6 00             	movzbl (%rax),%eax
  808e63:	3c 06                	cmp    $0x6,%al
  808e65:	75 18                	jne    808e7f <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  808e67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e6b:	48 89 c7             	mov    %rax,%rdi
  808e6e:	48 b8 02 9a 80 00 00 	movabs $0x809a02,%rax
  808e75:	00 00 00 
  808e78:	ff d0                	callq  *%rax
  808e7a:	e9 10 01 00 00       	jmpq   808f8f <dhcp_timeout+0x156>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  808e7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e83:	0f b6 00             	movzbl (%rax),%eax
  808e86:	3c 01                	cmp    $0x1,%al
  808e88:	75 4f                	jne    808ed9 <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  808e8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e8e:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808e92:	3c 05                	cmp    $0x5,%al
  808e94:	77 18                	ja     808eae <dhcp_timeout+0x75>
      dhcp_select(netif);
  808e96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e9a:	48 89 c7             	mov    %rax,%rdi
  808e9d:	48 b8 2e 8a 80 00 00 	movabs $0x808a2e,%rax
  808ea4:	00 00 00 
  808ea7:	ff d0                	callq  *%rax
  808ea9:	e9 e1 00 00 00       	jmpq   808f8f <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  808eae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808eb2:	48 89 c7             	mov    %rax,%rdi
  808eb5:	48 b8 7d a2 80 00 00 	movabs $0x80a27d,%rax
  808ebc:	00 00 00 
  808ebf:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  808ec1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808ec5:	48 89 c7             	mov    %rax,%rdi
  808ec8:	48 b8 02 9a 80 00 00 	movabs $0x809a02,%rax
  808ecf:	00 00 00 
  808ed2:	ff d0                	callq  *%rax
  808ed4:	e9 b6 00 00 00       	jmpq   808f8f <dhcp_timeout+0x156>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  808ed9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808edd:	0f b6 00             	movzbl (%rax),%eax
  808ee0:	3c 08                	cmp    $0x8,%al
  808ee2:	75 39                	jne    808f1d <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  808ee4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ee8:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808eec:	3c 01                	cmp    $0x1,%al
  808eee:	77 18                	ja     808f08 <dhcp_timeout+0xcf>
      dhcp_check(netif);
  808ef0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808ef4:	48 89 c7             	mov    %rax,%rdi
  808ef7:	48 b8 ed 88 80 00 00 	movabs $0x8088ed,%rax
  808efe:	00 00 00 
  808f01:	ff d0                	callq  *%rax
  808f03:	e9 87 00 00 00       	jmpq   808f8f <dhcp_timeout+0x156>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  808f08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f0c:	48 89 c7             	mov    %rax,%rdi
  808f0f:	48 b8 64 9c 80 00 00 	movabs $0x809c64,%rax
  808f16:	00 00 00 
  808f19:	ff d0                	callq  *%rax
  808f1b:	eb 72                	jmp    808f8f <dhcp_timeout+0x156>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  808f1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f21:	0f b6 00             	movzbl (%rax),%eax
  808f24:	3c 05                	cmp    $0x5,%al
  808f26:	75 15                	jne    808f3d <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  808f28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f2c:	48 89 c7             	mov    %rax,%rdi
  808f2f:	48 b8 e8 9e 80 00 00 	movabs $0x809ee8,%rax
  808f36:	00 00 00 
  808f39:	ff d0                	callq  *%rax
  808f3b:	eb 52                	jmp    808f8f <dhcp_timeout+0x156>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  808f3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f41:	0f b6 00             	movzbl (%rax),%eax
  808f44:	3c 04                	cmp    $0x4,%al
  808f46:	75 47                	jne    808f8f <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  808f48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f4c:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808f50:	3c 08                	cmp    $0x8,%al
  808f52:	77 15                	ja     808f69 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  808f54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f58:	48 89 c7             	mov    %rax,%rdi
  808f5b:	48 b8 b2 a0 80 00 00 	movabs $0x80a0b2,%rax
  808f62:	00 00 00 
  808f65:	ff d0                	callq  *%rax
  808f67:	eb 26                	jmp    808f8f <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  808f69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f6d:	48 89 c7             	mov    %rax,%rdi
  808f70:	48 b8 7d a2 80 00 00 	movabs $0x80a27d,%rax
  808f77:	00 00 00 
  808f7a:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  808f7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f80:	48 89 c7             	mov    %rax,%rdi
  808f83:	48 b8 02 9a 80 00 00 	movabs $0x809a02,%rax
  808f8a:	00 00 00 
  808f8d:	ff d0                	callq  *%rax
    }
  }
}
  808f8f:	c9                   	leaveq 
  808f90:	c3                   	retq   

0000000000808f91 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  808f91:	55                   	push   %rbp
  808f92:	48 89 e5             	mov    %rsp,%rbp
  808f95:	48 83 ec 20          	sub    $0x20,%rsp
  808f99:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808f9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808fa1:	48 8b 40 38          	mov    0x38(%rax),%rax
  808fa5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  808fa9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fad:	0f b6 00             	movzbl (%rax),%eax
  808fb0:	3c 01                	cmp    $0x1,%al
  808fb2:	74 16                	je     808fca <dhcp_t1_timeout+0x39>
  808fb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fb8:	0f b6 00             	movzbl (%rax),%eax
  808fbb:	3c 0a                	cmp    $0xa,%al
  808fbd:	74 0b                	je     808fca <dhcp_t1_timeout+0x39>
  808fbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fc3:	0f b6 00             	movzbl (%rax),%eax
  808fc6:	3c 05                	cmp    $0x5,%al
  808fc8:	75 13                	jne    808fdd <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  808fca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808fce:	48 89 c7             	mov    %rax,%rdi
  808fd1:	48 b8 e8 9e 80 00 00 	movabs $0x809ee8,%rax
  808fd8:	00 00 00 
  808fdb:	ff d0                	callq  *%rax
  }
}
  808fdd:	c9                   	leaveq 
  808fde:	c3                   	retq   

0000000000808fdf <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  808fdf:	55                   	push   %rbp
  808fe0:	48 89 e5             	mov    %rsp,%rbp
  808fe3:	48 83 ec 20          	sub    $0x20,%rsp
  808fe7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808feb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808fef:	48 8b 40 38          	mov    0x38(%rax),%rax
  808ff3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  808ff7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ffb:	0f b6 00             	movzbl (%rax),%eax
  808ffe:	3c 01                	cmp    $0x1,%al
  809000:	74 16                	je     809018 <dhcp_t2_timeout+0x39>
  809002:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809006:	0f b6 00             	movzbl (%rax),%eax
  809009:	3c 0a                	cmp    $0xa,%al
  80900b:	74 0b                	je     809018 <dhcp_t2_timeout+0x39>
  80900d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809011:	0f b6 00             	movzbl (%rax),%eax
  809014:	3c 05                	cmp    $0x5,%al
  809016:	75 13                	jne    80902b <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  809018:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80901c:	48 89 c7             	mov    %rax,%rdi
  80901f:	48 b8 b2 a0 80 00 00 	movabs $0x80a0b2,%rax
  809026:	00 00 00 
  809029:	ff d0                	callq  *%rax
  }
}
  80902b:	c9                   	leaveq 
  80902c:	c3                   	retq   

000000000080902d <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  80902d:	55                   	push   %rbp
  80902e:	48 89 e5             	mov    %rsp,%rbp
  809031:	53                   	push   %rbx
  809032:	48 83 ec 38          	sub    $0x38,%rsp
  809036:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80903a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80903e:	48 8b 40 38          	mov    0x38(%rax),%rax
  809042:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809046:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80904a:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809051:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809055:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  80905c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809060:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809067:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80906b:	be 33 00 00 00       	mov    $0x33,%esi
  809070:	48 89 c7             	mov    %rax,%rdi
  809073:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  80907a:	00 00 00 
  80907d:	ff d0                	callq  *%rax
  80907f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809083:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809088:	74 20                	je     8090aa <dhcp_handle_ack+0x7d>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80908a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80908e:	48 83 c0 02          	add    $0x2,%rax
  809092:	48 89 c7             	mov    %rax,%rdi
  809095:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  80909c:	00 00 00 
  80909f:	ff d0                	callq  *%rax
  8090a1:	89 c2                	mov    %eax,%edx
  8090a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8090a7:	89 50 68             	mov    %edx,0x68(%rax)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  8090aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8090ae:	be 3a 00 00 00       	mov    $0x3a,%esi
  8090b3:	48 89 c7             	mov    %rax,%rdi
  8090b6:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  8090bd:	00 00 00 
  8090c0:	ff d0                	callq  *%rax
  8090c2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8090c6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8090cb:	74 22                	je     8090ef <dhcp_handle_ack+0xc2>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8090cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8090d1:	48 83 c0 02          	add    $0x2,%rax
  8090d5:	48 89 c7             	mov    %rax,%rdi
  8090d8:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  8090df:	00 00 00 
  8090e2:	ff d0                	callq  *%rax
  8090e4:	89 c2                	mov    %eax,%edx
  8090e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8090ea:	89 50 6c             	mov    %edx,0x6c(%rax)
  8090ed:	eb 12                	jmp    809101 <dhcp_handle_ack+0xd4>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8090ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8090f3:	8b 40 68             	mov    0x68(%rax),%eax
  8090f6:	d1 e8                	shr    %eax
  8090f8:	89 c2                	mov    %eax,%edx
  8090fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8090fe:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  809101:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809105:	be 3b 00 00 00       	mov    $0x3b,%esi
  80910a:	48 89 c7             	mov    %rax,%rdi
  80910d:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  809114:	00 00 00 
  809117:	ff d0                	callq  *%rax
  809119:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80911d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809122:	74 22                	je     809146 <dhcp_handle_ack+0x119>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809124:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809128:	48 83 c0 02          	add    $0x2,%rax
  80912c:	48 89 c7             	mov    %rax,%rdi
  80912f:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  809136:	00 00 00 
  809139:	ff d0                	callq  *%rax
  80913b:	89 c2                	mov    %eax,%edx
  80913d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809141:	89 50 70             	mov    %edx,0x70(%rax)
  809144:	eb 0e                	jmp    809154 <dhcp_handle_ack+0x127>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809146:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80914a:	8b 50 68             	mov    0x68(%rax),%edx
  80914d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809151:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809154:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809158:	48 8b 40 18          	mov    0x18(%rax),%rax
  80915c:	48 83 c0 10          	add    $0x10,%rax
  809160:	48 85 c0             	test   %rax,%rax
  809163:	74 0d                	je     809172 <dhcp_handle_ack+0x145>
  809165:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809169:	48 8b 40 18          	mov    0x18(%rax),%rax
  80916d:	8b 40 10             	mov    0x10(%rax),%eax
  809170:	eb 05                	jmp    809177 <dhcp_handle_ack+0x14a>
  809172:	b8 00 00 00 00       	mov    $0x0,%eax
  809177:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80917b:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  80917e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809182:	be 01 00 00 00       	mov    $0x1,%esi
  809187:	48 89 c7             	mov    %rax,%rdi
  80918a:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  809191:	00 00 00 
  809194:	ff d0                	callq  *%rax
  809196:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  80919a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80919f:	74 2e                	je     8091cf <dhcp_handle_ack+0x1a2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8091a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8091a5:	48 83 c0 02          	add    $0x2,%rax
  8091a9:	48 89 c7             	mov    %rax,%rdi
  8091ac:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  8091b3:	00 00 00 
  8091b6:	ff d0                	callq  *%rax
  8091b8:	89 c7                	mov    %eax,%edi
  8091ba:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  8091c1:	00 00 00 
  8091c4:	ff d0                	callq  *%rax
  8091c6:	89 c2                	mov    %eax,%edx
  8091c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8091cc:	89 50 50             	mov    %edx,0x50(%rax)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8091cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8091d3:	be 03 00 00 00       	mov    $0x3,%esi
  8091d8:	48 89 c7             	mov    %rax,%rdi
  8091db:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  8091e2:	00 00 00 
  8091e5:	ff d0                	callq  *%rax
  8091e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8091eb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8091f0:	74 2e                	je     809220 <dhcp_handle_ack+0x1f3>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8091f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8091f6:	48 83 c0 02          	add    $0x2,%rax
  8091fa:	48 89 c7             	mov    %rax,%rdi
  8091fd:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  809204:	00 00 00 
  809207:	ff d0                	callq  *%rax
  809209:	89 c7                	mov    %eax,%edi
  80920b:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809212:	00 00 00 
  809215:	ff d0                	callq  *%rax
  809217:	89 c2                	mov    %eax,%edx
  809219:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80921d:	89 50 54             	mov    %edx,0x54(%rax)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809220:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809224:	be 1c 00 00 00       	mov    $0x1c,%esi
  809229:	48 89 c7             	mov    %rax,%rdi
  80922c:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  809233:	00 00 00 
  809236:	ff d0                	callq  *%rax
  809238:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80923c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809241:	74 2e                	je     809271 <dhcp_handle_ack+0x244>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809243:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809247:	48 83 c0 02          	add    $0x2,%rax
  80924b:	48 89 c7             	mov    %rax,%rdi
  80924e:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  809255:	00 00 00 
  809258:	ff d0                	callq  *%rax
  80925a:	89 c7                	mov    %eax,%edi
  80925c:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809263:	00 00 00 
  809266:	ff d0                	callq  *%rax
  809268:	89 c2                	mov    %eax,%edx
  80926a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80926e:	89 50 58             	mov    %edx,0x58(%rax)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809271:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809275:	be 06 00 00 00       	mov    $0x6,%esi
  80927a:	48 89 c7             	mov    %rax,%rdi
  80927d:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  809284:	00 00 00 
  809287:	ff d0                	callq  *%rax
  809289:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80928d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809292:	0f 84 9f 00 00 00    	je     809337 <dhcp_handle_ack+0x30a>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809298:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80929c:	48 83 c0 01          	add    $0x1,%rax
  8092a0:	48 89 c7             	mov    %rax,%rdi
  8092a3:	48 b8 7b b5 80 00 00 	movabs $0x80b57b,%rax
  8092aa:	00 00 00 
  8092ad:	ff d0                	callq  *%rax
  8092af:	c0 e8 02             	shr    $0x2,%al
  8092b2:	0f b6 d0             	movzbl %al,%edx
  8092b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8092b9:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  8092bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8092c0:	8b 40 5c             	mov    0x5c(%rax),%eax
  8092c3:	83 f8 02             	cmp    $0x2,%eax
  8092c6:	76 0b                	jbe    8092d3 <dhcp_handle_ack+0x2a6>
      dhcp->dns_count = DHCP_MAX_DNS;
  8092c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8092cc:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  8092d3:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  8092d7:	eb 4f                	jmp    809328 <dhcp_handle_ack+0x2fb>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  8092d9:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  8092dd:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8092e1:	c1 e0 02             	shl    $0x2,%eax
  8092e4:	83 c0 02             	add    $0x2,%eax
  8092e7:	48 63 d0             	movslq %eax,%rdx
  8092ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8092ee:	48 01 d0             	add    %rdx,%rax
  8092f1:	48 89 c7             	mov    %rax,%rdi
  8092f4:	48 b8 90 b5 80 00 00 	movabs $0x80b590,%rax
  8092fb:	00 00 00 
  8092fe:	ff d0                	callq  *%rax
  809300:	89 c7                	mov    %eax,%edi
  809302:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809309:	00 00 00 
  80930c:	ff d0                	callq  *%rax
  80930e:	89 c1                	mov    %eax,%ecx
  809310:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809314:	48 63 d3             	movslq %ebx,%rdx
  809317:	48 83 c2 18          	add    $0x18,%rdx
  80931b:	89 0c 90             	mov    %ecx,(%rax,%rdx,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  80931e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809322:	83 c0 01             	add    $0x1,%eax
  809325:	88 45 ef             	mov    %al,-0x11(%rbp)
  809328:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  80932c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809330:	8b 40 5c             	mov    0x5c(%rax),%eax
  809333:	39 c2                	cmp    %eax,%edx
  809335:	72 a2                	jb     8092d9 <dhcp_handle_ack+0x2ac>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809337:	48 83 c4 38          	add    $0x38,%rsp
  80933b:	5b                   	pop    %rbx
  80933c:	5d                   	pop    %rbp
  80933d:	c3                   	retq   

000000000080933e <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  80933e:	55                   	push   %rbp
  80933f:	48 89 e5             	mov    %rsp,%rbp
  809342:	48 83 ec 20          	sub    $0x20,%rsp
  809346:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  80934a:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  80934e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809353:	75 2a                	jne    80937f <dhcp_start+0x41>
  809355:	48 ba 28 0c 82 00 00 	movabs $0x820c28,%rdx
  80935c:	00 00 00 
  80935f:	be 38 02 00 00       	mov    $0x238,%esi
  809364:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80936b:	00 00 00 
  80936e:	b8 00 00 00 00       	mov    $0x0,%eax
  809373:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80937a:	00 00 00 
  80937d:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80937f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809383:	48 8b 40 38          	mov    0x38(%rax),%rax
  809387:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80938b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80938f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809393:	83 e0 f7             	and    $0xfffffff7,%eax
  809396:	89 c2                	mov    %eax,%edx
  809398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80939c:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  80939f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8093a4:	75 32                	jne    8093d8 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8093a6:	bf 78 00 00 00       	mov    $0x78,%edi
  8093ab:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  8093b2:	00 00 00 
  8093b5:	ff d0                	callq  *%rax
  8093b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  8093bb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8093c0:	75 0a                	jne    8093cc <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  8093c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093c7:	e9 3d 01 00 00       	jmpq   809509 <dhcp_start+0x1cb>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8093cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8093d0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8093d4:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8093d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093dc:	ba 78 00 00 00       	mov    $0x78,%edx
  8093e1:	be 00 00 00 00       	mov    $0x0,%esi
  8093e6:	48 89 c7             	mov    %rax,%rdi
  8093e9:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  8093f0:	00 00 00 
  8093f3:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8093f5:	48 b8 e3 4d 81 00 00 	movabs $0x814de3,%rax
  8093fc:	00 00 00 
  8093ff:	ff d0                	callq  *%rax
  809401:	48 89 c2             	mov    %rax,%rdx
  809404:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809408:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (dhcp->pcb == NULL) {
  80940c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809410:	48 8b 40 08          	mov    0x8(%rax),%rax
  809414:	48 85 c0             	test   %rax,%rax
  809417:	75 31                	jne    80944a <dhcp_start+0x10c>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  809419:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80941d:	48 89 c7             	mov    %rax,%rdi
  809420:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  809427:	00 00 00 
  80942a:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  80942c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  809433:	00 
  809434:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809438:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80943c:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  809440:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809445:	e9 bf 00 00 00       	jmpq   809509 <dhcp_start+0x1cb>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80944a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80944e:	48 8b 40 08          	mov    0x8(%rax),%rax
  809452:	ba 44 00 00 00       	mov    $0x44,%edx
  809457:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  80945e:	00 00 00 
  809461:	48 89 c7             	mov    %rax,%rdi
  809464:	48 b8 87 4a 81 00 00 	movabs $0x814a87,%rax
  80946b:	00 00 00 
  80946e:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809470:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809474:	48 8b 40 08          	mov    0x8(%rax),%rax
  809478:	ba 43 00 00 00       	mov    $0x43,%edx
  80947d:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  809484:	00 00 00 
  809487:	48 89 c7             	mov    %rax,%rdi
  80948a:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  809491:	00 00 00 
  809494:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  809496:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80949a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80949e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8094a2:	48 be 91 ab 80 00 00 	movabs $0x80ab91,%rsi
  8094a9:	00 00 00 
  8094ac:	48 89 c7             	mov    %rax,%rdi
  8094af:	48 b8 0b 4d 81 00 00 	movabs $0x814d0b,%rax
  8094b6:	00 00 00 
  8094b9:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  8094bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094bf:	48 89 c7             	mov    %rax,%rdi
  8094c2:	48 b8 02 9a 80 00 00 	movabs $0x809a02,%rax
  8094c9:	00 00 00 
  8094cc:	ff d0                	callq  *%rax
  8094ce:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  8094d1:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8094d5:	74 1a                	je     8094f1 <dhcp_start+0x1b3>
    /* free resources allocated above */
    dhcp_stop(netif);
  8094d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094db:	48 89 c7             	mov    %rax,%rdi
  8094de:	48 b8 eb a4 80 00 00 	movabs $0x80a4eb,%rax
  8094e5:	00 00 00 
  8094e8:	ff d0                	callq  *%rax
    return ERR_MEM;
  8094ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094ef:	eb 18                	jmp    809509 <dhcp_start+0x1cb>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8094f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094f5:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  8094f9:	83 c8 08             	or     $0x8,%eax
  8094fc:	89 c2                	mov    %eax,%edx
  8094fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809502:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  809505:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809509:	c9                   	leaveq 
  80950a:	c3                   	retq   

000000000080950b <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  80950b:	55                   	push   %rbp
  80950c:	48 89 e5             	mov    %rsp,%rbp
  80950f:	48 83 ec 30          	sub    $0x30,%rsp
  809513:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  809517:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80951b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80951f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809523:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  809527:	bf 78 00 00 00       	mov    $0x78,%edi
  80952c:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  809533:	00 00 00 
  809536:	ff d0                	callq  *%rax
  809538:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  80953c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809541:	75 05                	jne    809548 <dhcp_inform+0x3d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  809543:	e9 3a 02 00 00       	jmpq   809782 <dhcp_inform+0x277>
  }
  netif->dhcp = dhcp;
  809548:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80954c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809550:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  809554:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809558:	ba 78 00 00 00       	mov    $0x78,%edx
  80955d:	be 00 00 00 00       	mov    $0x0,%esi
  809562:	48 89 c7             	mov    %rax,%rdi
  809565:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80956c:	00 00 00 
  80956f:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  809571:	48 b8 e3 4d 81 00 00 	movabs $0x814de3,%rax
  809578:	00 00 00 
  80957b:	ff d0                	callq  *%rax
  80957d:	48 89 c2             	mov    %rax,%rdx
  809580:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809584:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (dhcp->pcb == NULL) {
  809588:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80958c:	48 8b 40 08          	mov    0x8(%rax),%rax
  809590:	48 85 c0             	test   %rax,%rax
  809593:	75 18                	jne    8095ad <dhcp_inform+0xa2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  809595:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809599:	48 89 c7             	mov    %rax,%rdi
  80959c:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  8095a3:	00 00 00 
  8095a6:	ff d0                	callq  *%rax
    return;
  8095a8:	e9 d5 01 00 00       	jmpq   809782 <dhcp_inform+0x277>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8095ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8095b1:	48 89 c7             	mov    %rax,%rdi
  8095b4:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  8095bb:	00 00 00 
  8095be:	ff d0                	callq  *%rax
  8095c0:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  8095c3:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8095c7:	0f 85 5f 01 00 00    	jne    80972c <dhcp_inform+0x221>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8095cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095d1:	ba 01 00 00 00       	mov    $0x1,%edx
  8095d6:	be 35 00 00 00       	mov    $0x35,%esi
  8095db:	48 89 c7             	mov    %rax,%rdi
  8095de:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  8095e5:	00 00 00 
  8095e8:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8095ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095ee:	be 08 00 00 00       	mov    $0x8,%esi
  8095f3:	48 89 c7             	mov    %rax,%rdi
  8095f6:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  8095fd:	00 00 00 
  809600:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809602:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809606:	ba 02 00 00 00       	mov    $0x2,%edx
  80960b:	be 39 00 00 00       	mov    $0x39,%esi
  809610:	48 89 c7             	mov    %rax,%rdi
  809613:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  80961a:	00 00 00 
  80961d:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  80961f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809623:	be 40 02 00 00       	mov    $0x240,%esi
  809628:	48 89 c7             	mov    %rax,%rdi
  80962b:	48 b8 3f a7 80 00 00 	movabs $0x80a73f,%rax
  809632:	00 00 00 
  809635:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809637:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80963b:	48 89 c7             	mov    %rax,%rdi
  80963e:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  809645:	00 00 00 
  809648:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80964a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80964e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809652:	66 05 f0 00          	add    $0xf0,%ax
  809656:	0f b7 d0             	movzwl %ax,%edx
  809659:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80965d:	48 8b 40 30          	mov    0x30(%rax),%rax
  809661:	89 d6                	mov    %edx,%esi
  809663:	48 89 c7             	mov    %rax,%rdi
  809666:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  80966d:	00 00 00 
  809670:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809672:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809676:	48 8b 40 08          	mov    0x8(%rax),%rax
  80967a:	ba 44 00 00 00       	mov    $0x44,%edx
  80967f:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  809686:	00 00 00 
  809689:	48 89 c7             	mov    %rax,%rdi
  80968c:	48 b8 87 4a 81 00 00 	movabs $0x814a87,%rax
  809693:	00 00 00 
  809696:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  809698:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80969c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8096a0:	ba 43 00 00 00       	mov    $0x43,%edx
  8096a5:	48 be 2c 1a 82 00 00 	movabs $0x821a2c,%rsi
  8096ac:	00 00 00 
  8096af:	48 89 c7             	mov    %rax,%rdi
  8096b2:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  8096b9:	00 00 00 
  8096bc:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8096be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096c2:	48 8b 70 30          	mov    0x30(%rax),%rsi
  8096c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096ca:	48 8b 40 08          	mov    0x8(%rax),%rax
  8096ce:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8096d2:	49 89 d0             	mov    %rdx,%r8
  8096d5:	b9 43 00 00 00       	mov    $0x43,%ecx
  8096da:	48 ba 2c 1a 82 00 00 	movabs $0x821a2c,%rdx
  8096e1:	00 00 00 
  8096e4:	48 89 c7             	mov    %rax,%rdi
  8096e7:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  8096ee:	00 00 00 
  8096f1:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8096f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096f7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8096fb:	ba 43 00 00 00       	mov    $0x43,%edx
  809700:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  809707:	00 00 00 
  80970a:	48 89 c7             	mov    %rax,%rdi
  80970d:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  809714:	00 00 00 
  809717:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809719:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80971d:	48 89 c7             	mov    %rax,%rdi
  809720:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  809727:	00 00 00 
  80972a:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  80972c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809731:	74 4f                	je     809782 <dhcp_inform+0x277>
    if (dhcp->pcb != NULL) {
  809733:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809737:	48 8b 40 08          	mov    0x8(%rax),%rax
  80973b:	48 85 c0             	test   %rax,%rax
  80973e:	74 17                	je     809757 <dhcp_inform+0x24c>
      udp_remove(dhcp->pcb);
  809740:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809744:	48 8b 40 08          	mov    0x8(%rax),%rax
  809748:	48 89 c7             	mov    %rax,%rdi
  80974b:	48 b8 39 4d 81 00 00 	movabs $0x814d39,%rax
  809752:	00 00 00 
  809755:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  809757:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80975b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  809762:	00 
    mem_free((void *)dhcp);
  809763:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809767:	48 89 c7             	mov    %rax,%rdi
  80976a:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  809771:	00 00 00 
  809774:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  809776:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80977a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80977e:	48 89 50 38          	mov    %rdx,0x38(%rax)
  }
}
  809782:	c9                   	leaveq 
  809783:	c3                   	retq   

0000000000809784 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  809784:	55                   	push   %rbp
  809785:	48 89 e5             	mov    %rsp,%rbp
  809788:	48 83 ec 10          	sub    $0x10,%rsp
  80978c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809790:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809794:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809799:	75 2a                	jne    8097c5 <dhcp_arp_reply+0x41>
  80979b:	48 ba 28 0c 82 00 00 	movabs $0x820c28,%rdx
  8097a2:	00 00 00 
  8097a5:	be b5 02 00 00       	mov    $0x2b5,%esi
  8097aa:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  8097b1:	00 00 00 
  8097b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8097b9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8097c0:	00 00 00 
  8097c3:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  8097c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097c9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8097cd:	48 85 c0             	test   %rax,%rax
  8097d0:	74 37                	je     809809 <dhcp_arp_reply+0x85>
  8097d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097d6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8097da:	0f b6 00             	movzbl (%rax),%eax
  8097dd:	3c 08                	cmp    $0x8,%al
  8097df:	75 28                	jne    809809 <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8097e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8097e5:	8b 10                	mov    (%rax),%edx
  8097e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097eb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8097ef:	8b 40 4c             	mov    0x4c(%rax),%eax
  8097f2:	39 c2                	cmp    %eax,%edx
  8097f4:	75 13                	jne    809809 <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  8097f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097fa:	48 89 c7             	mov    %rax,%rdi
  8097fd:	48 b8 0b 98 80 00 00 	movabs $0x80980b,%rax
  809804:	00 00 00 
  809807:	ff d0                	callq  *%rax
    }
  }
}
  809809:	c9                   	leaveq 
  80980a:	c3                   	retq   

000000000080980b <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  80980b:	55                   	push   %rbp
  80980c:	48 89 e5             	mov    %rsp,%rbp
  80980f:	48 83 ec 20          	sub    $0x20,%rsp
  809813:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809817:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80981b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80981f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809823:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  809827:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80982b:	be 0c 00 00 00       	mov    $0xc,%esi
  809830:	48 89 c7             	mov    %rax,%rdi
  809833:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  80983a:	00 00 00 
  80983d:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80983f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809843:	48 89 c7             	mov    %rax,%rdi
  809846:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  80984d:	00 00 00 
  809850:	ff d0                	callq  *%rax
  809852:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809855:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809859:	0f 85 5c 01 00 00    	jne    8099bb <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80985f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809863:	ba 01 00 00 00       	mov    $0x1,%edx
  809868:	be 35 00 00 00       	mov    $0x35,%esi
  80986d:	48 89 c7             	mov    %rax,%rdi
  809870:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  809877:	00 00 00 
  80987a:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80987c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809880:	be 04 00 00 00       	mov    $0x4,%esi
  809885:	48 89 c7             	mov    %rax,%rdi
  809888:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  80988f:	00 00 00 
  809892:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809894:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809898:	ba 02 00 00 00       	mov    $0x2,%edx
  80989d:	be 39 00 00 00       	mov    $0x39,%esi
  8098a2:	48 89 c7             	mov    %rax,%rdi
  8098a5:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  8098ac:	00 00 00 
  8098af:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  8098b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098b5:	be 40 02 00 00       	mov    $0x240,%esi
  8098ba:	48 89 c7             	mov    %rax,%rdi
  8098bd:	48 b8 3f a7 80 00 00 	movabs $0x80a73f,%rax
  8098c4:	00 00 00 
  8098c7:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8098c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098cd:	ba 04 00 00 00       	mov    $0x4,%edx
  8098d2:	be 32 00 00 00       	mov    $0x32,%esi
  8098d7:	48 89 c7             	mov    %rax,%rdi
  8098da:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  8098e1:	00 00 00 
  8098e4:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8098e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098ea:	8b 40 4c             	mov    0x4c(%rax),%eax
  8098ed:	89 c7                	mov    %eax,%edi
  8098ef:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8098f6:	00 00 00 
  8098f9:	ff d0                	callq  *%rax
  8098fb:	89 c2                	mov    %eax,%edx
  8098fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809901:	89 d6                	mov    %edx,%esi
  809903:	48 89 c7             	mov    %rax,%rdi
  809906:	48 b8 ea a7 80 00 00 	movabs $0x80a7ea,%rax
  80990d:	00 00 00 
  809910:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809912:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809916:	48 89 c7             	mov    %rax,%rdi
  809919:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  809920:	00 00 00 
  809923:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809925:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809929:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80992d:	66 05 f0 00          	add    $0xf0,%ax
  809931:	0f b7 d0             	movzwl %ax,%edx
  809934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809938:	48 8b 40 30          	mov    0x30(%rax),%rax
  80993c:	89 d6                	mov    %edx,%esi
  80993e:	48 89 c7             	mov    %rax,%rdi
  809941:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  809948:	00 00 00 
  80994b:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80994d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809951:	48 8b 40 08          	mov    0x8(%rax),%rax
  809955:	ba 43 00 00 00       	mov    $0x43,%edx
  80995a:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  809961:	00 00 00 
  809964:	48 89 c7             	mov    %rax,%rdi
  809967:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  80996e:	00 00 00 
  809971:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809973:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809977:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80997b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80997f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809983:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809987:	49 89 d0             	mov    %rdx,%r8
  80998a:	b9 43 00 00 00       	mov    $0x43,%ecx
  80998f:	48 ba 2c 1a 82 00 00 	movabs $0x821a2c,%rdx
  809996:	00 00 00 
  809999:	48 89 c7             	mov    %rax,%rdi
  80999c:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  8099a3:	00 00 00 
  8099a6:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  8099a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8099ac:	48 89 c7             	mov    %rax,%rdi
  8099af:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  8099b6:	00 00 00 
  8099b9:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8099bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099bf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8099c3:	8d 50 01             	lea    0x1(%rax),%edx
  8099c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099ca:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  8099cd:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8099d3:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8099d7:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8099dd:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8099e2:	89 c8                	mov    %ecx,%eax
  8099e4:	f7 ea                	imul   %edx
  8099e6:	c1 fa 05             	sar    $0x5,%edx
  8099e9:	89 c8                	mov    %ecx,%eax
  8099eb:	c1 f8 1f             	sar    $0x1f,%eax
  8099ee:	29 c2                	sub    %eax,%edx
  8099f0:	89 d0                	mov    %edx,%eax
  8099f2:	89 c2                	mov    %eax,%edx
  8099f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099f8:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  8099fc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809a00:	c9                   	leaveq 
  809a01:	c3                   	retq   

0000000000809a02 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  809a02:	55                   	push   %rbp
  809a03:	48 89 e5             	mov    %rsp,%rbp
  809a06:	48 83 ec 20          	sub    $0x20,%rsp
  809a0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809a0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a12:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a16:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809a1a:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  809a1e:	48 b8 28 1a 82 00 00 	movabs $0x821a28,%rax
  809a25:	00 00 00 
  809a28:	8b 10                	mov    (%rax),%edx
  809a2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a2e:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809a31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a35:	48 89 c7             	mov    %rax,%rdi
  809a38:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  809a3f:	00 00 00 
  809a42:	ff d0                	callq  *%rax
  809a44:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809a47:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809a4b:	0f 85 a8 01 00 00    	jne    809bf9 <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809a51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a55:	ba 01 00 00 00       	mov    $0x1,%edx
  809a5a:	be 35 00 00 00       	mov    $0x35,%esi
  809a5f:	48 89 c7             	mov    %rax,%rdi
  809a62:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  809a69:	00 00 00 
  809a6c:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  809a6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a72:	be 01 00 00 00       	mov    $0x1,%esi
  809a77:	48 89 c7             	mov    %rax,%rdi
  809a7a:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  809a81:	00 00 00 
  809a84:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809a86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a8a:	ba 02 00 00 00       	mov    $0x2,%edx
  809a8f:	be 39 00 00 00       	mov    $0x39,%esi
  809a94:	48 89 c7             	mov    %rax,%rdi
  809a97:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  809a9e:	00 00 00 
  809aa1:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  809aa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809aa7:	be 40 02 00 00       	mov    $0x240,%esi
  809aac:	48 89 c7             	mov    %rax,%rdi
  809aaf:	48 b8 3f a7 80 00 00 	movabs $0x80a73f,%rax
  809ab6:	00 00 00 
  809ab9:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  809abb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809abf:	ba 04 00 00 00       	mov    $0x4,%edx
  809ac4:	be 37 00 00 00       	mov    $0x37,%esi
  809ac9:	48 89 c7             	mov    %rax,%rdi
  809acc:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  809ad3:	00 00 00 
  809ad6:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  809ad8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809adc:	be 01 00 00 00       	mov    $0x1,%esi
  809ae1:	48 89 c7             	mov    %rax,%rdi
  809ae4:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  809aeb:	00 00 00 
  809aee:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  809af0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809af4:	be 03 00 00 00       	mov    $0x3,%esi
  809af9:	48 89 c7             	mov    %rax,%rdi
  809afc:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  809b03:	00 00 00 
  809b06:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  809b08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b0c:	be 1c 00 00 00       	mov    $0x1c,%esi
  809b11:	48 89 c7             	mov    %rax,%rdi
  809b14:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  809b1b:	00 00 00 
  809b1e:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  809b20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b24:	be 06 00 00 00       	mov    $0x6,%esi
  809b29:	48 89 c7             	mov    %rax,%rdi
  809b2c:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  809b33:	00 00 00 
  809b36:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809b38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b3c:	48 89 c7             	mov    %rax,%rdi
  809b3f:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  809b46:	00 00 00 
  809b49:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809b4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b4f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809b53:	66 05 f0 00          	add    $0xf0,%ax
  809b57:	0f b7 d0             	movzwl %ax,%edx
  809b5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b5e:	48 8b 40 30          	mov    0x30(%rax),%rax
  809b62:	89 d6                	mov    %edx,%esi
  809b64:	48 89 c7             	mov    %rax,%rdi
  809b67:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  809b6e:	00 00 00 
  809b71:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809b73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b77:	48 8b 40 08          	mov    0x8(%rax),%rax
  809b7b:	ba 43 00 00 00       	mov    $0x43,%edx
  809b80:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  809b87:	00 00 00 
  809b8a:	48 89 c7             	mov    %rax,%rdi
  809b8d:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  809b94:	00 00 00 
  809b97:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809b99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b9d:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809ba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ba5:	48 8b 40 08          	mov    0x8(%rax),%rax
  809ba9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809bad:	49 89 d0             	mov    %rdx,%r8
  809bb0:	b9 43 00 00 00       	mov    $0x43,%ecx
  809bb5:	48 ba 2c 1a 82 00 00 	movabs $0x821a2c,%rdx
  809bbc:	00 00 00 
  809bbf:	48 89 c7             	mov    %rax,%rdi
  809bc2:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  809bc9:	00 00 00 
  809bcc:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  809bce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bd2:	48 89 c7             	mov    %rax,%rdi
  809bd5:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  809bdc:	00 00 00 
  809bdf:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  809be1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809be5:	be 06 00 00 00       	mov    $0x6,%esi
  809bea:	48 89 c7             	mov    %rax,%rdi
  809bed:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  809bf4:	00 00 00 
  809bf7:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809bf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bfd:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809c01:	8d 50 01             	lea    0x1(%rax),%edx
  809c04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c08:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  809c0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c0f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809c13:	3c 03                	cmp    $0x3,%al
  809c15:	77 15                	ja     809c2c <dhcp_discover+0x22a>
  809c17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c1b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809c1f:	0f b6 c0             	movzbl %al,%eax
  809c22:	83 c0 01             	add    $0x1,%eax
  809c25:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  809c2a:	eb 05                	jmp    809c31 <dhcp_discover+0x22f>
  809c2c:	b8 10 27 00 00       	mov    $0x2710,%eax
  809c31:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  809c35:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809c39:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809c3f:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809c44:	89 c8                	mov    %ecx,%eax
  809c46:	f7 ea                	imul   %edx
  809c48:	c1 fa 05             	sar    $0x5,%edx
  809c4b:	89 c8                	mov    %ecx,%eax
  809c4d:	c1 f8 1f             	sar    $0x1f,%eax
  809c50:	29 c2                	sub    %eax,%edx
  809c52:	89 d0                	mov    %edx,%eax
  809c54:	89 c2                	mov    %eax,%edx
  809c56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c5a:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  809c5e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809c62:	c9                   	leaveq 
  809c63:	c3                   	retq   

0000000000809c64 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  809c64:	55                   	push   %rbp
  809c65:	48 89 e5             	mov    %rsp,%rbp
  809c68:	48 83 ec 40          	sub    $0x40,%rsp
  809c6c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  809c70:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  809c75:	75 2a                	jne    809ca1 <dhcp_bind+0x3d>
  809c77:	48 ba 4b 0c 82 00 00 	movabs $0x820c4b,%rdx
  809c7e:	00 00 00 
  809c81:	be 3d 03 00 00       	mov    $0x33d,%esi
  809c86:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  809c8d:	00 00 00 
  809c90:	b8 00 00 00 00       	mov    $0x0,%eax
  809c95:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  809c9c:	00 00 00 
  809c9f:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809ca1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809ca5:	48 8b 40 38          	mov    0x38(%rax),%rax
  809ca9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  809cad:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  809cb2:	75 2a                	jne    809cde <dhcp_bind+0x7a>
  809cb4:	48 ba 64 0c 82 00 00 	movabs $0x820c64,%rdx
  809cbb:	00 00 00 
  809cbe:	be 3f 03 00 00       	mov    $0x33f,%esi
  809cc3:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  809cca:	00 00 00 
  809ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  809cd2:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  809cd9:	00 00 00 
  809cdc:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  809cde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809ce2:	8b 40 6c             	mov    0x6c(%rax),%eax
  809ce5:	83 f8 ff             	cmp    $0xffffffff,%eax
  809ce8:	74 4d                	je     809d37 <dhcp_bind+0xd3>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  809cea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809cee:	8b 40 6c             	mov    0x6c(%rax),%eax
  809cf1:	83 c0 1e             	add    $0x1e,%eax
  809cf4:	ba 89 88 88 88       	mov    $0x88888889,%edx
  809cf9:	f7 e2                	mul    %edx
  809cfb:	89 d0                	mov    %edx,%eax
  809cfd:	c1 e8 05             	shr    $0x5,%eax
  809d00:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(timeout > 0xffff) {
  809d03:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  809d0a:	76 07                	jbe    809d13 <dhcp_bind+0xaf>
      timeout = 0xffff;
  809d0c:	c7 45 fc ff ff 00 00 	movl   $0xffff,-0x4(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  809d13:	8b 45 fc             	mov    -0x4(%rbp),%eax
  809d16:	89 c2                	mov    %eax,%edx
  809d18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d1c:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  809d20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d24:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  809d28:	66 85 c0             	test   %ax,%ax
  809d2b:	75 0a                	jne    809d37 <dhcp_bind+0xd3>
      dhcp->t1_timeout = 1;
  809d2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d31:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  809d37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d3b:	8b 40 70             	mov    0x70(%rax),%eax
  809d3e:	83 f8 ff             	cmp    $0xffffffff,%eax
  809d41:	74 4d                	je     809d90 <dhcp_bind+0x12c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  809d43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d47:	8b 40 70             	mov    0x70(%rax),%eax
  809d4a:	83 c0 1e             	add    $0x1e,%eax
  809d4d:	ba 89 88 88 88       	mov    $0x88888889,%edx
  809d52:	f7 e2                	mul    %edx
  809d54:	89 d0                	mov    %edx,%eax
  809d56:	c1 e8 05             	shr    $0x5,%eax
  809d59:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(timeout > 0xffff) {
  809d5c:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  809d63:	76 07                	jbe    809d6c <dhcp_bind+0x108>
      timeout = 0xffff;
  809d65:	c7 45 fc ff ff 00 00 	movl   $0xffff,-0x4(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  809d6c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  809d6f:	89 c2                	mov    %eax,%edx
  809d71:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d75:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  809d79:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d7d:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  809d81:	66 85 c0             	test   %ax,%ax
  809d84:	75 0a                	jne    809d90 <dhcp_bind+0x12c>
      dhcp->t2_timeout = 1;
  809d86:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d8a:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  809d90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809d94:	48 83 c0 50          	add    $0x50,%rax
  809d98:	48 85 c0             	test   %rax,%rax
  809d9b:	74 09                	je     809da6 <dhcp_bind+0x142>
  809d9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809da1:	8b 40 50             	mov    0x50(%rax),%eax
  809da4:	eb 05                	jmp    809dab <dhcp_bind+0x147>
  809da6:	b8 00 00 00 00       	mov    $0x0,%eax
  809dab:	89 45 e0             	mov    %eax,-0x20(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  809dae:	8b 45 e0             	mov    -0x20(%rbp),%eax
  809db1:	85 c0                	test   %eax,%eax
  809db3:	75 65                	jne    809e1a <dhcp_bind+0x1b6>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  809db5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  809db8:	89 c7                	mov    %eax,%edi
  809dba:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  809dc1:	00 00 00 
  809dc4:	ff d0                	callq  *%rax
  809dc6:	c1 e8 18             	shr    $0x18,%eax
  809dc9:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (first_octet <= 127) {
  809dcc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809dd0:	84 c0                	test   %al,%al
  809dd2:	78 16                	js     809dea <dhcp_bind+0x186>
      sn_mask.addr = htonl(0xff000000);
  809dd4:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  809dd9:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809de0:	00 00 00 
  809de3:	ff d0                	callq  *%rax
  809de5:	89 45 e0             	mov    %eax,-0x20(%rbp)
  809de8:	eb 30                	jmp    809e1a <dhcp_bind+0x1b6>
    } else if (first_octet >= 192) {
  809dea:	80 7d ef bf          	cmpb   $0xbf,-0x11(%rbp)
  809dee:	76 16                	jbe    809e06 <dhcp_bind+0x1a2>
      sn_mask.addr = htonl(0xffffff00);
  809df0:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  809df5:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809dfc:	00 00 00 
  809dff:	ff d0                	callq  *%rax
  809e01:	89 45 e0             	mov    %eax,-0x20(%rbp)
  809e04:	eb 14                	jmp    809e1a <dhcp_bind+0x1b6>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  809e06:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  809e0b:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809e12:	00 00 00 
  809e15:	ff d0                	callq  *%rax
  809e17:	89 45 e0             	mov    %eax,-0x20(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  809e1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809e1e:	48 83 c0 54          	add    $0x54,%rax
  809e22:	48 85 c0             	test   %rax,%rax
  809e25:	74 09                	je     809e30 <dhcp_bind+0x1cc>
  809e27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809e2b:	8b 40 54             	mov    0x54(%rax),%eax
  809e2e:	eb 05                	jmp    809e35 <dhcp_bind+0x1d1>
  809e30:	b8 00 00 00 00       	mov    $0x0,%eax
  809e35:	89 45 d0             	mov    %eax,-0x30(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  809e38:	8b 45 d0             	mov    -0x30(%rbp),%eax
  809e3b:	85 c0                	test   %eax,%eax
  809e3d:	75 2a                	jne    809e69 <dhcp_bind+0x205>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  809e3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809e43:	8b 50 4c             	mov    0x4c(%rax),%edx
  809e46:	8b 45 e0             	mov    -0x20(%rbp),%eax
  809e49:	21 d0                	and    %edx,%eax
  809e4b:	89 45 d0             	mov    %eax,-0x30(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  809e4e:	bf 01 00 00 00       	mov    $0x1,%edi
  809e53:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  809e5a:	00 00 00 
  809e5d:	ff d0                	callq  *%rax
  809e5f:	89 c2                	mov    %eax,%edx
  809e61:	8b 45 d0             	mov    -0x30(%rbp),%eax
  809e64:	09 d0                	or     %edx,%eax
  809e66:	89 45 d0             	mov    %eax,-0x30(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  809e69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809e6d:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  809e71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809e75:	48 89 d6             	mov    %rdx,%rsi
  809e78:	48 89 c7             	mov    %rax,%rdi
  809e7b:	48 b8 49 c6 80 00 00 	movabs $0x80c649,%rax
  809e82:	00 00 00 
  809e85:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  809e87:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  809e8b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809e8f:	48 89 d6             	mov    %rdx,%rsi
  809e92:	48 89 c7             	mov    %rax,%rdi
  809e95:	48 b8 7c c7 80 00 00 	movabs $0x80c77c,%rax
  809e9c:	00 00 00 
  809e9f:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  809ea1:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  809ea5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809ea9:	48 89 d6             	mov    %rdx,%rsi
  809eac:	48 89 c7             	mov    %rax,%rdi
  809eaf:	48 b8 4f c7 80 00 00 	movabs $0x80c74f,%rax
  809eb6:	00 00 00 
  809eb9:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  809ebb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809ebf:	48 89 c7             	mov    %rax,%rdi
  809ec2:	48 b8 c8 c7 80 00 00 	movabs $0x80c7c8,%rax
  809ec9:	00 00 00 
  809ecc:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  809ece:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809ed2:	be 0a 00 00 00       	mov    $0xa,%esi
  809ed7:	48 89 c7             	mov    %rax,%rdi
  809eda:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  809ee1:	00 00 00 
  809ee4:	ff d0                	callq  *%rax
}
  809ee6:	c9                   	leaveq 
  809ee7:	c3                   	retq   

0000000000809ee8 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  809ee8:	55                   	push   %rbp
  809ee9:	48 89 e5             	mov    %rsp,%rbp
  809eec:	48 83 ec 20          	sub    $0x20,%rsp
  809ef0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809ef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ef8:	48 8b 40 38          	mov    0x38(%rax),%rax
  809efc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  809f00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f04:	be 05 00 00 00       	mov    $0x5,%esi
  809f09:	48 89 c7             	mov    %rax,%rdi
  809f0c:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  809f13:	00 00 00 
  809f16:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809f18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f1c:	48 89 c7             	mov    %rax,%rdi
  809f1f:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  809f26:	00 00 00 
  809f29:	ff d0                	callq  *%rax
  809f2b:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809f2e:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809f32:	0f 85 12 01 00 00    	jne    80a04a <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809f38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f3c:	ba 01 00 00 00       	mov    $0x1,%edx
  809f41:	be 35 00 00 00       	mov    $0x35,%esi
  809f46:	48 89 c7             	mov    %rax,%rdi
  809f49:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  809f50:	00 00 00 
  809f53:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  809f55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f59:	be 03 00 00 00       	mov    $0x3,%esi
  809f5e:	48 89 c7             	mov    %rax,%rdi
  809f61:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  809f68:	00 00 00 
  809f6b:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809f6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f71:	ba 02 00 00 00       	mov    $0x2,%edx
  809f76:	be 39 00 00 00       	mov    $0x39,%esi
  809f7b:	48 89 c7             	mov    %rax,%rdi
  809f7e:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  809f85:	00 00 00 
  809f88:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  809f8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f8e:	be 40 02 00 00       	mov    $0x240,%esi
  809f93:	48 89 c7             	mov    %rax,%rdi
  809f96:	48 b8 3f a7 80 00 00 	movabs $0x80a73f,%rax
  809f9d:	00 00 00 
  809fa0:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  809fa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fa6:	48 89 c7             	mov    %rax,%rdi
  809fa9:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  809fb0:	00 00 00 
  809fb3:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809fb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fb9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809fbd:	66 05 f0 00          	add    $0xf0,%ax
  809fc1:	0f b7 d0             	movzwl %ax,%edx
  809fc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fc8:	48 8b 40 30          	mov    0x30(%rax),%rax
  809fcc:	89 d6                	mov    %edx,%esi
  809fce:	48 89 c7             	mov    %rax,%rdi
  809fd1:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  809fd8:	00 00 00 
  809fdb:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  809fdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fe1:	48 8d 48 48          	lea    0x48(%rax),%rcx
  809fe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fe9:	48 8b 40 08          	mov    0x8(%rax),%rax
  809fed:	ba 43 00 00 00       	mov    $0x43,%edx
  809ff2:	48 89 ce             	mov    %rcx,%rsi
  809ff5:	48 89 c7             	mov    %rax,%rdi
  809ff8:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  809fff:	00 00 00 
  80a002:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80a004:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a008:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80a00c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a010:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a014:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a018:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a01c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80a020:	49 89 c8             	mov    %rcx,%r8
  80a023:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a028:	48 89 c7             	mov    %rax,%rdi
  80a02b:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  80a032:	00 00 00 
  80a035:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a037:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a03b:	48 89 c7             	mov    %rax,%rdi
  80a03e:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  80a045:	00 00 00 
  80a048:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a04a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a04e:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a052:	8d 50 01             	lea    0x1(%rax),%edx
  80a055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a059:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80a05c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a060:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a064:	3c 09                	cmp    $0x9,%al
  80a066:	77 12                	ja     80a07a <dhcp_renew+0x192>
  80a068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a06c:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a070:	0f b6 c0             	movzbl %al,%eax
  80a073:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80a078:	eb 05                	jmp    80a07f <dhcp_renew+0x197>
  80a07a:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80a07f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a083:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a087:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a08d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a092:	89 c8                	mov    %ecx,%eax
  80a094:	f7 ea                	imul   %edx
  80a096:	c1 fa 05             	sar    $0x5,%edx
  80a099:	89 c8                	mov    %ecx,%eax
  80a09b:	c1 f8 1f             	sar    $0x1f,%eax
  80a09e:	29 c2                	sub    %eax,%edx
  80a0a0:	89 d0                	mov    %edx,%eax
  80a0a2:	89 c2                	mov    %eax,%edx
  80a0a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0a8:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a0ac:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a0b0:	c9                   	leaveq 
  80a0b1:	c3                   	retq   

000000000080a0b2 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80a0b2:	55                   	push   %rbp
  80a0b3:	48 89 e5             	mov    %rsp,%rbp
  80a0b6:	48 83 ec 20          	sub    $0x20,%rsp
  80a0ba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a0be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0c2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a0c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80a0ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0ce:	be 04 00 00 00       	mov    $0x4,%esi
  80a0d3:	48 89 c7             	mov    %rax,%rdi
  80a0d6:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  80a0dd:	00 00 00 
  80a0e0:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a0e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0e6:	48 89 c7             	mov    %rax,%rdi
  80a0e9:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  80a0f0:	00 00 00 
  80a0f3:	ff d0                	callq  *%rax
  80a0f5:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a0f8:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a0fc:	0f 85 13 01 00 00    	jne    80a215 <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a102:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a106:	ba 01 00 00 00       	mov    $0x1,%edx
  80a10b:	be 35 00 00 00       	mov    $0x35,%esi
  80a110:	48 89 c7             	mov    %rax,%rdi
  80a113:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  80a11a:	00 00 00 
  80a11d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a11f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a123:	be 03 00 00 00       	mov    $0x3,%esi
  80a128:	48 89 c7             	mov    %rax,%rdi
  80a12b:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  80a132:	00 00 00 
  80a135:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a137:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a13b:	ba 02 00 00 00       	mov    $0x2,%edx
  80a140:	be 39 00 00 00       	mov    $0x39,%esi
  80a145:	48 89 c7             	mov    %rax,%rdi
  80a148:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  80a14f:	00 00 00 
  80a152:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a154:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a158:	be 40 02 00 00       	mov    $0x240,%esi
  80a15d:	48 89 c7             	mov    %rax,%rdi
  80a160:	48 b8 3f a7 80 00 00 	movabs $0x80a73f,%rax
  80a167:	00 00 00 
  80a16a:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80a16c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a170:	48 89 c7             	mov    %rax,%rdi
  80a173:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  80a17a:	00 00 00 
  80a17d:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a17f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a183:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a187:	66 05 f0 00          	add    $0xf0,%ax
  80a18b:	0f b7 d0             	movzwl %ax,%edx
  80a18e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a192:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a196:	89 d6                	mov    %edx,%esi
  80a198:	48 89 c7             	mov    %rax,%rdi
  80a19b:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  80a1a2:	00 00 00 
  80a1a5:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a1a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a1af:	ba 43 00 00 00       	mov    $0x43,%edx
  80a1b4:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  80a1bb:	00 00 00 
  80a1be:	48 89 c7             	mov    %rax,%rdi
  80a1c1:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  80a1c8:	00 00 00 
  80a1cb:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a1cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1d1:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a1d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a1dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a1e1:	49 89 d0             	mov    %rdx,%r8
  80a1e4:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a1e9:	48 ba 2c 1a 82 00 00 	movabs $0x821a2c,%rdx
  80a1f0:	00 00 00 
  80a1f3:	48 89 c7             	mov    %rax,%rdi
  80a1f6:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  80a1fd:	00 00 00 
  80a200:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a206:	48 89 c7             	mov    %rax,%rdi
  80a209:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  80a210:	00 00 00 
  80a213:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a215:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a219:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a21d:	8d 50 01             	lea    0x1(%rax),%edx
  80a220:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a224:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80a227:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a22b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a22f:	3c 09                	cmp    $0x9,%al
  80a231:	77 12                	ja     80a245 <dhcp_rebind+0x193>
  80a233:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a237:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a23b:	0f b6 c0             	movzbl %al,%eax
  80a23e:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a243:	eb 05                	jmp    80a24a <dhcp_rebind+0x198>
  80a245:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a24a:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a24e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a252:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a258:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a25d:	89 c8                	mov    %ecx,%eax
  80a25f:	f7 ea                	imul   %edx
  80a261:	c1 fa 05             	sar    $0x5,%edx
  80a264:	89 c8                	mov    %ecx,%eax
  80a266:	c1 f8 1f             	sar    $0x1f,%eax
  80a269:	29 c2                	sub    %eax,%edx
  80a26b:	89 d0                	mov    %edx,%eax
  80a26d:	89 c2                	mov    %eax,%edx
  80a26f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a273:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a277:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a27b:	c9                   	leaveq 
  80a27c:	c3                   	retq   

000000000080a27d <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80a27d:	55                   	push   %rbp
  80a27e:	48 89 e5             	mov    %rsp,%rbp
  80a281:	48 83 ec 20          	sub    $0x20,%rsp
  80a285:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a289:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a28d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a291:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80a295:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a299:	be 0d 00 00 00       	mov    $0xd,%esi
  80a29e:	48 89 c7             	mov    %rax,%rdi
  80a2a1:	48 b8 e7 a5 80 00 00 	movabs $0x80a5e7,%rax
  80a2a8:	00 00 00 
  80a2ab:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80a2ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2b1:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80a2b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2bc:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80a2c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2c7:	8b 50 50             	mov    0x50(%rax),%edx
  80a2ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2ce:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80a2d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2d5:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80a2dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2e0:	8b 50 58             	mov    0x58(%rax),%edx
  80a2e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2e7:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80a2ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2ee:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80a2f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2f9:	8b 50 70             	mov    0x70(%rax),%edx
  80a2fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a300:	89 50 6c             	mov    %edx,0x6c(%rax)
  80a303:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a307:	8b 50 6c             	mov    0x6c(%rax),%edx
  80a30a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a30e:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80a311:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a315:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a31c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a320:	48 89 c7             	mov    %rax,%rdi
  80a323:	48 b8 e3 ad 80 00 00 	movabs $0x80ade3,%rax
  80a32a:	00 00 00 
  80a32d:	ff d0                	callq  *%rax
  80a32f:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a332:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a336:	0f 85 dd 00 00 00    	jne    80a419 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a33c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a340:	ba 01 00 00 00       	mov    $0x1,%edx
  80a345:	be 35 00 00 00       	mov    $0x35,%esi
  80a34a:	48 89 c7             	mov    %rax,%rdi
  80a34d:	48 b8 18 a6 80 00 00 	movabs $0x80a618,%rax
  80a354:	00 00 00 
  80a357:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80a359:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a35d:	be 07 00 00 00       	mov    $0x7,%esi
  80a362:	48 89 c7             	mov    %rax,%rdi
  80a365:	48 b8 c9 a6 80 00 00 	movabs $0x80a6c9,%rax
  80a36c:	00 00 00 
  80a36f:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a375:	48 89 c7             	mov    %rax,%rdi
  80a378:	48 b8 61 b2 80 00 00 	movabs $0x80b261,%rax
  80a37f:	00 00 00 
  80a382:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a384:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a388:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a38c:	66 05 f0 00          	add    $0xf0,%ax
  80a390:	0f b7 d0             	movzwl %ax,%edx
  80a393:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a397:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a39b:	89 d6                	mov    %edx,%esi
  80a39d:	48 89 c7             	mov    %rax,%rdi
  80a3a0:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  80a3a7:	00 00 00 
  80a3aa:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80a3ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3b0:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80a3b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a3bc:	ba 43 00 00 00       	mov    $0x43,%edx
  80a3c1:	48 89 ce             	mov    %rcx,%rsi
  80a3c4:	48 89 c7             	mov    %rax,%rdi
  80a3c7:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  80a3ce:	00 00 00 
  80a3d1:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80a3d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3d7:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80a3db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3df:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a3e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a3eb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80a3ef:	49 89 c8             	mov    %rcx,%r8
  80a3f2:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a3f7:	48 89 c7             	mov    %rax,%rdi
  80a3fa:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  80a401:	00 00 00 
  80a404:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a406:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a40a:	48 89 c7             	mov    %rax,%rdi
  80a40d:	48 b8 3b b1 80 00 00 	movabs $0x80b13b,%rax
  80a414:	00 00 00 
  80a417:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a419:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a41d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a421:	8d 50 01             	lea    0x1(%rax),%edx
  80a424:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a428:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80a42b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a42f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a433:	3c 09                	cmp    $0x9,%al
  80a435:	77 12                	ja     80a449 <dhcp_release+0x1cc>
  80a437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a43b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a43f:	0f b6 c0             	movzbl %al,%eax
  80a442:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a447:	eb 05                	jmp    80a44e <dhcp_release+0x1d1>
  80a449:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a44e:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a452:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a456:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a45c:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a461:	89 c8                	mov    %ecx,%eax
  80a463:	f7 ea                	imul   %edx
  80a465:	c1 fa 05             	sar    $0x5,%edx
  80a468:	89 c8                	mov    %ecx,%eax
  80a46a:	c1 f8 1f             	sar    $0x1f,%eax
  80a46d:	29 c2                	sub    %eax,%edx
  80a46f:	89 d0                	mov    %edx,%eax
  80a471:	89 c2                	mov    %eax,%edx
  80a473:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a477:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80a47b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a47f:	48 89 c7             	mov    %rax,%rdi
  80a482:	48 b8 31 c8 80 00 00 	movabs $0x80c831,%rax
  80a489:	00 00 00 
  80a48c:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80a48e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a492:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  80a499:	00 00 00 
  80a49c:	48 89 c7             	mov    %rax,%rdi
  80a49f:	48 b8 49 c6 80 00 00 	movabs $0x80c649,%rax
  80a4a6:	00 00 00 
  80a4a9:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80a4ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a4af:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  80a4b6:	00 00 00 
  80a4b9:	48 89 c7             	mov    %rax,%rdi
  80a4bc:	48 b8 4f c7 80 00 00 	movabs $0x80c74f,%rax
  80a4c3:	00 00 00 
  80a4c6:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80a4c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a4cc:	48 be 28 1a 82 00 00 	movabs $0x821a28,%rsi
  80a4d3:	00 00 00 
  80a4d6:	48 89 c7             	mov    %rax,%rdi
  80a4d9:	48 b8 7c c7 80 00 00 	movabs $0x80c77c,%rax
  80a4e0:	00 00 00 
  80a4e3:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80a4e5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a4e9:	c9                   	leaveq 
  80a4ea:	c3                   	retq   

000000000080a4eb <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80a4eb:	55                   	push   %rbp
  80a4ec:	48 89 e5             	mov    %rsp,%rbp
  80a4ef:	48 83 ec 20          	sub    $0x20,%rsp
  80a4f3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a4f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a4fb:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a4ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80a503:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a508:	75 2a                	jne    80a534 <dhcp_stop+0x49>
  80a50a:	48 ba 7c 0c 82 00 00 	movabs $0x820c7c,%rdx
  80a511:	00 00 00 
  80a514:	be 2c 04 00 00       	mov    $0x42c,%esi
  80a519:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a520:	00 00 00 
  80a523:	b8 00 00 00 00       	mov    $0x0,%eax
  80a528:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a52f:	00 00 00 
  80a532:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80a534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a538:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80a53c:	83 e0 f7             	and    $0xfffffff7,%eax
  80a53f:	89 c2                	mov    %eax,%edx
  80a541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a545:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80a548:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80a54d:	0f 84 92 00 00 00    	je     80a5e5 <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80a553:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a557:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a55b:	48 85 c0             	test   %rax,%rax
  80a55e:	74 23                	je     80a583 <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80a560:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a564:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a568:	48 89 c7             	mov    %rax,%rdi
  80a56b:	48 b8 39 4d 81 00 00 	movabs $0x814d39,%rax
  80a572:	00 00 00 
  80a575:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80a577:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a57b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80a582:	00 
    }
    if (dhcp->p != NULL) {
  80a583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a587:	48 8b 40 10          	mov    0x10(%rax),%rax
  80a58b:	48 85 c0             	test   %rax,%rax
  80a58e:	74 23                	je     80a5b3 <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80a590:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a594:	48 8b 40 10          	mov    0x10(%rax),%rax
  80a598:	48 89 c7             	mov    %rax,%rdi
  80a59b:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80a5a2:	00 00 00 
  80a5a5:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80a5a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5ab:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80a5b2:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80a5b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5b7:	48 89 c7             	mov    %rax,%rdi
  80a5ba:	48 b8 19 ab 80 00 00 	movabs $0x80ab19,%rax
  80a5c1:	00 00 00 
  80a5c4:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80a5c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5ca:	48 89 c7             	mov    %rax,%rdi
  80a5cd:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  80a5d4:	00 00 00 
  80a5d7:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80a5d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a5dd:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80a5e4:	00 
  }
}
  80a5e5:	c9                   	leaveq 
  80a5e6:	c3                   	retq   

000000000080a5e7 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80a5e7:	55                   	push   %rbp
  80a5e8:	48 89 e5             	mov    %rsp,%rbp
  80a5eb:	48 83 ec 10          	sub    $0x10,%rsp
  80a5ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a5f3:	89 f0                	mov    %esi,%eax
  80a5f5:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80a5f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5fc:	0f b6 00             	movzbl (%rax),%eax
  80a5ff:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80a602:	74 12                	je     80a616 <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80a604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a608:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80a60c:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80a60e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a612:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80a616:	c9                   	leaveq 
  80a617:	c3                   	retq   

000000000080a618 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80a618:	55                   	push   %rbp
  80a619:	48 89 e5             	mov    %rsp,%rbp
  80a61c:	48 83 ec 10          	sub    $0x10,%rsp
  80a620:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a624:	89 f1                	mov    %esi,%ecx
  80a626:	89 d0                	mov    %edx,%eax
  80a628:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80a62b:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80a62e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a632:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a636:	0f b7 d0             	movzwl %ax,%edx
  80a639:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80a63d:	01 d0                	add    %edx,%eax
  80a63f:	83 c0 02             	add    $0x2,%eax
  80a642:	83 f8 44             	cmp    $0x44,%eax
  80a645:	76 2a                	jbe    80a671 <dhcp_option+0x59>
  80a647:	48 ba 98 0c 82 00 00 	movabs $0x820c98,%rdx
  80a64e:	00 00 00 
  80a651:	be 5a 04 00 00       	mov    $0x45a,%esi
  80a656:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a65d:	00 00 00 
  80a660:	b8 00 00 00 00       	mov    $0x0,%eax
  80a665:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a66c:	00 00 00 
  80a66f:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80a671:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a675:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a679:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a67d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a681:	8d 70 01             	lea    0x1(%rax),%esi
  80a684:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a688:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a68c:	0f b7 c0             	movzwl %ax,%eax
  80a68f:	48 98                	cltq   
  80a691:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80a695:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80a69c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6a0:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a6a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6a8:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a6ac:	8d 70 01             	lea    0x1(%rax),%esi
  80a6af:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a6b3:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a6b7:	0f b7 c0             	movzwl %ax,%eax
  80a6ba:	48 98                	cltq   
  80a6bc:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
  80a6c0:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80a6c7:	c9                   	leaveq 
  80a6c8:	c3                   	retq   

000000000080a6c9 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80a6c9:	55                   	push   %rbp
  80a6ca:	48 89 e5             	mov    %rsp,%rbp
  80a6cd:	48 83 ec 10          	sub    $0x10,%rsp
  80a6d1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a6d5:	89 f0                	mov    %esi,%eax
  80a6d7:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80a6da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6de:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a6e2:	66 83 f8 43          	cmp    $0x43,%ax
  80a6e6:	76 2a                	jbe    80a712 <dhcp_option_byte+0x49>
  80a6e8:	48 ba e0 0c 82 00 00 	movabs $0x820ce0,%rdx
  80a6ef:	00 00 00 
  80a6f2:	be 65 04 00 00       	mov    $0x465,%esi
  80a6f7:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a6fe:	00 00 00 
  80a701:	b8 00 00 00 00       	mov    $0x0,%eax
  80a706:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a70d:	00 00 00 
  80a710:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80a712:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a716:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a71a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a71e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a722:	8d 70 01             	lea    0x1(%rax),%esi
  80a725:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a729:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a72d:	0f b7 c0             	movzwl %ax,%eax
  80a730:	48 98                	cltq   
  80a732:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80a736:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80a73d:	c9                   	leaveq 
  80a73e:	c3                   	retq   

000000000080a73f <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80a73f:	55                   	push   %rbp
  80a740:	48 89 e5             	mov    %rsp,%rbp
  80a743:	48 83 ec 10          	sub    $0x10,%rsp
  80a747:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a74b:	89 f0                	mov    %esi,%eax
  80a74d:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80a751:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a755:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a759:	0f b7 c0             	movzwl %ax,%eax
  80a75c:	83 c0 02             	add    $0x2,%eax
  80a75f:	83 f8 44             	cmp    $0x44,%eax
  80a762:	76 2a                	jbe    80a78e <dhcp_option_short+0x4f>
  80a764:	48 ba 20 0d 82 00 00 	movabs $0x820d20,%rdx
  80a76b:	00 00 00 
  80a76e:	be 6c 04 00 00       	mov    $0x46c,%esi
  80a773:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a77a:	00 00 00 
  80a77d:	b8 00 00 00 00       	mov    $0x0,%eax
  80a782:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a789:	00 00 00 
  80a78c:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80a78e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a792:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a796:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a79a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a79e:	8d 70 01             	lea    0x1(%rax),%esi
  80a7a1:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a7a5:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a7a9:	0f b7 c0             	movzwl %ax,%eax
  80a7ac:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80a7b0:	66 c1 e9 08          	shr    $0x8,%cx
  80a7b4:	48 98                	cltq   
  80a7b6:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80a7bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7c1:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a7c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7c9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a7cd:	8d 70 01             	lea    0x1(%rax),%esi
  80a7d0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a7d4:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a7d8:	0f b7 c0             	movzwl %ax,%eax
  80a7db:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80a7df:	48 98                	cltq   
  80a7e1:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80a7e8:	c9                   	leaveq 
  80a7e9:	c3                   	retq   

000000000080a7ea <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80a7ea:	55                   	push   %rbp
  80a7eb:	48 89 e5             	mov    %rsp,%rbp
  80a7ee:	48 83 ec 10          	sub    $0x10,%rsp
  80a7f2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a7f6:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80a7f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7fd:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a801:	0f b7 c0             	movzwl %ax,%eax
  80a804:	83 c0 04             	add    $0x4,%eax
  80a807:	83 f8 44             	cmp    $0x44,%eax
  80a80a:	76 2a                	jbe    80a836 <dhcp_option_long+0x4c>
  80a80c:	48 ba 68 0d 82 00 00 	movabs $0x820d68,%rdx
  80a813:	00 00 00 
  80a816:	be 74 04 00 00       	mov    $0x474,%esi
  80a81b:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a822:	00 00 00 
  80a825:	b8 00 00 00 00       	mov    $0x0,%eax
  80a82a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a831:	00 00 00 
  80a834:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80a836:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a83a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a83e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a842:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a846:	8d 70 01             	lea    0x1(%rax),%esi
  80a849:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a84d:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a851:	0f b7 c0             	movzwl %ax,%eax
  80a854:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80a857:	c1 e9 18             	shr    $0x18,%ecx
  80a85a:	48 98                	cltq   
  80a85c:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80a863:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a867:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a86b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a86f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a873:	8d 70 01             	lea    0x1(%rax),%esi
  80a876:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a87a:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a87e:	0f b7 c0             	movzwl %ax,%eax
  80a881:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80a884:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  80a88a:	48 c1 e9 10          	shr    $0x10,%rcx
  80a88e:	48 98                	cltq   
  80a890:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80a897:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a89b:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a89f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8a3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a8a7:	8d 70 01             	lea    0x1(%rax),%esi
  80a8aa:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a8ae:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a8b2:	0f b7 c0             	movzwl %ax,%eax
  80a8b5:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80a8b8:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80a8be:	48 c1 e9 08          	shr    $0x8,%rcx
  80a8c2:	48 98                	cltq   
  80a8c4:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80a8cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8cf:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80a8d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8d7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a8db:	8d 70 01             	lea    0x1(%rax),%esi
  80a8de:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80a8e2:	66 89 71 40          	mov    %si,0x40(%rcx)
  80a8e6:	0f b7 c0             	movzwl %ax,%eax
  80a8e9:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80a8ec:	48 98                	cltq   
  80a8ee:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80a8f5:	c9                   	leaveq 
  80a8f6:	c3                   	retq   

000000000080a8f7 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80a8f7:	55                   	push   %rbp
  80a8f8:	48 89 e5             	mov    %rsp,%rbp
  80a8fb:	48 83 ec 20          	sub    $0x20,%rsp
  80a8ff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80a903:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a908:	75 2a                	jne    80a934 <dhcp_unfold_reply+0x3d>
  80a90a:	48 ba a8 0d 82 00 00 	movabs $0x820da8,%rdx
  80a911:	00 00 00 
  80a914:	be 89 04 00 00       	mov    $0x489,%esi
  80a919:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a920:	00 00 00 
  80a923:	b8 00 00 00 00       	mov    $0x0,%eax
  80a928:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a92f:	00 00 00 
  80a932:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80a934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a938:	48 8b 40 10          	mov    0x10(%rax),%rax
  80a93c:	48 85 c0             	test   %rax,%rax
  80a93f:	75 2a                	jne    80a96b <dhcp_unfold_reply+0x74>
  80a941:	48 ba b5 0d 82 00 00 	movabs $0x820db5,%rdx
  80a948:	00 00 00 
  80a94b:	be 8a 04 00 00       	mov    $0x48a,%esi
  80a950:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80a957:	00 00 00 
  80a95a:	b8 00 00 00 00       	mov    $0x0,%eax
  80a95f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80a966:	00 00 00 
  80a969:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80a96b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a96f:	48 89 c7             	mov    %rax,%rdi
  80a972:	48 b8 19 ab 80 00 00 	movabs $0x80ab19,%rax
  80a979:	00 00 00 
  80a97c:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80a97e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a982:	48 8b 40 10          	mov    0x10(%rax),%rax
  80a986:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80a98a:	66 3d f0 00          	cmp    $0xf0,%ax
  80a98e:	76 55                	jbe    80a9e5 <dhcp_unfold_reply+0xee>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80a990:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a994:	48 8b 40 10          	mov    0x10(%rax),%rax
  80a998:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80a99c:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80a9a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9a6:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80a9aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9ae:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80a9b2:	0f b7 c0             	movzwl %ax,%eax
  80a9b5:	89 c7                	mov    %eax,%edi
  80a9b7:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  80a9be:	00 00 00 
  80a9c1:	ff d0                	callq  *%rax
  80a9c3:	48 89 c2             	mov    %rax,%rdx
  80a9c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9ca:	48 89 50 20          	mov    %rdx,0x20(%rax)
    if (dhcp->options_in == NULL) {
  80a9ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9d2:	48 8b 40 20          	mov    0x20(%rax),%rax
  80a9d6:	48 85 c0             	test   %rax,%rax
  80a9d9:	75 0a                	jne    80a9e5 <dhcp_unfold_reply+0xee>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80a9db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a9e0:	e9 32 01 00 00       	jmpq   80ab17 <dhcp_unfold_reply+0x220>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80a9e5:	bf f0 00 00 00       	mov    $0xf0,%edi
  80a9ea:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  80a9f1:	00 00 00 
  80a9f4:	ff d0                	callq  *%rax
  80a9f6:	48 89 c2             	mov    %rax,%rdx
  80a9f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9fd:	48 89 50 18          	mov    %rdx,0x18(%rax)
  if (dhcp->msg_in == NULL) {
  80aa01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa05:	48 8b 40 18          	mov    0x18(%rax),%rax
  80aa09:	48 85 c0             	test   %rax,%rax
  80aa0c:	75 2d                	jne    80aa3b <dhcp_unfold_reply+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80aa0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa12:	48 8b 40 20          	mov    0x20(%rax),%rax
  80aa16:	48 89 c7             	mov    %rax,%rdi
  80aa19:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  80aa20:	00 00 00 
  80aa23:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80aa25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa29:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80aa30:	00 
    return ERR_MEM;
  80aa31:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa36:	e9 dc 00 00 00       	jmpq   80ab17 <dhcp_unfold_reply+0x220>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80aa3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa3f:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80aa43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa47:	48 8b 40 10          	mov    0x10(%rax),%rax
  80aa4b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80aa50:	ba f0 00 00 00       	mov    $0xf0,%edx
  80aa55:	48 89 c7             	mov    %rax,%rdi
  80aa58:	48 b8 6b d8 80 00 00 	movabs $0x80d86b,%rax
  80aa5f:	00 00 00 
  80aa62:	ff d0                	callq  *%rax
  80aa64:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80aa68:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80aa6e:	74 2a                	je     80aa9a <dhcp_unfold_reply+0x1a3>
  80aa70:	48 ba c8 0d 82 00 00 	movabs $0x820dc8,%rdx
  80aa77:	00 00 00 
  80aa7a:	be a0 04 00 00       	mov    $0x4a0,%esi
  80aa7f:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80aa86:	00 00 00 
  80aa89:	b8 00 00 00 00       	mov    $0x0,%eax
  80aa8e:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80aa95:	00 00 00 
  80aa98:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80aa9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa9e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80aaa2:	48 85 c0             	test   %rax,%rax
  80aaa5:	74 6b                	je     80ab12 <dhcp_unfold_reply+0x21b>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80aaa7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aaab:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80aaaf:	0f b7 d0             	movzwl %ax,%edx
  80aab2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aab6:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80aaba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aabe:	48 8b 40 10          	mov    0x10(%rax),%rax
  80aac2:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80aac7:	48 89 c7             	mov    %rax,%rdi
  80aaca:	48 b8 6b d8 80 00 00 	movabs $0x80d86b,%rax
  80aad1:	00 00 00 
  80aad4:	ff d0                	callq  *%rax
  80aad6:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80aada:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aade:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80aae2:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80aae6:	74 2a                	je     80ab12 <dhcp_unfold_reply+0x21b>
  80aae8:	48 ba fa 0d 82 00 00 	movabs $0x820dfa,%rdx
  80aaef:	00 00 00 
  80aaf2:	be a7 04 00 00       	mov    $0x4a7,%esi
  80aaf7:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80aafe:	00 00 00 
  80ab01:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab06:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ab0d:	00 00 00 
  80ab10:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80ab12:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ab17:	c9                   	leaveq 
  80ab18:	c3                   	retq   

000000000080ab19 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80ab19:	55                   	push   %rbp
  80ab1a:	48 89 e5             	mov    %rsp,%rbp
  80ab1d:	48 83 ec 10          	sub    $0x10,%rsp
  80ab21:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80ab25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab29:	48 8b 40 18          	mov    0x18(%rax),%rax
  80ab2d:	48 85 c0             	test   %rax,%rax
  80ab30:	74 23                	je     80ab55 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80ab32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab36:	48 8b 40 18          	mov    0x18(%rax),%rax
  80ab3a:	48 89 c7             	mov    %rax,%rdi
  80ab3d:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  80ab44:	00 00 00 
  80ab47:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80ab49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab4d:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80ab54:	00 
  }
  if (dhcp->options_in) {
  80ab55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab59:	48 8b 40 20          	mov    0x20(%rax),%rax
  80ab5d:	48 85 c0             	test   %rax,%rax
  80ab60:	74 2d                	je     80ab8f <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80ab62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab66:	48 8b 40 20          	mov    0x20(%rax),%rax
  80ab6a:	48 89 c7             	mov    %rax,%rdi
  80ab6d:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  80ab74:	00 00 00 
  80ab77:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80ab79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab7d:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80ab84:	00 
    dhcp->options_in_len = 0;
  80ab85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab89:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80ab8f:	c9                   	leaveq 
  80ab90:	c3                   	retq   

000000000080ab91 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80ab91:	55                   	push   %rbp
  80ab92:	48 89 e5             	mov    %rsp,%rbp
  80ab95:	48 83 ec 60          	sub    $0x60,%rsp
  80ab99:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80ab9d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80aba1:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80aba5:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80aba9:	44 89 c0             	mov    %r8d,%eax
  80abac:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80abb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80abb4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80abb8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80abbc:	48 8b 40 38          	mov    0x38(%rax),%rax
  80abc0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80abc4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80abc8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80abcc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80abd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80abd4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80abd8:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80abdc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80abe0:	0f b6 00             	movzbl (%rax),%eax
  80abe3:	3c 02                	cmp    $0x2,%al
  80abe5:	74 05                	je     80abec <dhcp_recv+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80abe7:	e9 d6 01 00 00       	jmpq   80adc2 <dhcp_recv+0x231>
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80abec:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80abf0:	eb 31                	jmp    80ac23 <dhcp_recv+0x92>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80abf2:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80abf6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80abfa:	48 98                	cltq   
  80abfc:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80ac01:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80ac05:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ac09:	48 98                	cltq   
  80ac0b:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80ac10:	38 c1                	cmp    %al,%cl
  80ac12:	74 05                	je     80ac19 <dhcp_recv+0x88>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80ac14:	e9 a9 01 00 00       	jmpq   80adc2 <dhcp_recv+0x231>
  for (i = 0; i < netif->hwaddr_len; i++) {
  80ac19:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80ac1d:	83 c0 01             	add    $0x1,%eax
  80ac20:	88 45 ff             	mov    %al,-0x1(%rbp)
  80ac23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ac27:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80ac2b:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80ac2e:	77 c2                	ja     80abf2 <dhcp_recv+0x61>
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80ac30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ac34:	8b 40 04             	mov    0x4(%rax),%eax
  80ac37:	89 c7                	mov    %eax,%edi
  80ac39:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  80ac40:	00 00 00 
  80ac43:	ff d0                	callq  *%rax
  80ac45:	89 c2                	mov    %eax,%edx
  80ac47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac4b:	8b 40 04             	mov    0x4(%rax),%eax
  80ac4e:	39 c2                	cmp    %eax,%edx
  80ac50:	74 05                	je     80ac57 <dhcp_recv+0xc6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80ac52:	e9 6b 01 00 00       	jmpq   80adc2 <dhcp_recv+0x231>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80ac57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac5b:	48 89 c7             	mov    %rax,%rdi
  80ac5e:	48 b8 f7 a8 80 00 00 	movabs $0x80a8f7,%rax
  80ac65:	00 00 00 
  80ac68:	ff d0                	callq  *%rax
  80ac6a:	84 c0                	test   %al,%al
  80ac6c:	74 05                	je     80ac73 <dhcp_recv+0xe2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80ac6e:	e9 4f 01 00 00       	jmpq   80adc2 <dhcp_recv+0x231>
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80ac73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac77:	be 35 00 00 00       	mov    $0x35,%esi
  80ac7c:	48 89 c7             	mov    %rax,%rdi
  80ac7f:	48 b8 b9 b3 80 00 00 	movabs $0x80b3b9,%rax
  80ac86:	00 00 00 
  80ac89:	ff d0                	callq  *%rax
  80ac8b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80ac8f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80ac94:	75 05                	jne    80ac9b <dhcp_recv+0x10a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80ac96:	e9 27 01 00 00       	jmpq   80adc2 <dhcp_recv+0x231>
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80ac9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ac9f:	48 83 c0 02          	add    $0x2,%rax
  80aca3:	48 89 c7             	mov    %rax,%rdi
  80aca6:	48 b8 7b b5 80 00 00 	movabs $0x80b57b,%rax
  80acad:	00 00 00 
  80acb0:	ff d0                	callq  *%rax
  80acb2:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80acb5:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80acb9:	0f 85 84 00 00 00    	jne    80ad43 <dhcp_recv+0x1b2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80acbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80acc3:	0f b6 00             	movzbl (%rax),%eax
  80acc6:	3c 01                	cmp    $0x1,%al
  80acc8:	75 35                	jne    80acff <dhcp_recv+0x16e>
      dhcp_handle_ack(netif);
  80acca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80acce:	48 89 c7             	mov    %rax,%rdi
  80acd1:	48 b8 2d 90 80 00 00 	movabs $0x80902d,%rax
  80acd8:	00 00 00 
  80acdb:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80acdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ace1:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80ace7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aceb:	48 89 c7             	mov    %rax,%rdi
  80acee:	48 b8 ed 88 80 00 00 	movabs $0x8088ed,%rax
  80acf5:	00 00 00 
  80acf8:	ff d0                	callq  *%rax
  80acfa:	e9 c3 00 00 00       	jmpq   80adc2 <dhcp_recv+0x231>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80acff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad03:	0f b6 00             	movzbl (%rax),%eax
  80ad06:	3c 03                	cmp    $0x3,%al
  80ad08:	74 1a                	je     80ad24 <dhcp_recv+0x193>
  80ad0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad0e:	0f b6 00             	movzbl (%rax),%eax
  80ad11:	3c 04                	cmp    $0x4,%al
  80ad13:	74 0f                	je     80ad24 <dhcp_recv+0x193>
  80ad15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad19:	0f b6 00             	movzbl (%rax),%eax
  80ad1c:	3c 05                	cmp    $0x5,%al
  80ad1e:	0f 85 9e 00 00 00    	jne    80adc2 <dhcp_recv+0x231>
      dhcp->request_timeout = 0;
  80ad24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad28:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80ad2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ad32:	48 89 c7             	mov    %rax,%rdi
  80ad35:	48 b8 64 9c 80 00 00 	movabs $0x809c64,%rax
  80ad3c:	00 00 00 
  80ad3f:	ff d0                	callq  *%rax
  80ad41:	eb 7f                	jmp    80adc2 <dhcp_recv+0x231>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80ad43:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80ad47:	75 4b                	jne    80ad94 <dhcp_recv+0x203>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80ad49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad4d:	0f b6 00             	movzbl (%rax),%eax
  else if ((msg_type == DHCP_NAK) &&
  80ad50:	3c 03                	cmp    $0x3,%al
  80ad52:	74 21                	je     80ad75 <dhcp_recv+0x1e4>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80ad54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad58:	0f b6 00             	movzbl (%rax),%eax
  80ad5b:	3c 01                	cmp    $0x1,%al
  80ad5d:	74 16                	je     80ad75 <dhcp_recv+0x1e4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80ad5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad63:	0f b6 00             	movzbl (%rax),%eax
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80ad66:	3c 04                	cmp    $0x4,%al
  80ad68:	74 0b                	je     80ad75 <dhcp_recv+0x1e4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80ad6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad6e:	0f b6 00             	movzbl (%rax),%eax
  80ad71:	3c 05                	cmp    $0x5,%al
  80ad73:	75 1f                	jne    80ad94 <dhcp_recv+0x203>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80ad75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad79:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80ad7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ad83:	48 89 c7             	mov    %rax,%rdi
  80ad86:	48 b8 3e 88 80 00 00 	movabs $0x80883e,%rax
  80ad8d:	00 00 00 
  80ad90:	ff d0                	callq  *%rax
  80ad92:	eb 2e                	jmp    80adc2 <dhcp_recv+0x231>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80ad94:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80ad98:	75 28                	jne    80adc2 <dhcp_recv+0x231>
  80ad9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad9e:	0f b6 00             	movzbl (%rax),%eax
  80ada1:	3c 06                	cmp    $0x6,%al
  80ada3:	75 1d                	jne    80adc2 <dhcp_recv+0x231>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80ada5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ada9:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80adaf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80adb3:	48 89 c7             	mov    %rax,%rdi
  80adb6:	48 b8 86 89 80 00 00 	movabs $0x808986,%rax
  80adbd:	00 00 00 
  80adc0:	ff d0                	callq  *%rax
  }
free_pbuf_and_return:
  pbuf_free(p);
  80adc2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80adc6:	48 89 c7             	mov    %rax,%rdi
  80adc9:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80add0:	00 00 00 
  80add3:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80add5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80add9:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ade0:	00 
}
  80ade1:	c9                   	leaveq 
  80ade2:	c3                   	retq   

000000000080ade3 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80ade3:	55                   	push   %rbp
  80ade4:	48 89 e5             	mov    %rsp,%rbp
  80ade7:	53                   	push   %rbx
  80ade8:	48 83 ec 28          	sub    $0x28,%rsp
  80adec:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80adf0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80adf5:	75 2a                	jne    80ae21 <dhcp_create_request+0x3e>
  80adf7:	48 ba 18 0e 82 00 00 	movabs $0x820e18,%rdx
  80adfe:	00 00 00 
  80ae01:	be 2d 05 00 00       	mov    $0x52d,%esi
  80ae06:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80ae0d:	00 00 00 
  80ae10:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae15:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ae1c:	00 00 00 
  80ae1f:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80ae21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ae25:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ae29:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80ae2d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ae32:	75 2a                	jne    80ae5e <dhcp_create_request+0x7b>
  80ae34:	48 ba 40 0e 82 00 00 	movabs $0x820e40,%rdx
  80ae3b:	00 00 00 
  80ae3e:	be 2f 05 00 00       	mov    $0x52f,%esi
  80ae43:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80ae4a:	00 00 00 
  80ae4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae52:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ae59:	00 00 00 
  80ae5c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80ae5e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ae62:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ae66:	48 85 c0             	test   %rax,%rax
  80ae69:	74 2a                	je     80ae95 <dhcp_create_request+0xb2>
  80ae6b:	48 ba 68 0e 82 00 00 	movabs $0x820e68,%rdx
  80ae72:	00 00 00 
  80ae75:	be 30 05 00 00       	mov    $0x530,%esi
  80ae7a:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80ae81:	00 00 00 
  80ae84:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae89:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ae90:	00 00 00 
  80ae93:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80ae95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ae99:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ae9d:	48 85 c0             	test   %rax,%rax
  80aea0:	74 2a                	je     80aecc <dhcp_create_request+0xe9>
  80aea2:	48 ba 98 0e 82 00 00 	movabs $0x820e98,%rdx
  80aea9:	00 00 00 
  80aeac:	be 31 05 00 00       	mov    $0x531,%esi
  80aeb1:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80aeb8:	00 00 00 
  80aebb:	b8 00 00 00 00       	mov    $0x0,%eax
  80aec0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80aec7:	00 00 00 
  80aeca:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80aecc:	ba 00 00 00 00       	mov    $0x0,%edx
  80aed1:	be 34 01 00 00       	mov    $0x134,%esi
  80aed6:	bf 00 00 00 00       	mov    $0x0,%edi
  80aedb:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  80aee2:	00 00 00 
  80aee5:	ff d0                	callq  *%rax
  80aee7:	48 89 c2             	mov    %rax,%rdx
  80aeea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aeee:	48 89 50 30          	mov    %rdx,0x30(%rax)
  if (dhcp->p_out == NULL) {
  80aef2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aef6:	48 8b 40 30          	mov    0x30(%rax),%rax
  80aefa:	48 85 c0             	test   %rax,%rax
  80aefd:	75 0a                	jne    80af09 <dhcp_create_request+0x126>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80aeff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80af04:	e9 2b 02 00 00       	jmpq   80b134 <dhcp_create_request+0x351>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80af09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80af0d:	48 8b 40 30          	mov    0x30(%rax),%rax
  80af11:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80af15:	66 3d 33 01          	cmp    $0x133,%ax
  80af19:	77 2a                	ja     80af45 <dhcp_create_request+0x162>
  80af1b:	48 ba c8 0e 82 00 00 	movabs $0x820ec8,%rdx
  80af22:	00 00 00 
  80af25:	be 38 05 00 00       	mov    $0x538,%esi
  80af2a:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80af31:	00 00 00 
  80af34:	b8 00 00 00 00       	mov    $0x0,%eax
  80af39:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80af40:	00 00 00 
  80af43:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80af45:	48 b8 7c 71 82 00 00 	movabs $0x82717c,%rax
  80af4c:	00 00 00 
  80af4f:	8b 00                	mov    (%rax),%eax
  80af51:	8d 48 01             	lea    0x1(%rax),%ecx
  80af54:	48 ba 7c 71 82 00 00 	movabs $0x82717c,%rdx
  80af5b:	00 00 00 
  80af5e:	89 0a                	mov    %ecx,(%rdx)
  80af60:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80af64:	89 42 04             	mov    %eax,0x4(%rdx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80af67:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80af6b:	48 8b 40 30          	mov    0x30(%rax),%rax
  80af6f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80af73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80af77:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80af7b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80af7f:	48 8b 40 38          	mov    0x38(%rax),%rax
  80af83:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80af86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80af8a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80af8e:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80af92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80af96:	48 8b 40 38          	mov    0x38(%rax),%rax
  80af9a:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80af9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80afa2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80afa6:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80afaa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80afae:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80afb2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80afb6:	8b 40 04             	mov    0x4(%rax),%eax
  80afb9:	89 c7                	mov    %eax,%edi
  80afbb:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  80afc2:	00 00 00 
  80afc5:	ff d0                	callq  *%rax
  80afc7:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80afca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80afce:	48 8b 40 38          	mov    0x38(%rax),%rax
  80afd2:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80afd8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80afdc:	48 8b 40 38          	mov    0x38(%rax),%rax
  80afe0:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80afe6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80afea:	48 8b 40 38          	mov    0x38(%rax),%rax
  80afee:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80aff2:	8b 52 08             	mov    0x8(%rdx),%edx
  80aff5:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80aff8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80affc:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b000:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80b007:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b00b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b00f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80b016:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b01a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b01e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b025:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b02b:	eb 45                	jmp    80b072 <dhcp_create_request+0x28f>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80b02d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b031:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b035:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80b039:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b03d:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b041:	0f b6 c0             	movzbl %al,%eax
  80b044:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80b048:	76 11                	jbe    80b05b <dhcp_create_request+0x278>
  80b04a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b04e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b052:	48 98                	cltq   
  80b054:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80b059:	eb 05                	jmp    80b060 <dhcp_create_request+0x27d>
  80b05b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b060:	48 63 d6             	movslq %esi,%rdx
  80b063:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b067:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b06b:	83 c0 01             	add    $0x1,%eax
  80b06e:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b072:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80b077:	76 b4                	jbe    80b02d <dhcp_create_request+0x24a>
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b079:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b07f:	eb 1e                	jmp    80b09f <dhcp_create_request+0x2bc>
    dhcp->msg_out->sname[i] = 0;
  80b081:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b085:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b089:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b08d:	48 98                	cltq   
  80b08f:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b094:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b098:	83 c0 01             	add    $0x1,%eax
  80b09b:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b09f:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80b0a4:	76 db                	jbe    80b081 <dhcp_create_request+0x29e>
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b0a6:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b0ac:	eb 1e                	jmp    80b0cc <dhcp_create_request+0x2e9>
    dhcp->msg_out->file[i] = 0;
  80b0ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b0b2:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b0b6:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b0ba:	48 98                	cltq   
  80b0bc:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b0c1:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b0c5:	83 c0 01             	add    $0x1,%eax
  80b0c8:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b0cc:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80b0d1:	76 db                	jbe    80b0ae <dhcp_create_request+0x2cb>
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80b0d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b0d7:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b0db:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80b0e0:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  80b0e7:	00 00 00 
  80b0ea:	ff d0                	callq  *%rax
  80b0ec:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80b0f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b0f6:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b0fc:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b102:	eb 24                	jmp    80b128 <dhcp_create_request+0x345>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80b104:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b108:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b10c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b110:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80b114:	48 98                	cltq   
  80b116:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b11d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b121:	83 c0 01             	add    $0x1,%eax
  80b124:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b128:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80b12d:	76 d5                	jbe    80b104 <dhcp_create_request+0x321>
  }
  return ERR_OK;
  80b12f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b134:	48 83 c4 28          	add    $0x28,%rsp
  80b138:	5b                   	pop    %rbx
  80b139:	5d                   	pop    %rbp
  80b13a:	c3                   	retq   

000000000080b13b <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80b13b:	55                   	push   %rbp
  80b13c:	48 89 e5             	mov    %rsp,%rbp
  80b13f:	48 83 ec 20          	sub    $0x20,%rsp
  80b143:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80b147:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b14c:	75 2a                	jne    80b178 <dhcp_delete_request+0x3d>
  80b14e:	48 ba 10 0f 82 00 00 	movabs $0x820f10,%rdx
  80b155:	00 00 00 
  80b158:	be 69 05 00 00       	mov    $0x569,%esi
  80b15d:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b164:	00 00 00 
  80b167:	b8 00 00 00 00       	mov    $0x0,%eax
  80b16c:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b173:	00 00 00 
  80b176:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b178:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b17c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b180:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80b184:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b189:	75 2a                	jne    80b1b5 <dhcp_delete_request+0x7a>
  80b18b:	48 ba 38 0f 82 00 00 	movabs $0x820f38,%rdx
  80b192:	00 00 00 
  80b195:	be 6b 05 00 00       	mov    $0x56b,%esi
  80b19a:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b1a1:	00 00 00 
  80b1a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b1a9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b1b0:	00 00 00 
  80b1b3:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80b1b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1b9:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b1bd:	48 85 c0             	test   %rax,%rax
  80b1c0:	75 2a                	jne    80b1ec <dhcp_delete_request+0xb1>
  80b1c2:	48 ba 60 0f 82 00 00 	movabs $0x820f60,%rdx
  80b1c9:	00 00 00 
  80b1cc:	be 6c 05 00 00       	mov    $0x56c,%esi
  80b1d1:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b1d8:	00 00 00 
  80b1db:	b8 00 00 00 00       	mov    $0x0,%eax
  80b1e0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b1e7:	00 00 00 
  80b1ea:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80b1ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1f0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b1f4:	48 85 c0             	test   %rax,%rax
  80b1f7:	75 2a                	jne    80b223 <dhcp_delete_request+0xe8>
  80b1f9:	48 ba 90 0f 82 00 00 	movabs $0x820f90,%rdx
  80b200:	00 00 00 
  80b203:	be 6d 05 00 00       	mov    $0x56d,%esi
  80b208:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b20f:	00 00 00 
  80b212:	b8 00 00 00 00       	mov    $0x0,%eax
  80b217:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b21e:	00 00 00 
  80b221:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80b223:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b227:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b22b:	48 85 c0             	test   %rax,%rax
  80b22e:	74 17                	je     80b247 <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80b230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b234:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b238:	48 89 c7             	mov    %rax,%rdi
  80b23b:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80b242:	00 00 00 
  80b245:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80b247:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b24b:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80b252:	00 
  dhcp->msg_out = NULL;
  80b253:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b257:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80b25e:	00 
}
  80b25f:	c9                   	leaveq 
  80b260:	c3                   	retq   

000000000080b261 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80b261:	55                   	push   %rbp
  80b262:	48 89 e5             	mov    %rsp,%rbp
  80b265:	48 83 ec 10          	sub    $0x10,%rsp
  80b269:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80b26d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b272:	75 2a                	jne    80b29e <dhcp_option_trailer+0x3d>
  80b274:	48 ba c0 0f 82 00 00 	movabs $0x820fc0,%rdx
  80b27b:	00 00 00 
  80b27e:	be 80 05 00 00       	mov    $0x580,%esi
  80b283:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b28a:	00 00 00 
  80b28d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b292:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b299:	00 00 00 
  80b29c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80b29e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2a2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b2a6:	48 85 c0             	test   %rax,%rax
  80b2a9:	75 2a                	jne    80b2d5 <dhcp_option_trailer+0x74>
  80b2ab:	48 ba e8 0f 82 00 00 	movabs $0x820fe8,%rdx
  80b2b2:	00 00 00 
  80b2b5:	be 81 05 00 00       	mov    $0x581,%esi
  80b2ba:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b2c1:	00 00 00 
  80b2c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b2c9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b2d0:	00 00 00 
  80b2d3:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b2d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2d9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b2dd:	66 83 f8 43          	cmp    $0x43,%ax
  80b2e1:	76 2a                	jbe    80b30d <dhcp_option_trailer+0xac>
  80b2e3:	48 ba 18 10 82 00 00 	movabs $0x821018,%rdx
  80b2ea:	00 00 00 
  80b2ed:	be 82 05 00 00       	mov    $0x582,%esi
  80b2f2:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b2f9:	00 00 00 
  80b2fc:	b8 00 00 00 00       	mov    $0x0,%eax
  80b301:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b308:	00 00 00 
  80b30b:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80b30d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b311:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b315:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b319:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b31d:	8d 70 01             	lea    0x1(%rax),%esi
  80b320:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b324:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b328:	0f b7 c0             	movzwl %ax,%eax
  80b32b:	48 98                	cltq   
  80b32d:	c6 84 02 f0 00 00 00 	movb   $0xff,0xf0(%rdx,%rax,1)
  80b334:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80b335:	eb 60                	jmp    80b397 <dhcp_option_trailer+0x136>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b337:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b33b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b33f:	66 83 f8 43          	cmp    $0x43,%ax
  80b343:	76 2a                	jbe    80b36f <dhcp_option_trailer+0x10e>
  80b345:	48 ba 18 10 82 00 00 	movabs $0x821018,%rdx
  80b34c:	00 00 00 
  80b34f:	be 87 05 00 00       	mov    $0x587,%esi
  80b354:	48 bf 36 0c 82 00 00 	movabs $0x820c36,%rdi
  80b35b:	00 00 00 
  80b35e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b363:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b36a:	00 00 00 
  80b36d:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80b36f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b373:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b377:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b37b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b37f:	8d 70 01             	lea    0x1(%rax),%esi
  80b382:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b386:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b38a:	0f b7 c0             	movzwl %ax,%eax
  80b38d:	48 98                	cltq   
  80b38f:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%rdx,%rax,1)
  80b396:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80b397:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b39b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b39f:	66 83 f8 43          	cmp    $0x43,%ax
  80b3a3:	76 92                	jbe    80b337 <dhcp_option_trailer+0xd6>
  80b3a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3a9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b3ad:	0f b7 c0             	movzwl %ax,%eax
  80b3b0:	83 e0 03             	and    $0x3,%eax
  80b3b3:	85 c0                	test   %eax,%eax
  80b3b5:	75 80                	jne    80b337 <dhcp_option_trailer+0xd6>
  }
}
  80b3b7:	c9                   	leaveq 
  80b3b8:	c3                   	retq   

000000000080b3b9 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80b3b9:	55                   	push   %rbp
  80b3ba:	48 89 e5             	mov    %rsp,%rbp
  80b3bd:	48 83 ec 30          	sub    $0x30,%rsp
  80b3c1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80b3c5:	89 f0                	mov    %esi,%eax
  80b3c7:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80b3ca:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80b3ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b3d2:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b3d6:	48 85 c0             	test   %rax,%rax
  80b3d9:	0f 84 95 01 00 00    	je     80b574 <dhcp_get_option_ptr+0x1bb>
  80b3df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b3e3:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b3e7:	66 85 c0             	test   %ax,%ax
  80b3ea:	0f 84 84 01 00 00    	je     80b574 <dhcp_get_option_ptr+0x1bb>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80b3f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b3f4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b3f8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80b3fc:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80b402:	e9 80 00 00 00       	jmpq   80b487 <dhcp_get_option_ptr+0xce>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80b407:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b40b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b40f:	48 01 d0             	add    %rdx,%rax
  80b412:	0f b6 00             	movzbl (%rax),%eax
  80b415:	3c 34                	cmp    $0x34,%al
  80b417:	75 22                	jne    80b43b <dhcp_get_option_ptr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80b419:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80b41e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b422:	8d 50 01             	lea    0x1(%rax),%edx
  80b425:	66 89 55 ee          	mov    %dx,-0x12(%rbp)
  80b429:	0f b7 d0             	movzwl %ax,%edx
  80b42c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b430:	48 01 d0             	add    %rdx,%rax
  80b433:	0f b6 00             	movzbl (%rax),%eax
  80b436:	88 45 ff             	mov    %al,-0x1(%rbp)
  80b439:	eb 4c                	jmp    80b487 <dhcp_get_option_ptr+0xce>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80b43b:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b43f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b443:	48 01 d0             	add    %rdx,%rax
  80b446:	0f b6 00             	movzbl (%rax),%eax
  80b449:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80b44c:	75 10                	jne    80b45e <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80b44e:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b452:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b456:	48 01 d0             	add    %rdx,%rax
  80b459:	e9 1b 01 00 00       	jmpq   80b579 <dhcp_get_option_ptr+0x1c0>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80b45e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b462:	83 c0 01             	add    $0x1,%eax
  80b465:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80b469:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b46d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b471:	48 01 d0             	add    %rdx,%rax
  80b474:	0f b6 00             	movzbl (%rax),%eax
  80b477:	0f b6 d0             	movzbl %al,%edx
  80b47a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b47e:	01 d0                	add    %edx,%eax
  80b480:	83 c0 01             	add    $0x1,%eax
  80b483:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80b487:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b48b:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b48f:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80b493:	76 16                	jbe    80b4ab <dhcp_get_option_ptr+0xf2>
  80b495:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b499:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b49d:	48 01 d0             	add    %rdx,%rax
  80b4a0:	0f b6 00             	movzbl (%rax),%eax
  80b4a3:	3c ff                	cmp    $0xff,%al
  80b4a5:	0f 85 5c ff ff ff    	jne    80b407 <dhcp_get_option_ptr+0x4e>
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80b4ab:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80b4af:	0f 84 bf 00 00 00    	je     80b574 <dhcp_get_option_ptr+0x1bb>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80b4b5:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80b4b9:	75 18                	jne    80b4d3 <dhcp_get_option_ptr+0x11a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80b4bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b4bf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b4c3:	48 83 c0 6c          	add    $0x6c,%rax
  80b4c7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80b4cb:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80b4d1:	eb 34                	jmp    80b507 <dhcp_get_option_ptr+0x14e>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80b4d3:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80b4d7:	75 18                	jne    80b4f1 <dhcp_get_option_ptr+0x138>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80b4d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b4dd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b4e1:	48 83 c0 2c          	add    $0x2c,%rax
  80b4e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80b4e9:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80b4ef:	eb 16                	jmp    80b507 <dhcp_get_option_ptr+0x14e>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80b4f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b4f5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b4f9:	48 83 c0 2c          	add    $0x2c,%rax
  80b4fd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80b501:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80b507:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80b50d:	eb 49                	jmp    80b558 <dhcp_get_option_ptr+0x19f>
        if (options[offset] == option_type) {
  80b50f:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b513:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b517:	48 01 d0             	add    %rdx,%rax
  80b51a:	0f b6 00             	movzbl (%rax),%eax
  80b51d:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80b520:	75 0d                	jne    80b52f <dhcp_get_option_ptr+0x176>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80b522:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b526:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b52a:	48 01 d0             	add    %rdx,%rax
  80b52d:	eb 4a                	jmp    80b579 <dhcp_get_option_ptr+0x1c0>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80b52f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b533:	83 c0 01             	add    $0x1,%eax
  80b536:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
          offset += 1 + options[offset];
  80b53a:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b53e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b542:	48 01 d0             	add    %rdx,%rax
  80b545:	0f b6 00             	movzbl (%rax),%eax
  80b548:	0f b6 d0             	movzbl %al,%edx
  80b54b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b54f:	01 d0                	add    %edx,%eax
  80b551:	83 c0 01             	add    $0x1,%eax
  80b554:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80b558:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b55c:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80b560:	73 12                	jae    80b574 <dhcp_get_option_ptr+0x1bb>
  80b562:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80b566:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b56a:	48 01 d0             	add    %rdx,%rax
  80b56d:	0f b6 00             	movzbl (%rax),%eax
  80b570:	3c ff                	cmp    $0xff,%al
  80b572:	75 9b                	jne    80b50f <dhcp_get_option_ptr+0x156>
        }
      }
    }
  }
  return NULL;
  80b574:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b579:	c9                   	leaveq 
  80b57a:	c3                   	retq   

000000000080b57b <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80b57b:	55                   	push   %rbp
  80b57c:	48 89 e5             	mov    %rsp,%rbp
  80b57f:	48 83 ec 08          	sub    $0x8,%rsp
  80b583:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80b587:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b58b:	0f b6 00             	movzbl (%rax),%eax
}
  80b58e:	c9                   	leaveq 
  80b58f:	c3                   	retq   

000000000080b590 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80b590:	55                   	push   %rbp
  80b591:	48 89 e5             	mov    %rsp,%rbp
  80b594:	48 83 ec 18          	sub    $0x18,%rsp
  80b598:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80b59c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5a0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80b5a4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80b5a8:	0f b6 00             	movzbl (%rax),%eax
  80b5ab:	0f b6 c0             	movzbl %al,%eax
  80b5ae:	c1 e0 18             	shl    $0x18,%eax
  80b5b1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80b5b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5b8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80b5bc:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80b5c0:	0f b6 00             	movzbl (%rax),%eax
  80b5c3:	0f b6 c0             	movzbl %al,%eax
  80b5c6:	c1 e0 10             	shl    $0x10,%eax
  80b5c9:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80b5cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5d0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80b5d4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80b5d8:	0f b6 00             	movzbl (%rax),%eax
  80b5db:	0f b6 c0             	movzbl %al,%eax
  80b5de:	c1 e0 08             	shl    $0x8,%eax
  80b5e1:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++);
  80b5e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5e8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80b5ec:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80b5f0:	0f b6 00             	movzbl (%rax),%eax
  80b5f3:	0f b6 c0             	movzbl %al,%eax
  80b5f6:	09 45 fc             	or     %eax,-0x4(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80b5f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80b5fc:	c9                   	leaveq 
  80b5fd:	c3                   	retq   

000000000080b5fe <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80b5fe:	55                   	push   %rbp
  80b5ff:	48 89 e5             	mov    %rsp,%rbp
  80b602:	48 83 ec 20          	sub    $0x20,%rsp
  80b606:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80b60a:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b611:	00 00 00 
  80b614:	48 8b 00             	mov    (%rax),%rax
  80b617:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80b61b:	73 2a                	jae    80b647 <plug_holes+0x49>
  80b61d:	48 ba 58 10 82 00 00 	movabs $0x821058,%rdx
  80b624:	00 00 00 
  80b627:	be e3 00 00 00       	mov    $0xe3,%esi
  80b62c:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80b633:	00 00 00 
  80b636:	b8 00 00 00 00       	mov    $0x0,%eax
  80b63b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b642:	00 00 00 
  80b645:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80b647:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b64e:	00 00 00 
  80b651:	48 8b 00             	mov    (%rax),%rax
  80b654:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80b658:	72 2a                	jb     80b684 <plug_holes+0x86>
  80b65a:	48 ba 83 10 82 00 00 	movabs $0x821083,%rdx
  80b661:	00 00 00 
  80b664:	be e4 00 00 00       	mov    $0xe4,%esi
  80b669:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80b670:	00 00 00 
  80b673:	b8 00 00 00 00       	mov    $0x0,%eax
  80b678:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b67f:	00 00 00 
  80b682:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80b684:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b688:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80b68c:	84 c0                	test   %al,%al
  80b68e:	74 2a                	je     80b6ba <plug_holes+0xbc>
  80b690:	48 ba 9d 10 82 00 00 	movabs $0x82109d,%rdx
  80b697:	00 00 00 
  80b69a:	be e5 00 00 00       	mov    $0xe5,%esi
  80b69f:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80b6a6:	00 00 00 
  80b6a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6ae:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b6b5:	00 00 00 
  80b6b8:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80b6ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6be:	8b 00                	mov    (%rax),%eax
  80b6c0:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80b6c5:	76 2a                	jbe    80b6f1 <plug_holes+0xf3>
  80b6c7:	48 ba b8 10 82 00 00 	movabs $0x8210b8,%rdx
  80b6ce:	00 00 00 
  80b6d1:	be e8 00 00 00       	mov    $0xe8,%esi
  80b6d6:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80b6dd:	00 00 00 
  80b6e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6e5:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b6ec:	00 00 00 
  80b6ef:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80b6f1:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b6f8:	00 00 00 
  80b6fb:	48 8b 10             	mov    (%rax),%rdx
  80b6fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b702:	8b 00                	mov    (%rax),%eax
  80b704:	89 c0                	mov    %eax,%eax
  80b706:	48 01 d0             	add    %rdx,%rax
  80b709:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80b70d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b711:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80b715:	0f 84 81 00 00 00    	je     80b79c <plug_holes+0x19e>
  80b71b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b71f:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80b723:	84 c0                	test   %al,%al
  80b725:	75 75                	jne    80b79c <plug_holes+0x19e>
  80b727:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b72e:	00 00 00 
  80b731:	48 8b 00             	mov    (%rax),%rax
  80b734:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80b738:	74 62                	je     80b79c <plug_holes+0x19e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80b73a:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80b741:	00 00 00 
  80b744:	48 8b 00             	mov    (%rax),%rax
  80b747:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80b74b:	75 11                	jne    80b75e <plug_holes+0x160>
      lfree = mem;
  80b74d:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80b754:	00 00 00 
  80b757:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b75b:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80b75e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b762:	8b 10                	mov    (%rax),%edx
  80b764:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b768:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80b76a:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b771:	00 00 00 
  80b774:	48 8b 10             	mov    (%rax),%rdx
  80b777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b77b:	8b 00                	mov    (%rax),%eax
  80b77d:	89 c0                	mov    %eax,%eax
  80b77f:	48 01 c2             	add    %rax,%rdx
  80b782:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80b786:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b78d:	00 00 00 
  80b790:	48 8b 00             	mov    (%rax),%rax
  80b793:	48 29 c1             	sub    %rax,%rcx
  80b796:	48 89 c8             	mov    %rcx,%rax
  80b799:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80b79c:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b7a3:	00 00 00 
  80b7a6:	48 8b 10             	mov    (%rax),%rdx
  80b7a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7ad:	8b 40 04             	mov    0x4(%rax),%eax
  80b7b0:	89 c0                	mov    %eax,%eax
  80b7b2:	48 01 d0             	add    %rdx,%rax
  80b7b5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80b7b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7bd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80b7c1:	74 6e                	je     80b831 <plug_holes+0x233>
  80b7c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7c7:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80b7cb:	84 c0                	test   %al,%al
  80b7cd:	75 62                	jne    80b831 <plug_holes+0x233>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80b7cf:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80b7d6:	00 00 00 
  80b7d9:	48 8b 00             	mov    (%rax),%rax
  80b7dc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80b7e0:	75 11                	jne    80b7f3 <plug_holes+0x1f5>
      lfree = pmem;
  80b7e2:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80b7e9:	00 00 00 
  80b7ec:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b7f0:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80b7f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7f7:	8b 10                	mov    (%rax),%edx
  80b7f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7fd:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80b7ff:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b806:	00 00 00 
  80b809:	48 8b 10             	mov    (%rax),%rdx
  80b80c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b810:	8b 00                	mov    (%rax),%eax
  80b812:	89 c0                	mov    %eax,%eax
  80b814:	48 01 c2             	add    %rax,%rdx
  80b817:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80b81b:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b822:	00 00 00 
  80b825:	48 8b 00             	mov    (%rax),%rax
  80b828:	48 29 c1             	sub    %rax,%rcx
  80b82b:	48 89 c8             	mov    %rcx,%rax
  80b82e:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80b831:	c9                   	leaveq 
  80b832:	c3                   	retq   

000000000080b833 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80b833:	55                   	push   %rbp
  80b834:	48 89 e5             	mov    %rsp,%rbp
  80b837:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80b83b:	48 b8 00 85 82 00 00 	movabs $0x828500,%rax
  80b842:	00 00 00 
  80b845:	48 83 c0 03          	add    $0x3,%rax
  80b849:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80b84d:	48 89 c2             	mov    %rax,%rdx
  80b850:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b857:	00 00 00 
  80b85a:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80b85d:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b864:	00 00 00 
  80b867:	48 8b 00             	mov    (%rax),%rax
  80b86a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80b86e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b872:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80b878:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b87c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80b883:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b887:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80b88b:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b892:	00 00 00 
  80b895:	48 8b 00             	mov    (%rax),%rax
  80b898:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80b89f:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b8a6:	00 00 00 
  80b8a9:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80b8ac:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b8b3:	00 00 00 
  80b8b6:	48 8b 00             	mov    (%rax),%rax
  80b8b9:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80b8bd:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b8c4:	00 00 00 
  80b8c7:	48 8b 00             	mov    (%rax),%rax
  80b8ca:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80b8d0:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b8d7:	00 00 00 
  80b8da:	48 8b 00             	mov    (%rax),%rax
  80b8dd:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80b8e4:	bf 01 00 00 00       	mov    $0x1,%edi
  80b8e9:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  80b8f0:	00 00 00 
  80b8f3:	ff d0                	callq  *%rax
  80b8f5:	89 c2                	mov    %eax,%edx
  80b8f7:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80b8fe:	00 00 00 
  80b901:	89 10                	mov    %edx,(%rax)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80b903:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b90a:	00 00 00 
  80b90d:	48 8b 10             	mov    (%rax),%rdx
  80b910:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80b917:	00 00 00 
  80b91a:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80b91d:	c9                   	leaveq 
  80b91e:	c3                   	retq   

000000000080b91f <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80b91f:	55                   	push   %rbp
  80b920:	48 89 e5             	mov    %rsp,%rbp
  80b923:	48 83 ec 20          	sub    $0x20,%rsp
  80b927:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80b92b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b930:	75 05                	jne    80b937 <mem_free+0x18>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80b932:	e9 6b 01 00 00       	jmpq   80baa2 <mem_free+0x183>
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80b937:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b93b:	83 e0 03             	and    $0x3,%eax
  80b93e:	48 85 c0             	test   %rax,%rax
  80b941:	74 2a                	je     80b96d <mem_free+0x4e>
  80b943:	48 ba e8 10 82 00 00 	movabs $0x8210e8,%rdx
  80b94a:	00 00 00 
  80b94d:	be 30 01 00 00       	mov    $0x130,%esi
  80b952:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80b959:	00 00 00 
  80b95c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b961:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b968:	00 00 00 
  80b96b:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80b96d:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b974:	00 00 00 
  80b977:	48 8b 00             	mov    (%rax),%rax
  80b97a:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80b97e:	72 13                	jb     80b993 <mem_free+0x74>
  80b980:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b987:	00 00 00 
  80b98a:	48 8b 00             	mov    (%rax),%rax
  80b98d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80b991:	72 2a                	jb     80b9bd <mem_free+0x9e>
  80b993:	48 ba 09 11 82 00 00 	movabs $0x821109,%rdx
  80b99a:	00 00 00 
  80b99d:	be 33 01 00 00       	mov    $0x133,%esi
  80b9a2:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80b9a9:	00 00 00 
  80b9ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9b1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80b9b8:	00 00 00 
  80b9bb:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80b9bd:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80b9c4:	00 00 00 
  80b9c7:	48 8b 00             	mov    (%rax),%rax
  80b9ca:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80b9ce:	72 13                	jb     80b9e3 <mem_free+0xc4>
  80b9d0:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80b9d7:	00 00 00 
  80b9da:	48 8b 00             	mov    (%rax),%rax
  80b9dd:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80b9e1:	72 05                	jb     80b9e8 <mem_free+0xc9>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80b9e3:	e9 ba 00 00 00       	jmpq   80baa2 <mem_free+0x183>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80b9e8:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80b9ef:	00 00 00 
  80b9f2:	8b 00                	mov    (%rax),%eax
  80b9f4:	be 00 00 00 00       	mov    $0x0,%esi
  80b9f9:	89 c7                	mov    %eax,%edi
  80b9fb:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  80ba02:	00 00 00 
  80ba05:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80ba07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ba0b:	48 83 e8 0c          	sub    $0xc,%rax
  80ba0f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80ba13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba17:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80ba1b:	84 c0                	test   %al,%al
  80ba1d:	75 2a                	jne    80ba49 <mem_free+0x12a>
  80ba1f:	48 ba 20 11 82 00 00 	movabs $0x821120,%rdx
  80ba26:	00 00 00 
  80ba29:	be 43 01 00 00       	mov    $0x143,%esi
  80ba2e:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80ba35:	00 00 00 
  80ba38:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba3d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ba44:	00 00 00 
  80ba47:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80ba49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba4d:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80ba51:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80ba58:	00 00 00 
  80ba5b:	48 8b 00             	mov    (%rax),%rax
  80ba5e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80ba62:	73 11                	jae    80ba75 <mem_free+0x156>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80ba64:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80ba6b:	00 00 00 
  80ba6e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ba72:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80ba75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba79:	48 89 c7             	mov    %rax,%rdi
  80ba7c:	48 b8 fe b5 80 00 00 	movabs $0x80b5fe,%rax
  80ba83:	00 00 00 
  80ba86:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80ba88:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80ba8f:	00 00 00 
  80ba92:	8b 00                	mov    (%rax),%eax
  80ba94:	89 c7                	mov    %eax,%edi
  80ba96:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80ba9d:	00 00 00 
  80baa0:	ff d0                	callq  *%rax
}
  80baa2:	c9                   	leaveq 
  80baa3:	c3                   	retq   

000000000080baa4 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80baa4:	55                   	push   %rbp
  80baa5:	48 89 e5             	mov    %rsp,%rbp
  80baa8:	48 83 ec 30          	sub    $0x30,%rsp
  80baac:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80bab0:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80bab3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bab6:	83 c0 03             	add    $0x3,%eax
  80bab9:	83 e0 fc             	and    $0xfffffffc,%eax
  80babc:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80babf:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80bac3:	77 07                	ja     80bacc <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80bac5:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80bacc:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80bad3:	76 0a                	jbe    80badf <mem_realloc+0x3b>
    return NULL;
  80bad5:	b8 00 00 00 00       	mov    $0x0,%eax
  80bada:	e9 da 02 00 00       	jmpq   80bdb9 <mem_realloc+0x315>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80badf:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bae6:	00 00 00 
  80bae9:	48 8b 00             	mov    (%rax),%rax
  80baec:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80baf0:	72 13                	jb     80bb05 <mem_realloc+0x61>
  80baf2:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80baf9:	00 00 00 
  80bafc:	48 8b 00             	mov    (%rax),%rax
  80baff:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80bb03:	72 2a                	jb     80bb2f <mem_realloc+0x8b>
  80bb05:	48 ba 34 11 82 00 00 	movabs $0x821134,%rdx
  80bb0c:	00 00 00 
  80bb0f:	be 79 01 00 00       	mov    $0x179,%esi
  80bb14:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80bb1b:	00 00 00 
  80bb1e:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb23:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80bb2a:	00 00 00 
  80bb2d:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80bb2f:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bb36:	00 00 00 
  80bb39:	48 8b 00             	mov    (%rax),%rax
  80bb3c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80bb40:	72 13                	jb     80bb55 <mem_realloc+0xb1>
  80bb42:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80bb49:	00 00 00 
  80bb4c:	48 8b 00             	mov    (%rax),%rax
  80bb4f:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80bb53:	72 09                	jb     80bb5e <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80bb55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bb59:	e9 5b 02 00 00       	jmpq   80bdb9 <mem_realloc+0x315>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80bb5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bb62:	48 83 e8 0c          	sub    $0xc,%rax
  80bb66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80bb6a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80bb6e:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bb75:	00 00 00 
  80bb78:	48 8b 00             	mov    (%rax),%rax
  80bb7b:	48 29 c2             	sub    %rax,%rdx
  80bb7e:	48 89 d0             	mov    %rdx,%rax
  80bb81:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80bb84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb88:	8b 00                	mov    (%rax),%eax
  80bb8a:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80bb8d:	83 e8 0c             	sub    $0xc,%eax
  80bb90:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80bb93:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bb96:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80bb99:	76 2a                	jbe    80bbc5 <mem_realloc+0x121>
  80bb9b:	48 ba 50 11 82 00 00 	movabs $0x821150,%rdx
  80bba2:	00 00 00 
  80bba5:	be 8a 01 00 00       	mov    $0x18a,%esi
  80bbaa:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80bbb1:	00 00 00 
  80bbb4:	b8 00 00 00 00       	mov    $0x0,%eax
  80bbb9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80bbc0:	00 00 00 
  80bbc3:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80bbc5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bbc8:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80bbcb:	76 0a                	jbe    80bbd7 <mem_realloc+0x133>
    /* not supported */
    return NULL;
  80bbcd:	b8 00 00 00 00       	mov    $0x0,%eax
  80bbd2:	e9 e2 01 00 00       	jmpq   80bdb9 <mem_realloc+0x315>
  }
  if (newsize == size) {
  80bbd7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bbda:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80bbdd:	75 09                	jne    80bbe8 <mem_realloc+0x144>
    /* No change in size, simply return */
    return rmem;
  80bbdf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bbe3:	e9 d1 01 00 00       	jmpq   80bdb9 <mem_realloc+0x315>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80bbe8:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80bbef:	00 00 00 
  80bbf2:	8b 00                	mov    (%rax),%eax
  80bbf4:	be 00 00 00 00       	mov    $0x0,%esi
  80bbf9:	89 c7                	mov    %eax,%edi
  80bbfb:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  80bc02:	00 00 00 
  80bc05:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80bc07:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bc0e:	00 00 00 
  80bc11:	48 8b 10             	mov    (%rax),%rdx
  80bc14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bc18:	8b 00                	mov    (%rax),%eax
  80bc1a:	89 c0                	mov    %eax,%eax
  80bc1c:	48 01 d0             	add    %rdx,%rax
  80bc1f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80bc23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bc27:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bc2b:	84 c0                	test   %al,%al
  80bc2d:	0f 85 ba 00 00 00    	jne    80bced <mem_realloc+0x249>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80bc33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bc37:	8b 00                	mov    (%rax),%eax
  80bc39:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80bc3c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80bc3f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bc42:	01 d0                	add    %edx,%eax
  80bc44:	83 c0 0c             	add    $0xc,%eax
  80bc47:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80bc4a:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bc51:	00 00 00 
  80bc54:	48 8b 00             	mov    (%rax),%rax
  80bc57:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80bc5b:	75 20                	jne    80bc7d <mem_realloc+0x1d9>
      lfree = (struct mem *)&ram[ptr2];
  80bc5d:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bc64:	00 00 00 
  80bc67:	48 8b 10             	mov    (%rax),%rdx
  80bc6a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80bc6d:	48 01 c2             	add    %rax,%rdx
  80bc70:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bc77:	00 00 00 
  80bc7a:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80bc7d:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bc84:	00 00 00 
  80bc87:	48 8b 10             	mov    (%rax),%rdx
  80bc8a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80bc8d:	48 01 d0             	add    %rdx,%rax
  80bc90:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80bc94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bc98:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80bc9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bca0:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80bca3:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80bca5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bca9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80bcac:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80bcaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bcb3:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80bcb6:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80bcb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bcbc:	8b 00                	mov    (%rax),%eax
  80bcbe:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80bcc3:	74 23                	je     80bce8 <mem_realloc+0x244>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80bcc5:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bccc:	00 00 00 
  80bccf:	48 8b 10             	mov    (%rax),%rdx
  80bcd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bcd6:	8b 00                	mov    (%rax),%eax
  80bcd8:	89 c0                	mov    %eax,%eax
  80bcda:	48 01 c2             	add    %rax,%rdx
  80bcdd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80bce0:	89 42 04             	mov    %eax,0x4(%rdx)
  80bce3:	e9 b3 00 00 00       	jmpq   80bd9b <mem_realloc+0x2f7>
  80bce8:	e9 ae 00 00 00       	jmpq   80bd9b <mem_realloc+0x2f7>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80bced:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bcf0:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80bcf4:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80bcf7:	48 39 c2             	cmp    %rax,%rdx
  80bcfa:	0f 87 9b 00 00 00    	ja     80bd9b <mem_realloc+0x2f7>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80bd00:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80bd03:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80bd06:	01 d0                	add    %edx,%eax
  80bd08:	83 c0 0c             	add    $0xc,%eax
  80bd0b:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80bd0e:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bd15:	00 00 00 
  80bd18:	48 8b 10             	mov    (%rax),%rdx
  80bd1b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80bd1e:	48 01 d0             	add    %rdx,%rax
  80bd21:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80bd25:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bd2c:	00 00 00 
  80bd2f:	48 8b 00             	mov    (%rax),%rax
  80bd32:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bd36:	73 11                	jae    80bd49 <mem_realloc+0x2a5>
      lfree = mem2;
  80bd38:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bd3f:	00 00 00 
  80bd42:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80bd46:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80bd49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd4d:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80bd51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd55:	8b 10                	mov    (%rax),%edx
  80bd57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd5b:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80bd5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd61:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80bd64:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80bd67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd6b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80bd6e:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80bd70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd74:	8b 00                	mov    (%rax),%eax
  80bd76:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80bd7b:	74 1e                	je     80bd9b <mem_realloc+0x2f7>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80bd7d:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bd84:	00 00 00 
  80bd87:	48 8b 10             	mov    (%rax),%rdx
  80bd8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd8e:	8b 00                	mov    (%rax),%eax
  80bd90:	89 c0                	mov    %eax,%eax
  80bd92:	48 01 c2             	add    %rax,%rdx
  80bd95:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80bd98:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80bd9b:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80bda2:	00 00 00 
  80bda5:	8b 00                	mov    (%rax),%eax
  80bda7:	89 c7                	mov    %eax,%edi
  80bda9:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80bdb0:	00 00 00 
  80bdb3:	ff d0                	callq  *%rax
  return rmem;
  80bdb5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80bdb9:	c9                   	leaveq 
  80bdba:	c3                   	retq   

000000000080bdbb <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80bdbb:	55                   	push   %rbp
  80bdbc:	48 89 e5             	mov    %rsp,%rbp
  80bdbf:	48 83 ec 30          	sub    $0x30,%rsp
  80bdc3:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80bdc6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80bdca:	75 0a                	jne    80bdd6 <mem_malloc+0x1b>
    return NULL;
  80bdcc:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdd1:	e9 6b 03 00 00       	jmpq   80c141 <mem_malloc+0x386>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80bdd6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80bdd9:	83 c0 03             	add    $0x3,%eax
  80bddc:	83 e0 fc             	and    $0xfffffffc,%eax
  80bddf:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80bde2:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80bde6:	77 07                	ja     80bdef <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80bde8:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80bdef:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80bdf6:	76 0a                	jbe    80be02 <mem_malloc+0x47>
    return NULL;
  80bdf8:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdfd:	e9 3f 03 00 00       	jmpq   80c141 <mem_malloc+0x386>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80be02:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80be09:	00 00 00 
  80be0c:	8b 00                	mov    (%rax),%eax
  80be0e:	be 00 00 00 00       	mov    $0x0,%esi
  80be13:	89 c7                	mov    %eax,%edi
  80be15:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  80be1c:	00 00 00 
  80be1f:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80be21:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80be28:	00 00 00 
  80be2b:	48 8b 00             	mov    (%rax),%rax
  80be2e:	48 89 c2             	mov    %rax,%rdx
  80be31:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80be38:	00 00 00 
  80be3b:	48 8b 00             	mov    (%rax),%rax
  80be3e:	48 29 c2             	sub    %rax,%rdx
  80be41:	48 89 d0             	mov    %rdx,%rax
  80be44:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80be47:	e9 c5 02 00 00       	jmpq   80c111 <mem_malloc+0x356>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80be4c:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80be53:	00 00 00 
  80be56:	48 8b 10             	mov    (%rax),%rdx
  80be59:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80be5c:	48 01 d0             	add    %rdx,%rax
  80be5f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80be63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80be67:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80be6b:	84 c0                	test   %al,%al
  80be6d:	0f 85 86 02 00 00    	jne    80c0f9 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80be73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80be77:	8b 00                	mov    (%rax),%eax
  80be79:	89 c2                	mov    %eax,%edx
  80be7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80be7e:	48 29 c2             	sub    %rax,%rdx
  80be81:	48 89 d0             	mov    %rdx,%rax
  80be84:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80be88:	8b 45 dc             	mov    -0x24(%rbp),%eax
      if ((!mem->used) &&
  80be8b:	48 39 c2             	cmp    %rax,%rdx
  80be8e:	0f 82 65 02 00 00    	jb     80c0f9 <mem_malloc+0x33e>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80be94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80be98:	8b 00                	mov    (%rax),%eax
  80be9a:	89 c2                	mov    %eax,%edx
  80be9c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80be9f:	48 29 c2             	sub    %rax,%rdx
  80bea2:	48 89 d0             	mov    %rdx,%rax
  80bea5:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80bea9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80beac:	48 83 c0 18          	add    $0x18,%rax
  80beb0:	48 39 c2             	cmp    %rax,%rdx
  80beb3:	0f 82 81 00 00 00    	jb     80bf3a <mem_malloc+0x17f>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80beb9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80bebc:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80bebf:	01 d0                	add    %edx,%eax
  80bec1:	83 c0 0c             	add    $0xc,%eax
  80bec4:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80bec7:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bece:	00 00 00 
  80bed1:	48 8b 10             	mov    (%rax),%rdx
  80bed4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80bed7:	48 01 d0             	add    %rdx,%rax
  80beda:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80bede:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bee2:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80bee6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80beea:	8b 10                	mov    (%rax),%edx
  80beec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bef0:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80bef2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bef6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80bef9:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80befc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bf00:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80bf03:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80bf05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bf09:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80bf0d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bf11:	8b 00                	mov    (%rax),%eax
  80bf13:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80bf18:	74 28                	je     80bf42 <mem_malloc+0x187>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80bf1a:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bf21:	00 00 00 
  80bf24:	48 8b 10             	mov    (%rax),%rdx
  80bf27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bf2b:	8b 00                	mov    (%rax),%eax
  80bf2d:	89 c0                	mov    %eax,%eax
  80bf2f:	48 01 c2             	add    %rax,%rdx
  80bf32:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80bf35:	89 42 04             	mov    %eax,0x4(%rdx)
  80bf38:	eb 08                	jmp    80bf42 <mem_malloc+0x187>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80bf3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bf3e:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80bf42:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bf49:	00 00 00 
  80bf4c:	48 8b 00             	mov    (%rax),%rax
  80bf4f:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80bf53:	0f 85 c2 00 00 00    	jne    80c01b <mem_malloc+0x260>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80bf59:	eb 2e                	jmp    80bf89 <mem_malloc+0x1ce>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80bf5b:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80bf62:	00 00 00 
  80bf65:	48 8b 10             	mov    (%rax),%rdx
  80bf68:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bf6f:	00 00 00 
  80bf72:	48 8b 00             	mov    (%rax),%rax
  80bf75:	8b 00                	mov    (%rax),%eax
  80bf77:	89 c0                	mov    %eax,%eax
  80bf79:	48 01 c2             	add    %rax,%rdx
  80bf7c:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bf83:	00 00 00 
  80bf86:	48 89 10             	mov    %rdx,(%rax)
          while (lfree->used && lfree != ram_end) {
  80bf89:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bf90:	00 00 00 
  80bf93:	48 8b 00             	mov    (%rax),%rax
  80bf96:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bf9a:	84 c0                	test   %al,%al
  80bf9c:	74 1f                	je     80bfbd <mem_malloc+0x202>
  80bf9e:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bfa5:	00 00 00 
  80bfa8:	48 8b 10             	mov    (%rax),%rdx
  80bfab:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80bfb2:	00 00 00 
  80bfb5:	48 8b 00             	mov    (%rax),%rax
  80bfb8:	48 39 c2             	cmp    %rax,%rdx
  80bfbb:	75 9e                	jne    80bf5b <mem_malloc+0x1a0>
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80bfbd:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bfc4:	00 00 00 
  80bfc7:	48 8b 10             	mov    (%rax),%rdx
  80bfca:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80bfd1:	00 00 00 
  80bfd4:	48 8b 00             	mov    (%rax),%rax
  80bfd7:	48 39 c2             	cmp    %rax,%rdx
  80bfda:	74 3f                	je     80c01b <mem_malloc+0x260>
  80bfdc:	48 b8 30 85 a4 00 00 	movabs $0xa48530,%rax
  80bfe3:	00 00 00 
  80bfe6:	48 8b 00             	mov    (%rax),%rax
  80bfe9:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bfed:	84 c0                	test   %al,%al
  80bfef:	74 2a                	je     80c01b <mem_malloc+0x260>
  80bff1:	48 ba 73 11 82 00 00 	movabs $0x821173,%rdx
  80bff8:	00 00 00 
  80bffb:	be 46 02 00 00       	mov    $0x246,%esi
  80c000:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80c007:	00 00 00 
  80c00a:	b8 00 00 00 00       	mov    $0x0,%eax
  80c00f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c016:	00 00 00 
  80c019:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80c01b:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80c022:	00 00 00 
  80c025:	8b 00                	mov    (%rax),%eax
  80c027:	89 c7                	mov    %eax,%edi
  80c029:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80c030:	00 00 00 
  80c033:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80c035:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80c038:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c03c:	48 01 d0             	add    %rdx,%rax
  80c03f:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80c043:	48 b8 28 85 a4 00 00 	movabs $0xa48528,%rax
  80c04a:	00 00 00 
  80c04d:	48 8b 00             	mov    (%rax),%rax
  80c050:	48 39 c2             	cmp    %rax,%rdx
  80c053:	76 2a                	jbe    80c07f <mem_malloc+0x2c4>
  80c055:	48 ba 90 11 82 00 00 	movabs $0x821190,%rdx
  80c05c:	00 00 00 
  80c05f:	be 4b 02 00 00       	mov    $0x24b,%esi
  80c064:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80c06b:	00 00 00 
  80c06e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c073:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c07a:	00 00 00 
  80c07d:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80c07f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c083:	48 83 c0 0c          	add    $0xc,%rax
  80c087:	83 e0 03             	and    $0x3,%eax
  80c08a:	48 85 c0             	test   %rax,%rax
  80c08d:	74 2a                	je     80c0b9 <mem_malloc+0x2fe>
  80c08f:	48 ba c0 11 82 00 00 	movabs $0x8211c0,%rdx
  80c096:	00 00 00 
  80c099:	be 4d 02 00 00       	mov    $0x24d,%esi
  80c09e:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80c0a5:	00 00 00 
  80c0a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80c0ad:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c0b4:	00 00 00 
  80c0b7:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80c0b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0bd:	83 e0 03             	and    $0x3,%eax
  80c0c0:	48 85 c0             	test   %rax,%rax
  80c0c3:	74 2a                	je     80c0ef <mem_malloc+0x334>
  80c0c5:	48 ba f0 11 82 00 00 	movabs $0x8211f0,%rdx
  80c0cc:	00 00 00 
  80c0cf:	be 4f 02 00 00       	mov    $0x24f,%esi
  80c0d4:	48 bf 6f 10 82 00 00 	movabs $0x82106f,%rdi
  80c0db:	00 00 00 
  80c0de:	b8 00 00 00 00       	mov    $0x0,%eax
  80c0e3:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c0ea:	00 00 00 
  80c0ed:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80c0ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0f3:	48 83 c0 0c          	add    $0xc,%rax
  80c0f7:	eb 48                	jmp    80c141 <mem_malloc+0x386>
         ptr = ((struct mem *)&ram[ptr])->next) {
  80c0f9:	48 b8 20 85 a4 00 00 	movabs $0xa48520,%rax
  80c100:	00 00 00 
  80c103:	48 8b 10             	mov    (%rax),%rdx
  80c106:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c109:	48 01 d0             	add    %rdx,%rax
  80c10c:	8b 00                	mov    (%rax),%eax
  80c10e:	89 45 fc             	mov    %eax,-0x4(%rbp)
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c111:	b8 00 00 22 00       	mov    $0x220000,%eax
  80c116:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80c119:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80c11c:	0f 87 2a fd ff ff    	ja     80be4c <mem_malloc+0x91>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80c122:	48 b8 38 85 a4 00 00 	movabs $0xa48538,%rax
  80c129:	00 00 00 
  80c12c:	8b 00                	mov    (%rax),%eax
  80c12e:	89 c7                	mov    %eax,%edi
  80c130:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80c137:	00 00 00 
  80c13a:	ff d0                	callq  *%rax
  return NULL;
  80c13c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c141:	c9                   	leaveq 
  80c142:	c3                   	retq   

000000000080c143 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80c143:	55                   	push   %rbp
  80c144:	48 89 e5             	mov    %rsp,%rbp
  80c147:	48 83 ec 20          	sub    $0x20,%rsp
  80c14b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80c14e:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80c151:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c154:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80c158:	89 c7                	mov    %eax,%edi
  80c15a:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  80c161:	00 00 00 
  80c164:	ff d0                	callq  *%rax
  80c166:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80c16a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c16f:	74 21                	je     80c192 <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80c171:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c174:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80c178:	89 c2                	mov    %eax,%edx
  80c17a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c17e:	be 00 00 00 00       	mov    $0x0,%esi
  80c183:	48 89 c7             	mov    %rax,%rdi
  80c186:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80c18d:	00 00 00 
  80c190:	ff d0                	callq  *%rax
  }
  return p;
  80c192:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80c196:	c9                   	leaveq 
  80c197:	c3                   	retq   

000000000080c198 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80c198:	55                   	push   %rbp
  80c199:	48 89 e5             	mov    %rsp,%rbp
  80c19c:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80c1a0:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80c1a6:	eb 05                	jmp    80c1ad <memp_init+0x15>
  80c1a8:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80c1ad:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80c1b2:	76 f4                	jbe    80c1a8 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80c1b4:	48 b8 c0 85 a4 00 00 	movabs $0xa485c0,%rax
  80c1bb:	00 00 00 
  80c1be:	48 83 c0 03          	add    $0x3,%rax
  80c1c2:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c1c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80c1ca:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80c1d0:	e9 97 00 00 00       	jmpq   80c26c <memp_init+0xd4>
    memp_tab[i] = NULL;
  80c1d5:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c1d9:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c1e0:	00 00 00 
  80c1e3:	48 63 d2             	movslq %edx,%rdx
  80c1e6:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80c1ed:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80c1ee:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80c1f4:	eb 56                	jmp    80c24c <memp_init+0xb4>
      memp->next = memp_tab[i];
  80c1f6:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c1fa:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c201:	00 00 00 
  80c204:	48 63 d2             	movslq %edx,%rdx
  80c207:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80c20b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c20f:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80c212:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c216:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c21d:	00 00 00 
  80c220:	48 63 d2             	movslq %edx,%rdx
  80c223:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80c227:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80c22b:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c22f:	48 b8 20 12 82 00 00 	movabs $0x821220,%rax
  80c236:	00 00 00 
  80c239:	48 63 d2             	movslq %edx,%rdx
  80c23c:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80c240:	0f b7 c0             	movzwl %ax,%eax
  80c243:	48 01 45 f8          	add    %rax,-0x8(%rbp)
    for (j = 0; j < memp_num[i]; ++j) {
  80c247:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80c24c:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c250:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  80c257:	00 00 00 
  80c25a:	48 63 d2             	movslq %edx,%rdx
  80c25d:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80c261:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80c265:	77 8f                	ja     80c1f6 <memp_init+0x5e>
  for (i = 0; i < MEMP_MAX; ++i) {
  80c267:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80c26c:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80c271:	0f 86 5e ff ff ff    	jbe    80c1d5 <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80c277:	c9                   	leaveq 
  80c278:	c3                   	retq   

000000000080c279 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80c279:	55                   	push   %rbp
  80c27a:	48 89 e5             	mov    %rsp,%rbp
  80c27d:	48 83 ec 20          	sub    $0x20,%rsp
  80c281:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80c284:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80c288:	76 2a                	jbe    80c2b4 <memp_malloc+0x3b>
  80c28a:	48 ba ef 12 82 00 00 	movabs $0x8212ef,%rdx
  80c291:	00 00 00 
  80c294:	be 2d 01 00 00       	mov    $0x12d,%esi
  80c299:	48 bf 0c 13 82 00 00 	movabs $0x82130c,%rdi
  80c2a0:	00 00 00 
  80c2a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2a8:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c2af:	00 00 00 
  80c2b2:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80c2b4:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c2bb:	00 00 00 
  80c2be:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c2c1:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80c2c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80c2c9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c2ce:	74 4e                	je     80c31e <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80c2d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c2d4:	48 8b 08             	mov    (%rax),%rcx
  80c2d7:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c2de:	00 00 00 
  80c2e1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c2e4:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80c2e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c2ec:	83 e0 03             	and    $0x3,%eax
  80c2ef:	48 85 c0             	test   %rax,%rax
  80c2f2:	74 2a                	je     80c31e <memp_malloc+0xa5>
  80c2f4:	48 ba 28 13 82 00 00 	movabs $0x821328,%rdx
  80c2fb:	00 00 00 
  80c2fe:	be 3f 01 00 00       	mov    $0x13f,%esi
  80c303:	48 bf 0c 13 82 00 00 	movabs $0x82130c,%rdi
  80c30a:	00 00 00 
  80c30d:	b8 00 00 00 00       	mov    $0x0,%eax
  80c312:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c319:	00 00 00 
  80c31c:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80c31e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80c322:	c9                   	leaveq 
  80c323:	c3                   	retq   

000000000080c324 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80c324:	55                   	push   %rbp
  80c325:	48 89 e5             	mov    %rsp,%rbp
  80c328:	48 83 ec 20          	sub    $0x20,%rsp
  80c32c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80c32f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80c333:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80c338:	75 02                	jne    80c33c <memp_free+0x18>
    return;
  80c33a:	eb 6b                	jmp    80c3a7 <memp_free+0x83>
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80c33c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c340:	83 e0 03             	and    $0x3,%eax
  80c343:	48 85 c0             	test   %rax,%rax
  80c346:	74 2a                	je     80c372 <memp_free+0x4e>
  80c348:	48 ba 50 13 82 00 00 	movabs $0x821350,%rdx
  80c34f:	00 00 00 
  80c352:	be 5b 01 00 00       	mov    $0x15b,%esi
  80c357:	48 bf 0c 13 82 00 00 	movabs $0x82130c,%rdi
  80c35e:	00 00 00 
  80c361:	b8 00 00 00 00       	mov    $0x0,%eax
  80c366:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c36d:	00 00 00 
  80c370:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80c372:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c376:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80c37a:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c381:	00 00 00 
  80c384:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c387:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80c38b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c38f:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80c392:	48 b8 40 85 a4 00 00 	movabs $0xa48540,%rax
  80c399:	00 00 00 
  80c39c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c39f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80c3a3:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80c3a7:	c9                   	leaveq 
  80c3a8:	c3                   	retq   

000000000080c3a9 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80c3a9:	55                   	push   %rbp
  80c3aa:	48 89 e5             	mov    %rsp,%rbp
  80c3ad:	48 83 ec 30          	sub    $0x30,%rsp
  80c3b1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80c3b5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80c3b9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c3bd:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80c3c1:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80c3c5:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80c3c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3cd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80c3d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80c3df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3e3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80c3ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3ee:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80c3f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3f6:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80c3fd:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80c3fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c402:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80c406:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80c40a:	48 b8 6b a0 b4 00 00 	movabs $0xb4a06b,%rax
  80c411:	00 00 00 
  80c414:	0f b6 00             	movzbl (%rax),%eax
  80c417:	8d 48 01             	lea    0x1(%rax),%ecx
  80c41a:	48 ba 6b a0 b4 00 00 	movabs $0xb4a06b,%rdx
  80c421:	00 00 00 
  80c424:	88 0a                	mov    %cl,(%rdx)
  80c426:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c42a:	88 42 4d             	mov    %al,0x4d(%rdx)
  netif->input = input;
  80c42d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c431:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80c435:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80c439:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80c43d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c441:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80c445:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c449:	48 89 c7             	mov    %rax,%rdi
  80c44c:	48 b8 9b c4 80 00 00 	movabs $0x80c49b,%rax
  80c453:	00 00 00 
  80c456:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80c458:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c45c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80c460:	48 89 d7             	mov    %rdx,%rdi
  80c463:	ff d0                	callq  *%rax
  80c465:	84 c0                	test   %al,%al
  80c467:	74 07                	je     80c470 <netif_add+0xc7>
    return NULL;
  80c469:	b8 00 00 00 00       	mov    $0x0,%eax
  80c46e:	eb 29                	jmp    80c499 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80c470:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80c477:	00 00 00 
  80c47a:	48 8b 10             	mov    (%rax),%rdx
  80c47d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c481:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80c484:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80c48b:	00 00 00 
  80c48e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c492:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80c495:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80c499:	c9                   	leaveq 
  80c49a:	c3                   	retq   

000000000080c49b <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80c49b:	55                   	push   %rbp
  80c49c:	48 89 e5             	mov    %rsp,%rbp
  80c49f:	48 83 ec 20          	sub    $0x20,%rsp
  80c4a3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80c4a7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80c4ab:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c4af:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80c4b3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c4b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4bb:	48 89 d6             	mov    %rdx,%rsi
  80c4be:	48 89 c7             	mov    %rax,%rdi
  80c4c1:	48 b8 49 c6 80 00 00 	movabs $0x80c649,%rax
  80c4c8:	00 00 00 
  80c4cb:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80c4cd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c4d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4d5:	48 89 d6             	mov    %rdx,%rsi
  80c4d8:	48 89 c7             	mov    %rax,%rdi
  80c4db:	48 b8 7c c7 80 00 00 	movabs $0x80c77c,%rax
  80c4e2:	00 00 00 
  80c4e5:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80c4e7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80c4eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4ef:	48 89 d6             	mov    %rdx,%rsi
  80c4f2:	48 89 c7             	mov    %rax,%rdi
  80c4f5:	48 b8 4f c7 80 00 00 	movabs $0x80c74f,%rax
  80c4fc:	00 00 00 
  80c4ff:	ff d0                	callq  *%rax
}
  80c501:	c9                   	leaveq 
  80c502:	c3                   	retq   

000000000080c503 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80c503:	55                   	push   %rbp
  80c504:	48 89 e5             	mov    %rsp,%rbp
  80c507:	48 83 ec 20          	sub    $0x20,%rsp
  80c50b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80c50f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c514:	75 05                	jne    80c51b <netif_remove+0x18>
  80c516:	e9 98 00 00 00       	jmpq   80c5b3 <netif_remove+0xb0>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80c51b:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80c522:	00 00 00 
  80c525:	48 8b 00             	mov    (%rax),%rax
  80c528:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c52c:	75 16                	jne    80c544 <netif_remove+0x41>
    netif_list = netif->next;
  80c52e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c532:	48 8b 10             	mov    (%rax),%rdx
  80c535:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80c53c:	00 00 00 
  80c53f:	48 89 10             	mov    %rdx,(%rax)
  80c542:	eb 4b                	jmp    80c58f <netif_remove+0x8c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80c544:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80c54b:	00 00 00 
  80c54e:	48 8b 00             	mov    (%rax),%rax
  80c551:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80c555:	eb 28                	jmp    80c57f <netif_remove+0x7c>
      if (tmpNetif->next == netif) {
  80c557:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c55b:	48 8b 00             	mov    (%rax),%rax
  80c55e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c562:	75 10                	jne    80c574 <netif_remove+0x71>
        tmpNetif->next = netif->next;
  80c564:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c568:	48 8b 10             	mov    (%rax),%rdx
  80c56b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c56f:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80c572:	eb 12                	jmp    80c586 <netif_remove+0x83>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80c574:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c578:	48 8b 00             	mov    (%rax),%rax
  80c57b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80c57f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c584:	75 d1                	jne    80c557 <netif_remove+0x54>
      }
    }
    if (tmpNetif == NULL)
  80c586:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c58b:	75 02                	jne    80c58f <netif_remove+0x8c>
      return; /*  we didn't find any netif today */
  80c58d:	eb 24                	jmp    80c5b3 <netif_remove+0xb0>
  }
  /* this netif is default? */
  if (netif_default == netif)
  80c58f:	48 b8 08 a0 b5 00 00 	movabs $0xb5a008,%rax
  80c596:	00 00 00 
  80c599:	48 8b 00             	mov    (%rax),%rax
  80c59c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c5a0:	75 11                	jne    80c5b3 <netif_remove+0xb0>
    /* reset default netif */
    netif_set_default(NULL);
  80c5a2:	bf 00 00 00 00       	mov    $0x0,%edi
  80c5a7:	48 b8 a9 c7 80 00 00 	movabs $0x80c7a9,%rax
  80c5ae:	00 00 00 
  80c5b1:	ff d0                	callq  *%rax
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80c5b3:	c9                   	leaveq 
  80c5b4:	c3                   	retq   

000000000080c5b5 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80c5b5:	55                   	push   %rbp
  80c5b6:	48 89 e5             	mov    %rsp,%rbp
  80c5b9:	48 83 ec 18          	sub    $0x18,%rsp
  80c5bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80c5c1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c5c6:	75 07                	jne    80c5cf <netif_find+0x1a>
    return NULL;
  80c5c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5cd:	eb 78                	jmp    80c647 <netif_find+0x92>
  }

  num = name[2] - '0';
  80c5cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c5d3:	48 83 c0 02          	add    $0x2,%rax
  80c5d7:	0f b6 00             	movzbl (%rax),%eax
  80c5da:	83 e8 30             	sub    $0x30,%eax
  80c5dd:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80c5e0:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80c5e7:	00 00 00 
  80c5ea:	48 8b 00             	mov    (%rax),%rax
  80c5ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80c5f1:	eb 48                	jmp    80c63b <netif_find+0x86>
    if (num == netif->num &&
  80c5f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c5f7:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80c5fb:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80c5fe:	75 30                	jne    80c630 <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80c600:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c604:	0f b6 10             	movzbl (%rax),%edx
  80c607:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c60b:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
    if (num == netif->num &&
  80c60f:	38 c2                	cmp    %al,%dl
  80c611:	75 1d                	jne    80c630 <netif_find+0x7b>
       name[1] == netif->name[1]) {
  80c613:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c617:	48 83 c0 01          	add    $0x1,%rax
  80c61b:	0f b6 10             	movzbl (%rax),%edx
  80c61e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c622:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax
       name[0] == netif->name[0] &&
  80c626:	38 c2                	cmp    %al,%dl
  80c628:	75 06                	jne    80c630 <netif_find+0x7b>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80c62a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c62e:	eb 17                	jmp    80c647 <netif_find+0x92>
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80c630:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c634:	48 8b 00             	mov    (%rax),%rax
  80c637:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80c63b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c640:	75 b1                	jne    80c5f3 <netif_find+0x3e>
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80c642:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c647:	c9                   	leaveq 
  80c648:	c3                   	retq   

000000000080c649 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80c649:	55                   	push   %rbp
  80c64a:	48 89 e5             	mov    %rsp,%rbp
  80c64d:	48 83 ec 30          	sub    $0x30,%rsp
  80c651:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c655:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80c659:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80c65d:	8b 10                	mov    (%rax),%edx
  80c65f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c663:	8b 40 08             	mov    0x8(%rax),%eax
  80c666:	39 c2                	cmp    %eax,%edx
  80c668:	0f 84 c4 00 00 00    	je     80c732 <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80c66e:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80c675:	00 00 00 
  80c678:	48 8b 00             	mov    (%rax),%rax
  80c67b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80c67f:	eb 46                	jmp    80c6c7 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80c681:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c685:	8b 10                	mov    (%rax),%edx
  80c687:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c68b:	8b 40 08             	mov    0x8(%rax),%eax
  80c68e:	39 c2                	cmp    %eax,%edx
  80c690:	75 29                	jne    80c6bb <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80c692:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c696:	48 8b 40 10          	mov    0x10(%rax),%rax
  80c69a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80c69e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c6a2:	48 89 c7             	mov    %rax,%rdi
  80c6a5:	48 b8 12 e3 80 00 00 	movabs $0x80e312,%rax
  80c6ac:	00 00 00 
  80c6af:	ff d0                	callq  *%rax
        pcb = next;
  80c6b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c6b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80c6b9:	eb 0c                	jmp    80c6c7 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80c6bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c6bf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80c6c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80c6c7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c6cc:	75 b3                	jne    80c681 <netif_set_ipaddr+0x38>
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80c6ce:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  80c6d5:	00 00 00 
  80c6d8:	48 8b 00             	mov    (%rax),%rax
  80c6db:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80c6df:	eb 4a                	jmp    80c72b <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80c6e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6e5:	48 85 c0             	test   %rax,%rax
  80c6e8:	74 35                	je     80c71f <netif_set_ipaddr+0xd6>
  80c6ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6ee:	8b 00                	mov    (%rax),%eax
  80c6f0:	85 c0                	test   %eax,%eax
  80c6f2:	74 2b                	je     80c71f <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80c6f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6f8:	8b 10                	mov    (%rax),%edx
  80c6fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c6fe:	8b 40 08             	mov    0x8(%rax),%eax
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80c701:	39 c2                	cmp    %eax,%edx
  80c703:	75 1a                	jne    80c71f <netif_set_ipaddr+0xd6>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80c705:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80c70a:	74 08                	je     80c714 <netif_set_ipaddr+0xcb>
  80c70c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80c710:	8b 00                	mov    (%rax),%eax
  80c712:	eb 05                	jmp    80c719 <netif_set_ipaddr+0xd0>
  80c714:	b8 00 00 00 00       	mov    $0x0,%eax
  80c719:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c71d:	89 02                	mov    %eax,(%rdx)
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80c71f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c723:	48 8b 40 10          	mov    0x10(%rax),%rax
  80c727:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80c72b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80c730:	75 af                	jne    80c6e1 <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80c732:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80c737:	74 08                	je     80c741 <netif_set_ipaddr+0xf8>
  80c739:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80c73d:	8b 00                	mov    (%rax),%eax
  80c73f:	eb 05                	jmp    80c746 <netif_set_ipaddr+0xfd>
  80c741:	b8 00 00 00 00       	mov    $0x0,%eax
  80c746:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80c74a:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80c74d:	c9                   	leaveq 
  80c74e:	c3                   	retq   

000000000080c74f <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80c74f:	55                   	push   %rbp
  80c750:	48 89 e5             	mov    %rsp,%rbp
  80c753:	48 83 ec 10          	sub    $0x10,%rsp
  80c757:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80c75b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80c75f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80c764:	74 08                	je     80c76e <netif_set_gw+0x1f>
  80c766:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c76a:	8b 00                	mov    (%rax),%eax
  80c76c:	eb 05                	jmp    80c773 <netif_set_gw+0x24>
  80c76e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c773:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c777:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80c77a:	c9                   	leaveq 
  80c77b:	c3                   	retq   

000000000080c77c <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80c77c:	55                   	push   %rbp
  80c77d:	48 89 e5             	mov    %rsp,%rbp
  80c780:	48 83 ec 10          	sub    $0x10,%rsp
  80c784:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80c788:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80c78c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80c791:	74 08                	je     80c79b <netif_set_netmask+0x1f>
  80c793:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c797:	8b 00                	mov    (%rax),%eax
  80c799:	eb 05                	jmp    80c7a0 <netif_set_netmask+0x24>
  80c79b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c7a0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c7a4:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80c7a7:	c9                   	leaveq 
  80c7a8:	c3                   	retq   

000000000080c7a9 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80c7a9:	55                   	push   %rbp
  80c7aa:	48 89 e5             	mov    %rsp,%rbp
  80c7ad:	48 83 ec 08          	sub    $0x8,%rsp
  80c7b1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80c7b5:	48 b8 08 a0 b5 00 00 	movabs $0xb5a008,%rax
  80c7bc:	00 00 00 
  80c7bf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c7c3:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80c7c6:	c9                   	leaveq 
  80c7c7:	c3                   	retq   

000000000080c7c8 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80c7c8:	55                   	push   %rbp
  80c7c9:	48 89 e5             	mov    %rsp,%rbp
  80c7cc:	48 83 ec 10          	sub    $0x10,%rsp
  80c7d0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80c7d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7d8:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80c7dc:	0f b6 c0             	movzbl %al,%eax
  80c7df:	83 e0 01             	and    $0x1,%eax
  80c7e2:	85 c0                	test   %eax,%eax
  80c7e4:	75 49                	jne    80c82f <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80c7e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7ea:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80c7ee:	83 c8 01             	or     $0x1,%eax
  80c7f1:	89 c2                	mov    %eax,%edx
  80c7f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7f7:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80c7fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7fe:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80c802:	0f b6 c0             	movzbl %al,%eax
  80c805:	83 e0 20             	and    $0x20,%eax
  80c808:	85 c0                	test   %eax,%eax
  80c80a:	74 23                	je     80c82f <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80c80c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c810:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80c814:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c818:	ba 00 00 00 00       	mov    $0x0,%edx
  80c81d:	48 89 ce             	mov    %rcx,%rsi
  80c820:	48 89 c7             	mov    %rax,%rdi
  80c823:	48 b8 88 60 81 00 00 	movabs $0x816088,%rax
  80c82a:	00 00 00 
  80c82d:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80c82f:	c9                   	leaveq 
  80c830:	c3                   	retq   

000000000080c831 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80c831:	55                   	push   %rbp
  80c832:	48 89 e5             	mov    %rsp,%rbp
  80c835:	48 83 ec 08          	sub    $0x8,%rsp
  80c839:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80c83d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c841:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80c845:	0f b6 c0             	movzbl %al,%eax
  80c848:	83 e0 01             	and    $0x1,%eax
  80c84b:	85 c0                	test   %eax,%eax
  80c84d:	74 14                	je     80c863 <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80c84f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c853:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80c857:	83 e0 fe             	and    $0xfffffffe,%eax
  80c85a:	89 c2                	mov    %eax,%edx
  80c85c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c860:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80c863:	c9                   	leaveq 
  80c864:	c3                   	retq   

000000000080c865 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80c865:	55                   	push   %rbp
  80c866:	48 89 e5             	mov    %rsp,%rbp
  80c869:	48 83 ec 08          	sub    $0x8,%rsp
  80c86d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80c871:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c875:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80c879:	0f b6 c0             	movzbl %al,%eax
  80c87c:	83 e0 01             	and    $0x1,%eax
  80c87f:	85 c0                	test   %eax,%eax
  80c881:	0f 95 c0             	setne  %al
}
  80c884:	c9                   	leaveq 
  80c885:	c3                   	retq   

000000000080c886 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80c886:	55                   	push   %rbp
  80c887:	48 89 e5             	mov    %rsp,%rbp
  80c88a:	48 83 ec 30          	sub    $0x30,%rsp
  80c88e:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80c891:	89 f0                	mov    %esi,%eax
  80c893:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80c896:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80c89a:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80c8a0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c8a3:	83 f8 01             	cmp    $0x1,%eax
  80c8a6:	74 16                	je     80c8be <pbuf_alloc+0x38>
  80c8a8:	83 f8 01             	cmp    $0x1,%eax
  80c8ab:	72 0c                	jb     80c8b9 <pbuf_alloc+0x33>
  80c8ad:	83 f8 02             	cmp    $0x2,%eax
  80c8b0:	74 11                	je     80c8c3 <pbuf_alloc+0x3d>
  80c8b2:	83 f8 03             	cmp    $0x3,%eax
  80c8b5:	74 3d                	je     80c8f4 <pbuf_alloc+0x6e>
  80c8b7:	eb 11                	jmp    80c8ca <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80c8b9:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80c8be:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80c8c3:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80c8c8:	eb 2b                	jmp    80c8f5 <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80c8ca:	48 ba 70 13 82 00 00 	movabs $0x821370,%rdx
  80c8d1:	00 00 00 
  80c8d4:	be 8a 00 00 00       	mov    $0x8a,%esi
  80c8d9:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80c8e0:	00 00 00 
  80c8e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80c8e8:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c8ef:	00 00 00 
  80c8f2:	ff d1                	callq  *%rcx
    break;
  80c8f4:	90                   	nop
    return NULL;
  }

  switch (type) {
  80c8f5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c8f8:	83 f8 02             	cmp    $0x2,%eax
  80c8fb:	77 0e                	ja     80c90b <pbuf_alloc+0x85>
  80c8fd:	83 f8 01             	cmp    $0x1,%eax
  80c900:	0f 83 a4 03 00 00    	jae    80ccaa <pbuf_alloc+0x424>
  80c906:	e9 d0 02 00 00       	jmpq   80cbdb <pbuf_alloc+0x355>
  80c90b:	83 f8 03             	cmp    $0x3,%eax
  80c90e:	0f 85 fd 03 00 00    	jne    80cd11 <pbuf_alloc+0x48b>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80c914:	bf 0d 00 00 00       	mov    $0xd,%edi
  80c919:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80c920:	00 00 00 
  80c923:	ff d0                	callq  *%rax
  80c925:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80c929:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c92e:	75 0a                	jne    80c93a <pbuf_alloc+0xb4>
      return NULL;
  80c930:	b8 00 00 00 00       	mov    $0x0,%eax
  80c935:	e9 17 04 00 00       	jmpq   80cd51 <pbuf_alloc+0x4cb>
    }
    p->type = type;
  80c93a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c93d:	89 c2                	mov    %eax,%edx
  80c93f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c943:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80c946:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c94a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80c951:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c955:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c959:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c95d:	48 01 d0             	add    %rdx,%rax
  80c960:	48 83 c0 03          	add    $0x3,%rax
  80c964:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c968:	48 89 c2             	mov    %rax,%rdx
  80c96b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c96f:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80c973:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c977:	48 8b 40 08          	mov    0x8(%rax),%rax
  80c97b:	83 e0 03             	and    $0x3,%eax
  80c97e:	48 85 c0             	test   %rax,%rax
  80c981:	74 2a                	je     80c9ad <pbuf_alloc+0x127>
  80c983:	48 ba a0 13 82 00 00 	movabs $0x8213a0,%rdx
  80c98a:	00 00 00 
  80c98d:	be 9c 00 00 00       	mov    $0x9c,%esi
  80c992:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80c999:	00 00 00 
  80c99c:	b8 00 00 00 00       	mov    $0x0,%eax
  80c9a1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80c9a8:	00 00 00 
  80c9ab:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80c9ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9b1:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80c9b5:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80c9b9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c9bd:	83 c0 03             	add    $0x3,%eax
  80c9c0:	83 e0 fc             	and    $0xfffffffc,%eax
  80c9c3:	ba d0 07 00 00       	mov    $0x7d0,%edx
  80c9c8:	29 c2                	sub    %eax,%edx
  80c9ca:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80c9ce:	39 c2                	cmp    %eax,%edx
  80c9d0:	0f 4e c2             	cmovle %edx,%eax
  80c9d3:	89 c2                	mov    %eax,%edx
  80c9d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9d9:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80c9dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9e1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80c9e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9e9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80c9ed:	0f b7 c0             	movzwl %ax,%eax
  80c9f0:	48 01 c2             	add    %rax,%rdx
  80c9f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9f7:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80c9fd:	48 39 c2             	cmp    %rax,%rdx
  80ca00:	76 2a                	jbe    80ca2c <pbuf_alloc+0x1a6>
  80ca02:	48 ba d0 13 82 00 00 	movabs $0x8213d0,%rdx
  80ca09:	00 00 00 
  80ca0c:	be a3 00 00 00       	mov    $0xa3,%esi
  80ca11:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80ca18:	00 00 00 
  80ca1b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca20:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ca27:	00 00 00 
  80ca2a:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80ca2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca30:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80ca36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca3a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80ca3e:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80ca42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca46:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80ca4a:	0f b7 c0             	movzwl %ax,%eax
  80ca4d:	29 c2                	sub    %eax,%edx
  80ca4f:	89 d0                	mov    %edx,%eax
  80ca51:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80ca54:	e9 73 01 00 00       	jmpq   80cbcc <pbuf_alloc+0x346>
      q = memp_malloc(MEMP_PBUF_POOL);
  80ca59:	bf 0d 00 00 00       	mov    $0xd,%edi
  80ca5e:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80ca65:	00 00 00 
  80ca68:	ff d0                	callq  *%rax
  80ca6a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80ca6e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ca73:	75 1d                	jne    80ca92 <pbuf_alloc+0x20c>
        /* free chain so far allocated */
        pbuf_free(p);
  80ca75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca79:	48 89 c7             	mov    %rax,%rdi
  80ca7c:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80ca83:	00 00 00 
  80ca86:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80ca88:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca8d:	e9 bf 02 00 00       	jmpq   80cd51 <pbuf_alloc+0x4cb>
      }
      q->type = type;
  80ca92:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80ca95:	89 c2                	mov    %eax,%edx
  80ca97:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ca9b:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80ca9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80caa2:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80caa6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80caaa:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80cab1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cab5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80cab9:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80cabc:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80cac3:	7e 2a                	jle    80caef <pbuf_alloc+0x269>
  80cac5:	48 ba 01 14 82 00 00 	movabs $0x821401,%rdx
  80cacc:	00 00 00 
  80cacf:	be bc 00 00 00       	mov    $0xbc,%esi
  80cad4:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cadb:	00 00 00 
  80cade:	b8 00 00 00 00       	mov    $0x0,%eax
  80cae3:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80caea:	00 00 00 
  80caed:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80caef:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80caf2:	89 c2                	mov    %eax,%edx
  80caf4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80caf8:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80cafc:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80caff:	ba d0 07 00 00       	mov    $0x7d0,%edx
  80cb04:	66 3d d0 07          	cmp    $0x7d0,%ax
  80cb08:	0f 46 d0             	cmovbe %eax,%edx
  80cb0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb0f:	66 89 50 12          	mov    %dx,0x12(%rax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80cb13:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb17:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80cb1b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb1f:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80cb23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb27:	48 8b 40 08          	mov    0x8(%rax),%rax
  80cb2b:	83 e0 03             	and    $0x3,%eax
  80cb2e:	48 85 c0             	test   %rax,%rax
  80cb31:	74 2a                	je     80cb5d <pbuf_alloc+0x2d7>
  80cb33:	48 ba 18 14 82 00 00 	movabs $0x821418,%rdx
  80cb3a:	00 00 00 
  80cb3d:	be c2 00 00 00       	mov    $0xc2,%esi
  80cb42:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cb49:	00 00 00 
  80cb4c:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb51:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cb58:	00 00 00 
  80cb5b:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80cb5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb61:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80cb65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb69:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80cb6d:	0f b7 c0             	movzwl %ax,%eax
  80cb70:	48 01 c2             	add    %rax,%rdx
  80cb73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb77:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80cb7d:	48 39 c2             	cmp    %rax,%rdx
  80cb80:	76 2a                	jbe    80cbac <pbuf_alloc+0x326>
  80cb82:	48 ba d0 13 82 00 00 	movabs $0x8213d0,%rdx
  80cb89:	00 00 00 
  80cb8c:	be c5 00 00 00       	mov    $0xc5,%esi
  80cb91:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cb98:	00 00 00 
  80cb9b:	b8 00 00 00 00       	mov    $0x0,%eax
  80cba0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cba7:	00 00 00 
  80cbaa:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80cbac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cbb0:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80cbb6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cbba:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80cbbe:	0f b7 c0             	movzwl %ax,%eax
  80cbc1:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80cbc4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cbc8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    while (rem_len > 0) {
  80cbcc:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80cbd0:	0f 8f 83 fe ff ff    	jg     80ca59 <pbuf_alloc+0x1d3>
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80cbd6:	e9 60 01 00 00       	jmpq   80cd3b <pbuf_alloc+0x4b5>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80cbdb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80cbdf:	83 c0 1b             	add    $0x1b,%eax
  80cbe2:	83 e0 fc             	and    $0xfffffffc,%eax
  80cbe5:	89 c2                	mov    %eax,%edx
  80cbe7:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80cbeb:	83 c0 03             	add    $0x3,%eax
  80cbee:	83 e0 fc             	and    $0xfffffffc,%eax
  80cbf1:	01 d0                	add    %edx,%eax
  80cbf3:	89 c7                	mov    %eax,%edi
  80cbf5:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  80cbfc:	00 00 00 
  80cbff:	ff d0                	callq  *%rax
  80cc01:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80cc05:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cc0a:	75 0a                	jne    80cc16 <pbuf_alloc+0x390>
      return NULL;
  80cc0c:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc11:	e9 3b 01 00 00       	jmpq   80cd51 <pbuf_alloc+0x4cb>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80cc16:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80cc1a:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80cc1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc22:	48 01 d0             	add    %rdx,%rax
  80cc25:	48 83 c0 03          	add    $0x3,%rax
  80cc29:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80cc2d:	48 89 c2             	mov    %rax,%rdx
  80cc30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc34:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80cc38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc3c:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80cc40:	66 89 50 10          	mov    %dx,0x10(%rax)
  80cc44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc48:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80cc4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc50:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80cc54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc58:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80cc5f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80cc62:	89 c2                	mov    %eax,%edx
  80cc64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc68:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80cc6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80cc73:	83 e0 03             	and    $0x3,%eax
  80cc76:	48 85 c0             	test   %rax,%rax
  80cc79:	74 2a                	je     80cca5 <pbuf_alloc+0x41f>
  80cc7b:	48 ba 48 14 82 00 00 	movabs $0x821448,%rdx
  80cc82:	00 00 00 
  80cc85:	be dd 00 00 00       	mov    $0xdd,%esi
  80cc8a:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cc91:	00 00 00 
  80cc94:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc99:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cca0:	00 00 00 
  80cca3:	ff d1                	callq  *%rcx
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80cca5:	e9 91 00 00 00       	jmpq   80cd3b <pbuf_alloc+0x4b5>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80ccaa:	bf 0c 00 00 00       	mov    $0xc,%edi
  80ccaf:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80ccb6:	00 00 00 
  80ccb9:	ff d0                	callq  *%rax
  80ccbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80ccbf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ccc4:	75 0a                	jne    80ccd0 <pbuf_alloc+0x44a>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80ccc6:	b8 00 00 00 00       	mov    $0x0,%eax
  80cccb:	e9 81 00 00 00       	jmpq   80cd51 <pbuf_alloc+0x4cb>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80ccd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccd4:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80ccdb:	00 
    p->len = p->tot_len = length;
  80ccdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cce0:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80cce4:	66 89 50 10          	mov    %dx,0x10(%rax)
  80cce8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccec:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80ccf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccf4:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80ccf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccfc:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80cd03:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80cd06:	89 c2                	mov    %eax,%edx
  80cd08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd0c:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80cd0f:	eb 2a                	jmp    80cd3b <pbuf_alloc+0x4b5>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80cd11:	48 ba 73 14 82 00 00 	movabs $0x821473,%rdx
  80cd18:	00 00 00 
  80cd1b:	be f1 00 00 00       	mov    $0xf1,%esi
  80cd20:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cd27:	00 00 00 
  80cd2a:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd2f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cd36:	00 00 00 
  80cd39:	ff d1                	callq  *%rcx
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80cd3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd3f:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80cd45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd49:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80cd4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cd51:	c9                   	leaveq 
  80cd52:	c3                   	retq   

000000000080cd53 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80cd53:	55                   	push   %rbp
  80cd54:	48 89 e5             	mov    %rsp,%rbp
  80cd57:	48 83 ec 20          	sub    $0x20,%rsp
  80cd5b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80cd5f:	89 f0                	mov    %esi,%eax
  80cd61:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80cd65:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cd6a:	75 2a                	jne    80cd96 <pbuf_realloc+0x43>
  80cd6c:	48 ba 8e 14 82 00 00 	movabs $0x82148e,%rdx
  80cd73:	00 00 00 
  80cd76:	be 13 01 00 00       	mov    $0x113,%esi
  80cd7b:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cd82:	00 00 00 
  80cd85:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd8a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cd91:	00 00 00 
  80cd94:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80cd96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cd9a:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80cd9e:	3c 03                	cmp    $0x3,%al
  80cda0:	74 4e                	je     80cdf0 <pbuf_realloc+0x9d>
  80cda2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cda6:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80cdaa:	3c 01                	cmp    $0x1,%al
  80cdac:	74 42                	je     80cdf0 <pbuf_realloc+0x9d>
  80cdae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cdb2:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80cdb6:	84 c0                	test   %al,%al
  80cdb8:	74 36                	je     80cdf0 <pbuf_realloc+0x9d>
  80cdba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cdbe:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80cdc2:	3c 02                	cmp    $0x2,%al
  80cdc4:	74 2a                	je     80cdf0 <pbuf_realloc+0x9d>
  80cdc6:	48 ba a6 14 82 00 00 	movabs $0x8214a6,%rdx
  80cdcd:	00 00 00 
  80cdd0:	be 17 01 00 00       	mov    $0x117,%esi
  80cdd5:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cddc:	00 00 00 
  80cddf:	b8 00 00 00 00       	mov    $0x0,%eax
  80cde4:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cdeb:	00 00 00 
  80cdee:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80cdf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cdf4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80cdf8:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80cdfc:	77 05                	ja     80ce03 <pbuf_realloc+0xb0>
    /* enlarging not yet supported */
    return;
  80cdfe:	e9 97 01 00 00       	jmpq   80cf9a <pbuf_realloc+0x247>
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80ce03:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80ce07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ce0b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80ce0f:	0f b7 c0             	movzwl %ax,%eax
  80ce12:	29 c2                	sub    %eax,%edx
  80ce14:	89 d0                	mov    %edx,%eax
  80ce16:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80ce19:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80ce1d:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80ce21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ce25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80ce29:	e9 90 00 00 00       	jmpq   80cebe <pbuf_realloc+0x16b>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80ce2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce32:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80ce36:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80ce3a:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80ce41:	7e 2a                	jle    80ce6d <pbuf_realloc+0x11a>
  80ce43:	48 ba c1 14 82 00 00 	movabs $0x8214c1,%rdx
  80ce4a:	00 00 00 
  80ce4d:	be 2b 01 00 00       	mov    $0x12b,%esi
  80ce52:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80ce59:	00 00 00 
  80ce5c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce61:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ce68:	00 00 00 
  80ce6b:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80ce6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce71:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80ce75:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80ce78:	01 c2                	add    %eax,%edx
  80ce7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce7e:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80ce82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce86:	48 8b 00             	mov    (%rax),%rax
  80ce89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80ce8d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ce92:	75 2a                	jne    80cebe <pbuf_realloc+0x16b>
  80ce94:	48 ba d2 14 82 00 00 	movabs $0x8214d2,%rdx
  80ce9b:	00 00 00 
  80ce9e:	be 2f 01 00 00       	mov    $0x12f,%esi
  80cea3:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80ceaa:	00 00 00 
  80cead:	b8 00 00 00 00       	mov    $0x0,%eax
  80ceb2:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ceb9:	00 00 00 
  80cebc:	ff d1                	callq  *%rcx
  while (rem_len > q->len) {
  80cebe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cec2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80cec6:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80ceca:	0f 82 5e ff ff ff    	jb     80ce2e <pbuf_realloc+0xdb>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80ced0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ced4:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80ced8:	84 c0                	test   %al,%al
  80ceda:	75 75                	jne    80cf51 <pbuf_realloc+0x1fe>
  80cedc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cee0:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80cee4:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80cee8:	74 67                	je     80cf51 <pbuf_realloc+0x1fe>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80ceea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ceee:	48 8b 40 08          	mov    0x8(%rax),%rax
  80cef2:	48 89 c2             	mov    %rax,%rdx
  80cef5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cef9:	48 29 c2             	sub    %rax,%rdx
  80cefc:	48 89 d0             	mov    %rdx,%rax
  80ceff:	89 c2                	mov    %eax,%edx
  80cf01:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80cf05:	01 c2                	add    %eax,%edx
  80cf07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf0b:	89 d6                	mov    %edx,%esi
  80cf0d:	48 89 c7             	mov    %rax,%rdi
  80cf10:	48 b8 a4 ba 80 00 00 	movabs $0x80baa4,%rax
  80cf17:	00 00 00 
  80cf1a:	ff d0                	callq  *%rax
  80cf1c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80cf20:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cf25:	75 2a                	jne    80cf51 <pbuf_realloc+0x1fe>
  80cf27:	48 ba ea 14 82 00 00 	movabs $0x8214ea,%rdx
  80cf2e:	00 00 00 
  80cf31:	be 39 01 00 00       	mov    $0x139,%esi
  80cf36:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cf3d:	00 00 00 
  80cf40:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf45:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cf4c:	00 00 00 
  80cf4f:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80cf51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf55:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cf59:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80cf5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf61:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80cf65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf69:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80cf6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf71:	48 8b 00             	mov    (%rax),%rax
  80cf74:	48 85 c0             	test   %rax,%rax
  80cf77:	74 16                	je     80cf8f <pbuf_realloc+0x23c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80cf79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf7d:	48 8b 00             	mov    (%rax),%rax
  80cf80:	48 89 c7             	mov    %rax,%rdi
  80cf83:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80cf8a:	00 00 00 
  80cf8d:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80cf8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf93:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

}
  80cf9a:	c9                   	leaveq 
  80cf9b:	c3                   	retq   

000000000080cf9c <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80cf9c:	55                   	push   %rbp
  80cf9d:	48 89 e5             	mov    %rsp,%rbp
  80cfa0:	48 83 ec 20          	sub    $0x20,%rsp
  80cfa4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80cfa8:	89 f0                	mov    %esi,%eax
  80cfaa:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80cfae:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cfb3:	75 2a                	jne    80cfdf <pbuf_header+0x43>
  80cfb5:	48 ba 05 15 82 00 00 	movabs $0x821505,%rdx
  80cfbc:	00 00 00 
  80cfbf:	be 64 01 00 00       	mov    $0x164,%esi
  80cfc4:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80cfcb:	00 00 00 
  80cfce:	b8 00 00 00 00       	mov    $0x0,%eax
  80cfd3:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80cfda:	00 00 00 
  80cfdd:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80cfdf:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80cfe4:	74 07                	je     80cfed <pbuf_header+0x51>
  80cfe6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cfeb:	75 0a                	jne    80cff7 <pbuf_header+0x5b>
    return 0;
  80cfed:	b8 00 00 00 00       	mov    $0x0,%eax
  80cff2:	e9 64 01 00 00       	jmpq   80d15b <pbuf_header+0x1bf>
 
  if (header_size_increment < 0){
  80cff7:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80cffc:	79 42                	jns    80d040 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80cffe:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d002:	f7 d8                	neg    %eax
  80d004:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80d008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d00c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d010:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d014:	73 32                	jae    80d048 <pbuf_header+0xac>
  80d016:	48 ba 0f 15 82 00 00 	movabs $0x82150f,%rdx
  80d01d:	00 00 00 
  80d020:	be 6b 01 00 00       	mov    $0x16b,%esi
  80d025:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d02c:	00 00 00 
  80d02f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d034:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d03b:	00 00 00 
  80d03e:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80d040:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d044:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80d048:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d04c:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d050:	0f b6 c0             	movzbl %al,%eax
  80d053:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80d057:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d05b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d05f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80d063:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80d068:	74 07                	je     80d071 <pbuf_header+0xd5>
  80d06a:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80d06f:	75 48                	jne    80d0b9 <pbuf_header+0x11d>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80d071:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d075:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d079:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d07e:	48 f7 da             	neg    %rdx
  80d081:	48 01 c2             	add    %rax,%rdx
  80d084:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d088:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80d08c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d090:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d094:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d098:	48 83 c2 18          	add    $0x18,%rdx
  80d09c:	48 39 d0             	cmp    %rdx,%rax
  80d09f:	73 16                	jae    80d0b7 <pbuf_header+0x11b>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80d0a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d0a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d0a9:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80d0ad:	b8 01 00 00 00       	mov    $0x1,%eax
  80d0b2:	e9 a4 00 00 00       	jmpq   80d15b <pbuf_header+0x1bf>
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80d0b7:	eb 71                	jmp    80d12a <pbuf_header+0x18e>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80d0b9:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80d0be:	74 07                	je     80d0c7 <pbuf_header+0x12b>
  80d0c0:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80d0c5:	75 39                	jne    80d100 <pbuf_header+0x164>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d0c7:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d0cc:	79 2b                	jns    80d0f9 <pbuf_header+0x15d>
  80d0ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d0d2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d0d6:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d0da:	72 1d                	jb     80d0f9 <pbuf_header+0x15d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80d0dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d0e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d0e4:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d0e9:	48 f7 da             	neg    %rdx
  80d0ec:	48 01 c2             	add    %rax,%rdx
  80d0ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d0f3:	48 89 50 08          	mov    %rdx,0x8(%rax)
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d0f7:	eb 31                	jmp    80d12a <pbuf_header+0x18e>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80d0f9:	b8 01 00 00 00       	mov    $0x1,%eax
  80d0fe:	eb 5b                	jmp    80d15b <pbuf_header+0x1bf>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80d100:	48 ba 2d 15 82 00 00 	movabs $0x82152d,%rdx
  80d107:	00 00 00 
  80d10a:	be 9a 01 00 00       	mov    $0x19a,%esi
  80d10f:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d116:	00 00 00 
  80d119:	b8 00 00 00 00       	mov    $0x0,%eax
  80d11e:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d125:	00 00 00 
  80d128:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80d12a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d12e:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d132:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d136:	01 c2                	add    %eax,%edx
  80d138:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d13c:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80d140:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d144:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d148:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d14c:	01 c2                	add    %eax,%edx
  80d14e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d152:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80d156:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d15b:	c9                   	leaveq 
  80d15c:	c3                   	retq   

000000000080d15d <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80d15d:	55                   	push   %rbp
  80d15e:	48 89 e5             	mov    %rsp,%rbp
  80d161:	48 83 ec 30          	sub    $0x30,%rsp
  80d165:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80d169:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d16e:	75 3b                	jne    80d1ab <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80d170:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d175:	75 2a                	jne    80d1a1 <pbuf_free+0x44>
  80d177:	48 ba 05 15 82 00 00 	movabs $0x821505,%rdx
  80d17e:	00 00 00 
  80d181:	be d0 01 00 00       	mov    $0x1d0,%esi
  80d186:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d18d:	00 00 00 
  80d190:	b8 00 00 00 00       	mov    $0x0,%eax
  80d195:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d19c:	00 00 00 
  80d19f:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80d1a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1a6:	e9 65 01 00 00       	jmpq   80d310 <pbuf_free+0x1b3>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80d1ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d1af:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d1b3:	84 c0                	test   %al,%al
  80d1b5:	74 4e                	je     80d205 <pbuf_free+0xa8>
  80d1b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d1bb:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d1bf:	3c 01                	cmp    $0x1,%al
  80d1c1:	74 42                	je     80d205 <pbuf_free+0xa8>
  80d1c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d1c7:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d1cb:	3c 02                	cmp    $0x2,%al
  80d1cd:	74 36                	je     80d205 <pbuf_free+0xa8>
  80d1cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d1d3:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d1d7:	3c 03                	cmp    $0x3,%al
  80d1d9:	74 2a                	je     80d205 <pbuf_free+0xa8>
  80d1db:	48 ba 3b 15 82 00 00 	movabs $0x82153b,%rdx
  80d1e2:	00 00 00 
  80d1e5:	be db 01 00 00       	mov    $0x1db,%esi
  80d1ea:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d1f1:	00 00 00 
  80d1f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1f9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d200:	00 00 00 
  80d203:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80d205:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80d209:	e9 f3 00 00 00       	jmpq   80d301 <pbuf_free+0x1a4>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80d20e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d212:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d216:	66 85 c0             	test   %ax,%ax
  80d219:	75 2a                	jne    80d245 <pbuf_free+0xe8>
  80d21b:	48 ba 50 15 82 00 00 	movabs $0x821550,%rdx
  80d222:	00 00 00 
  80d225:	be e8 01 00 00       	mov    $0x1e8,%esi
  80d22a:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d231:	00 00 00 
  80d234:	b8 00 00 00 00       	mov    $0x0,%eax
  80d239:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d240:	00 00 00 
  80d243:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80d245:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d249:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d24d:	8d 50 ff             	lea    -0x1(%rax),%edx
  80d250:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d254:	66 89 50 16          	mov    %dx,0x16(%rax)
  80d258:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d25c:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d260:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80d264:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80d269:	0f 85 8a 00 00 00    	jne    80d2f9 <pbuf_free+0x19c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80d26f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d273:	48 8b 00             	mov    (%rax),%rax
  80d276:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80d27a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d27e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d282:	0f b6 c0             	movzbl %al,%eax
  80d285:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80d289:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80d28e:	75 1a                	jne    80d2aa <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80d290:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d294:	48 89 c6             	mov    %rax,%rsi
  80d297:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d29c:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80d2a3:	00 00 00 
  80d2a6:	ff d0                	callq  *%rax
  80d2a8:	eb 3b                	jmp    80d2e5 <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80d2aa:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80d2af:	74 07                	je     80d2b8 <pbuf_free+0x15b>
  80d2b1:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80d2b6:	75 1a                	jne    80d2d2 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80d2b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d2bc:	48 89 c6             	mov    %rax,%rsi
  80d2bf:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d2c4:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80d2cb:	00 00 00 
  80d2ce:	ff d0                	callq  *%rax
  80d2d0:	eb 13                	jmp    80d2e5 <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80d2d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d2d6:	48 89 c7             	mov    %rax,%rdi
  80d2d9:	48 b8 1f b9 80 00 00 	movabs $0x80b91f,%rax
  80d2e0:	00 00 00 
  80d2e3:	ff d0                	callq  *%rax
      }
      count++;
  80d2e5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80d2e9:	83 c0 01             	add    $0x1,%eax
  80d2ec:	88 45 ff             	mov    %al,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80d2ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2f3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80d2f7:	eb 08                	jmp    80d301 <pbuf_free+0x1a4>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80d2f9:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80d300:	00 
  while (p != NULL) {
  80d301:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d306:	0f 85 02 ff ff ff    	jne    80d20e <pbuf_free+0xb1>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80d30c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80d310:	c9                   	leaveq 
  80d311:	c3                   	retq   

000000000080d312 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80d312:	55                   	push   %rbp
  80d313:	48 89 e5             	mov    %rsp,%rbp
  80d316:	48 83 ec 18          	sub    $0x18,%rsp
  80d31a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80d31e:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80d322:	eb 0f                	jmp    80d333 <pbuf_clen+0x21>
    ++len;
  80d324:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80d328:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d32c:	48 8b 00             	mov    (%rax),%rax
  80d32f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  while (p != NULL) {
  80d333:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d338:	75 ea                	jne    80d324 <pbuf_clen+0x12>
  }
  return len;
  80d33a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80d33e:	c9                   	leaveq 
  80d33f:	c3                   	retq   

000000000080d340 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80d340:	55                   	push   %rbp
  80d341:	48 89 e5             	mov    %rsp,%rbp
  80d344:	48 83 ec 08          	sub    $0x8,%rsp
  80d348:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80d34c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d351:	74 13                	je     80d366 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80d353:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d357:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d35b:	8d 50 01             	lea    0x1(%rax),%edx
  80d35e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d362:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80d366:	c9                   	leaveq 
  80d367:	c3                   	retq   

000000000080d368 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80d368:	55                   	push   %rbp
  80d369:	48 89 e5             	mov    %rsp,%rbp
  80d36c:	48 83 ec 20          	sub    $0x20,%rsp
  80d370:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d374:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80d378:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d37d:	74 07                	je     80d386 <pbuf_cat+0x1e>
  80d37f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d384:	75 2a                	jne    80d3b0 <pbuf_cat+0x48>
  80d386:	48 ba 68 15 82 00 00 	movabs $0x821568,%rdx
  80d38d:	00 00 00 
  80d390:	be 42 02 00 00       	mov    $0x242,%esi
  80d395:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d39c:	00 00 00 
  80d39f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3a4:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d3ab:	00 00 00 
  80d3ae:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80d3b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d3b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d3b8:	eb 25                	jmp    80d3df <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80d3ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3be:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d3c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d3c6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d3ca:	01 c2                	add    %eax,%edx
  80d3cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3d0:	66 89 50 10          	mov    %dx,0x10(%rax)
  for (p = h; p->next != NULL; p = p->next) {
  80d3d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3d8:	48 8b 00             	mov    (%rax),%rax
  80d3db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d3df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3e3:	48 8b 00             	mov    (%rax),%rax
  80d3e6:	48 85 c0             	test   %rax,%rax
  80d3e9:	75 cf                	jne    80d3ba <pbuf_cat+0x52>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80d3eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3ef:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d3f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3f7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d3fb:	66 39 c2             	cmp    %ax,%dx
  80d3fe:	74 2a                	je     80d42a <pbuf_cat+0xc2>
  80d400:	48 ba a0 15 82 00 00 	movabs $0x8215a0,%rdx
  80d407:	00 00 00 
  80d40a:	be 4a 02 00 00       	mov    $0x24a,%esi
  80d40f:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d416:	00 00 00 
  80d419:	b8 00 00 00 00       	mov    $0x0,%eax
  80d41e:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d425:	00 00 00 
  80d428:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80d42a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d42e:	48 8b 00             	mov    (%rax),%rax
  80d431:	48 85 c0             	test   %rax,%rax
  80d434:	74 2a                	je     80d460 <pbuf_cat+0xf8>
  80d436:	48 ba cd 15 82 00 00 	movabs $0x8215cd,%rdx
  80d43d:	00 00 00 
  80d440:	be 4b 02 00 00       	mov    $0x24b,%esi
  80d445:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d44c:	00 00 00 
  80d44f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d454:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d45b:	00 00 00 
  80d45e:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80d460:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d464:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d468:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d46c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d470:	01 c2                	add    %eax,%edx
  80d472:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d476:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80d47a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d47e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d482:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80d485:	c9                   	leaveq 
  80d486:	c3                   	retq   

000000000080d487 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80d487:	55                   	push   %rbp
  80d488:	48 89 e5             	mov    %rsp,%rbp
  80d48b:	48 83 ec 10          	sub    $0x10,%rsp
  80d48f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d493:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80d497:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d49b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d49f:	48 89 d6             	mov    %rdx,%rsi
  80d4a2:	48 89 c7             	mov    %rax,%rdi
  80d4a5:	48 b8 68 d3 80 00 00 	movabs $0x80d368,%rax
  80d4ac:	00 00 00 
  80d4af:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80d4b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d4b5:	48 89 c7             	mov    %rax,%rdi
  80d4b8:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  80d4bf:	00 00 00 
  80d4c2:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80d4c4:	c9                   	leaveq 
  80d4c5:	c3                   	retq   

000000000080d4c6 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80d4c6:	55                   	push   %rbp
  80d4c7:	48 89 e5             	mov    %rsp,%rbp
  80d4ca:	48 83 ec 20          	sub    $0x20,%rsp
  80d4ce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80d4d2:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  /* tail */
  q = p->next;
  80d4d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d4da:	48 8b 00             	mov    (%rax),%rax
  80d4dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80d4e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d4e6:	0f 84 9e 00 00 00    	je     80d58a <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80d4ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d4f0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d4f4:	0f b7 d0             	movzwl %ax,%edx
  80d4f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d4fb:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d4ff:	0f b7 c8             	movzwl %ax,%ecx
  80d502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d506:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d50a:	0f b7 c0             	movzwl %ax,%eax
  80d50d:	29 c1                	sub    %eax,%ecx
  80d50f:	89 c8                	mov    %ecx,%eax
  80d511:	39 c2                	cmp    %eax,%edx
  80d513:	74 2a                	je     80d53f <pbuf_dechain+0x79>
  80d515:	48 ba e0 15 82 00 00 	movabs $0x8215e0,%rdx
  80d51c:	00 00 00 
  80d51f:	be 80 02 00 00       	mov    $0x280,%esi
  80d524:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d52b:	00 00 00 
  80d52e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d533:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d53a:	00 00 00 
  80d53d:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80d53f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d543:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d547:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d54b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d54f:	29 c2                	sub    %eax,%edx
  80d551:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d555:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80d559:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d55d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80d564:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d568:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d56c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d570:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80d574:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d578:	48 89 c7             	mov    %rax,%rdi
  80d57b:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80d582:	00 00 00 
  80d585:	ff d0                	callq  *%rax
  80d587:	88 45 ff             	mov    %al,-0x1(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80d58a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d58e:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d596:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d59a:	66 39 c2             	cmp    %ax,%dx
  80d59d:	74 2a                	je     80d5c9 <pbuf_dechain+0x103>
  80d59f:	48 ba 02 16 82 00 00 	movabs $0x821602,%rdx
  80d5a6:	00 00 00 
  80d5a9:	be 91 02 00 00       	mov    $0x291,%esi
  80d5ae:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d5b5:	00 00 00 
  80d5b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5bd:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d5c4:	00 00 00 
  80d5c7:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80d5c9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80d5cd:	75 06                	jne    80d5d5 <pbuf_dechain+0x10f>
  80d5cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d5d3:	eb 05                	jmp    80d5da <pbuf_dechain+0x114>
  80d5d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d5da:	c9                   	leaveq 
  80d5db:	c3                   	retq   

000000000080d5dc <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80d5dc:	55                   	push   %rbp
  80d5dd:	48 89 e5             	mov    %rsp,%rbp
  80d5e0:	48 83 ec 20          	sub    $0x20,%rsp
  80d5e4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d5e8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80d5ec:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  80d5f2:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80d5f8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d5fd:	74 1c                	je     80d61b <pbuf_copy+0x3f>
  80d5ff:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d604:	74 15                	je     80d61b <pbuf_copy+0x3f>
  80d606:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d60a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d60e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d612:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d616:	66 39 c2             	cmp    %ax,%dx
  80d619:	73 2a                	jae    80d645 <pbuf_copy+0x69>
  80d61b:	48 ba 18 16 82 00 00 	movabs $0x821618,%rdx
  80d622:	00 00 00 
  80d625:	be b1 02 00 00       	mov    $0x2b1,%esi
  80d62a:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d631:	00 00 00 
  80d634:	b8 00 00 00 00       	mov    $0x0,%eax
  80d639:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d640:	00 00 00 
  80d643:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80d645:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d64a:	75 2a                	jne    80d676 <pbuf_copy+0x9a>
  80d64c:	48 ba 48 16 82 00 00 	movabs $0x821648,%rdx
  80d653:	00 00 00 
  80d656:	be b6 02 00 00       	mov    $0x2b6,%esi
  80d65b:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d662:	00 00 00 
  80d665:	b8 00 00 00 00       	mov    $0x0,%eax
  80d66a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d671:	00 00 00 
  80d674:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80d676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d67a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d67e:	0f b7 d0             	movzwl %ax,%edx
  80d681:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80d685:	89 d1                	mov    %edx,%ecx
  80d687:	29 c1                	sub    %eax,%ecx
  80d689:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d68d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d691:	0f b7 d0             	movzwl %ax,%edx
  80d694:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  80d698:	29 c2                	sub    %eax,%edx
  80d69a:	89 d0                	mov    %edx,%eax
  80d69c:	39 c1                	cmp    %eax,%ecx
  80d69e:	7c 12                	jl     80d6b2 <pbuf_copy+0xd6>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80d6a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d6a4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d6a8:	66 2b 45 fc          	sub    -0x4(%rbp),%ax
  80d6ac:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
  80d6b0:	eb 10                	jmp    80d6c2 <pbuf_copy+0xe6>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80d6b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6b6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d6ba:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  80d6be:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80d6c2:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80d6c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d6ca:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80d6ce:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
  80d6d2:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80d6d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d6da:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80d6de:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  80d6e2:	48 01 d1             	add    %rdx,%rcx
  80d6e5:	48 89 c2             	mov    %rax,%rdx
  80d6e8:	48 89 cf             	mov    %rcx,%rdi
  80d6eb:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  80d6f2:	00 00 00 
  80d6f5:	ff d0                	callq  *%rax
    offset_to += len;
  80d6f7:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80d6fb:	66 01 45 fe          	add    %ax,-0x2(%rbp)
    offset_from += len;
  80d6ff:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80d703:	66 01 45 fc          	add    %ax,-0x4(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80d707:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d70b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d70f:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d713:	73 2a                	jae    80d73f <pbuf_copy+0x163>
  80d715:	48 ba 55 16 82 00 00 	movabs $0x821655,%rdx
  80d71c:	00 00 00 
  80d71f:	be c2 02 00 00       	mov    $0x2c2,%esi
  80d724:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d72b:	00 00 00 
  80d72e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d733:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d73a:	00 00 00 
  80d73d:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80d73f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d743:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d747:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d74b:	75 11                	jne    80d75e <pbuf_copy+0x182>
      /* on to next p_to (if any) */
      offset_to = 0;
  80d74d:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
      p_to = p_to->next;
  80d753:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d757:	48 8b 00             	mov    (%rax),%rax
  80d75a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80d75e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d762:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d766:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80d76a:	73 2a                	jae    80d796 <pbuf_copy+0x1ba>
  80d76c:	48 ba 6c 16 82 00 00 	movabs $0x82166c,%rdx
  80d773:	00 00 00 
  80d776:	be c8 02 00 00       	mov    $0x2c8,%esi
  80d77b:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d782:	00 00 00 
  80d785:	b8 00 00 00 00       	mov    $0x0,%eax
  80d78a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d791:	00 00 00 
  80d794:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80d796:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d79a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d79e:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80d7a2:	77 11                	ja     80d7b5 <pbuf_copy+0x1d9>
      /* on to next p_from (if any) */
      offset_from = 0;
  80d7a4:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)
      p_from = p_from->next;
  80d7aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7ae:	48 8b 00             	mov    (%rax),%rax
  80d7b1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80d7b5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d7ba:	74 4b                	je     80d807 <pbuf_copy+0x22b>
  80d7bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7c0:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d7c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7c8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d7cc:	66 39 c2             	cmp    %ax,%dx
  80d7cf:	75 36                	jne    80d807 <pbuf_copy+0x22b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80d7d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7d5:	48 8b 00             	mov    (%rax),%rax
  80d7d8:	48 85 c0             	test   %rax,%rax
  80d7db:	74 2a                	je     80d807 <pbuf_copy+0x22b>
  80d7dd:	48 ba 88 16 82 00 00 	movabs $0x821688,%rdx
  80d7e4:	00 00 00 
  80d7e7:	be d2 02 00 00       	mov    $0x2d2,%esi
  80d7ec:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d7f3:	00 00 00 
  80d7f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7fb:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d802:	00 00 00 
  80d805:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80d807:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d80c:	74 4b                	je     80d859 <pbuf_copy+0x27d>
  80d80e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d812:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d816:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d81a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d81e:	66 39 c2             	cmp    %ax,%dx
  80d821:	75 36                	jne    80d859 <pbuf_copy+0x27d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80d823:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d827:	48 8b 00             	mov    (%rax),%rax
  80d82a:	48 85 c0             	test   %rax,%rax
  80d82d:	74 2a                	je     80d859 <pbuf_copy+0x27d>
  80d82f:	48 ba 88 16 82 00 00 	movabs $0x821688,%rdx
  80d836:	00 00 00 
  80d839:	be d7 02 00 00       	mov    $0x2d7,%esi
  80d83e:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d845:	00 00 00 
  80d848:	b8 00 00 00 00       	mov    $0x0,%eax
  80d84d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d854:	00 00 00 
  80d857:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80d859:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d85e:	0f 85 e1 fd ff ff    	jne    80d645 <pbuf_copy+0x69>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80d864:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d869:	c9                   	leaveq 
  80d86a:	c3                   	retq   

000000000080d86b <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80d86b:	55                   	push   %rbp
  80d86c:	48 89 e5             	mov    %rsp,%rbp
  80d86f:	48 83 ec 30          	sub    $0x30,%rsp
  80d873:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d877:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80d87b:	89 c8                	mov    %ecx,%eax
  80d87d:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80d881:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80d885:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80d88b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d890:	75 2a                	jne    80d8bc <pbuf_copy_partial+0x51>
  80d892:	48 ba b8 16 82 00 00 	movabs $0x8216b8,%rdx
  80d899:	00 00 00 
  80d89c:	be ef 02 00 00       	mov    $0x2ef,%esi
  80d8a1:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d8a8:	00 00 00 
  80d8ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8b0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d8b7:	00 00 00 
  80d8ba:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80d8bc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d8c1:	75 2a                	jne    80d8ed <pbuf_copy_partial+0x82>
  80d8c3:	48 ba e0 16 82 00 00 	movabs $0x8216e0,%rdx
  80d8ca:	00 00 00 
  80d8cd:	be f0 02 00 00       	mov    $0x2f0,%esi
  80d8d2:	48 bf 8b 13 82 00 00 	movabs $0x82138b,%rdi
  80d8d9:	00 00 00 
  80d8dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8e1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80d8e8:	00 00 00 
  80d8eb:	ff d1                	callq  *%rcx

  left = 0;
  80d8ed:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80d8f3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d8f8:	74 07                	je     80d901 <pbuf_copy_partial+0x96>
  80d8fa:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d8ff:	75 0a                	jne    80d90b <pbuf_copy_partial+0xa0>
    return 0;
  80d901:	b8 00 00 00 00       	mov    $0x0,%eax
  80d906:	e9 c2 00 00 00       	jmpq   80d9cd <pbuf_copy_partial+0x162>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80d90b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d90f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d913:	e9 9f 00 00 00       	jmpq   80d9b7 <pbuf_copy_partial+0x14c>
    if ((offset != 0) && (offset >= p->len)) {
  80d918:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80d91d:	74 1c                	je     80d93b <pbuf_copy_partial+0xd0>
  80d91f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d923:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d927:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80d92b:	77 0e                	ja     80d93b <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80d92d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d931:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d935:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80d939:	eb 71                	jmp    80d9ac <pbuf_copy_partial+0x141>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80d93b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d93f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d943:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80d947:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80d94b:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80d94f:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80d953:	76 08                	jbe    80d95d <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80d955:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80d959:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80d95d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80d961:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d965:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80d969:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d96d:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80d971:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80d975:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d979:	48 01 d1             	add    %rdx,%rcx
  80d97c:	48 89 c2             	mov    %rax,%rdx
  80d97f:	48 89 cf             	mov    %rcx,%rdi
  80d982:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  80d989:	00 00 00 
  80d98c:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80d98e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80d992:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80d996:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80d99a:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80d99e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80d9a2:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80d9a6:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80d9ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9b0:	48 8b 00             	mov    (%rax),%rax
  80d9b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d9b7:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80d9bc:	74 0b                	je     80d9c9 <pbuf_copy_partial+0x15e>
  80d9be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d9c3:	0f 85 4f ff ff ff    	jne    80d918 <pbuf_copy_partial+0xad>
    }
  }
  return copied_total;
  80d9c9:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80d9cd:	c9                   	leaveq 
  80d9ce:	c3                   	retq   

000000000080d9cf <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80d9cf:	55                   	push   %rbp
  80d9d0:	48 89 e5             	mov    %rsp,%rbp
  80d9d3:	48 83 ec 40          	sub    $0x40,%rsp
  80d9d7:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80d9da:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80d9de:	48 b8 eb 7c 81 00 00 	movabs $0x817ceb,%rax
  80d9e5:	00 00 00 
  80d9e8:	ff d0                	callq  *%rax
  80d9ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80d9ee:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d9f3:	74 0c                	je     80da01 <sys_mbox_fetch+0x32>
  80d9f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d9f9:	48 8b 00             	mov    (%rax),%rax
  80d9fc:	48 85 c0             	test   %rax,%rax
  80d9ff:	75 25                	jne    80da26 <sys_mbox_fetch+0x57>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80da01:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80da05:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80da08:	ba 00 00 00 00       	mov    $0x0,%edx
  80da0d:	48 89 ce             	mov    %rcx,%rsi
  80da10:	89 c7                	mov    %eax,%edi
  80da12:	48 b8 08 78 81 00 00 	movabs $0x817808,%rax
  80da19:	00 00 00 
  80da1c:	ff d0                	callq  *%rax
  80da1e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80da21:	e9 dc 00 00 00       	jmpq   80db02 <sys_mbox_fetch+0x133>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80da26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80da2a:	48 8b 00             	mov    (%rax),%rax
  80da2d:	8b 40 08             	mov    0x8(%rax),%eax
  80da30:	85 c0                	test   %eax,%eax
  80da32:	74 27                	je     80da5b <sys_mbox_fetch+0x8c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80da34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80da38:	48 8b 00             	mov    (%rax),%rax
  80da3b:	8b 50 08             	mov    0x8(%rax),%edx
  80da3e:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80da42:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80da45:	48 89 ce             	mov    %rcx,%rsi
  80da48:	89 c7                	mov    %eax,%edi
  80da4a:	48 b8 08 78 81 00 00 	movabs $0x817808,%rax
  80da51:	00 00 00 
  80da54:	ff d0                	callq  *%rax
  80da56:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80da59:	eb 07                	jmp    80da62 <sys_mbox_fetch+0x93>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80da5b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80da62:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80da66:	75 64                	jne    80dacc <sys_mbox_fetch+0xfd>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80da68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80da6c:	48 8b 00             	mov    (%rax),%rax
  80da6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80da73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da77:	48 8b 10             	mov    (%rax),%rdx
  80da7a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80da7e:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80da81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da85:	48 8b 40 10          	mov    0x10(%rax),%rax
  80da89:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80da8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da91:	48 8b 40 18          	mov    0x18(%rax),%rax
  80da95:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80da99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da9d:	48 89 c6             	mov    %rax,%rsi
  80daa0:	bf 0b 00 00 00       	mov    $0xb,%edi
  80daa5:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80daac:	00 00 00 
  80daaf:	ff d0                	callq  *%rax
      if (h != NULL) {
  80dab1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dab5:	48 85 c0             	test   %rax,%rax
  80dab8:	74 0d                	je     80dac7 <sys_mbox_fetch+0xf8>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80daba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dabe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80dac2:	48 89 d7             	mov    %rdx,%rdi
  80dac5:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80dac7:	e9 12 ff ff ff       	jmpq   80d9de <sys_mbox_fetch+0xf>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80dacc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dad0:	48 8b 00             	mov    (%rax),%rax
  80dad3:	8b 40 08             	mov    0x8(%rax),%eax
  80dad6:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80dad9:	76 19                	jbe    80daf4 <sys_mbox_fetch+0x125>
        timeouts->next->time -= time_needed;
  80dadb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dadf:	48 8b 00             	mov    (%rax),%rax
  80dae2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dae6:	48 8b 12             	mov    (%rdx),%rdx
  80dae9:	8b 52 08             	mov    0x8(%rdx),%edx
  80daec:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80daef:	89 50 08             	mov    %edx,0x8(%rax)
  80daf2:	eb 0e                	jmp    80db02 <sys_mbox_fetch+0x133>
      } else {
        timeouts->next->time = 0;
  80daf4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80daf8:	48 8b 00             	mov    (%rax),%rax
  80dafb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80db02:	c9                   	leaveq 
  80db03:	c3                   	retq   

000000000080db04 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80db04:	55                   	push   %rbp
  80db05:	48 89 e5             	mov    %rsp,%rbp
  80db08:	48 83 ec 40          	sub    $0x40,%rsp
  80db0c:	89 7d cc             	mov    %edi,-0x34(%rbp)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80db0f:	48 b8 eb 7c 81 00 00 	movabs $0x817ceb,%rax
  80db16:	00 00 00 
  80db19:	ff d0                	callq  *%rax
  80db1b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80db1f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80db24:	74 0c                	je     80db32 <sys_sem_wait+0x2e>
  80db26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80db2a:	48 8b 00             	mov    (%rax),%rax
  80db2d:	48 85 c0             	test   %rax,%rax
  80db30:	75 1b                	jne    80db4d <sys_sem_wait+0x49>
    sys_arch_sem_wait(sem, 0);
  80db32:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80db35:	be 00 00 00 00       	mov    $0x0,%esi
  80db3a:	89 c7                	mov    %eax,%edi
  80db3c:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  80db43:	00 00 00 
  80db46:	ff d0                	callq  *%rax
  80db48:	e9 d7 00 00 00       	jmpq   80dc24 <sys_sem_wait+0x120>
  } else {
    if (timeouts->next->time > 0) {
  80db4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80db51:	48 8b 00             	mov    (%rax),%rax
  80db54:	8b 40 08             	mov    0x8(%rax),%eax
  80db57:	85 c0                	test   %eax,%eax
  80db59:	74 22                	je     80db7d <sys_sem_wait+0x79>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80db5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80db5f:	48 8b 00             	mov    (%rax),%rax
  80db62:	8b 50 08             	mov    0x8(%rax),%edx
  80db65:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80db68:	89 d6                	mov    %edx,%esi
  80db6a:	89 c7                	mov    %eax,%edi
  80db6c:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  80db73:	00 00 00 
  80db76:	ff d0                	callq  *%rax
  80db78:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80db7b:	eb 07                	jmp    80db84 <sys_sem_wait+0x80>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80db7d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80db84:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80db88:	75 64                	jne    80dbee <sys_sem_wait+0xea>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80db8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80db8e:	48 8b 00             	mov    (%rax),%rax
  80db91:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80db95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db99:	48 8b 10             	mov    (%rax),%rdx
  80db9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dba0:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80dba3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dba7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80dbab:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80dbaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbb3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80dbb7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80dbbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbbf:	48 89 c6             	mov    %rax,%rsi
  80dbc2:	bf 0b 00 00 00       	mov    $0xb,%edi
  80dbc7:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80dbce:	00 00 00 
  80dbd1:	ff d0                	callq  *%rax
      if (h != NULL) {
  80dbd3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dbd7:	48 85 c0             	test   %rax,%rax
  80dbda:	74 0d                	je     80dbe9 <sys_sem_wait+0xe5>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80dbdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dbe0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80dbe4:	48 89 d7             	mov    %rdx,%rdi
  80dbe7:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80dbe9:	e9 21 ff ff ff       	jmpq   80db0f <sys_sem_wait+0xb>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80dbee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dbf2:	48 8b 00             	mov    (%rax),%rax
  80dbf5:	8b 40 08             	mov    0x8(%rax),%eax
  80dbf8:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80dbfb:	76 19                	jbe    80dc16 <sys_sem_wait+0x112>
        timeouts->next->time -= time_needed;
  80dbfd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dc01:	48 8b 00             	mov    (%rax),%rax
  80dc04:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dc08:	48 8b 12             	mov    (%rdx),%rdx
  80dc0b:	8b 52 08             	mov    0x8(%rdx),%edx
  80dc0e:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80dc11:	89 50 08             	mov    %edx,0x8(%rax)
  80dc14:	eb 0e                	jmp    80dc24 <sys_sem_wait+0x120>
      } else {
        timeouts->next->time = 0;
  80dc16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dc1a:	48 8b 00             	mov    (%rax),%rax
  80dc1d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80dc24:	c9                   	leaveq 
  80dc25:	c3                   	retq   

000000000080dc26 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80dc26:	55                   	push   %rbp
  80dc27:	48 89 e5             	mov    %rsp,%rbp
  80dc2a:	48 83 ec 40          	sub    $0x40,%rsp
  80dc2e:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80dc31:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80dc35:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80dc39:	bf 0b 00 00 00       	mov    $0xb,%edi
  80dc3e:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80dc45:	00 00 00 
  80dc48:	ff d0                	callq  *%rax
  80dc4a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (timeout == NULL) {
  80dc4e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80dc53:	75 36                	jne    80dc8b <sys_timeout+0x65>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80dc55:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80dc5a:	75 2a                	jne    80dc86 <sys_timeout+0x60>
  80dc5c:	48 ba 08 17 82 00 00 	movabs $0x821708,%rdx
  80dc63:	00 00 00 
  80dc66:	be c3 00 00 00       	mov    $0xc3,%esi
  80dc6b:	48 bf 25 17 82 00 00 	movabs $0x821725,%rdi
  80dc72:	00 00 00 
  80dc75:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc7a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80dc81:	00 00 00 
  80dc84:	ff d1                	callq  *%rcx
    return;
  80dc86:	e9 7e 01 00 00       	jmpq   80de09 <sys_timeout+0x1e3>
  }
  timeout->next = NULL;
  80dc8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dc8f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80dc96:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80dc9a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dc9e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80dca2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dca6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80dcaa:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80dcae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dcb2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80dcb5:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80dcb8:	48 b8 eb 7c 81 00 00 	movabs $0x817ceb,%rax
  80dcbf:	00 00 00 
  80dcc2:	ff d0                	callq  *%rax
  80dcc4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80dcc8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dccd:	75 36                	jne    80dd05 <sys_timeout+0xdf>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80dccf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dcd4:	75 2a                	jne    80dd00 <sys_timeout+0xda>
  80dcd6:	48 ba 39 17 82 00 00 	movabs $0x821739,%rdx
  80dcdd:	00 00 00 
  80dce0:	be d1 00 00 00       	mov    $0xd1,%esi
  80dce5:	48 bf 25 17 82 00 00 	movabs $0x821725,%rdi
  80dcec:	00 00 00 
  80dcef:	b8 00 00 00 00       	mov    $0x0,%eax
  80dcf4:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80dcfb:	00 00 00 
  80dcfe:	ff d1                	callq  *%rcx
    return;
  80dd00:	e9 04 01 00 00       	jmpq   80de09 <sys_timeout+0x1e3>
  }

  if (timeouts->next == NULL) {
  80dd05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd09:	48 8b 00             	mov    (%rax),%rax
  80dd0c:	48 85 c0             	test   %rax,%rax
  80dd0f:	75 10                	jne    80dd21 <sys_timeout+0xfb>
    timeouts->next = timeout;
  80dd11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd15:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dd19:	48 89 10             	mov    %rdx,(%rax)
    return;
  80dd1c:	e9 e8 00 00 00       	jmpq   80de09 <sys_timeout+0x1e3>
  }

  if (timeouts->next->time > msecs) {
  80dd21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd25:	48 8b 00             	mov    (%rax),%rax
  80dd28:	8b 40 08             	mov    0x8(%rax),%eax
  80dd2b:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80dd2e:	76 35                	jbe    80dd65 <sys_timeout+0x13f>
    timeouts->next->time -= msecs;
  80dd30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd34:	48 8b 00             	mov    (%rax),%rax
  80dd37:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80dd3b:	48 8b 12             	mov    (%rdx),%rdx
  80dd3e:	8b 52 08             	mov    0x8(%rdx),%edx
  80dd41:	2b 55 dc             	sub    -0x24(%rbp),%edx
  80dd44:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80dd47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd4b:	48 8b 10             	mov    (%rax),%rdx
  80dd4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dd52:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80dd55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd59:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dd5d:	48 89 10             	mov    %rdx,(%rax)
  80dd60:	e9 a4 00 00 00       	jmpq   80de09 <sys_timeout+0x1e3>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80dd65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd69:	48 8b 00             	mov    (%rax),%rax
  80dd6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dd70:	e9 89 00 00 00       	jmpq   80ddfe <sys_timeout+0x1d8>
      timeout->time -= t->time;
  80dd75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dd79:	8b 50 08             	mov    0x8(%rax),%edx
  80dd7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd80:	8b 40 08             	mov    0x8(%rax),%eax
  80dd83:	29 c2                	sub    %eax,%edx
  80dd85:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dd89:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80dd8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd90:	48 8b 00             	mov    (%rax),%rax
  80dd93:	48 85 c0             	test   %rax,%rax
  80dd96:	74 15                	je     80ddad <sys_timeout+0x187>
  80dd98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd9c:	48 8b 00             	mov    (%rax),%rax
  80dd9f:	8b 50 08             	mov    0x8(%rax),%edx
  80dda2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dda6:	8b 40 08             	mov    0x8(%rax),%eax
  80dda9:	39 c2                	cmp    %eax,%edx
  80ddab:	76 46                	jbe    80ddf3 <sys_timeout+0x1cd>
        if (t->next != NULL) {
  80ddad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ddb1:	48 8b 00             	mov    (%rax),%rax
  80ddb4:	48 85 c0             	test   %rax,%rax
  80ddb7:	74 1f                	je     80ddd8 <sys_timeout+0x1b2>
          t->next->time -= timeout->time;
  80ddb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ddbd:	48 8b 00             	mov    (%rax),%rax
  80ddc0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ddc4:	48 8b 12             	mov    (%rdx),%rdx
  80ddc7:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80ddca:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ddce:	8b 52 08             	mov    0x8(%rdx),%edx
  80ddd1:	29 d1                	sub    %edx,%ecx
  80ddd3:	89 ca                	mov    %ecx,%edx
  80ddd5:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80ddd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dddc:	48 8b 10             	mov    (%rax),%rdx
  80dddf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dde3:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80dde6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ddea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ddee:	48 89 10             	mov    %rdx,(%rax)
        break;
  80ddf1:	eb 16                	jmp    80de09 <sys_timeout+0x1e3>
    for(t = timeouts->next; t != NULL; t = t->next) {
  80ddf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ddf7:	48 8b 00             	mov    (%rax),%rax
  80ddfa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ddfe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80de03:	0f 85 6c ff ff ff    	jne    80dd75 <sys_timeout+0x14f>
      }
    }
  }
}
  80de09:	c9                   	leaveq 
  80de0a:	c3                   	retq   

000000000080de0b <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80de0b:	55                   	push   %rbp
  80de0c:	48 89 e5             	mov    %rsp,%rbp
  80de0f:	48 83 ec 30          	sub    $0x30,%rsp
  80de13:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80de17:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80de1b:	48 b8 eb 7c 81 00 00 	movabs $0x817ceb,%rax
  80de22:	00 00 00 
  80de25:	ff d0                	callq  *%rax
  80de27:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80de2b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80de30:	75 36                	jne    80de68 <sys_untimeout+0x5d>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80de32:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80de37:	75 2a                	jne    80de63 <sys_untimeout+0x58>
  80de39:	48 ba 58 17 82 00 00 	movabs $0x821758,%rdx
  80de40:	00 00 00 
  80de43:	be 00 01 00 00       	mov    $0x100,%esi
  80de48:	48 bf 25 17 82 00 00 	movabs $0x821725,%rdi
  80de4f:	00 00 00 
  80de52:	b8 00 00 00 00       	mov    $0x0,%eax
  80de57:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80de5e:	00 00 00 
  80de61:	ff d1                	callq  *%rcx
    return;
  80de63:	e9 cc 00 00 00       	jmpq   80df34 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
  80de68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de6c:	48 8b 00             	mov    (%rax),%rax
  80de6f:	48 85 c0             	test   %rax,%rax
  80de72:	75 05                	jne    80de79 <sys_untimeout+0x6e>
    return;
  80de74:	e9 bb 00 00 00       	jmpq   80df34 <sys_untimeout+0x129>
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80de79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de7d:	48 8b 00             	mov    (%rax),%rax
  80de80:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80de84:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80de8b:	00 
  80de8c:	e9 97 00 00 00       	jmpq   80df28 <sys_untimeout+0x11d>
    if ((t->h == h) && (t->arg == arg)) {
  80de91:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80de95:	48 8b 40 10          	mov    0x10(%rax),%rax
  80de99:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80de9d:	75 76                	jne    80df15 <sys_untimeout+0x10a>
  80de9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dea3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80dea7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80deab:	75 68                	jne    80df15 <sys_untimeout+0x10a>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80dead:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80deb2:	75 10                	jne    80dec4 <sys_untimeout+0xb9>
        timeouts->next = t->next;
  80deb4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80deb8:	48 8b 10             	mov    (%rax),%rdx
  80debb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80debf:	48 89 10             	mov    %rdx,(%rax)
  80dec2:	eb 0e                	jmp    80ded2 <sys_untimeout+0xc7>
      else
        prev_t->next = t->next;
  80dec4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dec8:	48 8b 10             	mov    (%rax),%rdx
  80decb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80decf:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80ded2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ded6:	48 8b 00             	mov    (%rax),%rax
  80ded9:	48 85 c0             	test   %rax,%rax
  80dedc:	74 1d                	je     80defb <sys_untimeout+0xf0>
        t->next->time += t->time;
  80dede:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dee2:	48 8b 00             	mov    (%rax),%rax
  80dee5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dee9:	48 8b 12             	mov    (%rdx),%rdx
  80deec:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80deef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80def3:	8b 52 08             	mov    0x8(%rdx),%edx
  80def6:	01 ca                	add    %ecx,%edx
  80def8:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80defb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80deff:	48 89 c6             	mov    %rax,%rsi
  80df02:	bf 0b 00 00 00       	mov    $0xb,%edi
  80df07:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80df0e:	00 00 00 
  80df11:	ff d0                	callq  *%rax
      return;
  80df13:	eb 1f                	jmp    80df34 <sys_untimeout+0x129>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80df15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80df19:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80df1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80df21:	48 8b 00             	mov    (%rax),%rax
  80df24:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80df28:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80df2d:	0f 85 5e ff ff ff    	jne    80de91 <sys_untimeout+0x86>
    }
  }
  return;
  80df33:	90                   	nop
}
  80df34:	c9                   	leaveq 
  80df35:	c3                   	retq   

000000000080df36 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80df36:	55                   	push   %rbp
  80df37:	48 89 e5             	mov    %rsp,%rbp
  80df3a:	48 83 ec 20          	sub    $0x20,%rsp
  80df3e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80df42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df46:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80df4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df4e:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80df53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df57:	48 8b 40 08          	mov    0x8(%rax),%rax
  80df5b:	8b 00                	mov    (%rax),%eax
  80df5d:	89 c7                	mov    %eax,%edi
  80df5f:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  80df66:	00 00 00 
  80df69:	ff d0                	callq  *%rax
}
  80df6b:	c9                   	leaveq 
  80df6c:	c3                   	retq   

000000000080df6d <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80df6d:	55                   	push   %rbp
  80df6e:	48 89 e5             	mov    %rsp,%rbp
  80df71:	48 83 ec 20          	sub    $0x20,%rsp
  80df75:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80df78:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80df7b:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80df7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80df83:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80df89:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80df8d:	74 1f                	je     80dfae <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80df8f:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80df93:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80df96:	48 be 36 df 80 00 00 	movabs $0x80df36,%rsi
  80df9d:	00 00 00 
  80dfa0:	89 c7                	mov    %eax,%edi
  80dfa2:	48 b8 26 dc 80 00 00 	movabs $0x80dc26,%rax
  80dfa9:	00 00 00 
  80dfac:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80dfae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80dfb1:	89 c7                	mov    %eax,%edi
  80dfb3:	48 b8 04 db 80 00 00 	movabs $0x80db04,%rax
  80dfba:	00 00 00 
  80dfbd:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80dfbf:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80dfc3:	66 85 c0             	test   %ax,%ax
  80dfc6:	74 07                	je     80dfcf <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80dfc8:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfcd:	eb 22                	jmp    80dff1 <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80dfcf:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80dfd3:	48 89 c6             	mov    %rax,%rsi
  80dfd6:	48 bf 36 df 80 00 00 	movabs $0x80df36,%rdi
  80dfdd:	00 00 00 
  80dfe0:	48 b8 0b de 80 00 00 	movabs $0x80de0b,%rax
  80dfe7:	00 00 00 
  80dfea:	ff d0                	callq  *%rax
    return 1;
  80dfec:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80dff1:	c9                   	leaveq 
  80dff2:	c3                   	retq   

000000000080dff3 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80dff3:	55                   	push   %rbp
  80dff4:	48 89 e5             	mov    %rsp,%rbp
  80dff7:	48 83 ec 20          	sub    $0x20,%rsp
  80dffb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80dffe:	bf 00 00 00 00       	mov    $0x0,%edi
  80e003:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  80e00a:	00 00 00 
  80e00d:	ff d0                	callq  *%rax
  80e00f:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80e012:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80e015:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e018:	89 d6                	mov    %edx,%esi
  80e01a:	89 c7                	mov    %eax,%edi
  80e01c:	48 b8 6d df 80 00 00 	movabs $0x80df6d,%rax
  80e023:	00 00 00 
  80e026:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80e028:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e02b:	89 c7                	mov    %eax,%edi
  80e02d:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  80e034:	00 00 00 
  80e037:	ff d0                	callq  *%rax
}
  80e039:	c9                   	leaveq 
  80e03a:	c3                   	retq   

000000000080e03b <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80e03b:	55                   	push   %rbp
  80e03c:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80e03f:	48 b8 31 f7 80 00 00 	movabs $0x80f731,%rax
  80e046:	00 00 00 
  80e049:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80e04b:	48 b8 6c a0 b4 00 00 	movabs $0xb4a06c,%rax
  80e052:	00 00 00 
  80e055:	0f b6 00             	movzbl (%rax),%eax
  80e058:	8d 50 01             	lea    0x1(%rax),%edx
  80e05b:	48 b8 6c a0 b4 00 00 	movabs $0xb4a06c,%rax
  80e062:	00 00 00 
  80e065:	88 10                	mov    %dl,(%rax)
  80e067:	48 b8 6c a0 b4 00 00 	movabs $0xb4a06c,%rax
  80e06e:	00 00 00 
  80e071:	0f b6 00             	movzbl (%rax),%eax
  80e074:	0f b6 c0             	movzbl %al,%eax
  80e077:	83 e0 01             	and    $0x1,%eax
  80e07a:	85 c0                	test   %eax,%eax
  80e07c:	74 0c                	je     80e08a <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80e07e:	48 b8 f3 ee 80 00 00 	movabs $0x80eef3,%rax
  80e085:	00 00 00 
  80e088:	ff d0                	callq  *%rax
  }
}
  80e08a:	5d                   	pop    %rbp
  80e08b:	c3                   	retq   

000000000080e08c <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80e08c:	55                   	push   %rbp
  80e08d:	48 89 e5             	mov    %rsp,%rbp
  80e090:	48 83 ec 20          	sub    $0x20,%rsp
  80e094:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80e098:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e09c:	8b 40 18             	mov    0x18(%rax),%eax
  80e09f:	83 f8 07             	cmp    $0x7,%eax
  80e0a2:	0f 87 37 02 00 00    	ja     80e2df <tcp_close+0x253>
  80e0a8:	89 c0                	mov    %eax,%eax
  80e0aa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80e0b1:	00 
  80e0b2:	48 b8 90 17 82 00 00 	movabs $0x821790,%rax
  80e0b9:	00 00 00 
  80e0bc:	48 01 d0             	add    %rdx,%rax
  80e0bf:	48 8b 00             	mov    (%rax),%rax
  80e0c2:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80e0c4:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80e0c8:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e0cf:	00 00 00 
  80e0d2:	48 8b 00             	mov    (%rax),%rax
  80e0d5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e0d9:	75 23                	jne    80e0fe <tcp_close+0x72>
  80e0db:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e0e2:	00 00 00 
  80e0e5:	48 8b 00             	mov    (%rax),%rax
  80e0e8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e0ec:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e0f3:	00 00 00 
  80e0f6:	48 89 10             	mov    %rdx,(%rax)
  80e0f9:	e9 94 00 00 00       	jmpq   80e192 <tcp_close+0x106>
  80e0fe:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e105:	00 00 00 
  80e108:	48 8b 10             	mov    (%rax),%rdx
  80e10b:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e112:	00 00 00 
  80e115:	48 89 10             	mov    %rdx,(%rax)
  80e118:	eb 66                	jmp    80e180 <tcp_close+0xf4>
  80e11a:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e121:	00 00 00 
  80e124:	48 8b 00             	mov    (%rax),%rax
  80e127:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e12b:	48 85 c0             	test   %rax,%rax
  80e12e:	74 32                	je     80e162 <tcp_close+0xd6>
  80e130:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e137:	00 00 00 
  80e13a:	48 8b 00             	mov    (%rax),%rax
  80e13d:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e141:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e145:	75 1b                	jne    80e162 <tcp_close+0xd6>
  80e147:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e14e:	00 00 00 
  80e151:	48 8b 00             	mov    (%rax),%rax
  80e154:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e158:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80e15c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80e160:	eb 30                	jmp    80e192 <tcp_close+0x106>
  80e162:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e169:	00 00 00 
  80e16c:	48 8b 00             	mov    (%rax),%rax
  80e16f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e173:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e17a:	00 00 00 
  80e17d:	48 89 10             	mov    %rdx,(%rax)
  80e180:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e187:	00 00 00 
  80e18a:	48 8b 00             	mov    (%rax),%rax
  80e18d:	48 85 c0             	test   %rax,%rax
  80e190:	75 88                	jne    80e11a <tcp_close+0x8e>
  80e192:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e196:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80e19d:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80e19e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1a2:	48 89 c6             	mov    %rax,%rsi
  80e1a5:	bf 02 00 00 00       	mov    $0x2,%edi
  80e1aa:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80e1b1:	00 00 00 
  80e1b4:	ff d0                	callq  *%rax
    pcb = NULL;
  80e1b6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e1bd:	00 
    break;
  80e1be:	e9 29 01 00 00       	jmpq   80e2ec <tcp_close+0x260>
  case LISTEN:
    err = ERR_OK;
  80e1c3:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80e1c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1cb:	48 89 c6             	mov    %rax,%rsi
  80e1ce:	48 bf 20 a0 b5 00 00 	movabs $0xb5a020,%rdi
  80e1d5:	00 00 00 
  80e1d8:	48 b8 bf fe 80 00 00 	movabs $0x80febf,%rax
  80e1df:	00 00 00 
  80e1e2:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80e1e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1e8:	48 89 c6             	mov    %rax,%rsi
  80e1eb:	bf 03 00 00 00       	mov    $0x3,%edi
  80e1f0:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80e1f7:	00 00 00 
  80e1fa:	ff d0                	callq  *%rax
    pcb = NULL;
  80e1fc:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e203:	00 
    break;
  80e204:	e9 e3 00 00 00       	jmpq   80e2ec <tcp_close+0x260>
  case SYN_SENT:
    err = ERR_OK;
  80e209:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e20d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e211:	48 89 c6             	mov    %rax,%rsi
  80e214:	48 bf 10 a0 b5 00 00 	movabs $0xb5a010,%rdi
  80e21b:	00 00 00 
  80e21e:	48 b8 bf fe 80 00 00 	movabs $0x80febf,%rax
  80e225:	00 00 00 
  80e228:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80e22a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e22e:	48 89 c6             	mov    %rax,%rsi
  80e231:	bf 02 00 00 00       	mov    $0x2,%edi
  80e236:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80e23d:	00 00 00 
  80e240:	ff d0                	callq  *%rax
    pcb = NULL;
  80e242:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e249:	00 
    snmp_inc_tcpattemptfails();
    break;
  80e24a:	e9 9d 00 00 00       	jmpq   80e2ec <tcp_close+0x260>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80e24f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e253:	be 01 00 00 00       	mov    $0x1,%esi
  80e258:	48 89 c7             	mov    %rax,%rdi
  80e25b:	48 b8 e6 24 81 00 00 	movabs $0x8124e6,%rax
  80e262:	00 00 00 
  80e265:	ff d0                	callq  *%rax
  80e267:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80e26a:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e26e:	75 0d                	jne    80e27d <tcp_close+0x1f1>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80e270:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e274:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80e27b:	eb 6f                	jmp    80e2ec <tcp_close+0x260>
  80e27d:	eb 6d                	jmp    80e2ec <tcp_close+0x260>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80e27f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e283:	be 01 00 00 00       	mov    $0x1,%esi
  80e288:	48 89 c7             	mov    %rax,%rdi
  80e28b:	48 b8 e6 24 81 00 00 	movabs $0x8124e6,%rax
  80e292:	00 00 00 
  80e295:	ff d0                	callq  *%rax
  80e297:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80e29a:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e29e:	75 0d                	jne    80e2ad <tcp_close+0x221>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80e2a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2a4:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80e2ab:	eb 3f                	jmp    80e2ec <tcp_close+0x260>
  80e2ad:	eb 3d                	jmp    80e2ec <tcp_close+0x260>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80e2af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2b3:	be 01 00 00 00       	mov    $0x1,%esi
  80e2b8:	48 89 c7             	mov    %rax,%rdi
  80e2bb:	48 b8 e6 24 81 00 00 	movabs $0x8124e6,%rax
  80e2c2:	00 00 00 
  80e2c5:	ff d0                	callq  *%rax
  80e2c7:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80e2ca:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e2ce:	75 0d                	jne    80e2dd <tcp_close+0x251>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80e2d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2d4:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80e2db:	eb 0f                	jmp    80e2ec <tcp_close+0x260>
  80e2dd:	eb 0d                	jmp    80e2ec <tcp_close+0x260>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80e2df:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80e2e3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e2ea:	00 
    break;
  80e2eb:	90                   	nop
  }

  if (pcb != NULL && err == ERR_OK) {
  80e2ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e2f1:	74 19                	je     80e30c <tcp_close+0x280>
  80e2f3:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e2f7:	75 13                	jne    80e30c <tcp_close+0x280>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80e2f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2fd:	48 89 c7             	mov    %rax,%rdi
  80e300:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80e307:	00 00 00 
  80e30a:	ff d0                	callq  *%rax
  }
  return err;
  80e30c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80e310:	c9                   	leaveq 
  80e311:	c3                   	retq   

000000000080e312 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80e312:	55                   	push   %rbp
  80e313:	48 89 e5             	mov    %rsp,%rbp
  80e316:	48 83 ec 50          	sub    $0x50,%rsp
  80e31a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80e31e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e322:	8b 40 18             	mov    0x18(%rax),%eax
  80e325:	83 f8 0a             	cmp    $0xa,%eax
  80e328:	75 3a                	jne    80e364 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80e32a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e32e:	48 89 c6             	mov    %rax,%rsi
  80e331:	48 bf 38 a0 b5 00 00 	movabs $0xb5a038,%rdi
  80e338:	00 00 00 
  80e33b:	48 b8 bf fe 80 00 00 	movabs $0x80febf,%rax
  80e342:	00 00 00 
  80e345:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80e347:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e34b:	48 89 c6             	mov    %rax,%rsi
  80e34e:	bf 02 00 00 00       	mov    $0x2,%edi
  80e353:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80e35a:	00 00 00 
  80e35d:	ff d0                	callq  *%rax
  80e35f:	e9 75 01 00 00       	jmpq   80e4d9 <tcp_abort+0x1c7>
  } else {
    seqno = pcb->snd_nxt;
  80e364:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e368:	8b 40 60             	mov    0x60(%rax),%eax
  80e36b:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80e36e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e372:	8b 40 30             	mov    0x30(%rax),%eax
  80e375:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80e378:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e37c:	48 85 c0             	test   %rax,%rax
  80e37f:	74 08                	je     80e389 <tcp_abort+0x77>
  80e381:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e385:	8b 00                	mov    (%rax),%eax
  80e387:	eb 05                	jmp    80e38e <tcp_abort+0x7c>
  80e389:	b8 00 00 00 00       	mov    $0x0,%eax
  80e38e:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80e391:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e395:	48 83 c0 04          	add    $0x4,%rax
  80e399:	48 85 c0             	test   %rax,%rax
  80e39c:	74 09                	je     80e3a7 <tcp_abort+0x95>
  80e39e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e3a2:	8b 40 04             	mov    0x4(%rax),%eax
  80e3a5:	eb 05                	jmp    80e3ac <tcp_abort+0x9a>
  80e3a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3ac:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80e3af:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e3b3:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80e3b7:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80e3bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e3bf:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80e3c3:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80e3c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e3cb:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80e3d2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80e3d6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e3da:	48 8b 40 20          	mov    0x20(%rax),%rax
  80e3de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e3e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e3e6:	48 89 c6             	mov    %rax,%rsi
  80e3e9:	48 bf 10 a0 b5 00 00 	movabs $0xb5a010,%rdi
  80e3f0:	00 00 00 
  80e3f3:	48 b8 bf fe 80 00 00 	movabs $0x80febf,%rax
  80e3fa:	00 00 00 
  80e3fd:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80e3ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e403:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80e40a:	48 85 c0             	test   %rax,%rax
  80e40d:	74 1a                	je     80e429 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80e40f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e413:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80e41a:	48 89 c7             	mov    %rax,%rdi
  80e41d:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80e424:	00 00 00 
  80e427:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80e429:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e42d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80e434:	48 85 c0             	test   %rax,%rax
  80e437:	74 1a                	je     80e453 <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80e439:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e43d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80e444:	48 89 c7             	mov    %rax,%rdi
  80e447:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80e44e:	00 00 00 
  80e451:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80e453:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e457:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80e45e:	48 85 c0             	test   %rax,%rax
  80e461:	74 1a                	je     80e47d <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80e463:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e467:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80e46e:	48 89 c7             	mov    %rax,%rdi
  80e471:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80e478:	00 00 00 
  80e47b:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80e47d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e481:	48 89 c6             	mov    %rax,%rsi
  80e484:	bf 02 00 00 00       	mov    $0x2,%edi
  80e489:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80e490:	00 00 00 
  80e493:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80e495:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e49a:	74 12                	je     80e4ae <tcp_abort+0x19c>
  80e49c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e4a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e4a4:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80e4a9:	48 89 d7             	mov    %rdx,%rdi
  80e4ac:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80e4ae:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80e4b3:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80e4b7:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80e4bb:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80e4bf:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80e4c2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e4c5:	45 89 c1             	mov    %r8d,%r9d
  80e4c8:	41 89 f8             	mov    %edi,%r8d
  80e4cb:	89 c7                	mov    %eax,%edi
  80e4cd:	48 b8 a6 39 81 00 00 	movabs $0x8139a6,%rax
  80e4d4:	00 00 00 
  80e4d7:	ff d0                	callq  *%rax
  }
}
  80e4d9:	c9                   	leaveq 
  80e4da:	c3                   	retq   

000000000080e4db <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80e4db:	55                   	push   %rbp
  80e4dc:	48 89 e5             	mov    %rsp,%rbp
  80e4df:	48 83 ec 30          	sub    $0x30,%rsp
  80e4e3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e4e7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e4eb:	89 d0                	mov    %edx,%eax
  80e4ed:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80e4f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e4f5:	8b 40 18             	mov    0x18(%rax),%eax
  80e4f8:	85 c0                	test   %eax,%eax
  80e4fa:	74 2a                	je     80e526 <tcp_bind+0x4b>
  80e4fc:	48 ba d0 17 82 00 00 	movabs $0x8217d0,%rdx
  80e503:	00 00 00 
  80e506:	be 05 01 00 00       	mov    $0x105,%esi
  80e50b:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80e512:	00 00 00 
  80e515:	b8 00 00 00 00       	mov    $0x0,%eax
  80e51a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80e521:	00 00 00 
  80e524:	ff d1                	callq  *%rcx

  if (port == 0) {
  80e526:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e52b:	75 10                	jne    80e53d <tcp_bind+0x62>
    port = tcp_new_port();
  80e52d:	48 b8 ee ea 80 00 00 	movabs $0x80eaee,%rax
  80e534:	00 00 00 
  80e537:	ff d0                	callq  *%rax
  80e539:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80e53d:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  80e544:	00 00 00 
  80e547:	48 8b 00             	mov    (%rax),%rax
  80e54a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e54e:	eb 58                	jmp    80e5a8 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80e550:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e554:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80e558:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e55c:	75 3e                	jne    80e59c <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80e55e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e562:	48 85 c0             	test   %rax,%rax
  80e565:	74 2b                	je     80e592 <tcp_bind+0xb7>
  80e567:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e56b:	8b 00                	mov    (%rax),%eax
  80e56d:	85 c0                	test   %eax,%eax
  80e56f:	74 21                	je     80e592 <tcp_bind+0xb7>
  80e571:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e576:	74 1a                	je     80e592 <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80e578:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e57c:	8b 00                	mov    (%rax),%eax
  80e57e:	85 c0                	test   %eax,%eax
  80e580:	74 10                	je     80e592 <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80e582:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e586:	8b 10                	mov    (%rax),%edx
  80e588:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e58c:	8b 00                	mov    (%rax),%eax
          ip_addr_isany(ipaddr) ||
  80e58e:	39 c2                	cmp    %eax,%edx
  80e590:	75 0a                	jne    80e59c <tcp_bind+0xc1>
        return ERR_USE;
  80e592:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80e597:	e9 a2 01 00 00       	jmpq   80e73e <tcp_bind+0x263>
      cpcb != NULL; cpcb = cpcb->next) {
  80e59c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5a0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e5a4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80e5a8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e5ad:	75 a1                	jne    80e550 <tcp_bind+0x75>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80e5af:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80e5b6:	00 00 00 
  80e5b9:	48 8b 00             	mov    (%rax),%rax
  80e5bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e5c0:	eb 58                	jmp    80e61a <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80e5c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5c6:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80e5ca:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e5ce:	75 3e                	jne    80e60e <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80e5d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5d4:	48 85 c0             	test   %rax,%rax
  80e5d7:	74 2b                	je     80e604 <tcp_bind+0x129>
  80e5d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5dd:	8b 00                	mov    (%rax),%eax
  80e5df:	85 c0                	test   %eax,%eax
  80e5e1:	74 21                	je     80e604 <tcp_bind+0x129>
  80e5e3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e5e8:	74 1a                	je     80e604 <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80e5ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e5ee:	8b 00                	mov    (%rax),%eax
  80e5f0:	85 c0                	test   %eax,%eax
  80e5f2:	74 10                	je     80e604 <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80e5f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5f8:	8b 10                	mov    (%rax),%edx
  80e5fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e5fe:	8b 00                	mov    (%rax),%eax
          ip_addr_isany(ipaddr) ||
  80e600:	39 c2                	cmp    %eax,%edx
  80e602:	75 0a                	jne    80e60e <tcp_bind+0x133>
        return ERR_USE;
  80e604:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80e609:	e9 30 01 00 00       	jmpq   80e73e <tcp_bind+0x263>
      cpcb != NULL; cpcb = cpcb->next) {
  80e60e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e612:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e616:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  for(cpcb = tcp_active_pcbs;
  80e61a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e61f:	75 a1                	jne    80e5c2 <tcp_bind+0xe7>
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80e621:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e628:	00 00 00 
  80e62b:	48 8b 00             	mov    (%rax),%rax
  80e62e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e632:	eb 58                	jmp    80e68c <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80e634:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e638:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80e63c:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e640:	75 3e                	jne    80e680 <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80e642:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e646:	48 85 c0             	test   %rax,%rax
  80e649:	74 2b                	je     80e676 <tcp_bind+0x19b>
  80e64b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e64f:	8b 00                	mov    (%rax),%eax
  80e651:	85 c0                	test   %eax,%eax
  80e653:	74 21                	je     80e676 <tcp_bind+0x19b>
  80e655:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e65a:	74 1a                	je     80e676 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80e65c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e660:	8b 00                	mov    (%rax),%eax
  80e662:	85 c0                	test   %eax,%eax
  80e664:	74 10                	je     80e676 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80e666:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e66a:	8b 10                	mov    (%rax),%edx
  80e66c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e670:	8b 00                	mov    (%rax),%eax
          ip_addr_isany(ipaddr) ||
  80e672:	39 c2                	cmp    %eax,%edx
  80e674:	75 0a                	jne    80e680 <tcp_bind+0x1a5>
        return ERR_USE;
  80e676:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80e67b:	e9 be 00 00 00       	jmpq   80e73e <tcp_bind+0x263>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80e680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e684:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e688:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e68c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e691:	75 a1                	jne    80e634 <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80e693:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80e69a:	00 00 00 
  80e69d:	48 8b 00             	mov    (%rax),%rax
  80e6a0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e6a4:	eb 31                	jmp    80e6d7 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80e6a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e6aa:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80e6ae:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e6b2:	75 17                	jne    80e6cb <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80e6b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e6b8:	8b 10                	mov    (%rax),%edx
  80e6ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e6be:	8b 00                	mov    (%rax),%eax
  80e6c0:	39 c2                	cmp    %eax,%edx
  80e6c2:	75 07                	jne    80e6cb <tcp_bind+0x1f0>
        return ERR_USE;
  80e6c4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80e6c9:	eb 73                	jmp    80e73e <tcp_bind+0x263>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80e6cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e6cf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e6d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e6d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e6dc:	75 c8                	jne    80e6a6 <tcp_bind+0x1cb>
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80e6de:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e6e3:	74 16                	je     80e6fb <tcp_bind+0x220>
  80e6e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e6e9:	8b 00                	mov    (%rax),%eax
  80e6eb:	85 c0                	test   %eax,%eax
  80e6ed:	74 0c                	je     80e6fb <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80e6ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6f3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e6f7:	8b 12                	mov    (%rdx),%edx
  80e6f9:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80e6fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6ff:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80e703:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80e707:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e70e:	00 00 00 
  80e711:	48 8b 10             	mov    (%rax),%rdx
  80e714:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e718:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80e71c:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e723:	00 00 00 
  80e726:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e72a:	48 89 10             	mov    %rdx,(%rax)
  80e72d:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  80e734:	00 00 00 
  80e737:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80e739:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e73e:	c9                   	leaveq 
  80e73f:	c3                   	retq   

000000000080e740 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80e740:	55                   	push   %rbp
  80e741:	48 89 e5             	mov    %rsp,%rbp
  80e744:	48 83 ec 18          	sub    $0x18,%rsp
  80e748:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80e74c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80e750:	89 d0                	mov    %edx,%eax
  80e752:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80e755:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80e75a:	c9                   	leaveq 
  80e75b:	c3                   	retq   

000000000080e75c <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80e75c:	55                   	push   %rbp
  80e75d:	48 89 e5             	mov    %rsp,%rbp
  80e760:	48 83 ec 20          	sub    $0x20,%rsp
  80e764:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e768:	89 f0                	mov    %esi,%eax
  80e76a:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80e76d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e771:	8b 40 18             	mov    0x18(%rax),%eax
  80e774:	85 c0                	test   %eax,%eax
  80e776:	74 2a                	je     80e7a2 <tcp_listen_with_backlog+0x46>
  80e778:	48 ba 10 18 82 00 00 	movabs $0x821810,%rdx
  80e77f:	00 00 00 
  80e782:	be 60 01 00 00       	mov    $0x160,%esi
  80e787:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80e78e:	00 00 00 
  80e791:	b8 00 00 00 00       	mov    $0x0,%eax
  80e796:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80e79d:	00 00 00 
  80e7a0:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80e7a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7a6:	8b 40 18             	mov    0x18(%rax),%eax
  80e7a9:	83 f8 01             	cmp    $0x1,%eax
  80e7ac:	75 09                	jne    80e7b7 <tcp_listen_with_backlog+0x5b>
    return pcb;
  80e7ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7b2:	e9 e6 01 00 00       	jmpq   80e99d <tcp_listen_with_backlog+0x241>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80e7b7:	bf 03 00 00 00       	mov    $0x3,%edi
  80e7bc:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80e7c3:	00 00 00 
  80e7c6:	ff d0                	callq  *%rax
  80e7c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (lpcb == NULL) {
  80e7cc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e7d1:	75 0a                	jne    80e7dd <tcp_listen_with_backlog+0x81>
    return NULL;
  80e7d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e7d8:	e9 c0 01 00 00       	jmpq   80e99d <tcp_listen_with_backlog+0x241>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80e7dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7e1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80e7e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e7e9:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80e7ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7f1:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80e7f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e7f9:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80e7fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e801:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80e808:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e80c:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80e810:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e814:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80e818:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e81c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80e820:	83 c8 02             	or     $0x2,%eax
  80e823:	89 c2                	mov    %eax,%edx
  80e825:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e829:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80e82d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e831:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80e835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e839:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80e83c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e840:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80e844:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e848:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80e84b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e84f:	48 85 c0             	test   %rax,%rax
  80e852:	74 08                	je     80e85c <tcp_listen_with_backlog+0x100>
  80e854:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e858:	8b 00                	mov    (%rax),%eax
  80e85a:	eb 05                	jmp    80e861 <tcp_listen_with_backlog+0x105>
  80e85c:	b8 00 00 00 00       	mov    $0x0,%eax
  80e861:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e865:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80e867:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e86e:	00 00 00 
  80e871:	48 8b 00             	mov    (%rax),%rax
  80e874:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e878:	75 23                	jne    80e89d <tcp_listen_with_backlog+0x141>
  80e87a:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e881:	00 00 00 
  80e884:	48 8b 00             	mov    (%rax),%rax
  80e887:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e88b:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e892:	00 00 00 
  80e895:	48 89 10             	mov    %rdx,(%rax)
  80e898:	e9 94 00 00 00       	jmpq   80e931 <tcp_listen_with_backlog+0x1d5>
  80e89d:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80e8a4:	00 00 00 
  80e8a7:	48 8b 10             	mov    (%rax),%rdx
  80e8aa:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e8b1:	00 00 00 
  80e8b4:	48 89 10             	mov    %rdx,(%rax)
  80e8b7:	eb 66                	jmp    80e91f <tcp_listen_with_backlog+0x1c3>
  80e8b9:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e8c0:	00 00 00 
  80e8c3:	48 8b 00             	mov    (%rax),%rax
  80e8c6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e8ca:	48 85 c0             	test   %rax,%rax
  80e8cd:	74 32                	je     80e901 <tcp_listen_with_backlog+0x1a5>
  80e8cf:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e8d6:	00 00 00 
  80e8d9:	48 8b 00             	mov    (%rax),%rax
  80e8dc:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e8e0:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e8e4:	75 1b                	jne    80e901 <tcp_listen_with_backlog+0x1a5>
  80e8e6:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e8ed:	00 00 00 
  80e8f0:	48 8b 00             	mov    (%rax),%rax
  80e8f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e8f7:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80e8fb:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80e8ff:	eb 30                	jmp    80e931 <tcp_listen_with_backlog+0x1d5>
  80e901:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e908:	00 00 00 
  80e90b:	48 8b 00             	mov    (%rax),%rax
  80e90e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e912:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e919:	00 00 00 
  80e91c:	48 89 10             	mov    %rdx,(%rax)
  80e91f:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80e926:	00 00 00 
  80e929:	48 8b 00             	mov    (%rax),%rax
  80e92c:	48 85 c0             	test   %rax,%rax
  80e92f:	75 88                	jne    80e8b9 <tcp_listen_with_backlog+0x15d>
  80e931:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e935:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80e93c:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80e93d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e941:	48 89 c6             	mov    %rax,%rsi
  80e944:	bf 02 00 00 00       	mov    $0x2,%edi
  80e949:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80e950:	00 00 00 
  80e953:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80e955:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e959:	48 b9 40 e7 80 00 00 	movabs $0x80e740,%rcx
  80e960:	00 00 00 
  80e963:	48 89 48 30          	mov    %rcx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80e967:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  80e96e:	00 00 00 
  80e971:	48 8b 10             	mov    (%rax),%rdx
  80e974:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e978:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80e97c:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  80e983:	00 00 00 
  80e986:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e98a:	48 89 10             	mov    %rdx,(%rax)
  80e98d:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  80e994:	00 00 00 
  80e997:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80e999:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80e99d:	c9                   	leaveq 
  80e99e:	c3                   	retq   

000000000080e99f <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80e99f:	55                   	push   %rbp
  80e9a0:	48 89 e5             	mov    %rsp,%rbp
  80e9a3:	48 83 ec 10          	sub    $0x10,%rsp
  80e9a7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80e9ab:	89 f0                	mov    %esi,%eax
  80e9ad:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80e9b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9b5:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80e9b9:	0f b7 d0             	movzwl %ax,%edx
  80e9bc:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e9c0:	01 d0                	add    %edx,%eax
  80e9c2:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80e9c7:	76 16                	jbe    80e9df <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80e9c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9cd:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80e9d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9d7:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80e9dd:	eb 3b                	jmp    80ea1a <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80e9df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9e3:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80e9e7:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e9eb:	01 c2                	add    %eax,%edx
  80e9ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9f1:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80e9f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9f9:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80e9fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea01:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ea05:	66 39 c2             	cmp    %ax,%dx
  80ea08:	72 10                	jb     80ea1a <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80ea0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea0e:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80ea12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea16:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80ea1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea1e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ea22:	0f b6 c0             	movzbl %al,%eax
  80ea25:	83 e0 01             	and    $0x1,%eax
  80ea28:	85 c0                	test   %eax,%eax
  80ea2a:	75 77                	jne    80eaa3 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80ea2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea30:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ea34:	0f b6 c0             	movzbl %al,%eax
  80ea37:	83 e0 02             	and    $0x2,%eax
  if (!(pcb->flags & TF_ACK_DELAY) &&
  80ea3a:	85 c0                	test   %eax,%eax
  80ea3c:	75 65                	jne    80eaa3 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80ea3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea42:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ea46:	0f b6 c0             	movzbl %al,%eax
  80ea49:	83 e0 01             	and    $0x1,%eax
  80ea4c:	85 c0                	test   %eax,%eax
  80ea4e:	74 3d                	je     80ea8d <tcp_recved+0xee>
  80ea50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea54:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ea58:	83 e0 fe             	and    $0xfffffffe,%eax
  80ea5b:	89 c2                	mov    %eax,%edx
  80ea5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea61:	88 50 2c             	mov    %dl,0x2c(%rax)
  80ea64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea68:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ea6c:	83 c8 02             	or     $0x2,%eax
  80ea6f:	89 c2                	mov    %eax,%edx
  80ea71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea75:	88 50 2c             	mov    %dl,0x2c(%rax)
  80ea78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea7c:	48 89 c7             	mov    %rax,%rdi
  80ea7f:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80ea86:	00 00 00 
  80ea89:	ff d0                	callq  *%rax
  80ea8b:	eb 5f                	jmp    80eaec <tcp_recved+0x14d>
  80ea8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea91:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ea95:	83 c8 01             	or     $0x1,%eax
  80ea98:	89 c2                	mov    %eax,%edx
  80ea9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea9e:	88 50 2c             	mov    %dl,0x2c(%rax)
  80eaa1:	eb 49                	jmp    80eaec <tcp_recved+0x14d>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80eaa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eaa7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80eaab:	0f b6 c0             	movzbl %al,%eax
  80eaae:	83 e0 01             	and    $0x1,%eax
  80eab1:	85 c0                	test   %eax,%eax
  80eab3:	74 37                	je     80eaec <tcp_recved+0x14d>
  80eab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eab9:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80eabd:	66 3d df 2e          	cmp    $0x2edf,%ax
  80eac1:	76 29                	jbe    80eaec <tcp_recved+0x14d>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80eac3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eac7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80eacb:	83 c8 02             	or     $0x2,%eax
  80eace:	89 c2                	mov    %eax,%edx
  80ead0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ead4:	88 50 2c             	mov    %dl,0x2c(%rax)
  80ead7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eadb:	48 89 c7             	mov    %rax,%rdi
  80eade:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80eae5:	00 00 00 
  80eae8:	ff d0                	callq  *%rax
  80eaea:	eb 00                	jmp    80eaec <tcp_recved+0x14d>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80eaec:	c9                   	leaveq 
  80eaed:	c3                   	retq   

000000000080eaee <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80eaee:	55                   	push   %rbp
  80eaef:	48 89 e5             	mov    %rsp,%rbp
  80eaf2:	48 83 ec 10          	sub    $0x10,%rsp
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80eaf6:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80eafd:	00 00 00 
  80eb00:	0f b7 00             	movzwl (%rax),%eax
  80eb03:	8d 50 01             	lea    0x1(%rax),%edx
  80eb06:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80eb0d:	00 00 00 
  80eb10:	66 89 10             	mov    %dx,(%rax)
  80eb13:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80eb1a:	00 00 00 
  80eb1d:	0f b7 00             	movzwl (%rax),%eax
  80eb20:	66 85 c0             	test   %ax,%ax
  80eb23:	79 0f                	jns    80eb34 <tcp_new_port+0x46>
    port = TCP_LOCAL_PORT_RANGE_START;
  80eb25:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80eb2c:	00 00 00 
  80eb2f:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80eb34:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80eb3b:	00 00 00 
  80eb3e:	48 8b 00             	mov    (%rax),%rax
  80eb41:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb45:	eb 28                	jmp    80eb6f <tcp_new_port+0x81>
    if (pcb->local_port == port) {
  80eb47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb4b:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80eb4f:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80eb56:	00 00 00 
  80eb59:	0f b7 00             	movzwl (%rax),%eax
  80eb5c:	66 39 c2             	cmp    %ax,%dx
  80eb5f:	75 02                	jne    80eb63 <tcp_new_port+0x75>
      goto again;
  80eb61:	eb 93                	jmp    80eaf6 <tcp_new_port+0x8>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80eb63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb67:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eb6b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb6f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80eb74:	75 d1                	jne    80eb47 <tcp_new_port+0x59>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80eb76:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80eb7d:	00 00 00 
  80eb80:	48 8b 00             	mov    (%rax),%rax
  80eb83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb87:	eb 2b                	jmp    80ebb4 <tcp_new_port+0xc6>
    if (pcb->local_port == port) {
  80eb89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb8d:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80eb91:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80eb98:	00 00 00 
  80eb9b:	0f b7 00             	movzwl (%rax),%eax
  80eb9e:	66 39 c2             	cmp    %ax,%dx
  80eba1:	75 05                	jne    80eba8 <tcp_new_port+0xba>
      goto again;
  80eba3:	e9 4e ff ff ff       	jmpq   80eaf6 <tcp_new_port+0x8>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80eba8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebac:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ebb0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ebb4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ebb9:	75 ce                	jne    80eb89 <tcp_new_port+0x9b>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80ebbb:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  80ebc2:	00 00 00 
  80ebc5:	48 8b 00             	mov    (%rax),%rax
  80ebc8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ebcc:	eb 2b                	jmp    80ebf9 <tcp_new_port+0x10b>
    if (pcb->local_port == port) {
  80ebce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebd2:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80ebd6:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80ebdd:	00 00 00 
  80ebe0:	0f b7 00             	movzwl (%rax),%eax
  80ebe3:	66 39 c2             	cmp    %ax,%dx
  80ebe6:	75 05                	jne    80ebed <tcp_new_port+0xff>
      goto again;
  80ebe8:	e9 09 ff ff ff       	jmpq   80eaf6 <tcp_new_port+0x8>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80ebed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebf1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ebf5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ebf9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ebfe:	75 ce                	jne    80ebce <tcp_new_port+0xe0>
    }
  }
  return port;
  80ec00:	48 b8 f0 71 82 00 00 	movabs $0x8271f0,%rax
  80ec07:	00 00 00 
  80ec0a:	0f b7 00             	movzwl (%rax),%eax
}
  80ec0d:	c9                   	leaveq 
  80ec0e:	c3                   	retq   

000000000080ec0f <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80ec0f:	55                   	push   %rbp
  80ec10:	48 89 e5             	mov    %rsp,%rbp
  80ec13:	48 83 ec 30          	sub    $0x30,%rsp
  80ec17:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80ec1b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80ec1f:	89 d0                	mov    %edx,%eax
  80ec21:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80ec25:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80ec29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec2d:	8b 40 18             	mov    0x18(%rax),%eax
  80ec30:	85 c0                	test   %eax,%eax
  80ec32:	74 2a                	je     80ec5e <tcp_connect+0x4f>
  80ec34:	48 ba 38 18 82 00 00 	movabs $0x821838,%rdx
  80ec3b:	00 00 00 
  80ec3e:	be ec 01 00 00       	mov    $0x1ec,%esi
  80ec43:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80ec4a:	00 00 00 
  80ec4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ec52:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ec59:	00 00 00 
  80ec5c:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80ec5e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ec63:	74 28                	je     80ec8d <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80ec65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec69:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ec6d:	8b 12                	mov    (%rdx),%edx
  80ec6f:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80ec72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec76:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80ec7a:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80ec7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec82:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ec86:	66 85 c0             	test   %ax,%ax
  80ec89:	75 22                	jne    80ecad <tcp_connect+0x9e>
  80ec8b:	eb 0a                	jmp    80ec97 <tcp_connect+0x88>
    return ERR_VAL;
  80ec8d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80ec92:	e9 5a 02 00 00       	jmpq   80eef1 <tcp_connect+0x2e2>
    pcb->local_port = tcp_new_port();
  80ec97:	48 b8 ee ea 80 00 00 	movabs $0x80eaee,%rax
  80ec9e:	00 00 00 
  80eca1:	ff d0                	callq  *%rax
  80eca3:	89 c2                	mov    %eax,%edx
  80eca5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eca9:	66 89 50 28          	mov    %dx,0x28(%rax)
  }
  iss = tcp_next_iss();
  80ecad:	48 b8 bc 00 81 00 00 	movabs $0x8100bc,%rax
  80ecb4:	00 00 00 
  80ecb7:	ff d0                	callq  *%rax
  80ecb9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80ecbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecc0:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80ecc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eccb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80ecce:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80ecd1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ecd4:	8d 50 ff             	lea    -0x1(%rax),%edx
  80ecd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecdb:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80ecde:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ece1:	8d 50 ff             	lea    -0x1(%rax),%edx
  80ece4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ece8:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80eceb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecef:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80ecf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecf9:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80ecff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed03:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80ed09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed0d:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80ed13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed17:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ed1b:	0f b7 c0             	movzwl %ax,%eax
  80ed1e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ed22:	48 89 d6             	mov    %rdx,%rsi
  80ed25:	89 c7                	mov    %eax,%edi
  80ed27:	48 b8 f4 00 81 00 00 	movabs $0x8100f4,%rax
  80ed2e:	00 00 00 
  80ed31:	ff d0                	callq  *%rax
  80ed33:	89 c2                	mov    %eax,%edx
  80ed35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed39:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80ed3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed41:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80ed47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed4b:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80ed4f:	89 d0                	mov    %edx,%eax
  80ed51:	c1 e0 02             	shl    $0x2,%eax
  80ed54:	01 d0                	add    %edx,%eax
  80ed56:	01 c0                	add    %eax,%eax
  80ed58:	89 c2                	mov    %eax,%edx
  80ed5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed5e:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80ed62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed66:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80ed6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed71:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80ed75:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80ed7c:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80ed83:	00 00 00 
  80ed86:	48 8b 00             	mov    (%rax),%rax
  80ed89:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ed8d:	75 23                	jne    80edb2 <tcp_connect+0x1a3>
  80ed8f:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80ed96:	00 00 00 
  80ed99:	48 8b 00             	mov    (%rax),%rax
  80ed9c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80eda0:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80eda7:	00 00 00 
  80edaa:	48 89 10             	mov    %rdx,(%rax)
  80edad:	e9 94 00 00 00       	jmpq   80ee46 <tcp_connect+0x237>
  80edb2:	48 b8 30 a0 b5 00 00 	movabs $0xb5a030,%rax
  80edb9:	00 00 00 
  80edbc:	48 8b 10             	mov    (%rax),%rdx
  80edbf:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80edc6:	00 00 00 
  80edc9:	48 89 10             	mov    %rdx,(%rax)
  80edcc:	eb 66                	jmp    80ee34 <tcp_connect+0x225>
  80edce:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80edd5:	00 00 00 
  80edd8:	48 8b 00             	mov    (%rax),%rax
  80eddb:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eddf:	48 85 c0             	test   %rax,%rax
  80ede2:	74 32                	je     80ee16 <tcp_connect+0x207>
  80ede4:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80edeb:	00 00 00 
  80edee:	48 8b 00             	mov    (%rax),%rax
  80edf1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80edf5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80edf9:	75 1b                	jne    80ee16 <tcp_connect+0x207>
  80edfb:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ee02:	00 00 00 
  80ee05:	48 8b 00             	mov    (%rax),%rax
  80ee08:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ee0c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ee10:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ee14:	eb 30                	jmp    80ee46 <tcp_connect+0x237>
  80ee16:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ee1d:	00 00 00 
  80ee20:	48 8b 00             	mov    (%rax),%rax
  80ee23:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ee27:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ee2e:	00 00 00 
  80ee31:	48 89 10             	mov    %rdx,(%rax)
  80ee34:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ee3b:	00 00 00 
  80ee3e:	48 8b 00             	mov    (%rax),%rax
  80ee41:	48 85 c0             	test   %rax,%rax
  80ee44:	75 88                	jne    80edce <tcp_connect+0x1bf>
  80ee46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee4a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ee51:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80ee52:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80ee59:	00 00 00 
  80ee5c:	48 8b 10             	mov    (%rax),%rdx
  80ee5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee63:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ee67:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80ee6e:	00 00 00 
  80ee71:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ee75:	48 89 10             	mov    %rdx,(%rax)
  80ee78:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  80ee7f:	00 00 00 
  80ee82:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80ee84:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80ee89:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  80ee90:	00 00 00 
  80ee93:	ff d0                	callq  *%rax
  80ee95:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80ee98:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80ee9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eea0:	48 83 ec 08          	sub    $0x8,%rsp
  80eea4:	6a 04                	pushq  $0x4
  80eea6:	49 89 d1             	mov    %rdx,%r9
  80eea9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80eeaf:	b9 02 00 00 00       	mov    $0x2,%ecx
  80eeb4:	ba 00 00 00 00       	mov    $0x0,%edx
  80eeb9:	be 00 00 00 00       	mov    $0x0,%esi
  80eebe:	48 89 c7             	mov    %rax,%rdi
  80eec1:	48 b8 c9 25 81 00 00 	movabs $0x8125c9,%rax
  80eec8:	00 00 00 
  80eecb:	ff d0                	callq  *%rax
  80eecd:	48 83 c4 10          	add    $0x10,%rsp
  80eed1:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80eed4:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80eed8:	75 13                	jne    80eeed <tcp_connect+0x2de>
    tcp_output(pcb);
  80eeda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eede:	48 89 c7             	mov    %rax,%rdi
  80eee1:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80eee8:	00 00 00 
  80eeeb:	ff d0                	callq  *%rax
  }
  return ret;
  80eeed:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80eef1:	c9                   	leaveq 
  80eef2:	c3                   	retq   

000000000080eef3 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80eef3:	55                   	push   %rbp
  80eef4:	48 89 e5             	mov    %rsp,%rbp
  80eef7:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80eefb:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80eeff:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80ef06:	00 00 00 
  80ef09:	8b 00                	mov    (%rax),%eax
  80ef0b:	8d 50 01             	lea    0x1(%rax),%edx
  80ef0e:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80ef15:	00 00 00 
  80ef18:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80ef1a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80ef21:	00 
  pcb = tcp_active_pcbs;
  80ef22:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80ef29:	00 00 00 
  80ef2c:	48 8b 00             	mov    (%rax),%rax
  80ef2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80ef33:	e9 60 06 00 00       	jmpq   80f598 <tcp_slowtmr+0x6a5>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80ef38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef3c:	8b 40 18             	mov    0x18(%rax),%eax
  80ef3f:	85 c0                	test   %eax,%eax
  80ef41:	75 2a                	jne    80ef6d <tcp_slowtmr+0x7a>
  80ef43:	48 ba 70 18 82 00 00 	movabs $0x821870,%rdx
  80ef4a:	00 00 00 
  80ef4d:	be 36 02 00 00       	mov    $0x236,%esi
  80ef52:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80ef59:	00 00 00 
  80ef5c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef61:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ef68:	00 00 00 
  80ef6b:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80ef6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef71:	8b 40 18             	mov    0x18(%rax),%eax
  80ef74:	83 f8 01             	cmp    $0x1,%eax
  80ef77:	75 2a                	jne    80efa3 <tcp_slowtmr+0xb0>
  80ef79:	48 ba a0 18 82 00 00 	movabs $0x8218a0,%rdx
  80ef80:	00 00 00 
  80ef83:	be 37 02 00 00       	mov    $0x237,%esi
  80ef88:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80ef8f:	00 00 00 
  80ef92:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef97:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80ef9e:	00 00 00 
  80efa1:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80efa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80efa7:	8b 40 18             	mov    0x18(%rax),%eax
  80efaa:	83 f8 0a             	cmp    $0xa,%eax
  80efad:	75 2a                	jne    80efd9 <tcp_slowtmr+0xe6>
  80efaf:	48 ba d0 18 82 00 00 	movabs $0x8218d0,%rdx
  80efb6:	00 00 00 
  80efb9:	be 38 02 00 00       	mov    $0x238,%esi
  80efbe:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80efc5:	00 00 00 
  80efc8:	b8 00 00 00 00       	mov    $0x0,%eax
  80efcd:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80efd4:	00 00 00 
  80efd7:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80efd9:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80efdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80efe1:	8b 40 18             	mov    0x18(%rax),%eax
  80efe4:	83 f8 02             	cmp    $0x2,%eax
  80efe7:	75 15                	jne    80effe <tcp_slowtmr+0x10b>
  80efe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80efed:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80eff1:	3c 06                	cmp    $0x6,%al
  80eff3:	75 09                	jne    80effe <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80eff5:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80eff9:	e9 e6 01 00 00       	jmpq   80f1e4 <tcp_slowtmr+0x2f1>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80effe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f002:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f006:	3c 0c                	cmp    $0xc,%al
  80f008:	75 09                	jne    80f013 <tcp_slowtmr+0x120>
      ++pcb_remove;
  80f00a:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80f00e:	e9 d1 01 00 00       	jmpq   80f1e4 <tcp_slowtmr+0x2f1>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80f013:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f017:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f01e:	84 c0                	test   %al,%al
  80f020:	0f 84 9a 00 00 00    	je     80f0c0 <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80f026:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f02a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80f030:	8d 50 01             	lea    0x1(%rax),%edx
  80f033:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f037:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80f03d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f041:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80f047:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f04b:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f052:	0f b6 c0             	movzbl %al,%eax
  80f055:	83 e8 01             	sub    $0x1,%eax
  80f058:	48 ba 85 17 82 00 00 	movabs $0x821785,%rdx
  80f05f:	00 00 00 
  80f062:	48 98                	cltq   
  80f064:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f068:	0f b6 c0             	movzbl %al,%eax
  80f06b:	39 c1                	cmp    %eax,%ecx
  80f06d:	0f 82 71 01 00 00    	jb     80f1e4 <tcp_slowtmr+0x2f1>
          pcb->persist_cnt = 0;
  80f073:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f077:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80f07e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80f081:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f085:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f08c:	3c 06                	cmp    $0x6,%al
  80f08e:	77 18                	ja     80f0a8 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80f090:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f094:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f09b:	8d 50 01             	lea    0x1(%rax),%edx
  80f09e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0a2:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80f0a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0ac:	48 89 c7             	mov    %rax,%rdi
  80f0af:	48 b8 9c 3f 81 00 00 	movabs $0x813f9c,%rax
  80f0b6:	00 00 00 
  80f0b9:	ff d0                	callq  *%rax
  80f0bb:	e9 24 01 00 00       	jmpq   80f1e4 <tcp_slowtmr+0x2f1>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80f0c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0c4:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f0c8:	66 85 c0             	test   %ax,%ax
  80f0cb:	78 15                	js     80f0e2 <tcp_slowtmr+0x1ef>
          ++pcb->rtime;
  80f0cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0d1:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f0d5:	83 c0 01             	add    $0x1,%eax
  80f0d8:	89 c2                	mov    %eax,%edx
  80f0da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0de:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80f0e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0e6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f0ed:	48 85 c0             	test   %rax,%rax
  80f0f0:	0f 84 ee 00 00 00    	je     80f1e4 <tcp_slowtmr+0x2f1>
  80f0f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0fa:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80f0fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f102:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80f106:	66 39 c2             	cmp    %ax,%dx
  80f109:	0f 8c d5 00 00 00    	jl     80f1e4 <tcp_slowtmr+0x2f1>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80f10f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f113:	8b 40 18             	mov    0x18(%rax),%eax
  80f116:	83 f8 02             	cmp    $0x2,%eax
  80f119:	74 49                	je     80f164 <tcp_slowtmr+0x271>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80f11b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f11f:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80f123:	66 c1 f8 03          	sar    $0x3,%ax
  80f127:	0f bf d0             	movswl %ax,%edx
  80f12a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f12e:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80f132:	98                   	cwtl   
  80f133:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80f136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f13a:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f13e:	0f b6 c0             	movzbl %al,%eax
  80f141:	48 ba 78 17 82 00 00 	movabs $0x821778,%rdx
  80f148:	00 00 00 
  80f14b:	48 98                	cltq   
  80f14d:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f151:	0f b6 c0             	movzbl %al,%eax
  80f154:	89 c1                	mov    %eax,%ecx
  80f156:	d3 e6                	shl    %cl,%esi
  80f158:	89 f0                	mov    %esi,%eax
  80f15a:	89 c2                	mov    %eax,%edx
  80f15c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f160:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80f164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f168:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80f16e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f172:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80f176:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f17a:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80f17e:	66 39 c2             	cmp    %ax,%dx
  80f181:	0f 46 c2             	cmovbe %edx,%eax
  80f184:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80f188:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80f18c:	66 d1 e8             	shr    %ax
  80f18f:	89 c2                	mov    %eax,%edx
  80f191:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f195:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80f199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f19d:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80f1a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1a5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f1a9:	66 39 c2             	cmp    %ax,%dx
  80f1ac:	73 13                	jae    80f1c1 <tcp_slowtmr+0x2ce>
            pcb->ssthresh = pcb->mss * 2;
  80f1ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1b2:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f1b6:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80f1b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1bd:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80f1c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1c5:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f1c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1cd:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80f1d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1d5:	48 89 c7             	mov    %rax,%rdi
  80f1d8:	48 b8 c0 3b 81 00 00 	movabs $0x813bc0,%rax
  80f1df:	00 00 00 
  80f1e2:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80f1e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1e8:	8b 40 18             	mov    0x18(%rax),%eax
  80f1eb:	83 f8 06             	cmp    $0x6,%eax
  80f1ee:	75 20                	jne    80f210 <tcp_slowtmr+0x31d>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80f1f0:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f1f7:	00 00 00 
  80f1fa:	8b 10                	mov    (%rax),%edx
  80f1fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f200:	8b 40 38             	mov    0x38(%rax),%eax
  80f203:	29 c2                	sub    %eax,%edx
  80f205:	89 d0                	mov    %edx,%eax
  80f207:	83 f8 28             	cmp    $0x28,%eax
  80f20a:	76 04                	jbe    80f210 <tcp_slowtmr+0x31d>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80f20c:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80f210:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f214:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f218:	0f b7 c0             	movzwl %ax,%eax
  80f21b:	83 e0 08             	and    $0x8,%eax
  80f21e:	85 c0                	test   %eax,%eax
  80f220:	0f 84 01 01 00 00    	je     80f327 <tcp_slowtmr+0x434>
       ((pcb->state == ESTABLISHED) || 
  80f226:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f22a:	8b 40 18             	mov    0x18(%rax),%eax
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80f22d:	83 f8 04             	cmp    $0x4,%eax
  80f230:	74 10                	je     80f242 <tcp_slowtmr+0x34f>
        (pcb->state == CLOSE_WAIT))) {
  80f232:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f236:	8b 40 18             	mov    0x18(%rax),%eax
       ((pcb->state == ESTABLISHED) || 
  80f239:	83 f8 07             	cmp    $0x7,%eax
  80f23c:	0f 85 e5 00 00 00    	jne    80f327 <tcp_slowtmr+0x434>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f242:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f249:	00 00 00 
  80f24c:	8b 10                	mov    (%rax),%edx
  80f24e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f252:	8b 40 38             	mov    0x38(%rax),%eax
  80f255:	29 c2                	sub    %eax,%edx
  80f257:	89 d0                	mov    %edx,%eax
  80f259:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80f25b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f25f:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80f265:	89 c0                	mov    %eax,%eax
  80f267:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80f26d:	48 c1 e8 02          	shr    $0x2,%rax
  80f271:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80f278:	9b c4 20 
  80f27b:	48 f7 e2             	mul    %rdx
  80f27e:	48 89 d0             	mov    %rdx,%rax
  80f281:	48 c1 e8 04          	shr    $0x4,%rax
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f285:	48 39 c1             	cmp    %rax,%rcx
  80f288:	76 18                	jbe    80f2a2 <tcp_slowtmr+0x3af>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80f28a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f28e:	48 89 c7             	mov    %rax,%rdi
  80f291:	48 b8 12 e3 80 00 00 	movabs $0x80e312,%rax
  80f298:	00 00 00 
  80f29b:	ff d0                	callq  *%rax
  80f29d:	e9 85 00 00 00       	jmpq   80f327 <tcp_slowtmr+0x434>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f2a2:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f2a9:	00 00 00 
  80f2ac:	8b 10                	mov    (%rax),%edx
  80f2ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2b2:	8b 40 38             	mov    0x38(%rax),%eax
  80f2b5:	29 c2                	sub    %eax,%edx
  80f2b7:	89 d0                	mov    %edx,%eax
  80f2b9:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80f2bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2bf:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80f2c5:	89 c2                	mov    %eax,%edx
  80f2c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2cb:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80f2d2:	0f b6 c0             	movzbl %al,%eax
  80f2d5:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80f2dc:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80f2df:	48 c1 e8 02          	shr    $0x2,%rax
  80f2e3:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80f2ea:	9b c4 20 
  80f2ed:	48 f7 e2             	mul    %rdx
  80f2f0:	48 89 d0             	mov    %rdx,%rax
  80f2f3:	48 c1 e8 04          	shr    $0x4,%rax
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f2f7:	48 39 c1             	cmp    %rax,%rcx
  80f2fa:	76 2b                	jbe    80f327 <tcp_slowtmr+0x434>
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80f2fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f300:	48 89 c7             	mov    %rax,%rdi
  80f303:	48 b8 67 3d 81 00 00 	movabs $0x813d67,%rax
  80f30a:	00 00 00 
  80f30d:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80f30f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f313:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80f31a:	8d 50 01             	lea    0x1(%rax),%edx
  80f31d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f321:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80f327:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f32b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f332:	48 85 c0             	test   %rax,%rax
  80f335:	74 57                	je     80f38e <tcp_slowtmr+0x49b>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80f337:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f33e:	00 00 00 
  80f341:	8b 10                	mov    (%rax),%edx
  80f343:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f347:	8b 40 38             	mov    0x38(%rax),%eax
  80f34a:	89 d1                	mov    %edx,%ecx
  80f34c:	29 c1                	sub    %eax,%ecx
  80f34e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f352:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80f356:	0f bf d0             	movswl %ax,%edx
  80f359:	89 d0                	mov    %edx,%eax
  80f35b:	01 c0                	add    %eax,%eax
  80f35d:	01 d0                	add    %edx,%eax
  80f35f:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  80f361:	39 c1                	cmp    %eax,%ecx
  80f363:	72 29                	jb     80f38e <tcp_slowtmr+0x49b>
      tcp_segs_free(pcb->ooseq);
  80f365:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f369:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f370:	48 89 c7             	mov    %rax,%rdi
  80f373:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80f37a:	00 00 00 
  80f37d:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80f37f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f383:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80f38a:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80f38e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f392:	8b 40 18             	mov    0x18(%rax),%eax
  80f395:	83 f8 03             	cmp    $0x3,%eax
  80f398:	75 20                	jne    80f3ba <tcp_slowtmr+0x4c7>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80f39a:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f3a1:	00 00 00 
  80f3a4:	8b 10                	mov    (%rax),%edx
  80f3a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3aa:	8b 40 38             	mov    0x38(%rax),%eax
  80f3ad:	29 c2                	sub    %eax,%edx
  80f3af:	89 d0                	mov    %edx,%eax
  80f3b1:	83 f8 28             	cmp    $0x28,%eax
  80f3b4:	76 04                	jbe    80f3ba <tcp_slowtmr+0x4c7>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80f3b6:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80f3ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3be:	8b 40 18             	mov    0x18(%rax),%eax
  80f3c1:	83 f8 09             	cmp    $0x9,%eax
  80f3c4:	75 22                	jne    80f3e8 <tcp_slowtmr+0x4f5>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80f3c6:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f3cd:	00 00 00 
  80f3d0:	8b 10                	mov    (%rax),%edx
  80f3d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3d6:	8b 40 38             	mov    0x38(%rax),%eax
  80f3d9:	29 c2                	sub    %eax,%edx
  80f3db:	89 d0                	mov    %edx,%eax
  80f3dd:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80f3e2:	76 04                	jbe    80f3e8 <tcp_slowtmr+0x4f5>
        ++pcb_remove;
  80f3e4:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80f3e8:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80f3ec:	0f 84 19 01 00 00    	je     80f50b <tcp_slowtmr+0x618>
      tcp_pcb_purge(pcb);      
  80f3f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3f6:	48 89 c7             	mov    %rax,%rdi
  80f3f9:	48 b8 bd fd 80 00 00 	movabs $0x80fdbd,%rax
  80f400:	00 00 00 
  80f403:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80f405:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80f40a:	74 4f                	je     80f45b <tcp_slowtmr+0x568>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80f40c:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80f413:	00 00 00 
  80f416:	48 8b 00             	mov    (%rax),%rax
  80f419:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80f41d:	75 2a                	jne    80f449 <tcp_slowtmr+0x556>
  80f41f:	48 ba 00 19 82 00 00 	movabs $0x821900,%rdx
  80f426:	00 00 00 
  80f429:	be c1 02 00 00       	mov    $0x2c1,%esi
  80f42e:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80f435:	00 00 00 
  80f438:	b8 00 00 00 00       	mov    $0x0,%eax
  80f43d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80f444:	00 00 00 
  80f447:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80f449:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f44d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f451:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80f455:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f459:	eb 52                	jmp    80f4ad <tcp_slowtmr+0x5ba>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80f45b:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80f462:	00 00 00 
  80f465:	48 8b 00             	mov    (%rax),%rax
  80f468:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80f46c:	74 2a                	je     80f498 <tcp_slowtmr+0x5a5>
  80f46e:	48 ba 30 19 82 00 00 	movabs $0x821930,%rdx
  80f475:	00 00 00 
  80f478:	be c5 02 00 00       	mov    $0x2c5,%esi
  80f47d:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80f484:	00 00 00 
  80f487:	b8 00 00 00 00       	mov    $0x0,%eax
  80f48c:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80f493:	00 00 00 
  80f496:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  80f498:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f49c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f4a0:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80f4a7:	00 00 00 
  80f4aa:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80f4ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4b1:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80f4b8:	48 85 c0             	test   %rax,%rax
  80f4bb:	74 1d                	je     80f4da <tcp_slowtmr+0x5e7>
  80f4bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4c1:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80f4c8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f4cc:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80f4d0:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80f4d5:	48 89 d7             	mov    %rdx,%rdi
  80f4d8:	ff d0                	callq  *%rax

      pcb2 = pcb->next;
  80f4da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4de:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f4e2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80f4e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4ea:	48 89 c6             	mov    %rax,%rsi
  80f4ed:	bf 02 00 00 00       	mov    $0x2,%edi
  80f4f2:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80f4f9:	00 00 00 
  80f4fc:	ff d0                	callq  *%rax
      pcb = pcb2;
  80f4fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f502:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f506:	e9 8d 00 00 00       	jmpq   80f598 <tcp_slowtmr+0x6a5>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80f50b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f50f:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  80f513:	8d 50 01             	lea    0x1(%rax),%edx
  80f516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f51a:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  80f51d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f521:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  80f525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f529:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  80f52d:	38 c2                	cmp    %al,%dl
  80f52f:	72 53                	jb     80f584 <tcp_slowtmr+0x691>
        pcb->polltmr = 0;
  80f531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f535:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80f539:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f53d:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80f544:	48 85 c0             	test   %rax,%rax
  80f547:	74 22                	je     80f56b <tcp_slowtmr+0x678>
  80f549:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f54d:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80f554:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f558:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80f55c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80f560:	48 89 ce             	mov    %rcx,%rsi
  80f563:	48 89 d7             	mov    %rdx,%rdi
  80f566:	ff d0                	callq  *%rax
  80f568:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  80f56b:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  80f56f:	75 13                	jne    80f584 <tcp_slowtmr+0x691>
          tcp_output(pcb);
  80f571:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f575:	48 89 c7             	mov    %rax,%rdi
  80f578:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80f57f:	00 00 00 
  80f582:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  80f584:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f588:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80f58c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f590:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f594:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  80f598:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f59d:	0f 85 95 f9 ff ff    	jne    80ef38 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  80f5a3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80f5aa:	00 
  pcb = tcp_tw_pcbs;
  80f5ab:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80f5b2:	00 00 00 
  80f5b5:	48 8b 00             	mov    (%rax),%rax
  80f5b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  80f5bc:	e9 63 01 00 00       	jmpq   80f724 <tcp_slowtmr+0x831>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80f5c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5c5:	8b 40 18             	mov    0x18(%rax),%eax
  80f5c8:	83 f8 0a             	cmp    $0xa,%eax
  80f5cb:	74 2a                	je     80f5f7 <tcp_slowtmr+0x704>
  80f5cd:	48 ba 60 19 82 00 00 	movabs $0x821960,%rdx
  80f5d4:	00 00 00 
  80f5d7:	be e5 02 00 00       	mov    $0x2e5,%esi
  80f5dc:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80f5e3:	00 00 00 
  80f5e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5eb:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80f5f2:	00 00 00 
  80f5f5:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  80f5f7:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80f5fb:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80f602:	00 00 00 
  80f605:	8b 10                	mov    (%rax),%edx
  80f607:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f60b:	8b 40 38             	mov    0x38(%rax),%eax
  80f60e:	29 c2                	sub    %eax,%edx
  80f610:	89 d0                	mov    %edx,%eax
  80f612:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80f617:	76 04                	jbe    80f61d <tcp_slowtmr+0x72a>
      ++pcb_remove;
  80f619:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80f61d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80f621:	0f 84 e9 00 00 00    	je     80f710 <tcp_slowtmr+0x81d>
      tcp_pcb_purge(pcb);      
  80f627:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f62b:	48 89 c7             	mov    %rax,%rdi
  80f62e:	48 b8 bd fd 80 00 00 	movabs $0x80fdbd,%rax
  80f635:	00 00 00 
  80f638:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80f63a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80f63f:	74 4f                	je     80f690 <tcp_slowtmr+0x79d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80f641:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80f648:	00 00 00 
  80f64b:	48 8b 00             	mov    (%rax),%rax
  80f64e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80f652:	75 2a                	jne    80f67e <tcp_slowtmr+0x78b>
  80f654:	48 ba 90 19 82 00 00 	movabs $0x821990,%rdx
  80f65b:	00 00 00 
  80f65e:	be f4 02 00 00       	mov    $0x2f4,%esi
  80f663:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80f66a:	00 00 00 
  80f66d:	b8 00 00 00 00       	mov    $0x0,%eax
  80f672:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80f679:	00 00 00 
  80f67c:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80f67e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f682:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f686:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80f68a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f68e:	eb 52                	jmp    80f6e2 <tcp_slowtmr+0x7ef>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80f690:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80f697:	00 00 00 
  80f69a:	48 8b 00             	mov    (%rax),%rax
  80f69d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80f6a1:	74 2a                	je     80f6cd <tcp_slowtmr+0x7da>
  80f6a3:	48 ba b8 19 82 00 00 	movabs $0x8219b8,%rdx
  80f6aa:	00 00 00 
  80f6ad:	be f8 02 00 00       	mov    $0x2f8,%esi
  80f6b2:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  80f6b9:	00 00 00 
  80f6bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80f6c1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  80f6c8:	00 00 00 
  80f6cb:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  80f6cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6d1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f6d5:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80f6dc:	00 00 00 
  80f6df:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  80f6e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6e6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f6ea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80f6ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6f2:	48 89 c6             	mov    %rax,%rsi
  80f6f5:	bf 02 00 00 00       	mov    $0x2,%edi
  80f6fa:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80f701:	00 00 00 
  80f704:	ff d0                	callq  *%rax
      pcb = pcb2;
  80f706:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f70a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f70e:	eb 14                	jmp    80f724 <tcp_slowtmr+0x831>
    } else {
      prev = pcb;
  80f710:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f714:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80f718:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f71c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f720:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  80f724:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f729:	0f 85 92 fe ff ff    	jne    80f5c1 <tcp_slowtmr+0x6ce>
    }
  }
}
  80f72f:	c9                   	leaveq 
  80f730:	c3                   	retq   

000000000080f731 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80f731:	55                   	push   %rbp
  80f732:	48 89 e5             	mov    %rsp,%rbp
  80f735:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f739:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80f740:	00 00 00 
  80f743:	48 8b 00             	mov    (%rax),%rax
  80f746:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f74a:	e9 ee 00 00 00       	jmpq   80f83d <tcp_fasttmr+0x10c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80f74f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f753:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80f75a:	48 85 c0             	test   %rax,%rax
  80f75d:	0f 84 81 00 00 00    	je     80f7e4 <tcp_fasttmr+0xb3>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80f763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f767:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80f76e:	48 85 c0             	test   %rax,%rax
  80f771:	74 2e                	je     80f7a1 <tcp_fasttmr+0x70>
  80f773:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f777:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80f77e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f782:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  80f789:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80f78d:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  80f791:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  80f795:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f79a:	ff d0                	callq  *%rax
  80f79c:	88 45 f7             	mov    %al,-0x9(%rbp)
  80f79f:	eb 2e                	jmp    80f7cf <tcp_fasttmr+0x9e>
  80f7a1:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  80f7a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7a9:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80f7b0:	48 85 c0             	test   %rax,%rax
  80f7b3:	74 1a                	je     80f7cf <tcp_fasttmr+0x9e>
  80f7b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7b9:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80f7c0:	48 89 c7             	mov    %rax,%rdi
  80f7c3:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80f7ca:	00 00 00 
  80f7cd:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  80f7cf:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80f7d3:	75 0f                	jne    80f7e4 <tcp_fasttmr+0xb3>
        pcb->refused_data = NULL;
  80f7d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7d9:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  80f7e0:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80f7e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7e8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f7ec:	0f b6 c0             	movzbl %al,%eax
  80f7ef:	83 e0 01             	and    $0x1,%eax
  80f7f2:	85 c0                	test   %eax,%eax
  80f7f4:	74 3b                	je     80f831 <tcp_fasttmr+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80f7f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7fa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f7fe:	83 c8 02             	or     $0x2,%eax
  80f801:	89 c2                	mov    %eax,%edx
  80f803:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f807:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f80a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f80e:	48 89 c7             	mov    %rax,%rdi
  80f811:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80f818:	00 00 00 
  80f81b:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80f81d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f821:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f825:	83 e0 fc             	and    $0xfffffffc,%eax
  80f828:	89 c2                	mov    %eax,%edx
  80f82a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f82e:	88 50 2c             	mov    %dl,0x2c(%rax)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f831:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f835:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f839:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f83d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f842:	0f 85 07 ff ff ff    	jne    80f74f <tcp_fasttmr+0x1e>
    }
  }
}
  80f848:	c9                   	leaveq 
  80f849:	c3                   	retq   

000000000080f84a <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  80f84a:	55                   	push   %rbp
  80f84b:	48 89 e5             	mov    %rsp,%rbp
  80f84e:	48 83 ec 20          	sub    $0x20,%rsp
  80f852:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  80f856:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  80f85a:	eb 29                	jmp    80f885 <tcp_segs_free+0x3b>
    next = seg->next;
  80f85c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f860:	48 8b 00             	mov    (%rax),%rax
  80f863:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  80f867:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f86b:	48 89 c7             	mov    %rax,%rdi
  80f86e:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  80f875:	00 00 00 
  80f878:	ff d0                	callq  *%rax
  80f87a:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  80f87d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80f881:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  while (seg != NULL) {
  80f885:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f88a:	75 d0                	jne    80f85c <tcp_segs_free+0x12>
  }
  return count;
  80f88c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80f890:	c9                   	leaveq 
  80f891:	c3                   	retq   

000000000080f892 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80f892:	55                   	push   %rbp
  80f893:	48 89 e5             	mov    %rsp,%rbp
  80f896:	48 83 ec 20          	sub    $0x20,%rsp
  80f89a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  80f89e:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  80f8a2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f8a7:	74 3f                	je     80f8e8 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  80f8a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8ad:	48 8b 40 08          	mov    0x8(%rax),%rax
  80f8b1:	48 85 c0             	test   %rax,%rax
  80f8b4:	74 1a                	je     80f8d0 <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  80f8b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8ba:	48 8b 40 08          	mov    0x8(%rax),%rax
  80f8be:	48 89 c7             	mov    %rax,%rdi
  80f8c1:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80f8c8:	00 00 00 
  80f8cb:	ff d0                	callq  *%rax
  80f8cd:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80f8d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8d4:	48 89 c6             	mov    %rax,%rsi
  80f8d7:	bf 04 00 00 00       	mov    $0x4,%edi
  80f8dc:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  80f8e3:	00 00 00 
  80f8e6:	ff d0                	callq  *%rax
  }
  return count;
  80f8e8:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80f8ec:	c9                   	leaveq 
  80f8ed:	c3                   	retq   

000000000080f8ee <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80f8ee:	55                   	push   %rbp
  80f8ef:	48 89 e5             	mov    %rsp,%rbp
  80f8f2:	48 83 ec 10          	sub    $0x10,%rsp
  80f8f6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f8fa:	89 f0                	mov    %esi,%eax
  80f8fc:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  80f8ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f903:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80f907:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  80f90a:	c9                   	leaveq 
  80f90b:	c3                   	retq   

000000000080f90c <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  80f90c:	55                   	push   %rbp
  80f90d:	48 89 e5             	mov    %rsp,%rbp
  80f910:	48 83 ec 20          	sub    $0x20,%rsp
  80f914:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80f918:	bf 04 00 00 00       	mov    $0x4,%edi
  80f91d:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80f924:	00 00 00 
  80f927:	ff d0                	callq  *%rax
  80f929:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  80f92d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f932:	75 07                	jne    80f93b <tcp_seg_copy+0x2f>
    return NULL;
  80f934:	b8 00 00 00 00       	mov    $0x0,%eax
  80f939:	eb 3a                	jmp    80f975 <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80f93b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80f93f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f943:	ba 28 00 00 00       	mov    $0x28,%edx
  80f948:	48 89 ce             	mov    %rcx,%rsi
  80f94b:	48 89 c7             	mov    %rax,%rdi
  80f94e:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  80f955:	00 00 00 
  80f958:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  80f95a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f95e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80f962:	48 89 c7             	mov    %rax,%rdi
  80f965:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  80f96c:	00 00 00 
  80f96f:	ff d0                	callq  *%rax
  return cseg;
  80f971:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80f975:	c9                   	leaveq 
  80f976:	c3                   	retq   

000000000080f977 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f977:	55                   	push   %rbp
  80f978:	48 89 e5             	mov    %rsp,%rbp
  80f97b:	48 83 ec 20          	sub    $0x20,%rsp
  80f97f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f983:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80f987:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80f98b:	89 c8                	mov    %ecx,%eax
  80f98d:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  80f990:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f995:	74 15                	je     80f9ac <tcp_recv_null+0x35>
    pbuf_free(p);
  80f997:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f99b:	48 89 c7             	mov    %rax,%rdi
  80f99e:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80f9a5:	00 00 00 
  80f9a8:	ff d0                	callq  *%rax
  80f9aa:	eb 1b                	jmp    80f9c7 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  80f9ac:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  80f9b0:	75 15                	jne    80f9c7 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  80f9b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80f9b6:	48 89 c7             	mov    %rax,%rdi
  80f9b9:	48 b8 8c e0 80 00 00 	movabs $0x80e08c,%rax
  80f9c0:	00 00 00 
  80f9c3:	ff d0                	callq  *%rax
  80f9c5:	eb 05                	jmp    80f9cc <tcp_recv_null+0x55>
  }
  return ERR_OK;
  80f9c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f9cc:	c9                   	leaveq 
  80f9cd:	c3                   	retq   

000000000080f9ce <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  80f9ce:	55                   	push   %rbp
  80f9cf:	48 89 e5             	mov    %rsp,%rbp
  80f9d2:	48 83 ec 30          	sub    $0x30,%rsp
  80f9d6:	89 f8                	mov    %edi,%eax
  80f9d8:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  80f9db:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  80f9df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  80f9e6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80f9ed:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f9ee:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  80f9f5:	00 00 00 
  80f9f8:	48 8b 00             	mov    (%rax),%rax
  80f9fb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f9ff:	eb 6f                	jmp    80fa70 <tcp_kill_prio+0xa2>
    if (pcb->prio <= prio &&
  80fa01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa05:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80fa09:	3a 45 dc             	cmp    -0x24(%rbp),%al
  80fa0c:	77 56                	ja     80fa64 <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
  80fa0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa12:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
    if (pcb->prio <= prio &&
  80fa16:	3a 45 eb             	cmp    -0x15(%rbp),%al
  80fa19:	77 49                	ja     80fa64 <tcp_kill_prio+0x96>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80fa1b:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80fa22:	00 00 00 
  80fa25:	8b 10                	mov    (%rax),%edx
  80fa27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa2b:	8b 40 38             	mov    0x38(%rax),%eax
  80fa2e:	29 c2                	sub    %eax,%edx
  80fa30:	89 d0                	mov    %edx,%eax
       pcb->prio <= mprio &&
  80fa32:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80fa35:	72 2d                	jb     80fa64 <tcp_kill_prio+0x96>
      inactivity = tcp_ticks - pcb->tmr;
  80fa37:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80fa3e:	00 00 00 
  80fa41:	8b 10                	mov    (%rax),%edx
  80fa43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa47:	8b 40 38             	mov    0x38(%rax),%eax
  80fa4a:	29 c2                	sub    %eax,%edx
  80fa4c:	89 d0                	mov    %edx,%eax
  80fa4e:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  80fa51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa55:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  80fa59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa5d:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80fa61:	88 45 eb             	mov    %al,-0x15(%rbp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80fa64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa68:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fa6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fa70:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fa75:	75 8a                	jne    80fa01 <tcp_kill_prio+0x33>
    }
  }
  if (inactive != NULL) {
  80fa77:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fa7c:	74 13                	je     80fa91 <tcp_kill_prio+0xc3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80fa7e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fa82:	48 89 c7             	mov    %rax,%rdi
  80fa85:	48 b8 12 e3 80 00 00 	movabs $0x80e312,%rax
  80fa8c:	00 00 00 
  80fa8f:	ff d0                	callq  *%rax
  }      
}
  80fa91:	c9                   	leaveq 
  80fa92:	c3                   	retq   

000000000080fa93 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  80fa93:	55                   	push   %rbp
  80fa94:	48 89 e5             	mov    %rsp,%rbp
  80fa97:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  80fa9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  80faa2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80faa9:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80faaa:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  80fab1:	00 00 00 
  80fab4:	48 8b 00             	mov    (%rax),%rax
  80fab7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fabb:	eb 4a                	jmp    80fb07 <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80fabd:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80fac4:	00 00 00 
  80fac7:	8b 10                	mov    (%rax),%edx
  80fac9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80facd:	8b 40 38             	mov    0x38(%rax),%eax
  80fad0:	29 c2                	sub    %eax,%edx
  80fad2:	89 d0                	mov    %edx,%eax
  80fad4:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80fad7:	72 22                	jb     80fafb <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
  80fad9:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80fae0:	00 00 00 
  80fae3:	8b 10                	mov    (%rax),%edx
  80fae5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fae9:	8b 40 38             	mov    0x38(%rax),%eax
  80faec:	29 c2                	sub    %eax,%edx
  80faee:	89 d0                	mov    %edx,%eax
  80faf0:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  80faf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faf7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80fafb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faff:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fb03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fb07:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fb0c:	75 af                	jne    80fabd <tcp_kill_timewait+0x2a>
    }
  }
  if (inactive != NULL) {
  80fb0e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fb13:	74 13                	je     80fb28 <tcp_kill_timewait+0x95>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80fb15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fb19:	48 89 c7             	mov    %rax,%rdi
  80fb1c:	48 b8 12 e3 80 00 00 	movabs $0x80e312,%rax
  80fb23:	00 00 00 
  80fb26:	ff d0                	callq  *%rax
  }      
}
  80fb28:	c9                   	leaveq 
  80fb29:	c3                   	retq   

000000000080fb2a <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80fb2a:	55                   	push   %rbp
  80fb2b:	48 89 e5             	mov    %rsp,%rbp
  80fb2e:	48 83 ec 20          	sub    $0x20,%rsp
  80fb32:	89 f8                	mov    %edi,%eax
  80fb34:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  80fb37:	bf 02 00 00 00       	mov    $0x2,%edi
  80fb3c:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80fb43:	00 00 00 
  80fb46:	ff d0                	callq  *%rax
  80fb48:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  80fb4c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fb51:	75 4f                	jne    80fba2 <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  80fb53:	48 b8 93 fa 80 00 00 	movabs $0x80fa93,%rax
  80fb5a:	00 00 00 
  80fb5d:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  80fb5f:	bf 02 00 00 00       	mov    $0x2,%edi
  80fb64:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80fb6b:	00 00 00 
  80fb6e:	ff d0                	callq  *%rax
  80fb70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  80fb74:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fb79:	75 27                	jne    80fba2 <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  80fb7b:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  80fb7f:	89 c7                	mov    %eax,%edi
  80fb81:	48 b8 ce f9 80 00 00 	movabs $0x80f9ce,%rax
  80fb88:	00 00 00 
  80fb8b:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80fb8d:	bf 02 00 00 00       	mov    $0x2,%edi
  80fb92:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  80fb99:	00 00 00 
  80fb9c:	ff d0                	callq  *%rax
  80fb9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  80fba2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fba7:	0f 84 23 01 00 00    	je     80fcd0 <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  80fbad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbb1:	ba e0 00 00 00       	mov    $0xe0,%edx
  80fbb6:	be 00 00 00 00       	mov    $0x0,%esi
  80fbbb:	48 89 c7             	mov    %rax,%rdi
  80fbbe:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  80fbc5:	00 00 00 
  80fbc8:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  80fbca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbce:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  80fbd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbd6:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  80fbdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbe0:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  80fbe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbea:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80fbf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbf4:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  80fbfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbfe:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  80fc02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc06:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80fc0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc0e:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80fc14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc18:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  80fc1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc22:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80fc28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc2c:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  80fc32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc36:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  80fc3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc40:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  80fc46:	48 b8 bc 00 81 00 00 	movabs $0x8100bc,%rax
  80fc4d:	00 00 00 
  80fc50:	ff d0                	callq  *%rax
  80fc52:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  80fc55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc59:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80fc5c:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  80fc5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc63:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80fc66:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  80fc69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc6d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80fc70:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  80fc73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc77:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80fc7a:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  80fc7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc81:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80fc84:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  80fc87:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  80fc8e:	00 00 00 
  80fc91:	8b 10                	mov    (%rax),%edx
  80fc93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc97:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  80fc9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc9e:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  80fca2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fca6:	48 b9 77 f9 80 00 00 	movabs $0x80f977,%rcx
  80fcad:	00 00 00 
  80fcb0:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80fcb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcbb:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  80fcc2:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  80fcc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcc9:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  80fcd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80fcd4:	c9                   	leaveq 
  80fcd5:	c3                   	retq   

000000000080fcd6 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  80fcd6:	55                   	push   %rbp
  80fcd7:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80fcda:	bf 40 00 00 00       	mov    $0x40,%edi
  80fcdf:	48 b8 2a fb 80 00 00 	movabs $0x80fb2a,%rax
  80fce6:	00 00 00 
  80fce9:	ff d0                	callq  *%rax
}
  80fceb:	5d                   	pop    %rbp
  80fcec:	c3                   	retq   

000000000080fced <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  80fced:	55                   	push   %rbp
  80fcee:	48 89 e5             	mov    %rsp,%rbp
  80fcf1:	48 83 ec 10          	sub    $0x10,%rsp
  80fcf5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fcf9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  80fcfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd01:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80fd05:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  80fd09:	c9                   	leaveq 
  80fd0a:	c3                   	retq   

000000000080fd0b <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  80fd0b:	55                   	push   %rbp
  80fd0c:	48 89 e5             	mov    %rsp,%rbp
  80fd0f:	48 83 ec 10          	sub    $0x10,%rsp
  80fd13:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fd17:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  80fd1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd1f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80fd23:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  80fd2a:	c9                   	leaveq 
  80fd2b:	c3                   	retq   

000000000080fd2c <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  80fd2c:	55                   	push   %rbp
  80fd2d:	48 89 e5             	mov    %rsp,%rbp
  80fd30:	48 83 ec 10          	sub    $0x10,%rsp
  80fd34:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fd38:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  80fd3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd40:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80fd44:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  80fd4b:	c9                   	leaveq 
  80fd4c:	c3                   	retq   

000000000080fd4d <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  80fd4d:	55                   	push   %rbp
  80fd4e:	48 89 e5             	mov    %rsp,%rbp
  80fd51:	48 83 ec 10          	sub    $0x10,%rsp
  80fd55:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fd59:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  80fd5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd61:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80fd65:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  80fd6c:	c9                   	leaveq 
  80fd6d:	c3                   	retq   

000000000080fd6e <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  80fd6e:	55                   	push   %rbp
  80fd6f:	48 89 e5             	mov    %rsp,%rbp
  80fd72:	48 83 ec 10          	sub    $0x10,%rsp
  80fd76:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fd7a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80fd7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd82:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80fd86:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  80fd8a:	c9                   	leaveq 
  80fd8b:	c3                   	retq   

000000000080fd8c <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  80fd8c:	55                   	push   %rbp
  80fd8d:	48 89 e5             	mov    %rsp,%rbp
  80fd90:	48 83 ec 18          	sub    $0x18,%rsp
  80fd94:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fd98:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80fd9c:	89 d0                	mov    %edx,%eax
  80fd9e:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80fda1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80fda9:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  80fdb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdb4:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  80fdb8:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  80fdbb:	c9                   	leaveq 
  80fdbc:	c3                   	retq   

000000000080fdbd <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  80fdbd:	55                   	push   %rbp
  80fdbe:	48 89 e5             	mov    %rsp,%rbp
  80fdc1:	48 83 ec 10          	sub    $0x10,%rsp
  80fdc5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  80fdc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdcd:	8b 40 18             	mov    0x18(%rax),%eax
  80fdd0:	85 c0                	test   %eax,%eax
  80fdd2:	0f 84 e5 00 00 00    	je     80febd <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  80fdd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fddc:	8b 40 18             	mov    0x18(%rax),%eax
  if (pcb->state != CLOSED &&
  80fddf:	83 f8 0a             	cmp    $0xa,%eax
  80fde2:	0f 84 d5 00 00 00    	je     80febd <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {
  80fde8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdec:	8b 40 18             	mov    0x18(%rax),%eax
     pcb->state != TIME_WAIT &&
  80fdef:	83 f8 01             	cmp    $0x1,%eax
  80fdf2:	0f 84 c5 00 00 00    	je     80febd <tcp_pcb_purge+0x100>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  80fdf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdfc:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80fe03:	48 85 c0             	test   %rax,%rax
  80fe06:	74 29                	je     80fe31 <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  80fe08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe0c:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80fe13:	48 89 c7             	mov    %rax,%rdi
  80fe16:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  80fe1d:	00 00 00 
  80fe20:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  80fe22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe26:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  80fe2d:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  80fe31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe35:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  80fe3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe3f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fe46:	48 89 c7             	mov    %rax,%rdi
  80fe49:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80fe50:	00 00 00 
  80fe53:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  80fe55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe59:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80fe60:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  80fe64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe68:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80fe6f:	48 89 c7             	mov    %rax,%rdi
  80fe72:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80fe79:	00 00 00 
  80fe7c:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  80fe7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe82:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80fe89:	48 89 c7             	mov    %rax,%rdi
  80fe8c:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  80fe93:	00 00 00 
  80fe96:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  80fe98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe9c:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  80fea3:	00 00 00 00 
  80fea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feab:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  80feb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feb6:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  80febd:	c9                   	leaveq 
  80febe:	c3                   	retq   

000000000080febf <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  80febf:	55                   	push   %rbp
  80fec0:	48 89 e5             	mov    %rsp,%rbp
  80fec3:	48 83 ec 10          	sub    $0x10,%rsp
  80fec7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80fecb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  80fecf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fed3:	48 8b 00             	mov    (%rax),%rax
  80fed6:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80feda:	75 17                	jne    80fef3 <tcp_pcb_remove+0x34>
  80fedc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fee0:	48 8b 00             	mov    (%rax),%rax
  80fee3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fee7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feeb:	48 89 10             	mov    %rdx,(%rax)
  80feee:	e9 8e 00 00 00       	jmpq   80ff81 <tcp_pcb_remove+0xc2>
  80fef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fef7:	48 8b 10             	mov    (%rax),%rdx
  80fefa:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff01:	00 00 00 
  80ff04:	48 89 10             	mov    %rdx,(%rax)
  80ff07:	eb 66                	jmp    80ff6f <tcp_pcb_remove+0xb0>
  80ff09:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff10:	00 00 00 
  80ff13:	48 8b 00             	mov    (%rax),%rax
  80ff16:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ff1a:	48 85 c0             	test   %rax,%rax
  80ff1d:	74 32                	je     80ff51 <tcp_pcb_remove+0x92>
  80ff1f:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff26:	00 00 00 
  80ff29:	48 8b 00             	mov    (%rax),%rax
  80ff2c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ff30:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80ff34:	75 1b                	jne    80ff51 <tcp_pcb_remove+0x92>
  80ff36:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff3d:	00 00 00 
  80ff40:	48 8b 00             	mov    (%rax),%rax
  80ff43:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ff47:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ff4b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ff4f:	eb 30                	jmp    80ff81 <tcp_pcb_remove+0xc2>
  80ff51:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff58:	00 00 00 
  80ff5b:	48 8b 00             	mov    (%rax),%rax
  80ff5e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ff62:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff69:	00 00 00 
  80ff6c:	48 89 10             	mov    %rdx,(%rax)
  80ff6f:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  80ff76:	00 00 00 
  80ff79:	48 8b 00             	mov    (%rax),%rax
  80ff7c:	48 85 c0             	test   %rax,%rax
  80ff7f:	75 88                	jne    80ff09 <tcp_pcb_remove+0x4a>
  80ff81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ff85:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ff8c:	00 

  tcp_pcb_purge(pcb);
  80ff8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ff91:	48 89 c7             	mov    %rax,%rdi
  80ff94:	48 b8 bd fd 80 00 00 	movabs $0x80fdbd,%rax
  80ff9b:	00 00 00 
  80ff9e:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  80ffa0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ffa4:	8b 40 18             	mov    0x18(%rax),%eax
  80ffa7:	83 f8 0a             	cmp    $0xa,%eax
  80ffaa:	74 45                	je     80fff1 <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  80ffac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ffb0:	8b 40 18             	mov    0x18(%rax),%eax
  if (pcb->state != TIME_WAIT &&
  80ffb3:	83 f8 01             	cmp    $0x1,%eax
  80ffb6:	74 39                	je     80fff1 <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
  80ffb8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ffbc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ffc0:	0f b6 c0             	movzbl %al,%eax
  80ffc3:	83 e0 01             	and    $0x1,%eax
     pcb->state != LISTEN &&
  80ffc6:	85 c0                	test   %eax,%eax
  80ffc8:	74 27                	je     80fff1 <tcp_pcb_remove+0x132>
    pcb->flags |= TF_ACK_NOW;
  80ffca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ffce:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80ffd2:	83 c8 02             	or     $0x2,%eax
  80ffd5:	89 c2                	mov    %eax,%edx
  80ffd7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ffdb:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  80ffde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ffe2:	48 89 c7             	mov    %rax,%rdi
  80ffe5:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  80ffec:	00 00 00 
  80ffef:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  80fff1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fff5:	8b 40 18             	mov    0x18(%rax),%eax
  80fff8:	83 f8 01             	cmp    $0x1,%eax
  80fffb:	0f 84 ae 00 00 00    	je     8100af <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  810001:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810005:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81000c:	48 85 c0             	test   %rax,%rax
  81000f:	74 2a                	je     81003b <tcp_pcb_remove+0x17c>
  810011:	48 ba de 19 82 00 00 	movabs $0x8219de,%rdx
  810018:	00 00 00 
  81001b:	be b4 04 00 00       	mov    $0x4b4,%esi
  810020:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  810027:	00 00 00 
  81002a:	b8 00 00 00 00       	mov    $0x0,%eax
  81002f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  810036:	00 00 00 
  810039:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  81003b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81003f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810046:	48 85 c0             	test   %rax,%rax
  810049:	74 2a                	je     810075 <tcp_pcb_remove+0x1b6>
  81004b:	48 ba f6 19 82 00 00 	movabs $0x8219f6,%rdx
  810052:	00 00 00 
  810055:	be b5 04 00 00       	mov    $0x4b5,%esi
  81005a:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  810061:	00 00 00 
  810064:	b8 00 00 00 00       	mov    $0x0,%eax
  810069:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  810070:	00 00 00 
  810073:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  810075:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810079:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810080:	48 85 c0             	test   %rax,%rax
  810083:	74 2a                	je     8100af <tcp_pcb_remove+0x1f0>
  810085:	48 ba 0f 1a 82 00 00 	movabs $0x821a0f,%rdx
  81008c:	00 00 00 
  81008f:	be b7 04 00 00       	mov    $0x4b7,%esi
  810094:	48 bf fb 17 82 00 00 	movabs $0x8217fb,%rdi
  81009b:	00 00 00 
  81009e:	b8 00 00 00 00       	mov    $0x0,%eax
  8100a3:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8100aa:	00 00 00 
  8100ad:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8100af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8100b3:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8100ba:	c9                   	leaveq 
  8100bb:	c3                   	retq   

00000000008100bc <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  8100bc:	55                   	push   %rbp
  8100bd:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8100c0:	48 b8 f4 71 82 00 00 	movabs $0x8271f4,%rax
  8100c7:	00 00 00 
  8100ca:	8b 10                	mov    (%rax),%edx
  8100cc:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  8100d3:	00 00 00 
  8100d6:	8b 00                	mov    (%rax),%eax
  8100d8:	01 c2                	add    %eax,%edx
  8100da:	48 b8 f4 71 82 00 00 	movabs $0x8271f4,%rax
  8100e1:	00 00 00 
  8100e4:	89 10                	mov    %edx,(%rax)
  return iss;
  8100e6:	48 b8 f4 71 82 00 00 	movabs $0x8271f4,%rax
  8100ed:	00 00 00 
  8100f0:	8b 00                	mov    (%rax),%eax
}
  8100f2:	5d                   	pop    %rbp
  8100f3:	c3                   	retq   

00000000008100f4 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8100f4:	55                   	push   %rbp
  8100f5:	48 89 e5             	mov    %rsp,%rbp
  8100f8:	48 83 ec 20          	sub    $0x20,%rsp
  8100fc:	89 f8                	mov    %edi,%eax
  8100fe:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  810102:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  810106:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81010a:	48 89 c7             	mov    %rax,%rdi
  81010d:	48 b8 f4 01 81 00 00 	movabs $0x8101f4,%rax
  810114:	00 00 00 
  810117:	ff d0                	callq  *%rax
  810119:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  81011d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810122:	74 2d                	je     810151 <tcp_eff_send_mss+0x5d>
  810124:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810128:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81012c:	66 85 c0             	test   %ax,%ax
  81012f:	74 20                	je     810151 <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  810131:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810135:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810139:	83 e8 28             	sub    $0x28,%eax
  81013c:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810140:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  810144:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810148:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  81014d:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  810151:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  810155:	c9                   	leaveq 
  810156:	c3                   	retq   

0000000000810157 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810157:	55                   	push   %rbp
  810158:	48 89 e5             	mov    %rsp,%rbp
  81015b:	48 83 ec 20          	sub    $0x20,%rsp
  81015f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810163:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81016b:	8b 00                	mov    (%rax),%eax
  81016d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810170:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  810174:	74 06                	je     81017c <ip_addr_isbroadcast+0x25>
  810176:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  81017a:	75 07                	jne    810183 <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  81017c:	b8 01 00 00 00       	mov    $0x1,%eax
  810181:	eb 6f                	jmp    8101f2 <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  810183:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810187:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  81018b:	0f b6 c0             	movzbl %al,%eax
  81018e:	83 e0 02             	and    $0x2,%eax
  810191:	85 c0                	test   %eax,%eax
  810193:	75 07                	jne    81019c <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  810195:	b8 00 00 00 00       	mov    $0x0,%eax
  81019a:	eb 56                	jmp    8101f2 <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  81019c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8101a0:	8b 40 08             	mov    0x8(%rax),%eax
  8101a3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8101a6:	75 07                	jne    8101af <ip_addr_isbroadcast+0x58>
    return 0;
  8101a8:	b8 00 00 00 00       	mov    $0x0,%eax
  8101ad:	eb 43                	jmp    8101f2 <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8101af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8101b3:	8b 10                	mov    (%rax),%edx
  8101b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8101b9:	8b 40 08             	mov    0x8(%rax),%eax
  8101bc:	31 c2                	xor    %eax,%edx
  8101be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8101c2:	8b 40 0c             	mov    0xc(%rax),%eax
  8101c5:	21 d0                	and    %edx,%eax
  8101c7:	85 c0                	test   %eax,%eax
  8101c9:	75 22                	jne    8101ed <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8101cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8101cf:	8b 40 0c             	mov    0xc(%rax),%eax
  8101d2:	f7 d0                	not    %eax
  8101d4:	23 45 fc             	and    -0x4(%rbp),%eax
  8101d7:	89 c2                	mov    %eax,%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  8101d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8101dd:	8b 40 0c             	mov    0xc(%rax),%eax
  8101e0:	f7 d0                	not    %eax
          && ((addr2test & ~netif->netmask.addr) ==
  8101e2:	39 c2                	cmp    %eax,%edx
  8101e4:	75 07                	jne    8101ed <ip_addr_isbroadcast+0x96>
    /* => network broadcast address */
    return 1;
  8101e6:	b8 01 00 00 00       	mov    $0x1,%eax
  8101eb:	eb 05                	jmp    8101f2 <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  8101ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8101f2:	c9                   	leaveq 
  8101f3:	c3                   	retq   

00000000008101f4 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  8101f4:	55                   	push   %rbp
  8101f5:	48 89 e5             	mov    %rsp,%rbp
  8101f8:	48 83 ec 20          	sub    $0x20,%rsp
  8101fc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810200:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  810207:	00 00 00 
  81020a:	48 8b 00             	mov    (%rax),%rax
  81020d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810211:	eb 44                	jmp    810257 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810217:	48 89 c7             	mov    %rax,%rdi
  81021a:	48 b8 65 c8 80 00 00 	movabs $0x80c865,%rax
  810221:	00 00 00 
  810224:	ff d0                	callq  *%rax
  810226:	84 c0                	test   %al,%al
  810228:	74 22                	je     81024c <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  81022a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81022e:	8b 10                	mov    (%rax),%edx
  810230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810234:	8b 40 08             	mov    0x8(%rax),%eax
  810237:	31 c2                	xor    %eax,%edx
  810239:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81023d:	8b 40 0c             	mov    0xc(%rax),%eax
  810240:	21 d0                	and    %edx,%eax
  810242:	85 c0                	test   %eax,%eax
  810244:	75 06                	jne    81024c <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810246:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81024a:	eb 58                	jmp    8102a4 <ip_route+0xb0>
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  81024c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810250:	48 8b 00             	mov    (%rax),%rax
  810253:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810257:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81025c:	75 b5                	jne    810213 <ip_route+0x1f>
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  81025e:	48 b8 08 a0 b5 00 00 	movabs $0xb5a008,%rax
  810265:	00 00 00 
  810268:	48 8b 00             	mov    (%rax),%rax
  81026b:	48 85 c0             	test   %rax,%rax
  81026e:	74 20                	je     810290 <ip_route+0x9c>
  810270:	48 b8 08 a0 b5 00 00 	movabs $0xb5a008,%rax
  810277:	00 00 00 
  81027a:	48 8b 00             	mov    (%rax),%rax
  81027d:	48 89 c7             	mov    %rax,%rdi
  810280:	48 b8 65 c8 80 00 00 	movabs $0x80c865,%rax
  810287:	00 00 00 
  81028a:	ff d0                	callq  *%rax
  81028c:	84 c0                	test   %al,%al
  81028e:	75 07                	jne    810297 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810290:	b8 00 00 00 00       	mov    $0x0,%eax
  810295:	eb 0d                	jmp    8102a4 <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810297:	48 b8 08 a0 b5 00 00 	movabs $0xb5a008,%rax
  81029e:	00 00 00 
  8102a1:	48 8b 00             	mov    (%rax),%rax
}
  8102a4:	c9                   	leaveq 
  8102a5:	c3                   	retq   

00000000008102a6 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8102a6:	55                   	push   %rbp
  8102a7:	48 89 e5             	mov    %rsp,%rbp
  8102aa:	53                   	push   %rbx
  8102ab:	48 83 ec 38          	sub    $0x38,%rsp
  8102af:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8102b3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  8102b7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  8102be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8102c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8102c6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  8102ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8102ce:	0f b7 00             	movzwl (%rax),%eax
  8102d1:	0f b7 c0             	movzwl %ax,%eax
  8102d4:	89 c7                	mov    %eax,%edi
  8102d6:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8102dd:	00 00 00 
  8102e0:	ff d0                	callq  *%rax
  8102e2:	66 c1 e8 0c          	shr    $0xc,%ax
  8102e6:	66 83 f8 04          	cmp    $0x4,%ax
  8102ea:	74 1d                	je     810309 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8102ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8102f0:	48 89 c7             	mov    %rax,%rdi
  8102f3:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8102fa:	00 00 00 
  8102fd:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8102ff:	b8 00 00 00 00       	mov    $0x0,%eax
  810304:	e9 19 04 00 00       	jmpq   810722 <ip_input+0x47c>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810309:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81030d:	0f b7 00             	movzwl (%rax),%eax
  810310:	0f b7 c0             	movzwl %ax,%eax
  810313:	89 c7                	mov    %eax,%edi
  810315:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81031c:	00 00 00 
  81031f:	ff d0                	callq  *%rax
  810321:	66 c1 e8 08          	shr    $0x8,%ax
  810325:	83 e0 0f             	and    $0xf,%eax
  810328:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  81032c:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810331:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810335:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810339:	0f b7 c0             	movzwl %ax,%eax
  81033c:	89 c7                	mov    %eax,%edi
  81033e:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  810345:	00 00 00 
  810348:	ff d0                	callq  *%rax
  81034a:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  81034e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810352:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810356:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  81035a:	72 0e                	jb     81036a <ip_input+0xc4>
  81035c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810360:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810364:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810368:	73 1d                	jae    810387 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  81036a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81036e:	48 89 c7             	mov    %rax,%rdi
  810371:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  810378:	00 00 00 
  81037b:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  81037d:	b8 00 00 00 00       	mov    $0x0,%eax
  810382:	e9 9b 03 00 00       	jmpq   810722 <ip_input+0x47c>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  810387:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  81038b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81038f:	89 d6                	mov    %edx,%esi
  810391:	48 89 c7             	mov    %rax,%rdi
  810394:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  81039b:	00 00 00 
  81039e:	ff d0                	callq  *%rax
  8103a0:	66 85 c0             	test   %ax,%ax
  8103a3:	74 1d                	je     8103c2 <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  8103a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8103a9:	48 89 c7             	mov    %rax,%rdi
  8103ac:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8103b3:	00 00 00 
  8103b6:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8103b8:	b8 00 00 00 00       	mov    $0x0,%eax
  8103bd:	e9 60 03 00 00       	jmpq   810722 <ip_input+0x47c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  8103c2:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  8103c6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8103ca:	89 d6                	mov    %edx,%esi
  8103cc:	48 89 c7             	mov    %rax,%rdi
  8103cf:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  8103d6:	00 00 00 
  8103d9:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  8103db:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  8103e2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8103e6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8103ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8103ee:	48 89 c7             	mov    %rax,%rdi
  8103f1:	48 b8 65 c8 80 00 00 	movabs $0x80c865,%rax
  8103f8:	00 00 00 
  8103fb:	ff d0                	callq  *%rax
  8103fd:	84 c0                	test   %al,%al
  8103ff:	74 4e                	je     81044f <ip_input+0x1a9>
  810401:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810405:	48 83 c0 08          	add    $0x8,%rax
  810409:	48 85 c0             	test   %rax,%rax
  81040c:	74 41                	je     81044f <ip_input+0x1a9>
  81040e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810412:	8b 40 08             	mov    0x8(%rax),%eax
  810415:	85 c0                	test   %eax,%eax
  810417:	74 36                	je     81044f <ip_input+0x1a9>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810419:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81041d:	8b 50 10             	mov    0x10(%rax),%edx
  810420:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810424:	8b 40 08             	mov    0x8(%rax),%eax
  810427:	39 c2                	cmp    %eax,%edx
  810429:	74 22                	je     81044d <ip_input+0x1a7>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  81042b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81042f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810433:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810437:	48 89 c6             	mov    %rax,%rsi
  81043a:	48 89 d7             	mov    %rdx,%rdi
  81043d:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  810444:	00 00 00 
  810447:	ff d0                	callq  *%rax
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810449:	84 c0                	test   %al,%al
  81044b:	74 02                	je     81044f <ip_input+0x1a9>
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  81044d:	eb 4b                	jmp    81049a <ip_input+0x1f4>
        }
      }
      if (first) {
  81044f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  810453:	74 1a                	je     81046f <ip_input+0x1c9>
        first = 0;
  810455:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  81045c:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  810463:	00 00 00 
  810466:	48 8b 00             	mov    (%rax),%rax
  810469:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81046d:	eb 0b                	jmp    81047a <ip_input+0x1d4>
      } else {
        netif = netif->next;
  81046f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810473:	48 8b 00             	mov    (%rax),%rax
  810476:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  81047a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81047e:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  810482:	75 0b                	jne    81048f <ip_input+0x1e9>
        netif = netif->next;
  810484:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810488:	48 8b 00             	mov    (%rax),%rax
  81048b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  81048f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810494:	0f 85 50 ff ff ff    	jne    8103ea <ip_input+0x144>
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  81049a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81049f:	75 59                	jne    8104fa <ip_input+0x254>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8104a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104a5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8104a9:	0f b7 c0             	movzwl %ax,%eax
  8104ac:	89 c7                	mov    %eax,%edi
  8104ae:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8104b5:	00 00 00 
  8104b8:	ff d0                	callq  *%rax
  8104ba:	0f b7 c0             	movzwl %ax,%eax
  8104bd:	0f b6 c0             	movzbl %al,%eax
  8104c0:	83 f8 11             	cmp    $0x11,%eax
  8104c3:	75 35                	jne    8104fa <ip_input+0x254>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8104c5:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  8104c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104cd:	48 01 d0             	add    %rdx,%rax
  8104d0:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8104d4:	0f b7 c0             	movzwl %ax,%eax
  8104d7:	89 c7                	mov    %eax,%edi
  8104d9:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8104e0:	00 00 00 
  8104e3:	ff d0                	callq  *%rax
  8104e5:	66 83 f8 44          	cmp    $0x44,%ax
  8104e9:	75 0f                	jne    8104fa <ip_input+0x254>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  8104eb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8104ef:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  8104f3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  8104fa:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8104fe:	74 6e                	je     81056e <ip_input+0x2c8>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810500:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810504:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  810508:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81050c:	48 89 c6             	mov    %rax,%rsi
  81050f:	48 89 d7             	mov    %rdx,%rdi
  810512:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  810519:	00 00 00 
  81051c:	ff d0                	callq  *%rax
  81051e:	84 c0                	test   %al,%al
  810520:	75 2f                	jne    810551 <ip_input+0x2ab>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  810522:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810526:	8b 58 0c             	mov    0xc(%rax),%ebx
  810529:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81052e:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  810535:	00 00 00 
  810538:	ff d0                	callq  *%rax
  81053a:	21 c3                	and    %eax,%ebx
  81053c:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810541:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  810548:	00 00 00 
  81054b:	ff d0                	callq  *%rax
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  81054d:	39 c3                	cmp    %eax,%ebx
  81054f:	75 1d                	jne    81056e <ip_input+0x2c8>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  810551:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810555:	48 89 c7             	mov    %rax,%rdi
  810558:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81055f:	00 00 00 
  810562:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  810564:	b8 00 00 00 00       	mov    $0x0,%eax
  810569:	e9 b4 01 00 00       	jmpq   810722 <ip_input+0x47c>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  81056e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810573:	75 1d                	jne    810592 <ip_input+0x2ec>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  810575:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810579:	48 89 c7             	mov    %rax,%rdi
  81057c:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  810583:	00 00 00 
  810586:	ff d0                	callq  *%rax
    return ERR_OK;
  810588:	b8 00 00 00 00       	mov    $0x0,%eax
  81058d:	e9 90 01 00 00       	jmpq   810722 <ip_input+0x47c>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  810592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810596:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  81059a:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  81059f:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8105a6:	00 00 00 
  8105a9:	ff d0                	callq  *%rax
  8105ab:	21 d8                	and    %ebx,%eax
  8105ad:	66 85 c0             	test   %ax,%ax
  8105b0:	74 34                	je     8105e6 <ip_input+0x340>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  8105b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8105b6:	48 89 c7             	mov    %rax,%rdi
  8105b9:	48 b8 15 14 81 00 00 	movabs $0x811415,%rax
  8105c0:	00 00 00 
  8105c3:	ff d0                	callq  *%rax
  8105c5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  8105c9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8105ce:	75 0a                	jne    8105da <ip_input+0x334>
      return ERR_OK;
  8105d0:	b8 00 00 00 00       	mov    $0x0,%eax
  8105d5:	e9 48 01 00 00       	jmpq   810722 <ip_input+0x47c>
    }
    iphdr = p->payload;
  8105da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8105de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8105e2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  8105e6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8105ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8105ee:	48 89 d6             	mov    %rdx,%rsi
  8105f1:	48 89 c7             	mov    %rax,%rdi
  8105f4:	48 b8 c5 f1 81 00 00 	movabs $0x81f1c5,%rax
  8105fb:	00 00 00 
  8105fe:	ff d0                	callq  *%rax
  810600:	84 c0                	test   %al,%al
  810602:	0f 85 15 01 00 00    	jne    81071d <ip_input+0x477>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  810608:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81060c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810610:	0f b7 c0             	movzwl %ax,%eax
  810613:	89 c7                	mov    %eax,%edi
  810615:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81061c:	00 00 00 
  81061f:	ff d0                	callq  *%rax
  810621:	0f b7 c0             	movzwl %ax,%eax
  810624:	0f b6 c0             	movzbl %al,%eax
  810627:	83 f8 06             	cmp    $0x6,%eax
  81062a:	74 2b                	je     810657 <ip_input+0x3b1>
  81062c:	83 f8 11             	cmp    $0x11,%eax
  81062f:	74 07                	je     810638 <ip_input+0x392>
  810631:	83 f8 01             	cmp    $0x1,%eax
  810634:	74 40                	je     810676 <ip_input+0x3d0>
  810636:	eb 5d                	jmp    810695 <ip_input+0x3ef>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  810638:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81063c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810640:	48 89 d6             	mov    %rdx,%rsi
  810643:	48 89 c7             	mov    %rax,%rdi
  810646:	48 b8 0c 42 81 00 00 	movabs $0x81420c,%rax
  81064d:	00 00 00 
  810650:	ff d0                	callq  *%rax
      break;
  810652:	e9 c6 00 00 00       	jmpq   81071d <ip_input+0x477>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  810657:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81065b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81065f:	48 89 d6             	mov    %rdx,%rsi
  810662:	48 89 c7             	mov    %rax,%rdi
  810665:	48 b8 a6 b8 81 00 00 	movabs $0x81b8a6,%rax
  81066c:	00 00 00 
  81066f:	ff d0                	callq  *%rax
      break;
  810671:	e9 a7 00 00 00       	jmpq   81071d <ip_input+0x477>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  810676:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81067a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81067e:	48 89 d6             	mov    %rdx,%rsi
  810681:	48 89 c7             	mov    %rax,%rdi
  810684:	48 b8 7e f6 81 00 00 	movabs $0x81f67e,%rax
  81068b:	00 00 00 
  81068e:	ff d0                	callq  *%rax
      break;
  810690:	e9 88 00 00 00       	jmpq   81071d <ip_input+0x477>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810695:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810699:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81069d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8106a1:	48 89 c6             	mov    %rax,%rsi
  8106a4:	48 89 d7             	mov    %rdx,%rdi
  8106a7:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  8106ae:	00 00 00 
  8106b1:	ff d0                	callq  *%rax
  8106b3:	84 c0                	test   %al,%al
  8106b5:	75 53                	jne    81070a <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8106b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8106bb:	8b 58 10             	mov    0x10(%rax),%ebx
  8106be:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8106c3:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8106ca:	00 00 00 
  8106cd:	ff d0                	callq  *%rax
  8106cf:	21 c3                	and    %eax,%ebx
  8106d1:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8106d6:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8106dd:	00 00 00 
  8106e0:	ff d0                	callq  *%rax
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8106e2:	39 c3                	cmp    %eax,%ebx
  8106e4:	74 24                	je     81070a <ip_input+0x464>
        p->payload = iphdr;
  8106e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8106ea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8106ee:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8106f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8106f6:	be 02 00 00 00       	mov    $0x2,%esi
  8106fb:	48 89 c7             	mov    %rax,%rdi
  8106fe:	48 b8 ad fb 81 00 00 	movabs $0x81fbad,%rax
  810705:	00 00 00 
  810708:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  81070a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81070e:	48 89 c7             	mov    %rax,%rdi
  810711:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  810718:	00 00 00 
  81071b:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  81071d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810722:	48 83 c4 38          	add    $0x38,%rsp
  810726:	5b                   	pop    %rbx
  810727:	5d                   	pop    %rbp
  810728:	c3                   	retq   

0000000000810729 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  810729:	55                   	push   %rbp
  81072a:	48 89 e5             	mov    %rsp,%rbp
  81072d:	53                   	push   %rbx
  81072e:	48 83 ec 48          	sub    $0x48,%rsp
  810732:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  810736:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81073a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81073e:	89 c8                	mov    %ecx,%eax
  810740:	44 89 c1             	mov    %r8d,%ecx
  810743:	44 89 ca             	mov    %r9d,%edx
  810746:	88 45 c4             	mov    %al,-0x3c(%rbp)
  810749:	88 4d c0             	mov    %cl,-0x40(%rbp)
  81074c:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  81074f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810754:	0f 84 1a 02 00 00    	je     810974 <ip_output_if+0x24b>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  81075a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81075e:	be 14 00 00 00       	mov    $0x14,%esi
  810763:	48 89 c7             	mov    %rax,%rdi
  810766:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81076d:	00 00 00 
  810770:	ff d0                	callq  *%rax
  810772:	84 c0                	test   %al,%al
  810774:	74 0a                	je     810780 <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  810776:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  81077b:	e9 64 02 00 00       	jmpq   8109e4 <ip_output_if+0x2bb>
    }

    iphdr = p->payload;
  810780:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810784:	48 8b 40 08          	mov    0x8(%rax),%rax
  810788:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  81078c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810790:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810794:	66 83 f8 13          	cmp    $0x13,%ax
  810798:	77 2a                	ja     8107c4 <ip_output_if+0x9b>
  81079a:	48 ba 30 1a 82 00 00 	movabs $0x821a30,%rdx
  8107a1:	00 00 00 
  8107a4:	be ee 01 00 00       	mov    $0x1ee,%esi
  8107a9:	48 bf 5d 1a 82 00 00 	movabs $0x821a5d,%rdi
  8107b0:	00 00 00 
  8107b3:	b8 00 00 00 00       	mov    $0x0,%eax
  8107b8:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8107bf:	00 00 00 
  8107c2:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8107c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8107c8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8107cc:	0f b7 c0             	movzwl %ax,%eax
  8107cf:	89 c7                	mov    %eax,%edi
  8107d1:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8107d8:	00 00 00 
  8107db:	ff d0                	callq  *%rax
  8107dd:	0f b6 c0             	movzbl %al,%eax
  8107e0:	0f b6 55 c4          	movzbl -0x3c(%rbp),%edx
  8107e4:	c1 e2 08             	shl    $0x8,%edx
  8107e7:	09 d0                	or     %edx,%eax
  8107e9:	0f b7 c0             	movzwl %ax,%eax
  8107ec:	89 c7                	mov    %eax,%edi
  8107ee:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8107f5:	00 00 00 
  8107f8:	ff d0                	callq  *%rax
  8107fa:	89 c2                	mov    %eax,%edx
  8107fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810800:	66 89 50 08          	mov    %dx,0x8(%rax)
    IPH_PROTO_SET(iphdr, proto);
  810804:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  810808:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81080c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810810:	0f b7 c0             	movzwl %ax,%eax
  810813:	89 c7                	mov    %eax,%edi
  810815:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81081c:	00 00 00 
  81081f:	ff d0                	callq  *%rax
  810821:	66 c1 e8 08          	shr    $0x8,%ax
  810825:	0f b7 c0             	movzwl %ax,%eax
  810828:	c1 e0 08             	shl    $0x8,%eax
  81082b:	09 d8                	or     %ebx,%eax
  81082d:	0f b7 c0             	movzwl %ax,%eax
  810830:	89 c7                	mov    %eax,%edi
  810832:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  810839:	00 00 00 
  81083c:	ff d0                	callq  *%rax
  81083e:	89 c2                	mov    %eax,%edx
  810840:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810844:	66 89 50 08          	mov    %dx,0x8(%rax)

    ip_addr_set(&(iphdr->dest), dest);
  810848:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81084d:	74 08                	je     810857 <ip_output_if+0x12e>
  81084f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810853:	8b 00                	mov    (%rax),%eax
  810855:	eb 05                	jmp    81085c <ip_output_if+0x133>
  810857:	b8 00 00 00 00       	mov    $0x0,%eax
  81085c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810860:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  810863:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  810867:	80 cc 45             	or     $0x45,%ah
  81086a:	0f b7 c0             	movzwl %ax,%eax
  81086d:	89 c7                	mov    %eax,%edi
  81086f:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  810876:	00 00 00 
  810879:	ff d0                	callq  *%rax
  81087b:	89 c2                	mov    %eax,%edx
  81087d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810881:	66 89 10             	mov    %dx,(%rax)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  810884:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810888:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81088c:	0f b7 c0             	movzwl %ax,%eax
  81088f:	89 c7                	mov    %eax,%edi
  810891:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  810898:	00 00 00 
  81089b:	ff d0                	callq  *%rax
  81089d:	89 c2                	mov    %eax,%edx
  81089f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8108a3:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_OFFSET_SET(iphdr, 0);
  8108a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8108ab:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  8108b1:	48 b8 6e a0 b4 00 00 	movabs $0xb4a06e,%rax
  8108b8:	00 00 00 
  8108bb:	0f b7 00             	movzwl (%rax),%eax
  8108be:	0f b7 c0             	movzwl %ax,%eax
  8108c1:	89 c7                	mov    %eax,%edi
  8108c3:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8108ca:	00 00 00 
  8108cd:	ff d0                	callq  *%rax
  8108cf:	89 c2                	mov    %eax,%edx
  8108d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8108d5:	66 89 50 04          	mov    %dx,0x4(%rax)
    ++ip_id;
  8108d9:	48 b8 6e a0 b4 00 00 	movabs $0xb4a06e,%rax
  8108e0:	00 00 00 
  8108e3:	0f b7 00             	movzwl (%rax),%eax
  8108e6:	8d 50 01             	lea    0x1(%rax),%edx
  8108e9:	48 b8 6e a0 b4 00 00 	movabs $0xb4a06e,%rax
  8108f0:	00 00 00 
  8108f3:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  8108f6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8108fb:	74 0a                	je     810907 <ip_output_if+0x1de>
  8108fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  810901:	8b 00                	mov    (%rax),%eax
  810903:	85 c0                	test   %eax,%eax
  810905:	75 24                	jne    81092b <ip_output_if+0x202>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  810907:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81090b:	48 83 c0 08          	add    $0x8,%rax
  81090f:	48 85 c0             	test   %rax,%rax
  810912:	74 09                	je     81091d <ip_output_if+0x1f4>
  810914:	48 8b 45 10          	mov    0x10(%rbp),%rax
  810918:	8b 40 08             	mov    0x8(%rax),%eax
  81091b:	eb 05                	jmp    810922 <ip_output_if+0x1f9>
  81091d:	b8 00 00 00 00       	mov    $0x0,%eax
  810922:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810926:	89 42 0c             	mov    %eax,0xc(%rdx)
  810929:	eb 1b                	jmp    810946 <ip_output_if+0x21d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  81092b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  810930:	74 08                	je     81093a <ip_output_if+0x211>
  810932:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  810936:	8b 00                	mov    (%rax),%eax
  810938:	eb 05                	jmp    81093f <ip_output_if+0x216>
  81093a:	b8 00 00 00 00       	mov    $0x0,%eax
  81093f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810943:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  810946:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81094a:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  810950:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810954:	be 14 00 00 00       	mov    $0x14,%esi
  810959:	48 89 c7             	mov    %rax,%rdi
  81095c:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  810963:	00 00 00 
  810966:	ff d0                	callq  *%rax
  810968:	89 c2                	mov    %eax,%edx
  81096a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81096e:	66 89 50 0a          	mov    %dx,0xa(%rax)
  810972:	eb 18                	jmp    81098c <ip_output_if+0x263>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  810974:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810978:	48 8b 40 08          	mov    0x8(%rax),%rax
  81097c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  810980:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810984:	48 83 c0 10          	add    $0x10,%rax
  810988:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  81098c:	48 8b 45 10          	mov    0x10(%rbp),%rax
  810990:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810994:	66 85 c0             	test   %ax,%ax
  810997:	74 32                	je     8109cb <ip_output_if+0x2a2>
  810999:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81099d:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  8109a1:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8109a5:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8109a9:	66 39 c2             	cmp    %ax,%dx
  8109ac:	76 1d                	jbe    8109cb <ip_output_if+0x2a2>
    return ip_frag(p,netif,dest);
  8109ae:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8109b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8109b6:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8109ba:	48 89 c7             	mov    %rax,%rdi
  8109bd:	48 b8 5f 18 81 00 00 	movabs $0x81185f,%rax
  8109c4:	00 00 00 
  8109c7:	ff d0                	callq  *%rax
  8109c9:	eb 19                	jmp    8109e4 <ip_output_if+0x2bb>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8109cb:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8109cf:	48 8b 40 20          	mov    0x20(%rax),%rax
  8109d3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8109d7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8109db:	48 89 ce             	mov    %rcx,%rsi
  8109de:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8109e2:	ff d0                	callq  *%rax
  }
}
  8109e4:	48 83 c4 48          	add    $0x48,%rsp
  8109e8:	5b                   	pop    %rbx
  8109e9:	5d                   	pop    %rbp
  8109ea:	c3                   	retq   

00000000008109eb <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8109eb:	55                   	push   %rbp
  8109ec:	48 89 e5             	mov    %rsp,%rbp
  8109ef:	48 83 ec 40          	sub    $0x40,%rsp
  8109f3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8109f7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8109fb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8109ff:	89 c8                	mov    %ecx,%eax
  810a01:	44 89 c1             	mov    %r8d,%ecx
  810a04:	44 89 ca             	mov    %r9d,%edx
  810a07:	88 45 d4             	mov    %al,-0x2c(%rbp)
  810a0a:	88 4d d0             	mov    %cl,-0x30(%rbp)
  810a0d:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  810a10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810a14:	48 89 c7             	mov    %rax,%rdi
  810a17:	48 b8 f4 01 81 00 00 	movabs $0x8101f4,%rax
  810a1e:	00 00 00 
  810a21:	ff d0                	callq  *%rax
  810a23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810a27:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810a2c:	75 07                	jne    810a35 <ip_output+0x4a>
    return ERR_RTE;
  810a2e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  810a33:	eb 39                	jmp    810a6e <ip_output+0x83>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  810a35:	44 0f b6 45 cc       	movzbl -0x34(%rbp),%r8d
  810a3a:	0f b6 7d d0          	movzbl -0x30(%rbp),%edi
  810a3e:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  810a42:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  810a46:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  810a4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810a4e:	48 83 ec 08          	sub    $0x8,%rsp
  810a52:	ff 75 f8             	pushq  -0x8(%rbp)
  810a55:	45 89 c1             	mov    %r8d,%r9d
  810a58:	41 89 f8             	mov    %edi,%r8d
  810a5b:	48 89 c7             	mov    %rax,%rdi
  810a5e:	48 b8 29 07 81 00 00 	movabs $0x810729,%rax
  810a65:	00 00 00 
  810a68:	ff d0                	callq  *%rax
  810a6a:	48 83 c4 10          	add    $0x10,%rsp
}
  810a6e:	c9                   	leaveq 
  810a6f:	c3                   	retq   

0000000000810a70 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  810a70:	55                   	push   %rbp
  810a71:	48 89 e5             	mov    %rsp,%rbp
  810a74:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  810a78:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810a7f:	00 

  r = reassdatagrams;
  810a80:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  810a87:	00 00 00 
  810a8a:	48 8b 00             	mov    (%rax),%rax
  810a8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  810a91:	eb 60                	jmp    810af3 <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  810a93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a97:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  810a9b:	84 c0                	test   %al,%al
  810a9d:	74 27                	je     810ac6 <ip_reass_tmr+0x56>
      r->timer--;
  810a9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aa3:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  810aa7:	8d 50 ff             	lea    -0x1(%rax),%edx
  810aaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aae:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  810ab1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ab5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  810ab9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810abd:	48 8b 00             	mov    (%rax),%rax
  810ac0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810ac4:	eb 2d                	jmp    810af3 <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  810ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aca:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  810ace:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ad2:	48 8b 00             	mov    (%rax),%rax
  810ad5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  810ad9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810add:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ae1:	48 89 d6             	mov    %rdx,%rsi
  810ae4:	48 89 c7             	mov    %rax,%rdi
  810ae7:	48 b8 fc 0a 81 00 00 	movabs $0x810afc,%rax
  810aee:	00 00 00 
  810af1:	ff d0                	callq  *%rax
  while (r != NULL) {
  810af3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810af8:	75 99                	jne    810a93 <ip_reass_tmr+0x23>
     }
   }
}
  810afa:	c9                   	leaveq 
  810afb:	c3                   	retq   

0000000000810afc <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  810afc:	55                   	push   %rbp
  810afd:	48 89 e5             	mov    %rsp,%rbp
  810b00:	48 83 ec 30          	sub    $0x30,%rsp
  810b04:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  810b08:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  810b0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  810b13:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  810b17:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  810b1b:	75 2a                	jne    810b47 <ip_reass_free_complete_datagram+0x4b>
  810b1d:	48 ba 78 1a 82 00 00 	movabs $0x821a78,%rdx
  810b24:	00 00 00 
  810b27:	be 99 00 00 00       	mov    $0x99,%esi
  810b2c:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  810b33:	00 00 00 
  810b36:	b8 00 00 00 00       	mov    $0x0,%eax
  810b3b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  810b42:	00 00 00 
  810b45:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  810b47:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  810b4c:	74 37                	je     810b85 <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  810b4e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  810b52:	48 8b 00             	mov    (%rax),%rax
  810b55:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  810b59:	74 2a                	je     810b85 <ip_reass_free_complete_datagram+0x89>
  810b5b:	48 ba a1 1a 82 00 00 	movabs $0x821aa1,%rdx
  810b62:	00 00 00 
  810b65:	be 9b 00 00 00       	mov    $0x9b,%esi
  810b6a:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  810b71:	00 00 00 
  810b74:	b8 00 00 00 00       	mov    $0x0,%eax
  810b79:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  810b80:	00 00 00 
  810b83:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  810b85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810b89:	48 8b 40 08          	mov    0x8(%rax),%rax
  810b8d:	48 8b 40 08          	mov    0x8(%rax),%rax
  810b91:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  810b95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810b99:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810b9d:	66 85 c0             	test   %ax,%ax
  810ba0:	0f 85 86 00 00 00    	jne    810c2c <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  810ba6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810baa:	48 8b 40 08          	mov    0x8(%rax),%rax
  810bae:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  810bb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810bb6:	48 8b 10             	mov    (%rax),%rdx
  810bb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810bbd:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  810bc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810bc5:	48 8d 48 10          	lea    0x10(%rax),%rcx
  810bc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bcd:	48 8b 40 08          	mov    0x8(%rax),%rax
  810bd1:	ba 14 00 00 00       	mov    $0x14,%edx
  810bd6:	48 89 ce             	mov    %rcx,%rsi
  810bd9:	48 89 c7             	mov    %rax,%rdi
  810bdc:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  810be3:	00 00 00 
  810be6:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  810be8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bec:	be 01 00 00 00       	mov    $0x1,%esi
  810bf1:	48 89 c7             	mov    %rax,%rdi
  810bf4:	48 b8 4f fd 81 00 00 	movabs $0x81fd4f,%rax
  810bfb:	00 00 00 
  810bfe:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  810c00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c04:	48 89 c7             	mov    %rax,%rdi
  810c07:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  810c0e:	00 00 00 
  810c11:	ff d0                	callq  *%rax
  810c13:	0f b6 c0             	movzbl %al,%eax
  810c16:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  810c19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c1d:	48 89 c7             	mov    %rax,%rdi
  810c20:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  810c27:	00 00 00 
  810c2a:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  810c2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810c30:	48 8b 40 08          	mov    0x8(%rax),%rax
  810c34:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  810c38:	eb 4b                	jmp    810c85 <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  810c3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  810c42:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  810c46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c4a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  810c4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c52:	48 8b 00             	mov    (%rax),%rax
  810c55:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  810c59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c5d:	48 89 c7             	mov    %rax,%rdi
  810c60:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  810c67:	00 00 00 
  810c6a:	ff d0                	callq  *%rax
  810c6c:	0f b6 c0             	movzbl %al,%eax
  810c6f:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  810c72:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c76:	48 89 c7             	mov    %rax,%rdi
  810c79:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  810c80:	00 00 00 
  810c83:	ff d0                	callq  *%rax
  while (p != NULL) {
  810c85:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810c8a:	75 ae                	jne    810c3a <ip_reass_free_complete_datagram+0x13e>
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  810c8c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  810c90:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810c94:	48 89 d6             	mov    %rdx,%rsi
  810c97:	48 89 c7             	mov    %rax,%rdi
  810c9a:	48 b8 01 0f 81 00 00 	movabs $0x810f01,%rax
  810ca1:	00 00 00 
  810ca4:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  810ca6:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  810cad:	00 00 00 
  810cb0:	0f b7 00             	movzwl (%rax),%eax
  810cb3:	0f b7 c0             	movzwl %ax,%eax
  810cb6:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  810cb9:	7d 2a                	jge    810ce5 <ip_reass_free_complete_datagram+0x1e9>
  810cbb:	48 ba b3 1a 82 00 00 	movabs $0x821ab3,%rdx
  810cc2:	00 00 00 
  810cc5:	be bc 00 00 00       	mov    $0xbc,%esi
  810cca:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  810cd1:	00 00 00 
  810cd4:	b8 00 00 00 00       	mov    $0x0,%eax
  810cd9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  810ce0:	00 00 00 
  810ce3:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  810ce5:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  810cec:	00 00 00 
  810cef:	0f b7 00             	movzwl (%rax),%eax
  810cf2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  810cf5:	29 d0                	sub    %edx,%eax
  810cf7:	89 c2                	mov    %eax,%edx
  810cf9:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  810d00:	00 00 00 
  810d03:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  810d06:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  810d09:	c9                   	leaveq 
  810d0a:	c3                   	retq   

0000000000810d0b <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  810d0b:	55                   	push   %rbp
  810d0c:	48 89 e5             	mov    %rsp,%rbp
  810d0f:	48 83 ec 40          	sub    $0x40,%rsp
  810d13:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810d17:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  810d1a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  810d21:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810d28:	00 
    prev = NULL;
  810d29:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  810d30:	00 
    other_datagrams = 0;
  810d31:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  810d38:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  810d3f:	00 00 00 
  810d42:	48 8b 00             	mov    (%rax),%rax
  810d45:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  810d49:	e9 89 00 00 00       	jmpq   810dd7 <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  810d4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d52:	8b 50 1c             	mov    0x1c(%rax),%edx
  810d55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d59:	8b 40 0c             	mov    0xc(%rax),%eax
  810d5c:	39 c2                	cmp    %eax,%edx
  810d5e:	75 27                	jne    810d87 <ip_reass_remove_oldest_datagram+0x7c>
  810d60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d64:	8b 50 20             	mov    0x20(%rax),%edx
  810d67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d6b:	8b 40 10             	mov    0x10(%rax),%eax
  810d6e:	39 c2                	cmp    %eax,%edx
  810d70:	75 15                	jne    810d87 <ip_reass_remove_oldest_datagram+0x7c>
  810d72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d76:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  810d7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d7e:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  810d82:	66 39 c2             	cmp    %ax,%dx
  810d85:	74 31                	je     810db8 <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  810d87:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  810d8b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810d90:	75 0a                	jne    810d9c <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  810d92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d96:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  810d9a:	eb 1c                	jmp    810db8 <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  810d9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810da0:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  810da4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810da8:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  810dac:	38 c2                	cmp    %al,%dl
  810dae:	77 08                	ja     810db8 <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  810db0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810db4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  810db8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810dbc:	48 8b 00             	mov    (%rax),%rax
  810dbf:	48 85 c0             	test   %rax,%rax
  810dc2:	74 08                	je     810dcc <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  810dc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810dc8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  810dcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810dd0:	48 8b 00             	mov    (%rax),%rax
  810dd3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  810dd7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810ddc:	0f 85 6c ff ff ff    	jne    810d4e <ip_reass_remove_oldest_datagram+0x43>
    }
    if (oldest != NULL) {
  810de2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810de7:	74 23                	je     810e0c <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  810de9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810ded:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810df1:	48 89 d6             	mov    %rdx,%rsi
  810df4:	48 89 c7             	mov    %rax,%rdi
  810df7:	48 b8 fc 0a 81 00 00 	movabs $0x810afc,%rax
  810dfe:	00 00 00 
  810e01:	ff d0                	callq  *%rax
  810e03:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  810e06:	8b 45 dc             	mov    -0x24(%rbp),%eax
  810e09:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  810e0c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  810e0f:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  810e12:	7d 0a                	jge    810e1e <ip_reass_remove_oldest_datagram+0x113>
  810e14:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  810e18:	0f 8f 03 ff ff ff    	jg     810d21 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  810e1e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  810e21:	c9                   	leaveq 
  810e22:	c3                   	retq   

0000000000810e23 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  810e23:	55                   	push   %rbp
  810e24:	48 89 e5             	mov    %rsp,%rbp
  810e27:	48 83 ec 20          	sub    $0x20,%rsp
  810e2b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810e2f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  810e32:	bf 05 00 00 00       	mov    $0x5,%edi
  810e37:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  810e3e:	00 00 00 
  810e41:	ff d0                	callq  *%rax
  810e43:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  810e47:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810e4c:	75 40                	jne    810e8e <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  810e4e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  810e51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e55:	89 d6                	mov    %edx,%esi
  810e57:	48 89 c7             	mov    %rax,%rdi
  810e5a:	48 b8 0b 0d 81 00 00 	movabs $0x810d0b,%rax
  810e61:	00 00 00 
  810e64:	ff d0                	callq  *%rax
  810e66:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  810e69:	7c 15                	jl     810e80 <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  810e6b:	bf 05 00 00 00       	mov    $0x5,%edi
  810e70:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  810e77:	00 00 00 
  810e7a:	ff d0                	callq  *%rax
  810e7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  810e80:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810e85:	75 07                	jne    810e8e <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  810e87:	b8 00 00 00 00       	mov    $0x0,%eax
  810e8c:	eb 71                	jmp    810eff <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  810e8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e92:	ba 28 00 00 00       	mov    $0x28,%edx
  810e97:	be 00 00 00 00       	mov    $0x0,%esi
  810e9c:	48 89 c7             	mov    %rax,%rdi
  810e9f:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  810ea6:	00 00 00 
  810ea9:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  810eab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810eaf:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  810eb3:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  810eba:	00 00 00 
  810ebd:	48 8b 10             	mov    (%rax),%rdx
  810ec0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ec4:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  810ec7:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  810ece:	00 00 00 
  810ed1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  810ed5:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  810ed8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810edc:	48 8d 48 10          	lea    0x10(%rax),%rcx
  810ee0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ee4:	ba 14 00 00 00       	mov    $0x14,%edx
  810ee9:	48 89 c6             	mov    %rax,%rsi
  810eec:	48 89 cf             	mov    %rcx,%rdi
  810eef:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  810ef6:	00 00 00 
  810ef9:	ff d0                	callq  *%rax
  return ipr;
  810efb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  810eff:	c9                   	leaveq 
  810f00:	c3                   	retq   

0000000000810f01 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  810f01:	55                   	push   %rbp
  810f02:	48 89 e5             	mov    %rsp,%rbp
  810f05:	48 83 ec 10          	sub    $0x10,%rsp
  810f09:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810f0d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  810f11:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  810f18:	00 00 00 
  810f1b:	48 8b 00             	mov    (%rax),%rax
  810f1e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  810f22:	75 16                	jne    810f3a <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  810f24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810f28:	48 8b 10             	mov    (%rax),%rdx
  810f2b:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  810f32:	00 00 00 
  810f35:	48 89 10             	mov    %rdx,(%rax)
  810f38:	eb 3f                	jmp    810f79 <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  810f3a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810f3f:	75 2a                	jne    810f6b <ip_reass_dequeue_datagram+0x6a>
  810f41:	48 ba ce 1a 82 00 00 	movabs $0x821ace,%rdx
  810f48:	00 00 00 
  810f4b:	be 29 01 00 00       	mov    $0x129,%esi
  810f50:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  810f57:	00 00 00 
  810f5a:	b8 00 00 00 00       	mov    $0x0,%eax
  810f5f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  810f66:	00 00 00 
  810f69:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  810f6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810f6f:	48 8b 10             	mov    (%rax),%rdx
  810f72:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810f76:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  810f79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810f7d:	48 89 c6             	mov    %rax,%rsi
  810f80:	bf 05 00 00 00       	mov    $0x5,%edi
  810f85:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  810f8c:	00 00 00 
  810f8f:	ff d0                	callq  *%rax
}
  810f91:	c9                   	leaveq 
  810f92:	c3                   	retq   

0000000000810f93 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  810f93:	55                   	push   %rbp
  810f94:	48 89 e5             	mov    %rsp,%rbp
  810f97:	53                   	push   %rbx
  810f98:	48 83 ec 58          	sub    $0x58,%rsp
  810f9c:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  810fa0:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  810fa4:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  810fab:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  810fac:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  810fb3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  810fb7:	48 8b 40 08          	mov    0x8(%rax),%rax
  810fbb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  810fbf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fc3:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810fc7:	0f b7 c0             	movzwl %ax,%eax
  810fca:	89 c7                	mov    %eax,%edi
  810fcc:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  810fd3:	00 00 00 
  810fd6:	ff d0                	callq  *%rax
  810fd8:	89 c3                	mov    %eax,%ebx
  810fda:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fde:	0f b7 00             	movzwl (%rax),%eax
  810fe1:	0f b7 c0             	movzwl %ax,%eax
  810fe4:	89 c7                	mov    %eax,%edi
  810fe6:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  810fed:	00 00 00 
  810ff0:	ff d0                	callq  *%rax
  810ff2:	66 c1 e8 08          	shr    $0x8,%ax
  810ff6:	83 e0 0f             	and    $0xf,%eax
  810ff9:	89 c2                	mov    %eax,%edx
  810ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  811000:	29 d0                	sub    %edx,%eax
  811002:	c1 e0 02             	shl    $0x2,%eax
  811005:	01 d8                	add    %ebx,%eax
  811007:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  81100b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81100f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811013:	0f b7 c0             	movzwl %ax,%eax
  811016:	89 c7                	mov    %eax,%edi
  811018:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81101f:	00 00 00 
  811022:	ff d0                	callq  *%rax
  811024:	66 25 ff 1f          	and    $0x1fff,%ax
  811028:	c1 e0 03             	shl    $0x3,%eax
  81102b:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  81102f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811033:	48 8b 40 08          	mov    0x8(%rax),%rax
  811037:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  81103b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81103f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811046:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81104a:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  81104e:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  811052:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811056:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  81105a:	01 c2                	add    %eax,%edx
  81105c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811060:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811064:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811068:	48 8b 40 08          	mov    0x8(%rax),%rax
  81106c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  811070:	e9 ed 00 00 00       	jmpq   811162 <ip_reass_chain_frag_into_datagram_and_validate+0x1cf>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811075:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811079:	48 8b 40 08          	mov    0x8(%rax),%rax
  81107d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  811081:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811085:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811089:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81108d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811091:	66 39 c2             	cmp    %ax,%dx
  811094:	73 62                	jae    8110f8 <ip_reass_chain_frag_into_datagram_and_validate+0x165>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  811096:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81109a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81109e:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  8110a1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8110a6:	74 42                	je     8110ea <ip_reass_chain_frag_into_datagram_and_validate+0x157>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  8110a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110ac:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8110b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8110b4:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  8110b8:	66 39 c2             	cmp    %ax,%dx
  8110bb:	0f 82 01 03 00 00    	jb     8113c2 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
  8110c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110c5:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8110c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8110cd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8110d1:	66 39 c2             	cmp    %ax,%dx
  8110d4:	0f 87 e8 02 00 00    	ja     8113c2 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  8110da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8110de:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8110e2:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  8110e5:	e9 83 00 00 00       	jmpq   81116d <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
        ipr->p = new_p;
  8110ea:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8110ee:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8110f2:	48 89 50 08          	mov    %rdx,0x8(%rax)
      break;
  8110f6:	eb 75                	jmp    81116d <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
    } else if(iprh->start == iprh_tmp->start) {
  8110f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110fc:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811100:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811104:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811108:	66 39 c2             	cmp    %ax,%dx
  81110b:	75 05                	jne    811112 <ip_reass_chain_frag_into_datagram_and_validate+0x17f>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  81110d:	e9 b0 02 00 00       	jmpq   8113c2 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  811112:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811116:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  81111a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81111e:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811122:	66 39 c2             	cmp    %ax,%dx
  811125:	73 05                	jae    81112c <ip_reass_chain_frag_into_datagram_and_validate+0x199>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  811127:	e9 96 02 00 00       	jmpq   8113c2 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  81112c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811131:	74 1c                	je     81114f <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
        if (iprh_prev->end != iprh_tmp->start) {
  811133:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811137:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  81113b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81113f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811143:	66 39 c2             	cmp    %ax,%dx
  811146:	74 07                	je     81114f <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811148:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  81114f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811153:	48 8b 00             	mov    (%rax),%rax
  811156:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  81115a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81115e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  for (q = ipr->p; q != NULL;) {
  811162:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811167:	0f 85 08 ff ff ff    	jne    811075 <ip_reass_chain_frag_into_datagram_and_validate+0xe2>
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  81116d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811172:	0f 85 b2 00 00 00    	jne    81122a <ip_reass_chain_frag_into_datagram_and_validate+0x297>
    if (iprh_prev != NULL) {
  811178:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81117d:	74 68                	je     8111e7 <ip_reass_chain_frag_into_datagram_and_validate+0x254>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  81117f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811183:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81118b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81118f:	66 39 c2             	cmp    %ax,%dx
  811192:	76 2a                	jbe    8111be <ip_reass_chain_frag_into_datagram_and_validate+0x22b>
  811194:	48 ba e7 1a 82 00 00 	movabs $0x821ae7,%rdx
  81119b:	00 00 00 
  81119e:	be 83 01 00 00       	mov    $0x183,%esi
  8111a3:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  8111aa:	00 00 00 
  8111ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8111b2:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8111b9:	00 00 00 
  8111bc:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  8111be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8111c2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8111c6:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  8111c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8111cd:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8111d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111d5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8111d9:	66 39 c2             	cmp    %ax,%dx
  8111dc:	74 4c                	je     81122a <ip_reass_chain_frag_into_datagram_and_validate+0x297>
        valid = 0;
  8111de:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8111e5:	eb 43                	jmp    81122a <ip_reass_chain_frag_into_datagram_and_validate+0x297>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8111e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8111eb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8111ef:	48 85 c0             	test   %rax,%rax
  8111f2:	74 2a                	je     81121e <ip_reass_chain_frag_into_datagram_and_validate+0x28b>
  8111f4:	48 ba 08 1b 82 00 00 	movabs $0x821b08,%rdx
  8111fb:	00 00 00 
  8111fe:	be 8c 01 00 00       	mov    $0x18c,%esi
  811203:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  81120a:	00 00 00 
  81120d:	b8 00 00 00 00       	mov    $0x0,%eax
  811212:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  811219:	00 00 00 
  81121c:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  81121e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811222:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811226:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  81122a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81122e:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811232:	0f b6 c0             	movzbl %al,%eax
  811235:	83 e0 01             	and    $0x1,%eax
  811238:	85 c0                	test   %eax,%eax
  81123a:	0f 84 7b 01 00 00    	je     8113bb <ip_reass_chain_frag_into_datagram_and_validate+0x428>
    /* and had no wholes so far */
    if (valid) {
  811240:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811244:	0f 84 6c 01 00 00    	je     8113b6 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  81124a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81124e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811252:	48 8b 40 08          	mov    0x8(%rax),%rax
  811256:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81125a:	66 85 c0             	test   %ax,%ax
  81125d:	74 0c                	je     81126b <ip_reass_chain_frag_into_datagram_and_validate+0x2d8>
        valid = 0;
  81125f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811266:	e9 4b 01 00 00       	jmpq   8113b6 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  81126b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81126f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811273:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811277:	48 8b 00             	mov    (%rax),%rax
  81127a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  81127e:	eb 3d                	jmp    8112bd <ip_reass_chain_frag_into_datagram_and_validate+0x32a>
          iprh = (struct ip_reass_helper*)q->payload;
  811280:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811284:	48 8b 40 08          	mov    0x8(%rax),%rax
  811288:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  81128c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811290:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811294:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811298:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81129c:	66 39 c2             	cmp    %ax,%dx
  81129f:	74 09                	je     8112aa <ip_reass_chain_frag_into_datagram_and_validate+0x317>
            valid = 0;
  8112a1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  8112a8:	eb 1a                	jmp    8112c4 <ip_reass_chain_frag_into_datagram_and_validate+0x331>
          }
          iprh_prev = iprh;
  8112aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112ae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  8112b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112b6:	48 8b 00             	mov    (%rax),%rax
  8112b9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  8112bd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8112c2:	75 bc                	jne    811280 <ip_reass_chain_frag_into_datagram_and_validate+0x2ed>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  8112c4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8112c8:	0f 84 e8 00 00 00    	je     8113b6 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8112ce:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8112d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8112d6:	48 85 c0             	test   %rax,%rax
  8112d9:	75 2a                	jne    811305 <ip_reass_chain_frag_into_datagram_and_validate+0x372>
  8112db:	48 ba 3f 1b 82 00 00 	movabs $0x821b3f,%rdx
  8112e2:	00 00 00 
  8112e5:	be ac 01 00 00       	mov    $0x1ac,%esi
  8112ea:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  8112f1:	00 00 00 
  8112f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8112f9:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  811300:	00 00 00 
  811303:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811305:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811309:	48 8b 40 08          	mov    0x8(%rax),%rax
  81130d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811311:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811315:	75 2a                	jne    811341 <ip_reass_chain_frag_into_datagram_and_validate+0x3ae>
  811317:	48 ba 3f 1b 82 00 00 	movabs $0x821b3f,%rdx
  81131e:	00 00 00 
  811321:	be ae 01 00 00       	mov    $0x1ae,%esi
  811326:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  81132d:	00 00 00 
  811330:	b8 00 00 00 00       	mov    $0x0,%eax
  811335:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81133c:	00 00 00 
  81133f:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811341:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811345:	48 8b 00             	mov    (%rax),%rax
  811348:	48 85 c0             	test   %rax,%rax
  81134b:	74 2a                	je     811377 <ip_reass_chain_frag_into_datagram_and_validate+0x3e4>
  81134d:	48 ba 50 1b 82 00 00 	movabs $0x821b50,%rdx
  811354:	00 00 00 
  811357:	be b0 01 00 00       	mov    $0x1b0,%esi
  81135c:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  811363:	00 00 00 
  811366:	b8 00 00 00 00       	mov    $0x0,%eax
  81136b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  811372:	00 00 00 
  811375:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  811377:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81137b:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  81137f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811383:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811387:	66 39 c2             	cmp    %ax,%dx
  81138a:	74 2a                	je     8113b6 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
  81138c:	48 ba 78 1b 82 00 00 	movabs $0x821b78,%rdx
  811393:	00 00 00 
  811396:	be b2 01 00 00       	mov    $0x1b2,%esi
  81139b:	48 bf 84 1a 82 00 00 	movabs $0x821a84,%rdi
  8113a2:	00 00 00 
  8113a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8113aa:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8113b1:	00 00 00 
  8113b4:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  8113b6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8113b9:	eb 53                	jmp    81140e <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  8113bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8113c0:	eb 4c                	jmp    81140e <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  8113c2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8113c6:	48 89 c7             	mov    %rax,%rdi
  8113c9:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  8113d0:	00 00 00 
  8113d3:	ff d0                	callq  *%rax
  8113d5:	89 c1                	mov    %eax,%ecx
  8113d7:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  8113de:	00 00 00 
  8113e1:	0f b7 10             	movzwl (%rax),%edx
  8113e4:	0f b6 c1             	movzbl %cl,%eax
  8113e7:	29 c2                	sub    %eax,%edx
  8113e9:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  8113f0:	00 00 00 
  8113f3:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  8113f6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8113fa:	48 89 c7             	mov    %rax,%rdi
  8113fd:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  811404:	00 00 00 
  811407:	ff d0                	callq  *%rax
  return 0;
  811409:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  81140e:	48 83 c4 58          	add    $0x58,%rsp
  811412:	5b                   	pop    %rbx
  811413:	5d                   	pop    %rbp
  811414:	c3                   	retq   

0000000000811415 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  811415:	55                   	push   %rbp
  811416:	48 89 e5             	mov    %rsp,%rbp
  811419:	53                   	push   %rbx
  81141a:	48 83 ec 48          	sub    $0x48,%rsp
  81141e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  811422:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  811429:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  81142a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81142e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811432:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  811436:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81143a:	0f b7 00             	movzwl (%rax),%eax
  81143d:	0f b7 c0             	movzwl %ax,%eax
  811440:	89 c7                	mov    %eax,%edi
  811442:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  811449:	00 00 00 
  81144c:	ff d0                	callq  *%rax
  81144e:	66 c1 e8 08          	shr    $0x8,%ax
  811452:	0f b7 c0             	movzwl %ax,%eax
  811455:	83 e0 0f             	and    $0xf,%eax
  811458:	c1 e0 02             	shl    $0x2,%eax
  81145b:	83 f8 14             	cmp    $0x14,%eax
  81145e:	74 05                	je     811465 <ip_reass+0x50>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  811460:	e9 db 03 00 00       	jmpq   811840 <ip_reass+0x42b>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811465:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811469:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81146d:	0f b7 c0             	movzwl %ax,%eax
  811470:	89 c7                	mov    %eax,%edi
  811472:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  811479:	00 00 00 
  81147c:	ff d0                	callq  *%rax
  81147e:	66 25 ff 1f          	and    $0x1fff,%ax
  811482:	c1 e0 03             	shl    $0x3,%eax
  811485:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811489:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81148d:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811491:	0f b7 c0             	movzwl %ax,%eax
  811494:	89 c7                	mov    %eax,%edi
  811496:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81149d:	00 00 00 
  8114a0:	ff d0                	callq  *%rax
  8114a2:	89 c3                	mov    %eax,%ebx
  8114a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8114a8:	0f b7 00             	movzwl (%rax),%eax
  8114ab:	0f b7 c0             	movzwl %ax,%eax
  8114ae:	89 c7                	mov    %eax,%edi
  8114b0:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8114b7:	00 00 00 
  8114ba:	ff d0                	callq  *%rax
  8114bc:	66 c1 e8 08          	shr    $0x8,%ax
  8114c0:	83 e0 0f             	and    $0xf,%eax
  8114c3:	89 c2                	mov    %eax,%edx
  8114c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8114ca:	29 d0                	sub    %edx,%eax
  8114cc:	c1 e0 02             	shl    $0x2,%eax
  8114cf:	01 d8                	add    %ebx,%eax
  8114d1:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  8114d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8114d9:	48 89 c7             	mov    %rax,%rdi
  8114dc:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  8114e3:	00 00 00 
  8114e6:	ff d0                	callq  *%rax
  8114e8:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  8114eb:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  8114f2:	00 00 00 
  8114f5:	0f b7 00             	movzwl (%rax),%eax
  8114f8:	0f b7 d0             	movzwl %ax,%edx
  8114fb:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8114ff:	01 d0                	add    %edx,%eax
  811501:	83 f8 0a             	cmp    $0xa,%eax
  811504:	7e 3d                	jle    811543 <ip_reass+0x12e>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811506:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  81150a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81150e:	89 d6                	mov    %edx,%esi
  811510:	48 89 c7             	mov    %rax,%rdi
  811513:	48 b8 0b 0d 81 00 00 	movabs $0x810d0b,%rax
  81151a:	00 00 00 
  81151d:	ff d0                	callq  *%rax
  81151f:	85 c0                	test   %eax,%eax
  811521:	74 1b                	je     81153e <ip_reass+0x129>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  811523:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  81152a:	00 00 00 
  81152d:	0f b7 00             	movzwl (%rax),%eax
  811530:	0f b7 d0             	movzwl %ax,%edx
  811533:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811537:	01 d0                	add    %edx,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811539:	83 f8 0a             	cmp    $0xa,%eax
  81153c:	7e 05                	jle    811543 <ip_reass+0x12e>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  81153e:	e9 fd 02 00 00       	jmpq   811840 <ip_reass+0x42b>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811543:	48 b8 80 a0 b4 00 00 	movabs $0xb4a080,%rax
  81154a:	00 00 00 
  81154d:	48 8b 00             	mov    (%rax),%rax
  811550:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811554:	eb 4e                	jmp    8115a4 <ip_reass+0x18f>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  811556:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81155a:	8b 50 1c             	mov    0x1c(%rax),%edx
  81155d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811561:	8b 40 0c             	mov    0xc(%rax),%eax
  811564:	39 c2                	cmp    %eax,%edx
  811566:	75 29                	jne    811591 <ip_reass+0x17c>
  811568:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81156c:	8b 50 20             	mov    0x20(%rax),%edx
  81156f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811573:	8b 40 10             	mov    0x10(%rax),%eax
  811576:	39 c2                	cmp    %eax,%edx
  811578:	75 17                	jne    811591 <ip_reass+0x17c>
  81157a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81157e:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811582:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811586:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  81158a:	66 39 c2             	cmp    %ax,%dx
  81158d:	75 02                	jne    811591 <ip_reass+0x17c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  81158f:	eb 1a                	jmp    8115ab <ip_reass+0x196>
    }
    ipr_prev = ipr;
  811591:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811595:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811599:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81159d:	48 8b 00             	mov    (%rax),%rax
  8115a0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8115a4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8115a9:	75 ab                	jne    811556 <ip_reass+0x141>
  }

  if (ipr == NULL) {
  8115ab:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8115b0:	75 29                	jne    8115db <ip_reass+0x1c6>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  8115b2:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  8115b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8115ba:	89 d6                	mov    %edx,%esi
  8115bc:	48 89 c7             	mov    %rax,%rdi
  8115bf:	48 b8 23 0e 81 00 00 	movabs $0x810e23,%rax
  8115c6:	00 00 00 
  8115c9:	ff d0                	callq  *%rax
  8115cb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  8115cf:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8115d4:	75 72                	jne    811648 <ip_reass+0x233>
      goto nullreturn;
  8115d6:	e9 65 02 00 00       	jmpq   811840 <ip_reass+0x42b>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8115db:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8115df:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8115e3:	0f b7 c0             	movzwl %ax,%eax
  8115e6:	89 c7                	mov    %eax,%edi
  8115e8:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8115ef:	00 00 00 
  8115f2:	ff d0                	callq  *%rax
  8115f4:	0f b7 c0             	movzwl %ax,%eax
  8115f7:	25 ff 1f 00 00       	and    $0x1fff,%eax
  8115fc:	85 c0                	test   %eax,%eax
  8115fe:	75 48                	jne    811648 <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  811600:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811604:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  811608:	0f b7 c0             	movzwl %ax,%eax
  81160b:	89 c7                	mov    %eax,%edi
  81160d:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  811614:	00 00 00 
  811617:	ff d0                	callq  *%rax
  811619:	0f b7 c0             	movzwl %ax,%eax
  81161c:	25 ff 1f 00 00       	and    $0x1fff,%eax
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811621:	85 c0                	test   %eax,%eax
  811623:	74 23                	je     811648 <ip_reass+0x233>
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  811625:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811629:	48 8d 48 10          	lea    0x10(%rax),%rcx
  81162d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811631:	ba 14 00 00 00       	mov    $0x14,%edx
  811636:	48 89 c6             	mov    %rax,%rsi
  811639:	48 89 cf             	mov    %rcx,%rdi
  81163c:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  811643:	00 00 00 
  811646:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  811648:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  81164c:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  811653:	00 00 00 
  811656:	0f b7 00             	movzwl (%rax),%eax
  811659:	01 c2                	add    %eax,%edx
  81165b:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  811662:	00 00 00 
  811665:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  811668:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81166c:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811670:	0f b7 c0             	movzwl %ax,%eax
  811673:	89 c7                	mov    %eax,%edi
  811675:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81167c:	00 00 00 
  81167f:	ff d0                	callq  *%rax
  811681:	0f b7 c0             	movzwl %ax,%eax
  811684:	25 00 20 00 00       	and    $0x2000,%eax
  811689:	85 c0                	test   %eax,%eax
  81168b:	75 26                	jne    8116b3 <ip_reass+0x29e>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  81168d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811691:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811695:	83 c8 01             	or     $0x1,%eax
  811698:	89 c2                	mov    %eax,%edx
  81169a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81169e:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  8116a1:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  8116a5:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  8116a9:	01 c2                	add    %eax,%edx
  8116ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116af:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  8116b3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8116b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116bb:	48 89 d6             	mov    %rdx,%rsi
  8116be:	48 89 c7             	mov    %rax,%rdi
  8116c1:	48 b8 93 0f 81 00 00 	movabs $0x810f93,%rax
  8116c8:	00 00 00 
  8116cb:	ff d0                	callq  *%rax
  8116cd:	85 c0                	test   %eax,%eax
  8116cf:	0f 84 64 01 00 00    	je     811839 <ip_reass+0x424>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  8116d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116d9:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8116dd:	8d 50 14             	lea    0x14(%rax),%edx
  8116e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116e4:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8116e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  8116f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8116f4:	48 8b 00             	mov    (%rax),%rax
  8116f7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  8116fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  811703:	48 8b 40 08          	mov    0x8(%rax),%rax
  811707:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  81170b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81170f:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811713:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811717:	ba 14 00 00 00       	mov    $0x14,%edx
  81171c:	48 89 ce             	mov    %rcx,%rsi
  81171f:	48 89 c7             	mov    %rax,%rdi
  811722:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  811729:	00 00 00 
  81172c:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  81172e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811732:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811736:	0f b7 c0             	movzwl %ax,%eax
  811739:	89 c7                	mov    %eax,%edi
  81173b:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811742:	00 00 00 
  811745:	ff d0                	callq  *%rax
  811747:	89 c2                	mov    %eax,%edx
  811749:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81174d:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_OFFSET_SET(fraghdr, 0);
  811751:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811755:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  81175b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81175f:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  811765:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811769:	be 14 00 00 00       	mov    $0x14,%esi
  81176e:	48 89 c7             	mov    %rax,%rdi
  811771:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  811778:	00 00 00 
  81177b:	ff d0                	callq  *%rax
  81177d:	89 c2                	mov    %eax,%edx
  81177f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811783:	66 89 50 0a          	mov    %dx,0xa(%rax)

    p = ipr->p;
  811787:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81178b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81178f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  811793:	eb 49                	jmp    8117de <ip_reass+0x3c9>
      iprh = (struct ip_reass_helper*)r->payload;
  811795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811799:	48 8b 40 08          	mov    0x8(%rax),%rax
  81179d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  8117a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8117a5:	be ec ff ff ff       	mov    $0xffffffec,%esi
  8117aa:	48 89 c7             	mov    %rax,%rdi
  8117ad:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  8117b4:	00 00 00 
  8117b7:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  8117b9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8117bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8117c1:	48 89 d6             	mov    %rdx,%rsi
  8117c4:	48 89 c7             	mov    %rax,%rdi
  8117c7:	48 b8 68 d3 80 00 00 	movabs $0x80d368,%rax
  8117ce:	00 00 00 
  8117d1:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  8117d3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8117d7:	48 8b 00             	mov    (%rax),%rax
  8117da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    while(r != NULL) {
  8117de:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8117e3:	75 b0                	jne    811795 <ip_reass+0x380>
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8117e5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8117e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8117ed:	48 89 d6             	mov    %rdx,%rsi
  8117f0:	48 89 c7             	mov    %rax,%rdi
  8117f3:	48 b8 01 0f 81 00 00 	movabs $0x810f01,%rax
  8117fa:	00 00 00 
  8117fd:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8117ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811803:	48 89 c7             	mov    %rax,%rdi
  811806:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  81180d:	00 00 00 
  811810:	ff d0                	callq  *%rax
  811812:	89 c1                	mov    %eax,%ecx
  811814:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  81181b:	00 00 00 
  81181e:	0f b7 10             	movzwl (%rax),%edx
  811821:	0f b6 c1             	movzbl %cl,%eax
  811824:	29 c2                	sub    %eax,%edx
  811826:	48 b8 88 a0 b4 00 00 	movabs $0xb4a088,%rax
  81182d:	00 00 00 
  811830:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  811833:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811837:	eb 1f                	jmp    811858 <ip_reass+0x443>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  811839:	b8 00 00 00 00       	mov    $0x0,%eax
  81183e:	eb 18                	jmp    811858 <ip_reass+0x443>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  811840:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811844:	48 89 c7             	mov    %rax,%rdi
  811847:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81184e:	00 00 00 
  811851:	ff d0                	callq  *%rax
  return NULL;
  811853:	b8 00 00 00 00       	mov    $0x0,%eax
}
  811858:	48 83 c4 48          	add    $0x48,%rsp
  81185c:	5b                   	pop    %rbx
  81185d:	5d                   	pop    %rbp
  81185e:	c3                   	retq   

000000000081185f <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  81185f:	55                   	push   %rbp
  811860:	48 89 e5             	mov    %rsp,%rbp
  811863:	48 83 ec 50          	sub    $0x50,%rsp
  811867:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81186b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81186f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  811873:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811877:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81187b:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  81187f:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  811885:	ba 02 00 00 00       	mov    $0x2,%edx
  81188a:	be 00 00 00 00       	mov    $0x0,%esi
  81188f:	bf 02 00 00 00       	mov    $0x2,%edi
  811894:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81189b:	00 00 00 
  81189e:	ff d0                	callq  *%rax
  8118a0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  8118a4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8118a9:	75 0a                	jne    8118b5 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  8118ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8118b0:	e9 85 02 00 00       	jmpq   811b3a <ip_frag+0x2db>
  }
  rambuf->tot_len = rambuf->len = mtu;
  8118b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118b9:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8118bd:	66 89 50 12          	mov    %dx,0x12(%rax)
  8118c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118c5:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8118c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118cd:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8118d1:	48 b8 c0 a0 b4 00 00 	movabs $0xb4a0c0,%rax
  8118d8:	00 00 00 
  8118db:	48 83 c0 03          	add    $0x3,%rax
  8118df:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  8118e3:	48 89 c2             	mov    %rax,%rdx
  8118e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118ea:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  8118ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8118f6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8118fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8118fe:	48 8b 48 08          	mov    0x8(%rax),%rcx
  811902:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811906:	ba 14 00 00 00       	mov    $0x14,%edx
  81190b:	48 89 ce             	mov    %rcx,%rsi
  81190e:	48 89 c7             	mov    %rax,%rdi
  811911:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  811918:	00 00 00 
  81191b:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  81191d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811921:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811925:	0f b7 c0             	movzwl %ax,%eax
  811928:	89 c7                	mov    %eax,%edi
  81192a:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  811931:	00 00 00 
  811934:	ff d0                	callq  *%rax
  811936:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  81193a:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  81193e:	66 25 ff 1f          	and    $0x1fff,%ax
  811942:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  811946:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  81194a:	66 25 00 20          	and    $0x2000,%ax
  81194e:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  811952:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811956:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81195a:	83 e8 14             	sub    $0x14,%eax
  81195d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  811961:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  811965:	83 e8 14             	sub    $0x14,%eax
  811968:	8d 50 07             	lea    0x7(%rax),%edx
  81196b:	85 c0                	test   %eax,%eax
  81196d:	0f 48 c2             	cmovs  %edx,%eax
  811970:	c1 f8 03             	sar    $0x3,%eax
  811973:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  811977:	e9 9b 01 00 00       	jmpq   811b17 <ip_frag+0x2b8>
    last = (left <= mtu - IP_HLEN);
  81197c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  811980:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  811984:	83 ea 14             	sub    $0x14,%edx
  811987:	39 d0                	cmp    %edx,%eax
  811989:	0f 9e c0             	setle  %al
  81198c:	0f b6 c0             	movzbl %al,%eax
  81198f:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  811993:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  811997:	66 25 ff 1f          	and    $0x1fff,%ax
  81199b:	66 0b 45 de          	or     -0x22(%rbp),%ax
  81199f:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  8119a3:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8119a8:	75 06                	jne    8119b0 <ip_frag+0x151>
      tmp = tmp | IP_MF;
  8119aa:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8119b0:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8119b5:	75 09                	jne    8119c0 <ip_frag+0x161>
  8119b7:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8119bb:	c1 e0 03             	shl    $0x3,%eax
  8119be:	eb 04                	jmp    8119c4 <ip_frag+0x165>
  8119c0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8119c4:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8119c8:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  8119cc:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  8119d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8119d4:	48 8d 70 14          	lea    0x14(%rax),%rsi
  8119d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8119dc:	48 89 c7             	mov    %rax,%rdi
  8119df:	48 b8 6b d8 80 00 00 	movabs $0x80d86b,%rax
  8119e6:	00 00 00 
  8119e9:	ff d0                	callq  *%rax
  8119eb:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8119ef:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8119f3:	89 c7                	mov    %eax,%edi
  8119f5:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8119fc:	00 00 00 
  8119ff:	ff d0                	callq  *%rax
  811a01:	89 c2                	mov    %eax,%edx
  811a03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a07:	66 89 50 06          	mov    %dx,0x6(%rax)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  811a0b:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  811a0f:	83 c0 14             	add    $0x14,%eax
  811a12:	0f b7 c0             	movzwl %ax,%eax
  811a15:	89 c7                	mov    %eax,%edi
  811a17:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811a1e:	00 00 00 
  811a21:	ff d0                	callq  *%rax
  811a23:	89 c2                	mov    %eax,%edx
  811a25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a29:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_CHKSUM_SET(iphdr, 0);
  811a2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a31:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811a37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a3b:	be 14 00 00 00       	mov    $0x14,%esi
  811a40:	48 89 c7             	mov    %rax,%rdi
  811a43:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  811a4a:	00 00 00 
  811a4d:	ff d0                	callq  *%rax
  811a4f:	89 c2                	mov    %eax,%edx
  811a51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a55:	66 89 50 0a          	mov    %dx,0xa(%rax)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  811a59:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  811a5e:	74 1f                	je     811a7f <ip_frag+0x220>
      pbuf_realloc(rambuf, left + IP_HLEN);
  811a60:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  811a64:	83 c0 14             	add    $0x14,%eax
  811a67:	0f b7 d0             	movzwl %ax,%edx
  811a6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a6e:	89 d6                	mov    %edx,%esi
  811a70:	48 89 c7             	mov    %rax,%rdi
  811a73:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  811a7a:	00 00 00 
  811a7d:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  811a7f:	ba 00 00 00 00       	mov    $0x0,%edx
  811a84:	be 00 00 00 00       	mov    $0x0,%esi
  811a89:	bf 02 00 00 00       	mov    $0x2,%edi
  811a8e:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  811a95:	00 00 00 
  811a98:	ff d0                	callq  *%rax
  811a9a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  811a9e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811aa3:	74 48                	je     811aed <ip_frag+0x28e>
      pbuf_chain(header, rambuf);
  811aa5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811aa9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811aad:	48 89 d6             	mov    %rdx,%rsi
  811ab0:	48 89 c7             	mov    %rax,%rdi
  811ab3:	48 b8 87 d4 80 00 00 	movabs $0x80d487,%rax
  811aba:	00 00 00 
  811abd:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  811abf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811ac3:	48 8b 40 20          	mov    0x20(%rax),%rax
  811ac7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  811acb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  811acf:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  811ad3:	48 89 cf             	mov    %rcx,%rdi
  811ad6:	ff d0                	callq  *%rax
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  811ad8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811adc:	48 89 c7             	mov    %rax,%rdi
  811adf:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  811ae6:	00 00 00 
  811ae9:	ff d0                	callq  *%rax
  811aeb:	eb 1a                	jmp    811b07 <ip_frag+0x2a8>
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  811aed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811af1:	48 89 c7             	mov    %rax,%rdi
  811af4:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  811afb:	00 00 00 
  811afe:	ff d0                	callq  *%rax
      return ERR_MEM;
  811b00:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  811b05:	eb 33                	jmp    811b3a <ip_frag+0x2db>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  811b07:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  811b0b:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  811b0f:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  811b13:	66 01 45 fc          	add    %ax,-0x4(%rbp)
  while (left) {
  811b17:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  811b1c:	0f 85 5a fe ff ff    	jne    81197c <ip_frag+0x11d>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  811b22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b26:	48 89 c7             	mov    %rax,%rdi
  811b29:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  811b30:	00 00 00 
  811b33:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  811b35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  811b3a:	c9                   	leaveq 
  811b3b:	c3                   	retq   

0000000000811b3c <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  811b3c:	55                   	push   %rbp
  811b3d:	48 89 e5             	mov    %rsp,%rbp
  811b40:	48 83 ec 30          	sub    $0x30,%rsp
  811b44:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811b48:	89 f0                	mov    %esi,%eax
  811b4a:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  811b4e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  811b55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811b59:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  811b5d:	eb 35                	jmp    811b94 <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  811b5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811b63:	0f b6 00             	movzbl (%rax),%eax
  811b66:	0f b6 c0             	movzbl %al,%eax
  811b69:	c1 e0 08             	shl    $0x8,%eax
  811b6c:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  811b70:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  811b75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811b79:	0f b6 00             	movzbl (%rax),%eax
  811b7c:	0f b6 c0             	movzbl %al,%eax
  811b7f:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  811b83:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  811b88:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  811b8c:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  811b8f:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  while (len > 1) {
  811b94:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  811b99:	77 c4                	ja     811b5f <lwip_standard_chksum+0x23>
  }
  if (len > 0) {
  811b9b:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  811ba0:	74 18                	je     811bba <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  811ba2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811ba6:	0f b6 00             	movzbl (%rax),%eax
  811ba9:	0f b6 c0             	movzbl %al,%eax
  811bac:	c1 e0 08             	shl    $0x8,%eax
  811baf:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  811bb3:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  811bb7:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  811bba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811bbd:	c1 e8 10             	shr    $0x10,%eax
  811bc0:	89 c2                	mov    %eax,%edx
  811bc2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811bc5:	0f b7 c0             	movzwl %ax,%eax
  811bc8:	01 d0                	add    %edx,%eax
  811bca:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  811bcd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811bd0:	66 b8 00 00          	mov    $0x0,%ax
  811bd4:	85 c0                	test   %eax,%eax
  811bd6:	74 13                	je     811beb <lwip_standard_chksum+0xaf>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  811bd8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811bdb:	c1 e8 10             	shr    $0x10,%eax
  811bde:	89 c2                	mov    %eax,%edx
  811be0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811be3:	0f b7 c0             	movzwl %ax,%eax
  811be6:	01 d0                	add    %edx,%eax
  811be8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  811beb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811bee:	0f b7 c0             	movzwl %ax,%eax
  811bf1:	89 c7                	mov    %eax,%edi
  811bf3:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811bfa:	00 00 00 
  811bfd:	ff d0                	callq  *%rax
}
  811bff:	c9                   	leaveq 
  811c00:	c3                   	retq   

0000000000811c01 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  811c01:	55                   	push   %rbp
  811c02:	48 89 e5             	mov    %rsp,%rbp
  811c05:	48 83 ec 40          	sub    $0x40,%rsp
  811c09:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811c0d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  811c11:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  811c15:	89 c8                	mov    %ecx,%eax
  811c17:	44 89 c2             	mov    %r8d,%edx
  811c1a:	88 45 c4             	mov    %al,-0x3c(%rbp)
  811c1d:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  811c21:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  811c28:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  811c2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811c30:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  811c34:	eb 7d                	jmp    811cb3 <inet_chksum_pseudo+0xb2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  811c36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811c3a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811c3e:	0f b7 d0             	movzwl %ax,%edx
  811c41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811c45:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c49:	89 d6                	mov    %edx,%esi
  811c4b:	48 89 c7             	mov    %rax,%rdi
  811c4e:	48 b8 3c 1b 81 00 00 	movabs $0x811b3c,%rax
  811c55:	00 00 00 
  811c58:	ff d0                	callq  *%rax
  811c5a:	0f b7 c0             	movzwl %ax,%eax
  811c5d:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  811c60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811c63:	c1 e8 10             	shr    $0x10,%eax
  811c66:	89 c2                	mov    %eax,%edx
  811c68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811c6b:	0f b7 c0             	movzwl %ax,%eax
  811c6e:	01 d0                	add    %edx,%eax
  811c70:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  811c73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811c77:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811c7b:	83 e0 01             	and    $0x1,%eax
  811c7e:	66 85 c0             	test   %ax,%ax
  811c81:	74 25                	je     811ca8 <inet_chksum_pseudo+0xa7>
      swapped = 1 - swapped;
  811c83:	b8 01 00 00 00       	mov    $0x1,%eax
  811c88:	2a 45 ef             	sub    -0x11(%rbp),%al
  811c8b:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  811c8e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811c91:	c1 e0 08             	shl    $0x8,%eax
  811c94:	0f b7 c0             	movzwl %ax,%eax
  811c97:	8b 55 fc             	mov    -0x4(%rbp),%edx
  811c9a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  811ca0:	c1 ea 08             	shr    $0x8,%edx
  811ca3:	09 d0                	or     %edx,%eax
  811ca5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  for(q = p; q != NULL; q = q->next) {
  811ca8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811cac:	48 8b 00             	mov    (%rax),%rax
  811caf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  811cb3:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811cb8:	0f 85 78 ff ff ff    	jne    811c36 <inet_chksum_pseudo+0x35>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  811cbe:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  811cc2:	74 1a                	je     811cde <inet_chksum_pseudo+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  811cc4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811cc7:	c1 e0 08             	shl    $0x8,%eax
  811cca:	0f b7 c0             	movzwl %ax,%eax
  811ccd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  811cd0:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  811cd6:	c1 ea 08             	shr    $0x8,%edx
  811cd9:	09 d0                	or     %edx,%eax
  811cdb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  811cde:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811ce2:	8b 00                	mov    (%rax),%eax
  811ce4:	0f b7 c0             	movzwl %ax,%eax
  811ce7:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  811cea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811cee:	8b 00                	mov    (%rax),%eax
  811cf0:	c1 e8 10             	shr    $0x10,%eax
  811cf3:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  811cf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811cfa:	8b 00                	mov    (%rax),%eax
  811cfc:	0f b7 c0             	movzwl %ax,%eax
  811cff:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  811d02:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811d06:	8b 00                	mov    (%rax),%eax
  811d08:	c1 e8 10             	shr    $0x10,%eax
  811d0b:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  811d0e:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  811d12:	89 c7                	mov    %eax,%edi
  811d14:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811d1b:	00 00 00 
  811d1e:	ff d0                	callq  *%rax
  811d20:	0f b7 c0             	movzwl %ax,%eax
  811d23:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  811d26:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  811d2a:	89 c7                	mov    %eax,%edi
  811d2c:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811d33:	00 00 00 
  811d36:	ff d0                	callq  *%rax
  811d38:	0f b7 c0             	movzwl %ax,%eax
  811d3b:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  811d3e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811d41:	c1 e8 10             	shr    $0x10,%eax
  811d44:	89 c2                	mov    %eax,%edx
  811d46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811d49:	0f b7 c0             	movzwl %ax,%eax
  811d4c:	01 d0                	add    %edx,%eax
  811d4e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  811d51:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811d54:	c1 e8 10             	shr    $0x10,%eax
  811d57:	89 c2                	mov    %eax,%edx
  811d59:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811d5c:	0f b7 c0             	movzwl %ax,%eax
  811d5f:	01 d0                	add    %edx,%eax
  811d61:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  811d64:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811d67:	f7 d0                	not    %eax
}
  811d69:	c9                   	leaveq 
  811d6a:	c3                   	retq   

0000000000811d6b <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  811d6b:	55                   	push   %rbp
  811d6c:	48 89 e5             	mov    %rsp,%rbp
  811d6f:	48 83 ec 50          	sub    $0x50,%rsp
  811d73:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811d77:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  811d7b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  811d7f:	89 c8                	mov    %ecx,%eax
  811d81:	44 89 c1             	mov    %r8d,%ecx
  811d84:	44 89 ca             	mov    %r9d,%edx
  811d87:	88 45 c4             	mov    %al,-0x3c(%rbp)
  811d8a:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  811d8e:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  811d92:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  811d99:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  811d9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811da1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  811da5:	e9 ce 00 00 00       	jmpq   811e78 <inet_chksum_pseudo_partial+0x10d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  811daa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811dae:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811db2:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  811db6:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  811dba:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  811dbe:	76 08                	jbe    811dc8 <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  811dc0:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  811dc4:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  811dc8:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  811dcc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811dd0:	48 8b 40 08          	mov    0x8(%rax),%rax
  811dd4:	89 d6                	mov    %edx,%esi
  811dd6:	48 89 c7             	mov    %rax,%rdi
  811dd9:	48 b8 3c 1b 81 00 00 	movabs $0x811b3c,%rax
  811de0:	00 00 00 
  811de3:	ff d0                	callq  *%rax
  811de5:	0f b7 c0             	movzwl %ax,%eax
  811de8:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  811deb:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  811def:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  811df3:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  811df9:	76 2a                	jbe    811e25 <inet_chksum_pseudo_partial+0xba>
  811dfb:	48 ba a8 1b 82 00 00 	movabs $0x821ba8,%rdx
  811e02:	00 00 00 
  811e05:	be 60 01 00 00       	mov    $0x160,%esi
  811e0a:	48 bf b8 1b 82 00 00 	movabs $0x821bb8,%rdi
  811e11:	00 00 00 
  811e14:	b8 00 00 00 00       	mov    $0x0,%eax
  811e19:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  811e20:	00 00 00 
  811e23:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  811e25:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811e28:	c1 e8 10             	shr    $0x10,%eax
  811e2b:	89 c2                	mov    %eax,%edx
  811e2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811e30:	0f b7 c0             	movzwl %ax,%eax
  811e33:	01 d0                	add    %edx,%eax
  811e35:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  811e38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811e3c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811e40:	83 e0 01             	and    $0x1,%eax
  811e43:	66 85 c0             	test   %ax,%ax
  811e46:	74 25                	je     811e6d <inet_chksum_pseudo_partial+0x102>
      swapped = 1 - swapped;
  811e48:	b8 01 00 00 00       	mov    $0x1,%eax
  811e4d:	2a 45 ef             	sub    -0x11(%rbp),%al
  811e50:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  811e53:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811e56:	c1 e0 08             	shl    $0x8,%eax
  811e59:	0f b7 c0             	movzwl %ax,%eax
  811e5c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  811e5f:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  811e65:	c1 ea 08             	shr    $0x8,%edx
  811e68:	09 d0                	or     %edx,%eax
  811e6a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  811e6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811e71:	48 8b 00             	mov    (%rax),%rax
  811e74:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  811e78:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811e7d:	74 0b                	je     811e8a <inet_chksum_pseudo_partial+0x11f>
  811e7f:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  811e84:	0f 85 20 ff ff ff    	jne    811daa <inet_chksum_pseudo_partial+0x3f>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  811e8a:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  811e8e:	74 1a                	je     811eaa <inet_chksum_pseudo_partial+0x13f>
    acc = SWAP_BYTES_IN_WORD(acc);
  811e90:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811e93:	c1 e0 08             	shl    $0x8,%eax
  811e96:	0f b7 c0             	movzwl %ax,%eax
  811e99:	8b 55 fc             	mov    -0x4(%rbp),%edx
  811e9c:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  811ea2:	c1 ea 08             	shr    $0x8,%edx
  811ea5:	09 d0                	or     %edx,%eax
  811ea7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  811eaa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811eae:	8b 00                	mov    (%rax),%eax
  811eb0:	0f b7 c0             	movzwl %ax,%eax
  811eb3:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  811eb6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811eba:	8b 00                	mov    (%rax),%eax
  811ebc:	c1 e8 10             	shr    $0x10,%eax
  811ebf:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  811ec2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811ec6:	8b 00                	mov    (%rax),%eax
  811ec8:	0f b7 c0             	movzwl %ax,%eax
  811ecb:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  811ece:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811ed2:	8b 00                	mov    (%rax),%eax
  811ed4:	c1 e8 10             	shr    $0x10,%eax
  811ed7:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  811eda:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  811ede:	89 c7                	mov    %eax,%edi
  811ee0:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811ee7:	00 00 00 
  811eea:	ff d0                	callq  *%rax
  811eec:	0f b7 c0             	movzwl %ax,%eax
  811eef:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  811ef2:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  811ef6:	89 c7                	mov    %eax,%edi
  811ef8:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  811eff:	00 00 00 
  811f02:	ff d0                	callq  *%rax
  811f04:	0f b7 c0             	movzwl %ax,%eax
  811f07:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  811f0a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811f0d:	c1 e8 10             	shr    $0x10,%eax
  811f10:	89 c2                	mov    %eax,%edx
  811f12:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811f15:	0f b7 c0             	movzwl %ax,%eax
  811f18:	01 d0                	add    %edx,%eax
  811f1a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  811f1d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811f20:	c1 e8 10             	shr    $0x10,%eax
  811f23:	89 c2                	mov    %eax,%edx
  811f25:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811f28:	0f b7 c0             	movzwl %ax,%eax
  811f2b:	01 d0                	add    %edx,%eax
  811f2d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  811f30:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811f33:	f7 d0                	not    %eax
}
  811f35:	c9                   	leaveq 
  811f36:	c3                   	retq   

0000000000811f37 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  811f37:	55                   	push   %rbp
  811f38:	48 89 e5             	mov    %rsp,%rbp
  811f3b:	48 83 ec 10          	sub    $0x10,%rsp
  811f3f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  811f43:	89 f0                	mov    %esi,%eax
  811f45:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  811f49:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  811f4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811f51:	89 d6                	mov    %edx,%esi
  811f53:	48 89 c7             	mov    %rax,%rdi
  811f56:	48 b8 3c 1b 81 00 00 	movabs $0x811b3c,%rax
  811f5d:	00 00 00 
  811f60:	ff d0                	callq  *%rax
  811f62:	f7 d0                	not    %eax
}
  811f64:	c9                   	leaveq 
  811f65:	c3                   	retq   

0000000000811f66 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  811f66:	55                   	push   %rbp
  811f67:	48 89 e5             	mov    %rsp,%rbp
  811f6a:	48 83 ec 30          	sub    $0x30,%rsp
  811f6e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  811f72:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  811f79:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  811f7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811f81:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  811f85:	eb 7d                	jmp    812004 <inet_chksum_pbuf+0x9e>
    acc += LWIP_CHKSUM(q->payload, q->len);
  811f87:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811f8b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811f8f:	0f b7 d0             	movzwl %ax,%edx
  811f92:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811f96:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f9a:	89 d6                	mov    %edx,%esi
  811f9c:	48 89 c7             	mov    %rax,%rdi
  811f9f:	48 b8 3c 1b 81 00 00 	movabs $0x811b3c,%rax
  811fa6:	00 00 00 
  811fa9:	ff d0                	callq  *%rax
  811fab:	0f b7 c0             	movzwl %ax,%eax
  811fae:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  811fb1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811fb4:	c1 e8 10             	shr    $0x10,%eax
  811fb7:	89 c2                	mov    %eax,%edx
  811fb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811fbc:	0f b7 c0             	movzwl %ax,%eax
  811fbf:	01 d0                	add    %edx,%eax
  811fc1:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  811fc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811fc8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811fcc:	83 e0 01             	and    $0x1,%eax
  811fcf:	66 85 c0             	test   %ax,%ax
  811fd2:	74 25                	je     811ff9 <inet_chksum_pbuf+0x93>
      swapped = 1 - swapped;
  811fd4:	b8 01 00 00 00       	mov    $0x1,%eax
  811fd9:	2a 45 ef             	sub    -0x11(%rbp),%al
  811fdc:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  811fdf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811fe2:	c1 e0 08             	shl    $0x8,%eax
  811fe5:	0f b7 c0             	movzwl %ax,%eax
  811fe8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  811feb:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  811ff1:	c1 ea 08             	shr    $0x8,%edx
  811ff4:	09 d0                	or     %edx,%eax
  811ff6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  for(q = p; q != NULL; q = q->next) {
  811ff9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811ffd:	48 8b 00             	mov    (%rax),%rax
  812000:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812004:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812009:	0f 85 78 ff ff ff    	jne    811f87 <inet_chksum_pbuf+0x21>
    }
  }

  if (swapped) {
  81200f:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812013:	74 1a                	je     81202f <inet_chksum_pbuf+0xc9>
    acc = SWAP_BYTES_IN_WORD(acc);
  812015:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812018:	c1 e0 08             	shl    $0x8,%eax
  81201b:	0f b7 c0             	movzwl %ax,%eax
  81201e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812021:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812027:	c1 ea 08             	shr    $0x8,%edx
  81202a:	09 d0                	or     %edx,%eax
  81202c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  81202f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812032:	f7 d0                	not    %eax
}
  812034:	c9                   	leaveq 
  812035:	c3                   	retq   

0000000000812036 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  812036:	55                   	push   %rbp
  812037:	48 89 e5             	mov    %rsp,%rbp
  81203a:	48 83 ec 20          	sub    $0x20,%rsp
  81203e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  812042:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  812046:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81204a:	48 89 d6             	mov    %rdx,%rsi
  81204d:	48 89 c7             	mov    %rax,%rdi
  812050:	48 b8 6c 20 81 00 00 	movabs $0x81206c,%rax
  812057:	00 00 00 
  81205a:	ff d0                	callq  *%rax
  81205c:	85 c0                	test   %eax,%eax
  81205e:	74 05                	je     812065 <inet_addr+0x2f>
    return (val.s_addr);
  812060:	8b 45 f0             	mov    -0x10(%rbp),%eax
  812063:	eb 05                	jmp    81206a <inet_addr+0x34>
  }
  return (INADDR_NONE);
  812065:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  81206a:	c9                   	leaveq 
  81206b:	c3                   	retq   

000000000081206c <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  81206c:	55                   	push   %rbp
  81206d:	48 89 e5             	mov    %rsp,%rbp
  812070:	48 83 ec 40          	sub    $0x40,%rsp
  812074:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812078:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  81207c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812080:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  c = *cp;
  812084:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812088:	0f b6 00             	movzbl (%rax),%eax
  81208b:	0f be c0             	movsbl %al,%eax
  81208e:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  812091:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812094:	3c 2f                	cmp    $0x2f,%al
  812096:	76 07                	jbe    81209f <inet_aton+0x33>
  812098:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81209b:	3c 39                	cmp    $0x39,%al
  81209d:	76 0a                	jbe    8120a9 <inet_aton+0x3d>
      return (0);
  81209f:	b8 00 00 00 00       	mov    $0x0,%eax
  8120a4:	e9 6e 02 00 00       	jmpq   812317 <inet_aton+0x2ab>
    val = 0;
  8120a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    base = 10;
  8120b0:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
    if (c == '0') {
  8120b7:	83 7d f4 30          	cmpl   $0x30,-0xc(%rbp)
  8120bb:	75 40                	jne    8120fd <inet_aton+0x91>
      c = *++cp;
  8120bd:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  8120c2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8120c6:	0f b6 00             	movzbl (%rax),%eax
  8120c9:	0f be c0             	movsbl %al,%eax
  8120cc:	89 45 f4             	mov    %eax,-0xc(%rbp)
      if (c == 'x' || c == 'X') {
  8120cf:	83 7d f4 78          	cmpl   $0x78,-0xc(%rbp)
  8120d3:	74 06                	je     8120db <inet_aton+0x6f>
  8120d5:	83 7d f4 58          	cmpl   $0x58,-0xc(%rbp)
  8120d9:	75 1b                	jne    8120f6 <inet_aton+0x8a>
        base = 16;
  8120db:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        c = *++cp;
  8120e2:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  8120e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8120eb:	0f b6 00             	movzbl (%rax),%eax
  8120ee:	0f be c0             	movsbl %al,%eax
  8120f1:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8120f4:	eb 07                	jmp    8120fd <inet_aton+0x91>
      } else
        base = 8;
  8120f6:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  8120fd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812100:	3c 2f                	cmp    $0x2f,%al
  812102:	76 2f                	jbe    812133 <inet_aton+0xc7>
  812104:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812107:	3c 39                	cmp    $0x39,%al
  812109:	77 28                	ja     812133 <inet_aton+0xc7>
        val = (val * base) + (int)(c - '0');
  81210b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  81210e:	0f af 45 fc          	imul   -0x4(%rbp),%eax
  812112:	89 c2                	mov    %eax,%edx
  812114:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812117:	01 d0                	add    %edx,%eax
  812119:	83 e8 30             	sub    $0x30,%eax
  81211c:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  81211f:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812124:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812128:	0f b6 00             	movzbl (%rax),%eax
  81212b:	0f be c0             	movsbl %al,%eax
  81212e:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812131:	eb 73                	jmp    8121a6 <inet_aton+0x13a>
      } else if (base == 16 && isxdigit(c)) {
  812133:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
  812137:	75 72                	jne    8121ab <inet_aton+0x13f>
  812139:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81213c:	3c 2f                	cmp    $0x2f,%al
  81213e:	76 07                	jbe    812147 <inet_aton+0xdb>
  812140:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812143:	3c 39                	cmp    $0x39,%al
  812145:	76 1c                	jbe    812163 <inet_aton+0xf7>
  812147:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81214a:	3c 60                	cmp    $0x60,%al
  81214c:	76 07                	jbe    812155 <inet_aton+0xe9>
  81214e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812151:	3c 66                	cmp    $0x66,%al
  812153:	76 0e                	jbe    812163 <inet_aton+0xf7>
  812155:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812158:	3c 40                	cmp    $0x40,%al
  81215a:	76 4f                	jbe    8121ab <inet_aton+0x13f>
  81215c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81215f:	3c 46                	cmp    $0x46,%al
  812161:	77 48                	ja     8121ab <inet_aton+0x13f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  812163:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812166:	c1 e0 04             	shl    $0x4,%eax
  812169:	89 c2                	mov    %eax,%edx
  81216b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81216e:	8d 48 0a             	lea    0xa(%rax),%ecx
  812171:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812174:	3c 60                	cmp    $0x60,%al
  812176:	76 0e                	jbe    812186 <inet_aton+0x11a>
  812178:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81217b:	3c 7a                	cmp    $0x7a,%al
  81217d:	77 07                	ja     812186 <inet_aton+0x11a>
  81217f:	b8 61 00 00 00       	mov    $0x61,%eax
  812184:	eb 05                	jmp    81218b <inet_aton+0x11f>
  812186:	b8 41 00 00 00       	mov    $0x41,%eax
  81218b:	29 c1                	sub    %eax,%ecx
  81218d:	89 c8                	mov    %ecx,%eax
  81218f:	09 d0                	or     %edx,%eax
  812191:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812194:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812199:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81219d:	0f b6 00             	movzbl (%rax),%eax
  8121a0:	0f be c0             	movsbl %al,%eax
  8121a3:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else
        break;
    }
  8121a6:	e9 52 ff ff ff       	jmpq   8120fd <inet_aton+0x91>
    if (c == '.') {
  8121ab:	83 7d f4 2e          	cmpl   $0x2e,-0xc(%rbp)
  8121af:	75 3d                	jne    8121ee <inet_aton+0x182>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  8121b1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8121b5:	48 83 c0 0c          	add    $0xc,%rax
  8121b9:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8121bd:	72 0a                	jb     8121c9 <inet_aton+0x15d>
        return (0);
  8121bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8121c4:	e9 4e 01 00 00       	jmpq   812317 <inet_aton+0x2ab>
      *pp++ = val;
  8121c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8121cd:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8121d1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8121d5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8121d8:	89 10                	mov    %edx,(%rax)
      c = *++cp;
  8121da:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  8121df:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8121e3:	0f b6 00             	movzbl (%rax),%eax
  8121e6:	0f be c0             	movsbl %al,%eax
  8121e9:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8121ec:	eb 09                	jmp    8121f7 <inet_aton+0x18b>
    } else
      break;
  8121ee:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8121ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8121f3:	74 43                	je     812238 <inet_aton+0x1cc>
  8121f5:	eb 05                	jmp    8121fc <inet_aton+0x190>
  }
  8121f7:	e9 95 fe ff ff       	jmpq   812091 <inet_aton+0x25>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8121fc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8121ff:	3c 1f                	cmp    $0x1f,%al
  812201:	76 2b                	jbe    81222e <inet_aton+0x1c2>
  812203:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812206:	84 c0                	test   %al,%al
  812208:	78 24                	js     81222e <inet_aton+0x1c2>
  81220a:	83 7d f4 20          	cmpl   $0x20,-0xc(%rbp)
  81220e:	74 28                	je     812238 <inet_aton+0x1cc>
  812210:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
  812214:	74 22                	je     812238 <inet_aton+0x1cc>
  812216:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  81221a:	74 1c                	je     812238 <inet_aton+0x1cc>
  81221c:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  812220:	74 16                	je     812238 <inet_aton+0x1cc>
  812222:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  812226:	74 10                	je     812238 <inet_aton+0x1cc>
  812228:	83 7d f4 0b          	cmpl   $0xb,-0xc(%rbp)
  81222c:	74 0a                	je     812238 <inet_aton+0x1cc>
    return (0);
  81222e:	b8 00 00 00 00       	mov    $0x0,%eax
  812233:	e9 df 00 00 00       	jmpq   812317 <inet_aton+0x2ab>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812238:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81223c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812240:	48 29 c2             	sub    %rax,%rdx
  812243:	48 89 d0             	mov    %rdx,%rax
  812246:	48 c1 f8 02          	sar    $0x2,%rax
  81224a:	83 c0 01             	add    $0x1,%eax
  81224d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  switch (n) {
  812250:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  812254:	0f 87 98 00 00 00    	ja     8122f2 <inet_aton+0x286>
  81225a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81225d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812264:	00 
  812265:	48 b8 e0 1b 82 00 00 	movabs $0x821be0,%rax
  81226c:	00 00 00 
  81226f:	48 01 d0             	add    %rdx,%rax
  812272:	48 8b 00             	mov    (%rax),%rax
  812275:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812277:	b8 00 00 00 00       	mov    $0x0,%eax
  81227c:	e9 96 00 00 00       	jmpq   812317 <inet_aton+0x2ab>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812281:	81 7d fc ff ff ff 00 	cmpl   $0xffffff,-0x4(%rbp)
  812288:	76 0a                	jbe    812294 <inet_aton+0x228>
      return (0);
  81228a:	b8 00 00 00 00       	mov    $0x0,%eax
  81228f:	e9 83 00 00 00       	jmpq   812317 <inet_aton+0x2ab>
    val |= parts[0] << 24;
  812294:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812297:	c1 e0 18             	shl    $0x18,%eax
  81229a:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  81229d:	eb 53                	jmp    8122f2 <inet_aton+0x286>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  81229f:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  8122a6:	76 07                	jbe    8122af <inet_aton+0x243>
      return (0);
  8122a8:	b8 00 00 00 00       	mov    $0x0,%eax
  8122ad:	eb 68                	jmp    812317 <inet_aton+0x2ab>
    val |= (parts[0] << 24) | (parts[1] << 16);
  8122af:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8122b2:	c1 e0 18             	shl    $0x18,%eax
  8122b5:	89 c2                	mov    %eax,%edx
  8122b7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8122ba:	c1 e0 10             	shl    $0x10,%eax
  8122bd:	09 d0                	or     %edx,%eax
  8122bf:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  8122c2:	eb 2e                	jmp    8122f2 <inet_aton+0x286>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  8122c4:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  8122cb:	76 07                	jbe    8122d4 <inet_aton+0x268>
      return (0);
  8122cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8122d2:	eb 43                	jmp    812317 <inet_aton+0x2ab>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  8122d4:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8122d7:	c1 e0 18             	shl    $0x18,%eax
  8122da:	89 c2                	mov    %eax,%edx
  8122dc:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8122df:	c1 e0 10             	shl    $0x10,%eax
  8122e2:	09 c2                	or     %eax,%edx
  8122e4:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8122e7:	c1 e0 08             	shl    $0x8,%eax
  8122ea:	09 d0                	or     %edx,%eax
  8122ec:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  8122ef:	eb 01                	jmp    8122f2 <inet_aton+0x286>
    break;
  8122f1:	90                   	nop
  }
  if (addr)
  8122f2:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8122f7:	74 19                	je     812312 <inet_aton+0x2a6>
    addr->s_addr = htonl(val);
  8122f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8122fc:	89 c7                	mov    %eax,%edi
  8122fe:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  812305:	00 00 00 
  812308:	ff d0                	callq  *%rax
  81230a:	89 c2                	mov    %eax,%edx
  81230c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812310:	89 10                	mov    %edx,(%rax)
  return (1);
  812312:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812317:	c9                   	leaveq 
  812318:	c3                   	retq   

0000000000812319 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812319:	55                   	push   %rbp
  81231a:	48 89 e5             	mov    %rsp,%rbp
  81231d:	48 83 ec 30          	sub    $0x30,%rsp
  812321:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812324:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812327:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  81232a:	48 b8 a0 a6 b4 00 00 	movabs $0xb4a6a0,%rax
  812331:	00 00 00 
  812334:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  812338:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  81233c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  812340:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  812344:	e9 e0 00 00 00       	jmpq   812429 <inet_ntoa+0x110>
    i = 0;
  812349:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  81234d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812351:	0f b6 08             	movzbl (%rax),%ecx
  812354:	0f b6 d1             	movzbl %cl,%edx
  812357:	89 d0                	mov    %edx,%eax
  812359:	c1 e0 02             	shl    $0x2,%eax
  81235c:	01 d0                	add    %edx,%eax
  81235e:	c1 e0 03             	shl    $0x3,%eax
  812361:	01 d0                	add    %edx,%eax
  812363:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  81236a:	01 d0                	add    %edx,%eax
  81236c:	66 c1 e8 08          	shr    $0x8,%ax
  812370:	c0 e8 03             	shr    $0x3,%al
  812373:	88 45 ed             	mov    %al,-0x13(%rbp)
  812376:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81237a:	89 d0                	mov    %edx,%eax
  81237c:	c1 e0 02             	shl    $0x2,%eax
  81237f:	01 d0                	add    %edx,%eax
  812381:	01 c0                	add    %eax,%eax
  812383:	29 c1                	sub    %eax,%ecx
  812385:	89 c8                	mov    %ecx,%eax
  812387:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  81238a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81238e:	0f b6 00             	movzbl (%rax),%eax
  812391:	0f b6 d0             	movzbl %al,%edx
  812394:	89 d0                	mov    %edx,%eax
  812396:	c1 e0 02             	shl    $0x2,%eax
  812399:	01 d0                	add    %edx,%eax
  81239b:	c1 e0 03             	shl    $0x3,%eax
  81239e:	01 d0                	add    %edx,%eax
  8123a0:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  8123a7:	01 d0                	add    %edx,%eax
  8123a9:	66 c1 e8 08          	shr    $0x8,%ax
  8123ad:	89 c2                	mov    %eax,%edx
  8123af:	c0 ea 03             	shr    $0x3,%dl
  8123b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8123b6:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  8123b8:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  8123bc:	8d 50 01             	lea    0x1(%rax),%edx
  8123bf:	88 55 ee             	mov    %dl,-0x12(%rbp)
  8123c2:	0f b6 c0             	movzbl %al,%eax
  8123c5:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  8123c9:	83 c2 30             	add    $0x30,%edx
  8123cc:	48 98                	cltq   
  8123ce:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
    } while(*ap);
  8123d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8123d6:	0f b6 00             	movzbl (%rax),%eax
  8123d9:	84 c0                	test   %al,%al
  8123db:	0f 85 6c ff ff ff    	jne    81234d <inet_ntoa+0x34>
    while(i--)
  8123e1:	eb 1a                	jmp    8123fd <inet_ntoa+0xe4>
      *rp++ = inv[i];
  8123e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8123e7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8123eb:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  8123ef:	0f b6 55 ee          	movzbl -0x12(%rbp),%edx
  8123f3:	48 63 d2             	movslq %edx,%rdx
  8123f6:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  8123fb:	88 10                	mov    %dl,(%rax)
    while(i--)
  8123fd:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812401:	8d 50 ff             	lea    -0x1(%rax),%edx
  812404:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812407:	84 c0                	test   %al,%al
  812409:	75 d8                	jne    8123e3 <inet_ntoa+0xca>
    *rp++ = '.';
  81240b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81240f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812413:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812417:	c6 00 2e             	movb   $0x2e,(%rax)
    ap++;
  81241a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  81241f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  812423:	83 c0 01             	add    $0x1,%eax
  812426:	88 45 ef             	mov    %al,-0x11(%rbp)
  812429:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  81242d:	0f 86 16 ff ff ff    	jbe    812349 <inet_ntoa+0x30>
  }
  *--rp = 0;
  812433:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  812438:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81243c:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  81243f:	48 b8 a0 a6 b4 00 00 	movabs $0xb4a6a0,%rax
  812446:	00 00 00 
}
  812449:	c9                   	leaveq 
  81244a:	c3                   	retq   

000000000081244b <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  81244b:	55                   	push   %rbp
  81244c:	48 89 e5             	mov    %rsp,%rbp
  81244f:	48 83 ec 08          	sub    $0x8,%rsp
  812453:	89 f8                	mov    %edi,%eax
  812455:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  812459:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  81245d:	c1 e0 08             	shl    $0x8,%eax
  812460:	89 c2                	mov    %eax,%edx
  812462:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812466:	66 c1 e8 08          	shr    $0x8,%ax
  81246a:	09 d0                	or     %edx,%eax
}
  81246c:	c9                   	leaveq 
  81246d:	c3                   	retq   

000000000081246e <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  81246e:	55                   	push   %rbp
  81246f:	48 89 e5             	mov    %rsp,%rbp
  812472:	48 83 ec 08          	sub    $0x8,%rsp
  812476:	89 f8                	mov    %edi,%eax
  812478:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  81247c:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812480:	89 c7                	mov    %eax,%edi
  812482:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812489:	00 00 00 
  81248c:	ff d0                	callq  *%rax
}
  81248e:	c9                   	leaveq 
  81248f:	c3                   	retq   

0000000000812490 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  812490:	55                   	push   %rbp
  812491:	48 89 e5             	mov    %rsp,%rbp
  812494:	48 83 ec 08          	sub    $0x8,%rsp
  812498:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  81249b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81249e:	c1 e0 18             	shl    $0x18,%eax
  8124a1:	89 c2                	mov    %eax,%edx
    ((n & 0xff00) << 8) |
  8124a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124a6:	25 00 ff 00 00       	and    $0xff00,%eax
  8124ab:	c1 e0 08             	shl    $0x8,%eax
  return ((n & 0xff) << 24) |
  8124ae:	09 c2                	or     %eax,%edx
    ((n & 0xff0000UL) >> 8) |
  8124b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124b3:	25 00 00 ff 00       	and    $0xff0000,%eax
  8124b8:	48 c1 e8 08          	shr    $0x8,%rax
  return ((n & 0xff) << 24) |
  8124bc:	09 c2                	or     %eax,%edx
    ((n & 0xff000000UL) >> 24);
  8124be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124c1:	c1 e8 18             	shr    $0x18,%eax
  return ((n & 0xff) << 24) |
  8124c4:	09 d0                	or     %edx,%eax
}
  8124c6:	c9                   	leaveq 
  8124c7:	c3                   	retq   

00000000008124c8 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  8124c8:	55                   	push   %rbp
  8124c9:	48 89 e5             	mov    %rsp,%rbp
  8124cc:	48 83 ec 08          	sub    $0x8,%rsp
  8124d0:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  8124d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124d6:	89 c7                	mov    %eax,%edi
  8124d8:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  8124df:	00 00 00 
  8124e2:	ff d0                	callq  *%rax
}
  8124e4:	c9                   	leaveq 
  8124e5:	c3                   	retq   

00000000008124e6 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  8124e6:	55                   	push   %rbp
  8124e7:	48 89 e5             	mov    %rsp,%rbp
  8124ea:	48 83 ec 10          	sub    $0x10,%rsp
  8124ee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8124f2:	89 f0                	mov    %esi,%eax
  8124f4:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8124f7:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  8124fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8124ff:	48 83 ec 08          	sub    $0x8,%rsp
  812503:	6a 00                	pushq  $0x0
  812505:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  81250b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  812511:	89 d1                	mov    %edx,%ecx
  812513:	ba 00 00 00 00       	mov    $0x0,%edx
  812518:	be 00 00 00 00       	mov    $0x0,%esi
  81251d:	48 89 c7             	mov    %rax,%rdi
  812520:	48 b8 c9 25 81 00 00 	movabs $0x8125c9,%rax
  812527:	00 00 00 
  81252a:	ff d0                	callq  *%rax
  81252c:	48 83 c4 10          	add    $0x10,%rsp
}
  812530:	c9                   	leaveq 
  812531:	c3                   	retq   

0000000000812532 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  812532:	55                   	push   %rbp
  812533:	48 89 e5             	mov    %rsp,%rbp
  812536:	48 83 ec 20          	sub    $0x20,%rsp
  81253a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81253e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  812542:	89 c8                	mov    %ecx,%eax
  812544:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  812548:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  81254b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81254f:	8b 40 18             	mov    0x18(%rax),%eax
  812552:	83 f8 04             	cmp    $0x4,%eax
  812555:	74 24                	je     81257b <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  812557:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81255b:	8b 40 18             	mov    0x18(%rax),%eax
  if (pcb->state == ESTABLISHED ||
  81255e:	83 f8 07             	cmp    $0x7,%eax
  812561:	74 18                	je     81257b <tcp_write+0x49>
     pcb->state == SYN_SENT ||
  812563:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812567:	8b 40 18             	mov    0x18(%rax),%eax
     pcb->state == CLOSE_WAIT ||
  81256a:	83 f8 02             	cmp    $0x2,%eax
  81256d:	74 0c                	je     81257b <tcp_write+0x49>
     pcb->state == SYN_RCVD) {
  81256f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812573:	8b 40 18             	mov    0x18(%rax),%eax
     pcb->state == SYN_SENT ||
  812576:	83 f8 03             	cmp    $0x3,%eax
  812579:	75 47                	jne    8125c2 <tcp_write+0x90>
    if (len > 0) {
  81257b:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  812580:	74 39                	je     8125bb <tcp_write+0x89>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  812582:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  812586:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  81258a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81258e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812592:	48 83 ec 08          	sub    $0x8,%rsp
  812596:	6a 00                	pushq  $0x0
  812598:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  81259e:	41 89 c8             	mov    %ecx,%r8d
  8125a1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8125a6:	48 89 c7             	mov    %rax,%rdi
  8125a9:	48 b8 c9 25 81 00 00 	movabs $0x8125c9,%rax
  8125b0:	00 00 00 
  8125b3:	ff d0                	callq  *%rax
  8125b5:	48 83 c4 10          	add    $0x10,%rsp
  8125b9:	eb 0c                	jmp    8125c7 <tcp_write+0x95>
    }
    return ERR_OK;
  8125bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8125c0:	eb 05                	jmp    8125c7 <tcp_write+0x95>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  8125c2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  8125c7:	c9                   	leaveq 
  8125c8:	c3                   	retq   

00000000008125c9 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  8125c9:	55                   	push   %rbp
  8125ca:	48 89 e5             	mov    %rsp,%rbp
  8125cd:	41 54                	push   %r12
  8125cf:	53                   	push   %rbx
  8125d0:	48 83 ec 70          	sub    $0x70,%rsp
  8125d4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8125d8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8125dc:	89 d6                	mov    %edx,%esi
  8125de:	89 ca                	mov    %ecx,%edx
  8125e0:	44 89 c1             	mov    %r8d,%ecx
  8125e3:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  8125e7:	8b 45 10             	mov    0x10(%rbp),%eax
  8125ea:	66 89 75 9c          	mov    %si,-0x64(%rbp)
  8125ee:	88 55 98             	mov    %dl,-0x68(%rbp)
  8125f1:	88 4d 94             	mov    %cl,-0x6c(%rbp)
  8125f4:	88 45 90             	mov    %al,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  8125f7:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  8125fc:	74 30                	je     81262e <tcp_enqueue+0x65>
  8125fe:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  812602:	74 2a                	je     81262e <tcp_enqueue+0x65>
  812604:	48 ba 08 1c 82 00 00 	movabs $0x821c08,%rdx
  81260b:	00 00 00 
  81260e:	be 90 00 00 00       	mov    $0x90,%esi
  812613:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  81261a:	00 00 00 
  81261d:	b8 00 00 00 00       	mov    $0x0,%eax
  812622:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812629:	00 00 00 
  81262c:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  81262e:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  812633:	74 31                	je     812666 <tcp_enqueue+0x9d>
  812635:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81263a:	74 2a                	je     812666 <tcp_enqueue+0x9d>
  81263c:	48 ba 60 1c 82 00 00 	movabs $0x821c60,%rdx
  812643:	00 00 00 
  812646:	be 92 00 00 00       	mov    $0x92,%esi
  81264b:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  812652:	00 00 00 
  812655:	b8 00 00 00 00       	mov    $0x0,%eax
  81265a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812661:	00 00 00 
  812664:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  812666:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81266a:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81266e:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  812672:	73 1e                	jae    812692 <tcp_enqueue+0xc9>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  812674:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812678:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81267c:	83 c8 80             	or     $0xffffff80,%eax
  81267f:	89 c2                	mov    %eax,%edx
  812681:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812685:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812688:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81268d:	e9 ee 09 00 00       	jmpq   813080 <tcp_enqueue+0xab7>
  }
  left = len;
  812692:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  812696:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  81269a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81269e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8126a2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8126a6:	8b 40 74             	mov    0x74(%rax),%eax
  8126a9:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8126ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8126b0:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  8126b4:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8126b8:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  8126bd:	77 07                	ja     8126c6 <tcp_enqueue+0xfd>
  8126bf:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  8126c4:	76 1e                	jbe    8126e4 <tcp_enqueue+0x11b>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  8126c6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8126ca:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8126ce:	83 c8 80             	or     $0xffffff80,%eax
  8126d1:	89 c2                	mov    %eax,%edx
  8126d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8126d7:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  8126da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8126df:	e9 9c 09 00 00       	jmpq   813080 <tcp_enqueue+0xab7>
  }
  if (queuelen != 0) {
  8126e4:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  8126e9:	74 4e                	je     812739 <tcp_enqueue+0x170>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8126eb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8126ef:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8126f6:	48 85 c0             	test   %rax,%rax
  8126f9:	0f 85 84 00 00 00    	jne    812783 <tcp_enqueue+0x1ba>
  8126ff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812703:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81270a:	48 85 c0             	test   %rax,%rax
  81270d:	75 74                	jne    812783 <tcp_enqueue+0x1ba>
  81270f:	48 ba a8 1c 82 00 00 	movabs $0x821ca8,%rdx
  812716:	00 00 00 
  812719:	be ae 00 00 00       	mov    $0xae,%esi
  81271e:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  812725:	00 00 00 
  812728:	b8 00 00 00 00       	mov    $0x0,%eax
  81272d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812734:	00 00 00 
  812737:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  812739:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81273d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812744:	48 85 c0             	test   %rax,%rax
  812747:	75 10                	jne    812759 <tcp_enqueue+0x190>
  812749:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81274d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812754:	48 85 c0             	test   %rax,%rax
  812757:	74 2a                	je     812783 <tcp_enqueue+0x1ba>
  812759:	48 ba e8 1c 82 00 00 	movabs $0x821ce8,%rdx
  812760:	00 00 00 
  812763:	be b1 00 00 00       	mov    $0xb1,%esi
  812768:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  81276f:	00 00 00 
  812772:	b8 00 00 00 00       	mov    $0x0,%eax
  812777:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81277e:	00 00 00 
  812781:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  812783:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81278a:	00 
  81278b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81278f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  812793:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812797:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  81279b:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  8127a1:	e9 02 05 00 00       	jmpq   812ca8 <tcp_enqueue+0x6df>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  8127a6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8127aa:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  8127ae:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  8127b2:	66 39 c2             	cmp    %ax,%dx
  8127b5:	0f 46 c2             	cmovbe %edx,%eax
  8127b8:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8127bc:	bf 04 00 00 00       	mov    $0x4,%edi
  8127c1:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  8127c8:	00 00 00 
  8127cb:	ff d0                	callq  *%rax
  8127cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  8127d1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8127d6:	75 05                	jne    8127dd <tcp_enqueue+0x214>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  8127d8:	e9 19 08 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
    }
    seg->next = NULL;
  8127dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8127e1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  8127e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8127ec:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8127f3:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  8127f4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8127f9:	75 0a                	jne    812805 <tcp_enqueue+0x23c>
      queue = seg;
  8127fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8127ff:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  812803:	eb 3c                	jmp    812841 <tcp_enqueue+0x278>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  812805:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81280a:	75 2a                	jne    812836 <tcp_enqueue+0x26d>
  81280c:	48 ba 1c 1d 82 00 00 	movabs $0x821d1c,%rdx
  812813:	00 00 00 
  812816:	be ce 00 00 00       	mov    $0xce,%esi
  81281b:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  812822:	00 00 00 
  812825:	b8 00 00 00 00       	mov    $0x0,%eax
  81282a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812831:	00 00 00 
  812834:	ff d1                	callq  *%rcx
      useg->next = seg;
  812836:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81283a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81283e:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  812841:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812845:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  812849:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81284e:	0f 84 af 00 00 00    	je     812903 <tcp_enqueue+0x33a>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  812854:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  812858:	ba 00 00 00 00       	mov    $0x0,%edx
  81285d:	89 c6                	mov    %eax,%esi
  81285f:	bf 00 00 00 00       	mov    $0x0,%edi
  812864:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81286b:	00 00 00 
  81286e:	ff d0                	callq  *%rax
  812870:	48 89 c2             	mov    %rax,%rdx
  812873:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812877:	48 89 50 08          	mov    %rdx,0x8(%rax)
  81287b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81287f:	48 8b 40 08          	mov    0x8(%rax),%rax
  812883:	48 85 c0             	test   %rax,%rax
  812886:	75 05                	jne    81288d <tcp_enqueue+0x2c4>
        goto memerr;
  812888:	e9 69 07 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  81288d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812891:	48 8b 40 08          	mov    0x8(%rax),%rax
  812895:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  812899:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  81289d:	66 39 c2             	cmp    %ax,%dx
  8128a0:	73 2a                	jae    8128cc <tcp_enqueue+0x303>
  8128a2:	48 ba 30 1d 82 00 00 	movabs $0x821d30,%rdx
  8128a9:	00 00 00 
  8128ac:	be df 00 00 00       	mov    $0xdf,%esi
  8128b1:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  8128b8:	00 00 00 
  8128bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8128c0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8128c7:	00 00 00 
  8128ca:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8128cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8128d0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8128d4:	48 89 c7             	mov    %rax,%rdi
  8128d7:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  8128de:	00 00 00 
  8128e1:	ff d0                	callq  *%rax
  8128e3:	0f b6 c0             	movzbl %al,%eax
  8128e6:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  8128ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8128ee:	48 8b 40 08          	mov    0x8(%rax),%rax
  8128f2:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8128f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8128fa:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8128fe:	e9 c0 01 00 00       	jmpq   812ac3 <tcp_enqueue+0x4fa>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  812903:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  812907:	83 e0 01             	and    $0x1,%eax
  81290a:	85 c0                	test   %eax,%eax
  81290c:	0f 84 d9 00 00 00    	je     8129eb <tcp_enqueue+0x422>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  812912:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  812916:	ba 00 00 00 00       	mov    $0x0,%edx
  81291b:	89 c6                	mov    %eax,%esi
  81291d:	bf 00 00 00 00       	mov    $0x0,%edi
  812922:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  812929:	00 00 00 
  81292c:	ff d0                	callq  *%rax
  81292e:	48 89 c2             	mov    %rax,%rdx
  812931:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812935:	48 89 50 08          	mov    %rdx,0x8(%rax)
  812939:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81293d:	48 8b 40 08          	mov    0x8(%rax),%rax
  812941:	48 85 c0             	test   %rax,%rax
  812944:	75 05                	jne    81294b <tcp_enqueue+0x382>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  812946:	e9 ab 06 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  81294b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81294f:	48 8b 40 08          	mov    0x8(%rax),%rax
  812953:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812957:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  81295b:	73 2a                	jae    812987 <tcp_enqueue+0x3be>
  81295d:	48 ba 58 1d 82 00 00 	movabs $0x821d58,%rdx
  812964:	00 00 00 
  812967:	be ea 00 00 00       	mov    $0xea,%esi
  81296c:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  812973:	00 00 00 
  812976:	b8 00 00 00 00       	mov    $0x0,%eax
  81297b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812982:	00 00 00 
  812985:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  812987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81298b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81298f:	48 89 c7             	mov    %rax,%rdi
  812992:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  812999:	00 00 00 
  81299c:	ff d0                	callq  *%rax
  81299e:	0f b6 c0             	movzbl %al,%eax
  8129a1:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  8129a5:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8129aa:	74 26                	je     8129d2 <tcp_enqueue+0x409>
        MEMCPY(seg->p->payload, ptr, seglen);
  8129ac:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  8129b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8129b4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8129b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8129bc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8129c0:	48 89 ce             	mov    %rcx,%rsi
  8129c3:	48 89 c7             	mov    %rax,%rdi
  8129c6:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  8129cd:	00 00 00 
  8129d0:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  8129d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8129d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8129da:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8129de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8129e2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8129e6:	e9 d8 00 00 00       	jmpq   812ac3 <tcp_enqueue+0x4fa>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  8129eb:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8129ef:	ba 01 00 00 00       	mov    $0x1,%edx
  8129f4:	89 c6                	mov    %eax,%esi
  8129f6:	bf 00 00 00 00       	mov    $0x0,%edi
  8129fb:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  812a02:	00 00 00 
  812a05:	ff d0                	callq  *%rax
  812a07:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  812a0b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  812a10:	75 05                	jne    812a17 <tcp_enqueue+0x44e>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  812a12:	e9 df 05 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
      }
      ++queuelen;
  812a17:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  812a1c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812a20:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  812a24:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  812a28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812a2c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  812a30:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  812a34:	ba 00 00 00 00       	mov    $0x0,%edx
  812a39:	be 00 00 00 00       	mov    $0x0,%esi
  812a3e:	bf 00 00 00 00       	mov    $0x0,%edi
  812a43:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  812a4a:	00 00 00 
  812a4d:	ff d0                	callq  *%rax
  812a4f:	48 89 c2             	mov    %rax,%rdx
  812a52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812a56:	48 89 50 08          	mov    %rdx,0x8(%rax)
  812a5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812a5e:	48 8b 40 08          	mov    0x8(%rax),%rax
  812a62:	48 85 c0             	test   %rax,%rax
  812a65:	75 18                	jne    812a7f <tcp_enqueue+0x4b6>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  812a67:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812a6b:	48 89 c7             	mov    %rax,%rdi
  812a6e:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  812a75:	00 00 00 
  812a78:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  812a7a:	e9 77 05 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
      }
      queuelen += pbuf_clen(seg->p);
  812a7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812a83:	48 8b 40 08          	mov    0x8(%rax),%rax
  812a87:	48 89 c7             	mov    %rax,%rdi
  812a8a:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  812a91:	00 00 00 
  812a94:	ff d0                	callq  *%rax
  812a96:	0f b6 c0             	movzbl %al,%eax
  812a99:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  812a9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812aa1:	48 8b 40 08          	mov    0x8(%rax),%rax
  812aa5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  812aa9:	48 89 d6             	mov    %rdx,%rsi
  812aac:	48 89 c7             	mov    %rax,%rdi
  812aaf:	48 b8 68 d3 80 00 00 	movabs $0x80d368,%rax
  812ab6:	00 00 00 
  812ab9:	ff d0                	callq  *%rax
      p = NULL;
  812abb:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  812ac2:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  812ac3:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  812ac8:	77 07                	ja     812ad1 <tcp_enqueue+0x508>
  812aca:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  812acf:	76 05                	jbe    812ad6 <tcp_enqueue+0x50d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  812ad1:	e9 20 05 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
    }

    seg->len = seglen;
  812ad6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812ada:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  812ade:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  812ae2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812ae6:	48 8b 40 08          	mov    0x8(%rax),%rax
  812aea:	be 14 00 00 00       	mov    $0x14,%esi
  812aef:	48 89 c7             	mov    %rax,%rdi
  812af2:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  812af9:	00 00 00 
  812afc:	ff d0                	callq  *%rax
  812afe:	84 c0                	test   %al,%al
  812b00:	74 05                	je     812b07 <tcp_enqueue+0x53e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  812b02:	e9 ef 04 00 00       	jmpq   812ff6 <tcp_enqueue+0xa2d>
    }
    seg->tcphdr = seg->p->payload;
  812b07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b0b:	48 8b 40 08          	mov    0x8(%rax),%rax
  812b0f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  812b13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b17:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  812b1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b1f:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812b23:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812b27:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  812b2b:	0f b7 c0             	movzwl %ax,%eax
  812b2e:	89 c7                	mov    %eax,%edi
  812b30:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812b37:	00 00 00 
  812b3a:	ff d0                	callq  *%rax
  812b3c:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  812b3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b43:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812b47:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812b4b:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  812b4f:	0f b7 c0             	movzwl %ax,%eax
  812b52:	89 c7                	mov    %eax,%edi
  812b54:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812b5b:	00 00 00 
  812b5e:	ff d0                	callq  *%rax
  812b60:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  812b64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b68:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812b6c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812b6f:	89 c7                	mov    %eax,%edi
  812b71:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  812b78:	00 00 00 
  812b7b:	ff d0                	callq  *%rax
  812b7d:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  812b80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b84:	48 8b 40 20          	mov    0x20(%rax),%rax
  812b88:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  812b8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b92:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812b96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812b9a:	48 8b 40 20          	mov    0x20(%rax),%rax
  812b9e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812ba2:	0f b7 c0             	movzwl %ax,%eax
  812ba5:	89 c7                	mov    %eax,%edi
  812ba7:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812bae:	00 00 00 
  812bb1:	ff d0                	callq  *%rax
  812bb3:	83 e0 c0             	and    $0xffffffc0,%eax
  812bb6:	89 c2                	mov    %eax,%edx
  812bb8:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  812bbc:	09 d0                	or     %edx,%eax
  812bbe:	0f b7 c0             	movzwl %ax,%eax
  812bc1:	89 c7                	mov    %eax,%edi
  812bc3:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812bca:	00 00 00 
  812bcd:	ff d0                	callq  *%rax
  812bcf:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  812bd3:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  812bd8:	75 42                	jne    812c1c <tcp_enqueue+0x653>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  812bda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812bde:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812be2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812be6:	48 8b 40 20          	mov    0x20(%rax),%rax
  812bea:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812bee:	0f b7 c0             	movzwl %ax,%eax
  812bf1:	89 c7                	mov    %eax,%edi
  812bf3:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812bfa:	00 00 00 
  812bfd:	ff d0                	callq  *%rax
  812bff:	83 e0 3f             	and    $0x3f,%eax
  812c02:	80 cc 50             	or     $0x50,%ah
  812c05:	0f b7 c0             	movzwl %ax,%eax
  812c08:	89 c7                	mov    %eax,%edi
  812c0a:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812c11:	00 00 00 
  812c14:	ff d0                	callq  *%rax
  812c16:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  812c1a:	eb 75                	jmp    812c91 <tcp_enqueue+0x6c8>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  812c1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812c20:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812c24:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  812c28:	c0 e8 02             	shr    $0x2,%al
  812c2b:	0f b6 c0             	movzbl %al,%eax
  812c2e:	83 c0 05             	add    $0x5,%eax
  812c31:	c1 e0 0c             	shl    $0xc,%eax
  812c34:	41 89 c4             	mov    %eax,%r12d
  812c37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812c3b:	48 8b 40 20          	mov    0x20(%rax),%rax
  812c3f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812c43:	0f b7 c0             	movzwl %ax,%eax
  812c46:	89 c7                	mov    %eax,%edi
  812c48:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812c4f:	00 00 00 
  812c52:	ff d0                	callq  *%rax
  812c54:	83 e0 3f             	and    $0x3f,%eax
  812c57:	44 09 e0             	or     %r12d,%eax
  812c5a:	0f b7 c0             	movzwl %ax,%eax
  812c5d:	89 c7                	mov    %eax,%edi
  812c5f:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812c66:	00 00 00 
  812c69:	ff d0                	callq  *%rax
  812c6b:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  812c6f:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  812c73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812c77:	48 8b 40 10          	mov    0x10(%rax),%rax
  812c7b:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  812c7f:	48 89 ce             	mov    %rcx,%rsi
  812c82:	48 89 c7             	mov    %rax,%rdi
  812c85:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  812c8c:	00 00 00 
  812c8f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  812c91:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  812c95:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  812c99:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  812c9d:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  812ca0:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  812ca4:	48 01 45 c8          	add    %rax,-0x38(%rbp)
  while (queue == NULL || left > 0) {
  812ca8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  812cad:	0f 84 f3 fa ff ff    	je     8127a6 <tcp_enqueue+0x1dd>
  812cb3:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  812cb8:	0f 85 e8 fa ff ff    	jne    8127a6 <tcp_enqueue+0x1dd>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  812cbe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812cc2:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812cc9:	48 85 c0             	test   %rax,%rax
  812ccc:	75 0a                	jne    812cd8 <tcp_enqueue+0x70f>
    useg = NULL;
  812cce:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  812cd5:	00 
  812cd6:	eb 28                	jmp    812d00 <tcp_enqueue+0x737>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  812cd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812cdc:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812ce3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812ce7:	eb 0b                	jmp    812cf4 <tcp_enqueue+0x72b>
  812ce9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812ced:	48 8b 00             	mov    (%rax),%rax
  812cf0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812cf4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812cf8:	48 8b 00             	mov    (%rax),%rax
  812cfb:	48 85 c0             	test   %rax,%rax
  812cfe:	75 e9                	jne    812ce9 <tcp_enqueue+0x720>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  812d00:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812d05:	0f 84 94 01 00 00    	je     812e9f <tcp_enqueue+0x8d6>
    TCP_TCPLEN(useg) != 0 &&
  812d0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812d0f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  812d13:	0f b7 d8             	movzwl %ax,%ebx
  812d16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812d1a:	48 8b 40 20          	mov    0x20(%rax),%rax
  812d1e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812d22:	0f b7 c0             	movzwl %ax,%eax
  812d25:	89 c7                	mov    %eax,%edi
  812d27:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812d2e:	00 00 00 
  812d31:	ff d0                	callq  *%rax
  812d33:	0f b7 c0             	movzwl %ax,%eax
  812d36:	83 e0 01             	and    $0x1,%eax
  812d39:	85 c0                	test   %eax,%eax
  812d3b:	75 27                	jne    812d64 <tcp_enqueue+0x79b>
  812d3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812d41:	48 8b 40 20          	mov    0x20(%rax),%rax
  812d45:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812d49:	0f b7 c0             	movzwl %ax,%eax
  812d4c:	89 c7                	mov    %eax,%edi
  812d4e:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812d55:	00 00 00 
  812d58:	ff d0                	callq  *%rax
  812d5a:	0f b7 c0             	movzwl %ax,%eax
  812d5d:	83 e0 02             	and    $0x2,%eax
  812d60:	85 c0                	test   %eax,%eax
  812d62:	74 07                	je     812d6b <tcp_enqueue+0x7a2>
  812d64:	b8 01 00 00 00       	mov    $0x1,%eax
  812d69:	eb 05                	jmp    812d70 <tcp_enqueue+0x7a7>
  812d6b:	b8 00 00 00 00       	mov    $0x0,%eax
  812d70:	01 d8                	add    %ebx,%eax
  if (useg != NULL &&
  812d72:	85 c0                	test   %eax,%eax
  812d74:	0f 84 25 01 00 00    	je     812e9f <tcp_enqueue+0x8d6>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  812d7a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812d7e:	48 8b 40 20          	mov    0x20(%rax),%rax
  812d82:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812d86:	0f b7 c0             	movzwl %ax,%eax
  812d89:	89 c7                	mov    %eax,%edi
  812d8b:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812d92:	00 00 00 
  812d95:	ff d0                	callq  *%rax
  812d97:	0f b7 c0             	movzwl %ax,%eax
  812d9a:	83 e0 03             	and    $0x3,%eax
    TCP_TCPLEN(useg) != 0 &&
  812d9d:	85 c0                	test   %eax,%eax
  812d9f:	0f 85 fa 00 00 00    	jne    812e9f <tcp_enqueue+0x8d6>
    !(flags & (TCP_SYN | TCP_FIN)) &&
  812da5:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  812da9:	83 e0 03             	and    $0x3,%eax
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  812dac:	85 c0                	test   %eax,%eax
  812dae:	0f 85 eb 00 00 00    	jne    812e9f <tcp_enqueue+0x8d6>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  812db4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812db8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  812dbc:	0f b7 d0             	movzwl %ax,%edx
  812dbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812dc3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  812dc7:	0f b7 c0             	movzwl %ax,%eax
  812dca:	01 c2                	add    %eax,%edx
  812dcc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812dd0:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  812dd4:	0f b7 c0             	movzwl %ax,%eax
    !(flags & (TCP_SYN | TCP_FIN)) &&
  812dd7:	39 c2                	cmp    %eax,%edx
  812dd9:	0f 8f c0 00 00 00    	jg     812e9f <tcp_enqueue+0x8d6>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  812ddf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812de3:	48 8b 40 08          	mov    0x8(%rax),%rax
  812de7:	be ec ff ff ff       	mov    $0xffffffec,%esi
  812dec:	48 89 c7             	mov    %rax,%rdi
  812def:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  812df6:	00 00 00 
  812df9:	ff d0                	callq  *%rax
  812dfb:	84 c0                	test   %al,%al
  812dfd:	74 2a                	je     812e29 <tcp_enqueue+0x860>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  812dff:	48 ba 8b 1d 82 00 00 	movabs $0x821d8b,%rdx
  812e06:	00 00 00 
  812e09:	be 52 01 00 00       	mov    $0x152,%esi
  812e0e:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  812e15:	00 00 00 
  812e18:	b8 00 00 00 00       	mov    $0x0,%eax
  812e1d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812e24:	00 00 00 
  812e27:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  812e29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812e2d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  812e31:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812e35:	48 8b 40 08          	mov    0x8(%rax),%rax
  812e39:	48 89 d6             	mov    %rdx,%rsi
  812e3c:	48 89 c7             	mov    %rax,%rdi
  812e3f:	48 b8 68 d3 80 00 00 	movabs $0x80d368,%rax
  812e46:	00 00 00 
  812e49:	ff d0                	callq  *%rax
    useg->len += queue->len;
  812e4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812e4f:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  812e53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812e57:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  812e5b:	01 c2                	add    %eax,%edx
  812e5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812e61:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  812e65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812e69:	48 8b 10             	mov    (%rax),%rdx
  812e6c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812e70:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  812e73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e77:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  812e7b:	75 08                	jne    812e85 <tcp_enqueue+0x8bc>
      seg = NULL;
  812e7d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  812e84:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  812e85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812e89:	48 89 c6             	mov    %rax,%rsi
  812e8c:	bf 04 00 00 00       	mov    $0x4,%edi
  812e91:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  812e98:	00 00 00 
  812e9b:	ff d0                	callq  *%rax
  812e9d:	eb 23                	jmp    812ec2 <tcp_enqueue+0x8f9>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  812e9f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812ea4:	75 11                	jne    812eb7 <tcp_enqueue+0x8ee>
      /* initialize list with this segment */
      pcb->unsent = queue;
  812ea6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812eaa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812eae:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  812eb5:	eb 0b                	jmp    812ec2 <tcp_enqueue+0x8f9>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  812eb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812ebb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812ebf:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  812ec2:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  812ec6:	83 e0 02             	and    $0x2,%eax
  812ec9:	85 c0                	test   %eax,%eax
  812ecb:	75 0b                	jne    812ed8 <tcp_enqueue+0x90f>
  812ecd:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  812ed1:	83 e0 01             	and    $0x1,%eax
  812ed4:	85 c0                	test   %eax,%eax
  812ed6:	74 05                	je     812edd <tcp_enqueue+0x914>
    ++len;
  812ed8:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  812edd:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  812ee1:	83 e0 01             	and    $0x1,%eax
  812ee4:	85 c0                	test   %eax,%eax
  812ee6:	74 14                	je     812efc <tcp_enqueue+0x933>
    pcb->flags |= TF_FIN;
  812ee8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812eec:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812ef0:	83 c8 20             	or     $0x20,%eax
  812ef3:	89 c2                	mov    %eax,%edx
  812ef5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812ef9:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  812efc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f00:	8b 50 74             	mov    0x74(%rax),%edx
  812f03:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  812f07:	01 c2                	add    %eax,%edx
  812f09:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f0d:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  812f10:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f14:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  812f18:	66 2b 45 9c          	sub    -0x64(%rbp),%ax
  812f1c:	89 c2                	mov    %eax,%edx
  812f1e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f22:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  812f26:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f2a:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  812f2e:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  812f32:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f36:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  812f3a:	66 85 c0             	test   %ax,%ax
  812f3d:	74 4a                	je     812f89 <tcp_enqueue+0x9c0>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  812f3f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f43:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812f4a:	48 85 c0             	test   %rax,%rax
  812f4d:	75 3a                	jne    812f89 <tcp_enqueue+0x9c0>
  812f4f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f53:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812f5a:	48 85 c0             	test   %rax,%rax
  812f5d:	75 2a                	jne    812f89 <tcp_enqueue+0x9c0>
  812f5f:	48 ba a0 1d 82 00 00 	movabs $0x821da0,%rdx
  812f66:	00 00 00 
  812f69:	be 7a 01 00 00       	mov    $0x17a,%esi
  812f6e:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  812f75:	00 00 00 
  812f78:	b8 00 00 00 00       	mov    $0x0,%eax
  812f7d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  812f84:	00 00 00 
  812f87:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  812f89:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812f8e:	74 5c                	je     812fec <tcp_enqueue+0xa23>
  812f90:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  812f95:	74 55                	je     812fec <tcp_enqueue+0xa23>
  812f97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812f9b:	48 8b 40 20          	mov    0x20(%rax),%rax
  812f9f:	48 85 c0             	test   %rax,%rax
  812fa2:	74 48                	je     812fec <tcp_enqueue+0xa23>
  812fa4:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  812fa8:	83 e0 02             	and    $0x2,%eax
  812fab:	85 c0                	test   %eax,%eax
  812fad:	75 3d                	jne    812fec <tcp_enqueue+0xa23>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  812faf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812fb3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  812fb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812fbb:	48 8b 40 20          	mov    0x20(%rax),%rax
  812fbf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  812fc3:	0f b7 c0             	movzwl %ax,%eax
  812fc6:	89 c7                	mov    %eax,%edi
  812fc8:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  812fcf:	00 00 00 
  812fd2:	ff d0                	callq  *%rax
  812fd4:	83 c8 08             	or     $0x8,%eax
  812fd7:	0f b7 c0             	movzwl %ax,%eax
  812fda:	89 c7                	mov    %eax,%edi
  812fdc:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  812fe3:	00 00 00 
  812fe6:	ff d0                	callq  *%rax
  812fe8:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  812fec:	b8 00 00 00 00       	mov    $0x0,%eax
  812ff1:	e9 8a 00 00 00       	jmpq   813080 <tcp_enqueue+0xab7>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  812ff6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812ffa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812ffe:	83 c8 80             	or     $0xffffff80,%eax
  813001:	89 c2                	mov    %eax,%edx
  813003:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813007:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  81300a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81300f:	74 13                	je     813024 <tcp_enqueue+0xa5b>
    tcp_segs_free(queue);
  813011:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813015:	48 89 c7             	mov    %rax,%rdi
  813018:	48 b8 4a f8 80 00 00 	movabs $0x80f84a,%rax
  81301f:	00 00 00 
  813022:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  813024:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813028:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81302c:	66 85 c0             	test   %ax,%ax
  81302f:	74 4a                	je     81307b <tcp_enqueue+0xab2>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  813031:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813035:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81303c:	48 85 c0             	test   %rax,%rax
  81303f:	75 3a                	jne    81307b <tcp_enqueue+0xab2>
  813041:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813045:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81304c:	48 85 c0             	test   %rax,%rax
  81304f:	75 2a                	jne    81307b <tcp_enqueue+0xab2>
  813051:	48 ba a0 1d 82 00 00 	movabs $0x821da0,%rdx
  813058:	00 00 00 
  81305b:	be 8d 01 00 00       	mov    $0x18d,%esi
  813060:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  813067:	00 00 00 
  81306a:	b8 00 00 00 00       	mov    $0x0,%eax
  81306f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  813076:	00 00 00 
  813079:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  81307b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  813080:	48 83 c4 70          	add    $0x70,%rsp
  813084:	5b                   	pop    %rbx
  813085:	41 5c                	pop    %r12
  813087:	5d                   	pop    %rbp
  813088:	c3                   	retq   

0000000000813089 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  813089:	55                   	push   %rbp
  81308a:	48 89 e5             	mov    %rsp,%rbp
  81308d:	41 54                	push   %r12
  81308f:	53                   	push   %rbx
  813090:	48 83 ec 40          	sub    $0x40,%rsp
  813094:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  813098:	48 b8 48 a0 b5 00 00 	movabs $0xb5a048,%rax
  81309f:	00 00 00 
  8130a2:	48 8b 00             	mov    (%rax),%rax
  8130a5:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8130a9:	75 0a                	jne    8130b5 <tcp_output+0x2c>
    return ERR_OK;
  8130ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8130b0:	e9 d0 06 00 00       	jmpq   813785 <tcp_output+0x6fc>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8130b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8130b9:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  8130bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8130c1:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  8130c5:	66 39 c2             	cmp    %ax,%dx
  8130c8:	0f 46 c2             	cmovbe %edx,%eax
  8130cb:	0f b7 c0             	movzwl %ax,%eax
  8130ce:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  8130d1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8130d5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8130dc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  8130e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8130e4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8130eb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  8130ef:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8130f4:	74 19                	je     81310f <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  8130f6:	eb 0b                	jmp    813103 <tcp_output+0x7a>
  8130f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8130fc:	48 8b 00             	mov    (%rax),%rax
  8130ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813103:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813107:	48 8b 00             	mov    (%rax),%rax
  81310a:	48 85 c0             	test   %rax,%rax
  81310d:	75 e9                	jne    8130f8 <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  81310f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813113:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813117:	0f b6 c0             	movzbl %al,%eax
  81311a:	83 e0 02             	and    $0x2,%eax
  81311d:	85 c0                	test   %eax,%eax
  81311f:	0f 84 59 02 00 00    	je     81337e <tcp_output+0x2f5>
  813125:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81312a:	74 3a                	je     813166 <tcp_output+0xdd>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  81312c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813130:	48 8b 40 20          	mov    0x20(%rax),%rax
  813134:	8b 40 04             	mov    0x4(%rax),%eax
  813137:	89 c7                	mov    %eax,%edi
  813139:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813140:	00 00 00 
  813143:	ff d0                	callq  *%rax
  813145:	89 c2                	mov    %eax,%edx
  813147:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81314b:	8b 40 54             	mov    0x54(%rax),%eax
  81314e:	29 c2                	sub    %eax,%edx
  813150:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813154:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813158:	0f b7 c0             	movzwl %ax,%eax
  81315b:	01 d0                	add    %edx,%eax
     (seg == NULL ||
  81315d:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813160:	0f 86 18 02 00 00    	jbe    81337e <tcp_output+0x2f5>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  813166:	ba 00 00 00 00       	mov    $0x0,%edx
  81316b:	be 14 00 00 00       	mov    $0x14,%esi
  813170:	bf 01 00 00 00       	mov    $0x1,%edi
  813175:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81317c:	00 00 00 
  81317f:	ff d0                	callq  *%rax
  813181:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  813185:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81318a:	75 0a                	jne    813196 <tcp_output+0x10d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  81318c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  813191:	e9 ef 05 00 00       	jmpq   813785 <tcp_output+0x6fc>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813196:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81319a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81319e:	83 e0 fc             	and    $0xfffffffc,%eax
  8131a1:	89 c2                	mov    %eax,%edx
  8131a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8131a7:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  8131aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8131ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  8131b2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  8131b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8131ba:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8131be:	0f b7 c0             	movzwl %ax,%eax
  8131c1:	89 c7                	mov    %eax,%edi
  8131c3:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8131ca:	00 00 00 
  8131cd:	ff d0                	callq  *%rax
  8131cf:	89 c2                	mov    %eax,%edx
  8131d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8131d5:	66 89 10             	mov    %dx,(%rax)
    tcphdr->dest = htons(pcb->remote_port);
  8131d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8131dc:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  8131e0:	0f b7 c0             	movzwl %ax,%eax
  8131e3:	89 c7                	mov    %eax,%edi
  8131e5:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8131ec:	00 00 00 
  8131ef:	ff d0                	callq  *%rax
  8131f1:	89 c2                	mov    %eax,%edx
  8131f3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8131f7:	66 89 50 02          	mov    %dx,0x2(%rax)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8131fb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8131ff:	8b 40 60             	mov    0x60(%rax),%eax
  813202:	89 c7                	mov    %eax,%edi
  813204:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  81320b:	00 00 00 
  81320e:	ff d0                	callq  *%rax
  813210:	89 c2                	mov    %eax,%edx
  813212:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813216:	89 50 04             	mov    %edx,0x4(%rax)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813219:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81321d:	8b 40 30             	mov    0x30(%rax),%eax
  813220:	89 c7                	mov    %eax,%edi
  813222:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  813229:	00 00 00 
  81322c:	ff d0                	callq  *%rax
  81322e:	89 c2                	mov    %eax,%edx
  813230:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813234:	89 50 08             	mov    %edx,0x8(%rax)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813237:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81323b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81323f:	0f b7 c0             	movzwl %ax,%eax
  813242:	89 c7                	mov    %eax,%edi
  813244:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81324b:	00 00 00 
  81324e:	ff d0                	callq  *%rax
  813250:	83 e0 c0             	and    $0xffffffc0,%eax
  813253:	83 c8 10             	or     $0x10,%eax
  813256:	0f b7 c0             	movzwl %ax,%eax
  813259:	89 c7                	mov    %eax,%edi
  81325b:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813262:	00 00 00 
  813265:	ff d0                	callq  *%rax
  813267:	89 c2                	mov    %eax,%edx
  813269:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81326d:	66 89 50 0c          	mov    %dx,0xc(%rax)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813271:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813275:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813279:	0f b7 c0             	movzwl %ax,%eax
  81327c:	89 c7                	mov    %eax,%edi
  81327e:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813285:	00 00 00 
  813288:	ff d0                	callq  *%rax
  81328a:	89 c2                	mov    %eax,%edx
  81328c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813290:	66 89 50 0e          	mov    %dx,0xe(%rax)
    tcphdr->urgp = 0;
  813294:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813298:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  81329e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8132a2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8132a6:	0f b7 c0             	movzwl %ax,%eax
  8132a9:	89 c7                	mov    %eax,%edi
  8132ab:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8132b2:	00 00 00 
  8132b5:	ff d0                	callq  *%rax
  8132b7:	83 e0 3f             	and    $0x3f,%eax
  8132ba:	80 cc 50             	or     $0x50,%ah
  8132bd:	0f b7 c0             	movzwl %ax,%eax
  8132c0:	89 c7                	mov    %eax,%edi
  8132c2:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8132c9:	00 00 00 
  8132cc:	ff d0                	callq  *%rax
  8132ce:	89 c2                	mov    %eax,%edx
  8132d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8132d4:	66 89 50 0c          	mov    %dx,0xc(%rax)

    tcphdr->chksum = 0;
  8132d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8132dc:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  8132e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8132e6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  8132ea:	0f b7 c8             	movzwl %ax,%ecx
  8132ed:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8132f1:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8132f5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8132f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8132fd:	41 89 c8             	mov    %ecx,%r8d
  813300:	b9 06 00 00 00       	mov    $0x6,%ecx
  813305:	48 89 c7             	mov    %rax,%rdi
  813308:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  81330f:	00 00 00 
  813312:	ff d0                	callq  *%rax
  813314:	89 c2                	mov    %eax,%edx
  813316:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81331a:	66 89 50 10          	mov    %dx,0x10(%rax)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  81331e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813322:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813326:	0f b6 c8             	movzbl %al,%ecx
  813329:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81332d:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813331:	0f b6 d0             	movzbl %al,%edx
  813334:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813338:	48 8d 78 04          	lea    0x4(%rax),%rdi
  81333c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813340:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813344:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  81334a:	41 89 c8             	mov    %ecx,%r8d
  81334d:	89 d1                	mov    %edx,%ecx
  81334f:	48 89 fa             	mov    %rdi,%rdx
  813352:	48 89 c7             	mov    %rax,%rdi
  813355:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  81335c:	00 00 00 
  81335f:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  813361:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813365:	48 89 c7             	mov    %rax,%rdi
  813368:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81336f:	00 00 00 
  813372:	ff d0                	callq  *%rax

    return ERR_OK;
  813374:	b8 00 00 00 00       	mov    $0x0,%eax
  813379:	e9 07 04 00 00       	jmpq   813785 <tcp_output+0x6fc>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  81337e:	e9 39 03 00 00       	jmpq   8136bc <tcp_output+0x633>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  813383:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813387:	48 8b 40 20          	mov    0x20(%rax),%rax
  81338b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81338f:	0f b7 c0             	movzwl %ax,%eax
  813392:	89 c7                	mov    %eax,%edi
  813394:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81339b:	00 00 00 
  81339e:	ff d0                	callq  *%rax
  8133a0:	0f b7 c0             	movzwl %ax,%eax
  8133a3:	83 e0 04             	and    $0x4,%eax
  8133a6:	85 c0                	test   %eax,%eax
  8133a8:	74 2a                	je     8133d4 <tcp_output+0x34b>
  8133aa:	48 ba c0 1d 82 00 00 	movabs $0x821dc0,%rdx
  8133b1:	00 00 00 
  8133b4:	be 05 02 00 00       	mov    $0x205,%esi
  8133b9:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  8133c0:	00 00 00 
  8133c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8133c8:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8133cf:	00 00 00 
  8133d2:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8133d4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8133d8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8133df:	48 85 c0             	test   %rax,%rax
  8133e2:	74 35                	je     813419 <tcp_output+0x390>
  8133e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8133e8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8133ec:	0f b6 c0             	movzbl %al,%eax
  8133ef:	83 e0 40             	and    $0x40,%eax
  8133f2:	85 c0                	test   %eax,%eax
  8133f4:	75 23                	jne    813419 <tcp_output+0x390>
  8133f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8133fa:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813401:	48 85 c0             	test   %rax,%rax
  813404:	74 1a                	je     813420 <tcp_output+0x397>
  813406:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81340a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813411:	48 8b 00             	mov    (%rax),%rax
  813414:	48 85 c0             	test   %rax,%rax
  813417:	74 07                	je     813420 <tcp_output+0x397>
  813419:	b8 01 00 00 00       	mov    $0x1,%eax
  81341e:	eb 05                	jmp    813425 <tcp_output+0x39c>
  813420:	b8 00 00 00 00       	mov    $0x0,%eax
  813425:	85 c0                	test   %eax,%eax
  813427:	75 19                	jne    813442 <tcp_output+0x3b9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  813429:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81342d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813431:	0f b6 c0             	movzbl %al,%eax
  813434:	25 a0 00 00 00       	and    $0xa0,%eax
    if((tcp_do_output_nagle(pcb) == 0) &&
  813439:	85 c0                	test   %eax,%eax
  81343b:	75 05                	jne    813442 <tcp_output+0x3b9>
      break;
  81343d:	e9 bb 02 00 00       	jmpq   8136fd <tcp_output+0x674>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  813442:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813446:	48 8b 10             	mov    (%rax),%rdx
  813449:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81344d:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  813454:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813458:	8b 40 18             	mov    0x18(%rax),%eax
  81345b:	83 f8 02             	cmp    $0x2,%eax
  81345e:	74 51                	je     8134b1 <tcp_output+0x428>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  813460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813464:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813468:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81346c:	48 8b 40 20          	mov    0x20(%rax),%rax
  813470:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813474:	0f b7 c0             	movzwl %ax,%eax
  813477:	89 c7                	mov    %eax,%edi
  813479:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  813480:	00 00 00 
  813483:	ff d0                	callq  *%rax
  813485:	83 c8 10             	or     $0x10,%eax
  813488:	0f b7 c0             	movzwl %ax,%eax
  81348b:	89 c7                	mov    %eax,%edi
  81348d:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813494:	00 00 00 
  813497:	ff d0                	callq  *%rax
  813499:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  81349d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8134a1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8134a5:	83 e0 fc             	and    $0xfffffffc,%eax
  8134a8:	89 c2                	mov    %eax,%edx
  8134aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8134ae:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  8134b1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8134b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134b9:	48 89 d6             	mov    %rdx,%rsi
  8134bc:	48 89 c7             	mov    %rax,%rdi
  8134bf:	48 b8 8e 37 81 00 00 	movabs $0x81378e,%rax
  8134c6:	00 00 00 
  8134c9:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8134cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134cf:	48 8b 40 20          	mov    0x20(%rax),%rax
  8134d3:	8b 40 04             	mov    0x4(%rax),%eax
  8134d6:	89 c7                	mov    %eax,%edi
  8134d8:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8134df:	00 00 00 
  8134e2:	ff d0                	callq  *%rax
  8134e4:	41 89 c4             	mov    %eax,%r12d
  8134e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134eb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8134ef:	0f b7 d8             	movzwl %ax,%ebx
  8134f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134f6:	48 8b 40 20          	mov    0x20(%rax),%rax
  8134fa:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8134fe:	0f b7 c0             	movzwl %ax,%eax
  813501:	89 c7                	mov    %eax,%edi
  813503:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81350a:	00 00 00 
  81350d:	ff d0                	callq  *%rax
  81350f:	0f b7 c0             	movzwl %ax,%eax
  813512:	83 e0 01             	and    $0x1,%eax
  813515:	85 c0                	test   %eax,%eax
  813517:	75 27                	jne    813540 <tcp_output+0x4b7>
  813519:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81351d:	48 8b 40 20          	mov    0x20(%rax),%rax
  813521:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813525:	0f b7 c0             	movzwl %ax,%eax
  813528:	89 c7                	mov    %eax,%edi
  81352a:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  813531:	00 00 00 
  813534:	ff d0                	callq  *%rax
  813536:	0f b7 c0             	movzwl %ax,%eax
  813539:	83 e0 02             	and    $0x2,%eax
  81353c:	85 c0                	test   %eax,%eax
  81353e:	74 07                	je     813547 <tcp_output+0x4be>
  813540:	b8 01 00 00 00       	mov    $0x1,%eax
  813545:	eb 05                	jmp    81354c <tcp_output+0x4c3>
  813547:	b8 00 00 00 00       	mov    $0x0,%eax
  81354c:	01 d8                	add    %ebx,%eax
  81354e:	41 8d 14 04          	lea    (%r12,%rax,1),%edx
  813552:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813556:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  813559:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81355d:	8b 50 64             	mov    0x64(%rax),%edx
  813560:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813564:	8b 40 60             	mov    0x60(%rax),%eax
  813567:	29 c2                	sub    %eax,%edx
  813569:	89 d0                	mov    %edx,%eax
  81356b:	85 c0                	test   %eax,%eax
  81356d:	79 0e                	jns    81357d <tcp_output+0x4f4>
      pcb->snd_max = pcb->snd_nxt;
  81356f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813573:	8b 50 60             	mov    0x60(%rax),%edx
  813576:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81357a:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  81357d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813581:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813585:	0f b7 d8             	movzwl %ax,%ebx
  813588:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81358c:	48 8b 40 20          	mov    0x20(%rax),%rax
  813590:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813594:	0f b7 c0             	movzwl %ax,%eax
  813597:	89 c7                	mov    %eax,%edi
  813599:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8135a0:	00 00 00 
  8135a3:	ff d0                	callq  *%rax
  8135a5:	0f b7 c0             	movzwl %ax,%eax
  8135a8:	83 e0 01             	and    $0x1,%eax
  8135ab:	85 c0                	test   %eax,%eax
  8135ad:	75 27                	jne    8135d6 <tcp_output+0x54d>
  8135af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135b3:	48 8b 40 20          	mov    0x20(%rax),%rax
  8135b7:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8135bb:	0f b7 c0             	movzwl %ax,%eax
  8135be:	89 c7                	mov    %eax,%edi
  8135c0:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8135c7:	00 00 00 
  8135ca:	ff d0                	callq  *%rax
  8135cc:	0f b7 c0             	movzwl %ax,%eax
  8135cf:	83 e0 02             	and    $0x2,%eax
  8135d2:	85 c0                	test   %eax,%eax
  8135d4:	74 07                	je     8135dd <tcp_output+0x554>
  8135d6:	b8 01 00 00 00       	mov    $0x1,%eax
  8135db:	eb 05                	jmp    8135e2 <tcp_output+0x559>
  8135dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8135e2:	01 d8                	add    %ebx,%eax
  8135e4:	85 c0                	test   %eax,%eax
  8135e6:	0f 8e ae 00 00 00    	jle    81369a <tcp_output+0x611>
      seg->next = NULL;
  8135ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135f0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  8135f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8135fb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813602:	48 85 c0             	test   %rax,%rax
  813605:	75 1c                	jne    813623 <tcp_output+0x59a>
        pcb->unacked = seg;
  813607:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81360b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81360f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  813616:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81361a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81361e:	e9 8a 00 00 00       	jmpq   8136ad <tcp_output+0x624>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  813623:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813627:	48 8b 40 20          	mov    0x20(%rax),%rax
  81362b:	8b 40 04             	mov    0x4(%rax),%eax
  81362e:	89 c7                	mov    %eax,%edi
  813630:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813637:	00 00 00 
  81363a:	ff d0                	callq  *%rax
  81363c:	89 c3                	mov    %eax,%ebx
  81363e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813642:	48 8b 40 20          	mov    0x20(%rax),%rax
  813646:	8b 40 04             	mov    0x4(%rax),%eax
  813649:	89 c7                	mov    %eax,%edi
  81364b:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813652:	00 00 00 
  813655:	ff d0                	callq  *%rax
  813657:	29 c3                	sub    %eax,%ebx
  813659:	89 d8                	mov    %ebx,%eax
  81365b:	85 c0                	test   %eax,%eax
  81365d:	79 23                	jns    813682 <tcp_output+0x5f9>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  81365f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813663:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  81366a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81366e:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  813671:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813675:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813679:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  813680:	eb 2b                	jmp    8136ad <tcp_output+0x624>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  813682:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813686:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81368a:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  81368d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813691:	48 8b 00             	mov    (%rax),%rax
  813694:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813698:	eb 13                	jmp    8136ad <tcp_output+0x624>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  81369a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81369e:	48 89 c7             	mov    %rax,%rdi
  8136a1:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  8136a8:	00 00 00 
  8136ab:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  8136ad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8136b1:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8136b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  while (seg != NULL &&
  8136bc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8136c1:	74 3a                	je     8136fd <tcp_output+0x674>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  8136c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136c7:	48 8b 40 20          	mov    0x20(%rax),%rax
  8136cb:	8b 40 04             	mov    0x4(%rax),%eax
  8136ce:	89 c7                	mov    %eax,%edi
  8136d0:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8136d7:	00 00 00 
  8136da:	ff d0                	callq  *%rax
  8136dc:	89 c2                	mov    %eax,%edx
  8136de:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8136e2:	8b 40 54             	mov    0x54(%rax),%eax
  8136e5:	29 c2                	sub    %eax,%edx
  8136e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136eb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8136ef:	0f b7 c0             	movzwl %ax,%eax
  8136f2:	01 d0                	add    %edx,%eax
  while (seg != NULL &&
  8136f4:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8136f7:	0f 86 86 fc ff ff    	jbe    813383 <tcp_output+0x2fa>
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8136fd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813702:	74 68                	je     81376c <tcp_output+0x6e3>
  813704:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813708:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81370f:	84 c0                	test   %al,%al
  813711:	75 59                	jne    81376c <tcp_output+0x6e3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  813713:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813717:	48 8b 40 20          	mov    0x20(%rax),%rax
  81371b:	8b 40 04             	mov    0x4(%rax),%eax
  81371e:	89 c7                	mov    %eax,%edi
  813720:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813727:	00 00 00 
  81372a:	ff d0                	callq  *%rax
  81372c:	89 c2                	mov    %eax,%edx
  81372e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813732:	8b 40 54             	mov    0x54(%rax),%eax
  813735:	29 c2                	sub    %eax,%edx
  813737:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81373b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81373f:	0f b7 c0             	movzwl %ax,%eax
  813742:	01 c2                	add    %eax,%edx
  813744:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813748:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81374c:	0f b7 c0             	movzwl %ax,%eax
  if (seg != NULL && pcb->persist_backoff == 0 && 
  81374f:	39 c2                	cmp    %eax,%edx
  813751:	76 19                	jbe    81376c <tcp_output+0x6e3>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  813753:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813757:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  81375e:	00 00 00 
    pcb->persist_backoff = 1;
  813761:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813765:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  81376c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813770:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813774:	83 e0 7f             	and    $0x7f,%eax
  813777:	89 c2                	mov    %eax,%edx
  813779:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81377d:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  813780:	b8 00 00 00 00       	mov    $0x0,%eax
}
  813785:	48 83 c4 40          	add    $0x40,%rsp
  813789:	5b                   	pop    %rbx
  81378a:	41 5c                	pop    %r12
  81378c:	5d                   	pop    %rbp
  81378d:	c3                   	retq   

000000000081378e <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  81378e:	55                   	push   %rbp
  81378f:	48 89 e5             	mov    %rsp,%rbp
  813792:	53                   	push   %rbx
  813793:	48 83 ec 28          	sub    $0x28,%rsp
  813797:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81379b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  81379f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8137a3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8137ab:	8b 40 30             	mov    0x30(%rax),%eax
  8137ae:	89 c7                	mov    %eax,%edi
  8137b0:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  8137b7:	00 00 00 
  8137ba:	ff d0                	callq  *%rax
  8137bc:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8137bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8137c3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8137cb:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8137cf:	0f b7 c0             	movzwl %ax,%eax
  8137d2:	89 c7                	mov    %eax,%edi
  8137d4:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8137db:	00 00 00 
  8137de:	ff d0                	callq  *%rax
  8137e0:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  8137e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8137e8:	48 85 c0             	test   %rax,%rax
  8137eb:	74 0a                	je     8137f7 <tcp_output_segment+0x69>
  8137ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8137f1:	8b 00                	mov    (%rax),%eax
  8137f3:	85 c0                	test   %eax,%eax
  8137f5:	75 48                	jne    81383f <tcp_output_segment+0xb1>
    netif = ip_route(&(pcb->remote_ip));
  8137f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8137fb:	48 83 c0 04          	add    $0x4,%rax
  8137ff:	48 89 c7             	mov    %rax,%rdi
  813802:	48 b8 f4 01 81 00 00 	movabs $0x8101f4,%rax
  813809:	00 00 00 
  81380c:	ff d0                	callq  *%rax
  81380e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  813812:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813817:	75 05                	jne    81381e <tcp_output_segment+0x90>
      return;
  813819:	e9 81 01 00 00       	jmpq   81399f <tcp_output_segment+0x211>
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  81381e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813822:	48 83 c0 08          	add    $0x8,%rax
  813826:	48 85 c0             	test   %rax,%rax
  813829:	74 09                	je     813834 <tcp_output_segment+0xa6>
  81382b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81382f:	8b 40 08             	mov    0x8(%rax),%eax
  813832:	eb 05                	jmp    813839 <tcp_output_segment+0xab>
  813834:	b8 00 00 00 00       	mov    $0x0,%eax
  813839:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81383d:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  81383f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813843:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  813847:	66 83 f8 ff          	cmp    $0xffff,%ax
  81384b:	75 0a                	jne    813857 <tcp_output_segment+0xc9>
    pcb->rtime = 0;
  81384d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813851:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  813857:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81385b:	8b 40 44             	mov    0x44(%rax),%eax
  81385e:	85 c0                	test   %eax,%eax
  813860:	75 35                	jne    813897 <tcp_output_segment+0x109>
    pcb->rttest = tcp_ticks;
  813862:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  813869:	00 00 00 
  81386c:	8b 10                	mov    (%rax),%edx
  81386e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813872:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  813875:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813879:	48 8b 40 20          	mov    0x20(%rax),%rax
  81387d:	8b 40 04             	mov    0x4(%rax),%eax
  813880:	89 c7                	mov    %eax,%edi
  813882:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813889:	00 00 00 
  81388c:	ff d0                	callq  *%rax
  81388e:	89 c2                	mov    %eax,%edx
  813890:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813894:	89 50 48             	mov    %edx,0x48(%rax)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  813897:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81389b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81389f:	48 89 c2             	mov    %rax,%rdx
  8138a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8138aa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8138ae:	48 29 c2             	sub    %rax,%rdx
  8138b1:	48 89 d0             	mov    %rdx,%rax
  8138b4:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  8138b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8138c0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8138c4:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8138c8:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  8138cc:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  8138d0:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  8138d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8138dc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8138e0:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8138e4:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  8138e8:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  8138ec:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  8138f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8138f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8138fc:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  813900:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  813904:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813908:	48 8b 40 20          	mov    0x20(%rax),%rax
  81390c:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  813912:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813916:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  81391a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81391e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813922:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  813926:	0f b7 c8             	movzwl %ax,%ecx
  813929:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81392d:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813931:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  813935:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813939:	48 8b 40 08          	mov    0x8(%rax),%rax
  81393d:	41 89 c8             	mov    %ecx,%r8d
  813940:	b9 06 00 00 00       	mov    $0x6,%ecx
  813945:	48 89 c7             	mov    %rax,%rdi
  813948:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  81394f:	00 00 00 
  813952:	ff d0                	callq  *%rax
  813954:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813958:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81395c:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813960:	0f b6 c8             	movzbl %al,%ecx
  813963:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813967:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81396b:	0f b6 d0             	movzbl %al,%edx
  81396e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813972:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813976:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  81397a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81397e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813982:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813988:	41 89 c8             	mov    %ecx,%r8d
  81398b:	89 d1                	mov    %edx,%ecx
  81398d:	48 89 fa             	mov    %rdi,%rdx
  813990:	48 89 c7             	mov    %rax,%rdi
  813993:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  81399a:	00 00 00 
  81399d:	ff d0                	callq  *%rax
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  81399f:	48 83 c4 28          	add    $0x28,%rsp
  8139a3:	5b                   	pop    %rbx
  8139a4:	5d                   	pop    %rbp
  8139a5:	c3                   	retq   

00000000008139a6 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8139a6:	55                   	push   %rbp
  8139a7:	48 89 e5             	mov    %rsp,%rbp
  8139aa:	48 83 ec 30          	sub    $0x30,%rsp
  8139ae:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8139b1:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8139b4:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8139b8:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  8139bc:	44 89 c2             	mov    %r8d,%edx
  8139bf:	44 89 c8             	mov    %r9d,%eax
  8139c2:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  8139c6:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8139ca:	ba 00 00 00 00       	mov    $0x0,%edx
  8139cf:	be 14 00 00 00       	mov    $0x14,%esi
  8139d4:	bf 01 00 00 00       	mov    $0x1,%edi
  8139d9:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  8139e0:	00 00 00 
  8139e3:	ff d0                	callq  *%rax
  8139e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  8139e9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8139ee:	75 05                	jne    8139f5 <tcp_rst+0x4f>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  8139f0:	e9 c9 01 00 00       	jmpq   813bbe <tcp_rst+0x218>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8139f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8139f9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8139fd:	66 83 f8 13          	cmp    $0x13,%ax
  813a01:	77 2a                	ja     813a2d <tcp_rst+0x87>
  813a03:	48 ba d8 1d 82 00 00 	movabs $0x821dd8,%rdx
  813a0a:	00 00 00 
  813a0d:	be be 02 00 00       	mov    $0x2be,%esi
  813a12:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  813a19:	00 00 00 
  813a1c:	b8 00 00 00 00       	mov    $0x0,%eax
  813a21:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  813a28:	00 00 00 
  813a2b:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  813a2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813a31:	48 8b 40 08          	mov    0x8(%rax),%rax
  813a35:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  813a39:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  813a3d:	89 c7                	mov    %eax,%edi
  813a3f:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813a46:	00 00 00 
  813a49:	ff d0                	callq  *%rax
  813a4b:	89 c2                	mov    %eax,%edx
  813a4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813a51:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(remote_port);
  813a54:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813a58:	89 c7                	mov    %eax,%edi
  813a5a:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813a61:	00 00 00 
  813a64:	ff d0                	callq  *%rax
  813a66:	89 c2                	mov    %eax,%edx
  813a68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813a6c:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = htonl(seqno);
  813a70:	8b 45 ec             	mov    -0x14(%rbp),%eax
  813a73:	89 c7                	mov    %eax,%edi
  813a75:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  813a7c:	00 00 00 
  813a7f:	ff d0                	callq  *%rax
  813a81:	89 c2                	mov    %eax,%edx
  813a83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813a87:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(ackno);
  813a8a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  813a8d:	89 c7                	mov    %eax,%edi
  813a8f:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  813a96:	00 00 00 
  813a99:	ff d0                	callq  *%rax
  813a9b:	89 c2                	mov    %eax,%edx
  813a9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813aa1:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  813aa4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813aa8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813aac:	0f b7 c0             	movzwl %ax,%eax
  813aaf:	89 c7                	mov    %eax,%edi
  813ab1:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  813ab8:	00 00 00 
  813abb:	ff d0                	callq  *%rax
  813abd:	83 e0 c0             	and    $0xffffffc0,%eax
  813ac0:	83 c8 14             	or     $0x14,%eax
  813ac3:	0f b7 c0             	movzwl %ax,%eax
  813ac6:	89 c7                	mov    %eax,%edi
  813ac8:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813acf:	00 00 00 
  813ad2:	ff d0                	callq  *%rax
  813ad4:	89 c2                	mov    %eax,%edx
  813ad6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813ada:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(TCP_WND);
  813ade:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  813ae3:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813aea:	00 00 00 
  813aed:	ff d0                	callq  *%rax
  813aef:	89 c2                	mov    %eax,%edx
  813af1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813af5:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  813af9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813afd:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  813b03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813b07:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813b0b:	0f b7 c0             	movzwl %ax,%eax
  813b0e:	89 c7                	mov    %eax,%edi
  813b10:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  813b17:	00 00 00 
  813b1a:	ff d0                	callq  *%rax
  813b1c:	83 e0 3f             	and    $0x3f,%eax
  813b1f:	80 cc 50             	or     $0x50,%ah
  813b22:	0f b7 c0             	movzwl %ax,%eax
  813b25:	89 c7                	mov    %eax,%edi
  813b27:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813b2e:	00 00 00 
  813b31:	ff d0                	callq  *%rax
  813b33:	89 c2                	mov    %eax,%edx
  813b35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813b39:	66 89 50 0c          	mov    %dx,0xc(%rax)

  tcphdr->chksum = 0;
  813b3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813b41:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  813b47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813b4b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  813b4f:	0f b7 c8             	movzwl %ax,%ecx
  813b52:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813b56:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  813b5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813b5e:	41 89 c8             	mov    %ecx,%r8d
  813b61:	b9 06 00 00 00       	mov    $0x6,%ecx
  813b66:	48 89 c7             	mov    %rax,%rdi
  813b69:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  813b70:	00 00 00 
  813b73:	ff d0                	callq  *%rax
  813b75:	89 c2                	mov    %eax,%edx
  813b77:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813b7b:	66 89 50 10          	mov    %dx,0x10(%rax)
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  813b7f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813b83:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  813b87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813b8b:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813b91:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  813b97:	b9 ff 00 00 00       	mov    $0xff,%ecx
  813b9c:	48 89 c7             	mov    %rax,%rdi
  813b9f:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  813ba6:	00 00 00 
  813ba9:	ff d0                	callq  *%rax
  pbuf_free(p);
  813bab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813baf:	48 89 c7             	mov    %rax,%rdi
  813bb2:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  813bb9:	00 00 00 
  813bbc:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  813bbe:	c9                   	leaveq 
  813bbf:	c3                   	retq   

0000000000813bc0 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  813bc0:	55                   	push   %rbp
  813bc1:	48 89 e5             	mov    %rsp,%rbp
  813bc4:	48 83 ec 20          	sub    $0x20,%rsp
  813bc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  813bcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bd0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813bd7:	48 85 c0             	test   %rax,%rax
  813bda:	75 05                	jne    813be1 <tcp_rexmit_rto+0x21>
    return;
  813bdc:	e9 b8 00 00 00       	jmpq   813c99 <tcp_rexmit_rto+0xd9>
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  813be1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813be5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813bec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  813bf0:	eb 0b                	jmp    813bfd <tcp_rexmit_rto+0x3d>
  813bf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813bf6:	48 8b 00             	mov    (%rax),%rax
  813bf9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  813bfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813c01:	48 8b 00             	mov    (%rax),%rax
  813c04:	48 85 c0             	test   %rax,%rax
  813c07:	75 e9                	jne    813bf2 <tcp_rexmit_rto+0x32>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  813c09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c0d:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  813c14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813c18:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  813c1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c1f:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  813c26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c2a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  813c31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c35:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  813c3c:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  813c40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c44:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c4b:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c4f:	8b 40 04             	mov    0x4(%rax),%eax
  813c52:	89 c7                	mov    %eax,%edi
  813c54:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813c5b:	00 00 00 
  813c5e:	ff d0                	callq  *%rax
  813c60:	89 c2                	mov    %eax,%edx
  813c62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c66:	89 50 60             	mov    %edx,0x60(%rax)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  813c69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c6d:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  813c71:	8d 50 01             	lea    0x1(%rax),%edx
  813c74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c78:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  813c7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c7f:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  813c86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c8a:	48 89 c7             	mov    %rax,%rdi
  813c8d:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  813c94:	00 00 00 
  813c97:	ff d0                	callq  *%rax
}
  813c99:	c9                   	leaveq 
  813c9a:	c3                   	retq   

0000000000813c9b <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  813c9b:	55                   	push   %rbp
  813c9c:	48 89 e5             	mov    %rsp,%rbp
  813c9f:	48 83 ec 20          	sub    $0x20,%rsp
  813ca3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  813ca7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cab:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813cb2:	48 85 c0             	test   %rax,%rax
  813cb5:	75 05                	jne    813cbc <tcp_rexmit+0x21>
    return;
  813cb7:	e9 a9 00 00 00       	jmpq   813d65 <tcp_rexmit+0xca>
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  813cbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cc0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813cc7:	48 8b 00             	mov    (%rax),%rax
  813cca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  813cce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cd2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813cd9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813cdd:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  813ce4:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  813ce7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ceb:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  813cf2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cf6:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  813cfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d01:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  813d05:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  813d0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d10:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813d17:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d1b:	8b 40 04             	mov    0x4(%rax),%eax
  813d1e:	89 c7                	mov    %eax,%edi
  813d20:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  813d27:	00 00 00 
  813d2a:	ff d0                	callq  *%rax
  813d2c:	89 c2                	mov    %eax,%edx
  813d2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d32:	89 50 60             	mov    %edx,0x60(%rax)

  ++pcb->nrtx;
  813d35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d39:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  813d3d:	8d 50 01             	lea    0x1(%rax),%edx
  813d40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d44:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  813d47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d4b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  813d52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d56:	48 89 c7             	mov    %rax,%rdi
  813d59:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  813d60:	00 00 00 
  813d63:	ff d0                	callq  *%rax
}
  813d65:	c9                   	leaveq 
  813d66:	c3                   	retq   

0000000000813d67 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  813d67:	55                   	push   %rbp
  813d68:	48 89 e5             	mov    %rsp,%rbp
  813d6b:	48 83 ec 20          	sub    $0x20,%rsp
  813d6f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  813d73:	ba 00 00 00 00       	mov    $0x0,%edx
  813d78:	be 14 00 00 00       	mov    $0x14,%esi
  813d7d:	bf 01 00 00 00       	mov    $0x1,%edi
  813d82:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  813d89:	00 00 00 
  813d8c:	ff d0                	callq  *%rax
  813d8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  813d92:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  813d97:	75 05                	jne    813d9e <tcp_keepalive+0x37>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  813d99:	e9 fc 01 00 00       	jmpq   813f9a <tcp_keepalive+0x233>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  813d9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813da2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  813da6:	66 83 f8 13          	cmp    $0x13,%ax
  813daa:	77 2a                	ja     813dd6 <tcp_keepalive+0x6f>
  813dac:	48 ba d8 1d 82 00 00 	movabs $0x821dd8,%rdx
  813db3:	00 00 00 
  813db6:	be 3a 03 00 00       	mov    $0x33a,%esi
  813dbb:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  813dc2:	00 00 00 
  813dc5:	b8 00 00 00 00       	mov    $0x0,%eax
  813dca:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  813dd1:	00 00 00 
  813dd4:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  813dd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813dda:	48 8b 40 08          	mov    0x8(%rax),%rax
  813dde:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  813de2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813de6:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813dea:	0f b7 c0             	movzwl %ax,%eax
  813ded:	89 c7                	mov    %eax,%edi
  813def:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813df6:	00 00 00 
  813df9:	ff d0                	callq  *%rax
  813dfb:	89 c2                	mov    %eax,%edx
  813dfd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813e01:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(pcb->remote_port);
  813e04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e08:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813e0c:	0f b7 c0             	movzwl %ax,%eax
  813e0f:	89 c7                	mov    %eax,%edi
  813e11:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813e18:	00 00 00 
  813e1b:	ff d0                	callq  *%rax
  813e1d:	89 c2                	mov    %eax,%edx
  813e1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813e23:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  813e27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e2b:	8b 40 60             	mov    0x60(%rax),%eax
  813e2e:	83 e8 01             	sub    $0x1,%eax
  813e31:	89 c7                	mov    %eax,%edi
  813e33:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  813e3a:	00 00 00 
  813e3d:	ff d0                	callq  *%rax
  813e3f:	89 c2                	mov    %eax,%edx
  813e41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813e45:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  813e48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e4c:	8b 40 30             	mov    0x30(%rax),%eax
  813e4f:	89 c7                	mov    %eax,%edi
  813e51:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  813e58:	00 00 00 
  813e5b:	ff d0                	callq  *%rax
  813e5d:	89 c2                	mov    %eax,%edx
  813e5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813e63:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, 0);
  813e66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813e6a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813e6e:	0f b7 c0             	movzwl %ax,%eax
  813e71:	89 c7                	mov    %eax,%edi
  813e73:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  813e7a:	00 00 00 
  813e7d:	ff d0                	callq  *%rax
  813e7f:	0f b7 c0             	movzwl %ax,%eax
  813e82:	25 c0 ff 00 00       	and    $0xffc0,%eax
  813e87:	89 c7                	mov    %eax,%edi
  813e89:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813e90:	00 00 00 
  813e93:	ff d0                	callq  *%rax
  813e95:	89 c2                	mov    %eax,%edx
  813e97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813e9b:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813e9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ea3:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813ea7:	0f b7 c0             	movzwl %ax,%eax
  813eaa:	89 c7                	mov    %eax,%edi
  813eac:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813eb3:	00 00 00 
  813eb6:	ff d0                	callq  *%rax
  813eb8:	89 c2                	mov    %eax,%edx
  813eba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813ebe:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  813ec2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813ec6:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  813ecc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813ed0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813ed4:	0f b7 c0             	movzwl %ax,%eax
  813ed7:	89 c7                	mov    %eax,%edi
  813ed9:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  813ee0:	00 00 00 
  813ee3:	ff d0                	callq  *%rax
  813ee5:	83 e0 3f             	and    $0x3f,%eax
  813ee8:	80 cc 50             	or     $0x50,%ah
  813eeb:	0f b7 c0             	movzwl %ax,%eax
  813eee:	89 c7                	mov    %eax,%edi
  813ef0:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  813ef7:	00 00 00 
  813efa:	ff d0                	callq  *%rax
  813efc:	89 c2                	mov    %eax,%edx
  813efe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813f02:	66 89 50 0c          	mov    %dx,0xc(%rax)

  tcphdr->chksum = 0;
  813f06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813f0a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  813f10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813f14:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  813f18:	0f b7 c8             	movzwl %ax,%ecx
  813f1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f1f:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813f23:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  813f27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813f2b:	41 89 c8             	mov    %ecx,%r8d
  813f2e:	b9 06 00 00 00       	mov    $0x6,%ecx
  813f33:	48 89 c7             	mov    %rax,%rdi
  813f36:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  813f3d:	00 00 00 
  813f40:	ff d0                	callq  *%rax
  813f42:	89 c2                	mov    %eax,%edx
  813f44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813f48:	66 89 50 10          	mov    %dx,0x10(%rax)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  813f4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f50:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813f54:	0f b6 d0             	movzbl %al,%edx
  813f57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f5b:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813f5f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  813f63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813f67:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813f6d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  813f73:	89 d1                	mov    %edx,%ecx
  813f75:	48 89 fa             	mov    %rdi,%rdx
  813f78:	48 89 c7             	mov    %rax,%rdi
  813f7b:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  813f82:	00 00 00 
  813f85:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  813f87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813f8b:	48 89 c7             	mov    %rax,%rdi
  813f8e:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  813f95:	00 00 00 
  813f98:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  813f9a:	c9                   	leaveq 
  813f9b:	c3                   	retq   

0000000000813f9c <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  813f9c:	55                   	push   %rbp
  813f9d:	48 89 e5             	mov    %rsp,%rbp
  813fa0:	48 83 ec 30          	sub    $0x30,%rsp
  813fa4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  813fa8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813fac:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813fb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  813fb7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  813fbc:	75 0f                	jne    813fcd <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  813fbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813fc2:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813fc9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  813fcd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  813fd2:	75 05                	jne    813fd9 <tcp_zero_window_probe+0x3d>
    return;
  813fd4:	e9 31 02 00 00       	jmpq   81420a <tcp_zero_window_probe+0x26e>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  813fd9:	ba 00 00 00 00       	mov    $0x0,%edx
  813fde:	be 15 00 00 00       	mov    $0x15,%esi
  813fe3:	bf 01 00 00 00       	mov    $0x1,%edi
  813fe8:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  813fef:	00 00 00 
  813ff2:	ff d0                	callq  *%rax
  813ff4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  813ff8:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  813ffd:	75 05                	jne    814004 <tcp_zero_window_probe+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  813fff:	e9 06 02 00 00       	jmpq   81420a <tcp_zero_window_probe+0x26e>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814004:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814008:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81400c:	66 83 f8 13          	cmp    $0x13,%ax
  814010:	77 2a                	ja     81403c <tcp_zero_window_probe+0xa0>
  814012:	48 ba d8 1d 82 00 00 	movabs $0x821dd8,%rdx
  814019:	00 00 00 
  81401c:	be 8d 03 00 00       	mov    $0x38d,%esi
  814021:	48 bf 47 1c 82 00 00 	movabs $0x821c47,%rdi
  814028:	00 00 00 
  81402b:	b8 00 00 00 00       	mov    $0x0,%eax
  814030:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  814037:	00 00 00 
  81403a:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  81403c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814040:	48 8b 40 08          	mov    0x8(%rax),%rax
  814044:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814048:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81404c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814050:	0f b7 c0             	movzwl %ax,%eax
  814053:	89 c7                	mov    %eax,%edi
  814055:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81405c:	00 00 00 
  81405f:	ff d0                	callq  *%rax
  814061:	89 c2                	mov    %eax,%edx
  814063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814067:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(pcb->remote_port);
  81406a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81406e:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814072:	0f b7 c0             	movzwl %ax,%eax
  814075:	89 c7                	mov    %eax,%edi
  814077:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81407e:	00 00 00 
  814081:	ff d0                	callq  *%rax
  814083:	89 c2                	mov    %eax,%edx
  814085:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814089:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = seg->tcphdr->seqno;
  81408d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814091:	48 8b 40 20          	mov    0x20(%rax),%rax
  814095:	8b 50 04             	mov    0x4(%rax),%edx
  814098:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81409c:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  81409f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140a3:	8b 40 30             	mov    0x30(%rax),%eax
  8140a6:	89 c7                	mov    %eax,%edi
  8140a8:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  8140af:	00 00 00 
  8140b2:	ff d0                	callq  *%rax
  8140b4:	89 c2                	mov    %eax,%edx
  8140b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140ba:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, 0);
  8140bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140c1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8140c5:	0f b7 c0             	movzwl %ax,%eax
  8140c8:	89 c7                	mov    %eax,%edi
  8140ca:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8140d1:	00 00 00 
  8140d4:	ff d0                	callq  *%rax
  8140d6:	0f b7 c0             	movzwl %ax,%eax
  8140d9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8140de:	89 c7                	mov    %eax,%edi
  8140e0:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8140e7:	00 00 00 
  8140ea:	ff d0                	callq  *%rax
  8140ec:	89 c2                	mov    %eax,%edx
  8140ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140f2:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8140f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140fa:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8140fe:	0f b7 c0             	movzwl %ax,%eax
  814101:	89 c7                	mov    %eax,%edi
  814103:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81410a:	00 00 00 
  81410d:	ff d0                	callq  *%rax
  81410f:	89 c2                	mov    %eax,%edx
  814111:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814115:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  814119:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81411d:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814123:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814127:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81412b:	0f b7 c0             	movzwl %ax,%eax
  81412e:	89 c7                	mov    %eax,%edi
  814130:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  814137:	00 00 00 
  81413a:	ff d0                	callq  *%rax
  81413c:	83 e0 3f             	and    $0x3f,%eax
  81413f:	80 cc 50             	or     $0x50,%ah
  814142:	0f b7 c0             	movzwl %ax,%eax
  814145:	89 c7                	mov    %eax,%edi
  814147:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81414e:	00 00 00 
  814151:	ff d0                	callq  *%rax
  814153:	89 c2                	mov    %eax,%edx
  814155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814159:	66 89 50 0c          	mov    %dx,0xc(%rax)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  81415d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814161:	48 8b 40 08          	mov    0x8(%rax),%rax
  814165:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814169:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81416d:	48 8b 40 10          	mov    0x10(%rax),%rax
  814171:	0f b6 00             	movzbl (%rax),%eax
  814174:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  814176:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81417a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814180:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814184:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814188:	0f b7 c8             	movzwl %ax,%ecx
  81418b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81418f:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814193:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814197:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81419b:	41 89 c8             	mov    %ecx,%r8d
  81419e:	b9 06 00 00 00       	mov    $0x6,%ecx
  8141a3:	48 89 c7             	mov    %rax,%rdi
  8141a6:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  8141ad:	00 00 00 
  8141b0:	ff d0                	callq  *%rax
  8141b2:	89 c2                	mov    %eax,%edx
  8141b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141b8:	66 89 50 10          	mov    %dx,0x10(%rax)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8141bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8141c0:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8141c4:	0f b6 d0             	movzbl %al,%edx
  8141c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8141cb:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8141cf:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8141d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8141d7:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8141dd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8141e3:	89 d1                	mov    %edx,%ecx
  8141e5:	48 89 fa             	mov    %rdi,%rdx
  8141e8:	48 89 c7             	mov    %rax,%rdi
  8141eb:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  8141f2:	00 00 00 
  8141f5:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8141f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8141fb:	48 89 c7             	mov    %rax,%rdi
  8141fe:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814205:	00 00 00 
  814208:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  81420a:	c9                   	leaveq 
  81420b:	c3                   	retq   

000000000081420c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  81420c:	55                   	push   %rbp
  81420d:	48 89 e5             	mov    %rsp,%rbp
  814210:	53                   	push   %rbx
  814211:	48 83 ec 58          	sub    $0x58,%rsp
  814215:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814219:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  81421d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814221:	48 8b 40 08          	mov    0x8(%rax),%rax
  814225:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814229:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81422d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814231:	0f b7 d8             	movzwl %ax,%ebx
  814234:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814238:	0f b7 00             	movzwl (%rax),%eax
  81423b:	0f b7 c0             	movzwl %ax,%eax
  81423e:	89 c7                	mov    %eax,%edi
  814240:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  814247:	00 00 00 
  81424a:	ff d0                	callq  *%rax
  81424c:	66 c1 e8 08          	shr    $0x8,%ax
  814250:	0f b7 c0             	movzwl %ax,%eax
  814253:	83 e0 0f             	and    $0xf,%eax
  814256:	83 c0 02             	add    $0x2,%eax
  814259:	c1 e0 02             	shl    $0x2,%eax
  81425c:	39 c3                	cmp    %eax,%ebx
  81425e:	7c 40                	jl     8142a0 <udp_input+0x94>
  814260:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814264:	0f b7 00             	movzwl (%rax),%eax
  814267:	0f b7 c0             	movzwl %ax,%eax
  81426a:	89 c7                	mov    %eax,%edi
  81426c:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  814273:	00 00 00 
  814276:	ff d0                	callq  *%rax
  814278:	66 c1 e8 08          	shr    $0x8,%ax
  81427c:	83 e0 0f             	and    $0xf,%eax
  81427f:	c1 e0 02             	shl    $0x2,%eax
  814282:	f7 d8                	neg    %eax
  814284:	0f bf d0             	movswl %ax,%edx
  814287:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81428b:	89 d6                	mov    %edx,%esi
  81428d:	48 89 c7             	mov    %rax,%rdi
  814290:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  814297:	00 00 00 
  81429a:	ff d0                	callq  *%rax
  81429c:	84 c0                	test   %al,%al
  81429e:	74 18                	je     8142b8 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  8142a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8142a4:	48 89 c7             	mov    %rax,%rdi
  8142a7:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8142ae:	00 00 00 
  8142b1:	ff d0                	callq  *%rax
    goto end;
  8142b3:	e9 62 04 00 00       	jmpq   81471a <udp_input+0x50e>
  }

  udphdr = (struct udp_hdr *)p->payload;
  8142b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8142bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8142c0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  8142c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8142c8:	0f b7 00             	movzwl (%rax),%eax
  8142cb:	0f b7 c0             	movzwl %ax,%eax
  8142ce:	89 c7                	mov    %eax,%edi
  8142d0:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8142d7:	00 00 00 
  8142da:	ff d0                	callq  *%rax
  8142dc:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  8142e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8142e4:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8142e8:	0f b7 c0             	movzwl %ax,%eax
  8142eb:	89 c7                	mov    %eax,%edi
  8142ed:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  8142f4:	00 00 00 
  8142f7:	ff d0                	callq  *%rax
  8142f9:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  8142fd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814304:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814305:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  81430a:	0f 85 8c 00 00 00    	jne    81439c <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814310:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814315:	0f 85 d3 01 00 00    	jne    8144ee <udp_input+0x2e2>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  81431b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81431f:	48 8b 40 38          	mov    0x38(%rax),%rax
  814323:	48 85 c0             	test   %rax,%rax
  814326:	0f 84 c2 01 00 00    	je     8144ee <udp_input+0x2e2>
  81432c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814330:	48 8b 40 38          	mov    0x38(%rax),%rax
  814334:	48 8b 40 08          	mov    0x8(%rax),%rax
  814338:	48 85 c0             	test   %rax,%rax
  81433b:	0f 84 ad 01 00 00    	je     8144ee <udp_input+0x2e2>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814341:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814345:	48 8b 40 38          	mov    0x38(%rax),%rax
  814349:	48 8b 40 08          	mov    0x8(%rax),%rax
  81434d:	48 83 c0 04          	add    $0x4,%rax
  814351:	48 85 c0             	test   %rax,%rax
  814354:	74 31                	je     814387 <udp_input+0x17b>
  814356:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81435a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81435e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814362:	8b 40 04             	mov    0x4(%rax),%eax
  814365:	85 c0                	test   %eax,%eax
  814367:	74 1e                	je     814387 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814369:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81436d:	48 8b 40 38          	mov    0x38(%rax),%rax
  814371:	48 8b 40 08          	mov    0x8(%rax),%rax
  814375:	8b 50 04             	mov    0x4(%rax),%edx
  814378:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81437c:	8b 40 0c             	mov    0xc(%rax),%eax
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  81437f:	39 c2                	cmp    %eax,%edx
  814381:	0f 85 67 01 00 00    	jne    8144ee <udp_input+0x2e2>
          pcb = inp->dhcp->pcb;
  814387:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81438b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81438f:	48 8b 40 08          	mov    0x8(%rax),%rax
  814393:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814397:	e9 52 01 00 00       	jmpq   8144ee <udp_input+0x2e2>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  81439c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8143a3:	00 
    local_match = 0;
  8143a4:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  8143a8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8143af:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8143b0:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  8143b7:	00 00 00 
  8143ba:	48 8b 00             	mov    (%rax),%rax
  8143bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8143c1:	e9 0e 01 00 00       	jmpq   8144d4 <udp_input+0x2c8>
      local_match = 0;
  8143c6:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8143ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143ce:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8143d2:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  8143d6:	75 6b                	jne    814443 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  8143d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
      if ((pcb->local_port == dest) &&
  8143dc:	48 85 c0             	test   %rax,%rax
  8143df:	74 3d                	je     81441e <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  8143e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143e5:	8b 00                	mov    (%rax),%eax
  8143e7:	85 c0                	test   %eax,%eax
  8143e9:	74 33                	je     81441e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8143eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143ef:	8b 10                	mov    (%rax),%edx
  8143f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8143f5:	8b 40 10             	mov    0x10(%rax),%eax
          (ip_addr_isany(&pcb->local_ip) ||
  8143f8:	39 c2                	cmp    %eax,%edx
  8143fa:	74 22                	je     81441e <udp_input+0x212>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8143fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814400:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814404:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814408:	48 89 c6             	mov    %rax,%rsi
  81440b:	48 89 d7             	mov    %rdx,%rdi
  81440e:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  814415:	00 00 00 
  814418:	ff d0                	callq  *%rax
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  81441a:	84 c0                	test   %al,%al
  81441c:	74 25                	je     814443 <udp_input+0x237>
        local_match = 1;
  81441e:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  814422:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  814427:	75 1a                	jne    814443 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  814429:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81442d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814431:	0f b6 c0             	movzbl %al,%eax
  814434:	83 e0 04             	and    $0x4,%eax
        if ((uncon_pcb == NULL) && 
  814437:	85 c0                	test   %eax,%eax
  814439:	75 08                	jne    814443 <udp_input+0x237>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  81443b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81443f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814443:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  814447:	74 77                	je     8144c0 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  814449:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81444d:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
      if ((local_match != 0) &&
  814451:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  814455:	75 69                	jne    8144c0 <udp_input+0x2b4>
          (ip_addr_isany(&pcb->remote_ip) ||
  814457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81445b:	48 83 c0 04          	add    $0x4,%rax
          (pcb->remote_port == src) &&
  81445f:	48 85 c0             	test   %rax,%rax
  814462:	74 1d                	je     814481 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  814464:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814468:	8b 40 04             	mov    0x4(%rax),%eax
  81446b:	85 c0                	test   %eax,%eax
  81446d:	74 12                	je     814481 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  81446f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814473:	8b 50 04             	mov    0x4(%rax),%edx
  814476:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81447a:	8b 40 0c             	mov    0xc(%rax),%eax
          (ip_addr_isany(&pcb->remote_ip) ||
  81447d:	39 c2                	cmp    %eax,%edx
  81447f:	75 3f                	jne    8144c0 <udp_input+0x2b4>
        /* the first fully matching PCB */
        if (prev != NULL) {
  814481:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814486:	74 36                	je     8144be <udp_input+0x2b2>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  814488:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81448c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814490:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814494:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  814498:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  81449f:	00 00 00 
  8144a2:	48 8b 10             	mov    (%rax),%rdx
  8144a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144a9:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  8144ad:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  8144b4:	00 00 00 
  8144b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8144bb:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  8144be:	eb 1f                	jmp    8144df <udp_input+0x2d3>
      }
      prev = pcb;
  8144c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144c4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8144c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144cc:	48 8b 40 10          	mov    0x10(%rax),%rax
  8144d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8144d4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8144d9:	0f 85 e7 fe ff ff    	jne    8143c6 <udp_input+0x1ba>
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  8144df:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8144e4:	75 08                	jne    8144ee <udp_input+0x2e2>
      pcb = uncon_pcb;
  8144e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144ea:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8144ee:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8144f3:	75 16                	jne    81450b <udp_input+0x2ff>
  8144f5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8144f9:	8b 50 08             	mov    0x8(%rax),%edx
  8144fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814500:	8b 40 10             	mov    0x10(%rax),%eax
  814503:	39 c2                	cmp    %eax,%edx
  814505:	0f 85 fc 01 00 00    	jne    814707 <udp_input+0x4fb>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  81450b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81450f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  814513:	66 85 c0             	test   %ax,%ax
  814516:	74 53                	je     81456b <udp_input+0x35f>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  814518:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81451c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  814520:	0f b7 c8             	movzwl %ax,%ecx
  814523:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814527:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81452b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81452f:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  814533:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814537:	41 89 c8             	mov    %ecx,%r8d
  81453a:	b9 11 00 00 00       	mov    $0x11,%ecx
  81453f:	48 89 c7             	mov    %rax,%rdi
  814542:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  814549:	00 00 00 
  81454c:	ff d0                	callq  *%rax
  81454e:	66 85 c0             	test   %ax,%ax
  814551:	74 18                	je     81456b <udp_input+0x35f>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  814553:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814557:	48 89 c7             	mov    %rax,%rdi
  81455a:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814561:	00 00 00 
  814564:	ff d0                	callq  *%rax
          goto end;
  814566:	e9 af 01 00 00       	jmpq   81471a <udp_input+0x50e>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  81456b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81456f:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  814574:	48 89 c7             	mov    %rax,%rdi
  814577:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81457e:	00 00 00 
  814581:	ff d0                	callq  *%rax
  814583:	84 c0                	test   %al,%al
  814585:	74 2a                	je     8145b1 <udp_input+0x3a5>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  814587:	48 ba 08 1e 82 00 00 	movabs $0x821e08,%rdx
  81458e:	00 00 00 
  814591:	be 0a 01 00 00       	mov    $0x10a,%esi
  814596:	48 bf 1c 1e 82 00 00 	movabs $0x821e1c,%rdi
  81459d:	00 00 00 
  8145a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8145a5:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8145ac:	00 00 00 
  8145af:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8145b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8145b6:	74 51                	je     814609 <udp_input+0x3fd>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8145b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8145bc:	48 8b 40 20          	mov    0x20(%rax),%rax
  8145c0:	48 85 c0             	test   %rax,%rax
  8145c3:	74 2c                	je     8145f1 <udp_input+0x3e5>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  8145c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8145c9:	48 8b 40 20          	mov    0x20(%rax),%rax
  8145cd:	44 0f b7 45 be       	movzwl -0x42(%rbp),%r8d
  8145d2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8145d6:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8145da:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8145de:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  8145e2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8145e6:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8145ea:	ff d0                	callq  *%rax
    if (pcb != NULL) {
  8145ec:	e9 29 01 00 00       	jmpq   81471a <udp_input+0x50e>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  8145f1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8145f5:	48 89 c7             	mov    %rax,%rdi
  8145f8:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8145ff:	00 00 00 
  814602:	ff d0                	callq  *%rax
        goto end;
  814604:	e9 11 01 00 00       	jmpq   81471a <udp_input+0x50e>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814609:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81460d:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814611:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814615:	48 89 c6             	mov    %rax,%rsi
  814618:	48 89 d7             	mov    %rdx,%rdi
  81461b:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  814622:	00 00 00 
  814625:	ff d0                	callq  *%rax
  814627:	84 c0                	test   %al,%al
  814629:	0f 85 c3 00 00 00    	jne    8146f2 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
  81462f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814633:	8b 58 10             	mov    0x10(%rax),%ebx
  814636:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81463b:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  814642:	00 00 00 
  814645:	ff d0                	callq  *%rax
  814647:	21 c3                	and    %eax,%ebx
  814649:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81464e:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  814655:	00 00 00 
  814658:	ff d0                	callq  *%rax
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  81465a:	39 c3                	cmp    %eax,%ebx
  81465c:	0f 84 90 00 00 00    	je     8146f2 <udp_input+0x4e6>
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  814662:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814666:	0f b7 00             	movzwl (%rax),%eax
  814669:	0f b7 c0             	movzwl %ax,%eax
  81466c:	89 c7                	mov    %eax,%edi
  81466e:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  814675:	00 00 00 
  814678:	ff d0                	callq  *%rax
  81467a:	66 c1 e8 08          	shr    $0x8,%ax
  81467e:	0f b7 c0             	movzwl %ax,%eax
  814681:	83 e0 0f             	and    $0xf,%eax
  814684:	83 c0 02             	add    $0x2,%eax
  814687:	c1 e0 02             	shl    $0x2,%eax
  81468a:	0f bf d0             	movswl %ax,%edx
  81468d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814691:	89 d6                	mov    %edx,%esi
  814693:	48 89 c7             	mov    %rax,%rdi
  814696:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81469d:	00 00 00 
  8146a0:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  8146a2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8146a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8146aa:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8146ae:	74 2a                	je     8146da <udp_input+0x4ce>
  8146b0:	48 ba 30 1e 82 00 00 	movabs $0x821e30,%rdx
  8146b7:	00 00 00 
  8146ba:	be 25 01 00 00       	mov    $0x125,%esi
  8146bf:	48 bf 1c 1e 82 00 00 	movabs $0x821e1c,%rdi
  8146c6:	00 00 00 
  8146c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8146ce:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8146d5:	00 00 00 
  8146d8:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8146da:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8146de:	be 03 00 00 00       	mov    $0x3,%esi
  8146e3:	48 89 c7             	mov    %rax,%rdi
  8146e6:	48 b8 ad fb 81 00 00 	movabs $0x81fbad,%rax
  8146ed:	00 00 00 
  8146f0:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  8146f2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8146f6:	48 89 c7             	mov    %rax,%rdi
  8146f9:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814700:	00 00 00 
  814703:	ff d0                	callq  *%rax
    if (pcb != NULL) {
  814705:	eb 13                	jmp    81471a <udp_input+0x50e>
    }
  } else {
    pbuf_free(p);
  814707:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81470b:	48 89 c7             	mov    %rax,%rdi
  81470e:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814715:	00 00 00 
  814718:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  81471a:	48 83 c4 58          	add    $0x58,%rsp
  81471e:	5b                   	pop    %rbx
  81471f:	5d                   	pop    %rbp
  814720:	c3                   	retq   

0000000000814721 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  814721:	55                   	push   %rbp
  814722:	48 89 e5             	mov    %rsp,%rbp
  814725:	48 83 ec 10          	sub    $0x10,%rsp
  814729:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81472d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  814731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814735:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  814739:	0f b7 d0             	movzwl %ax,%edx
  81473c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814740:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814744:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  814748:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81474c:	89 d1                	mov    %edx,%ecx
  81474e:	48 89 fa             	mov    %rdi,%rdx
  814751:	48 89 c7             	mov    %rax,%rdi
  814754:	48 b8 62 47 81 00 00 	movabs $0x814762,%rax
  81475b:	00 00 00 
  81475e:	ff d0                	callq  *%rax
}
  814760:	c9                   	leaveq 
  814761:	c3                   	retq   

0000000000814762 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  814762:	55                   	push   %rbp
  814763:	48 89 e5             	mov    %rsp,%rbp
  814766:	48 83 ec 30          	sub    $0x30,%rsp
  81476a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81476e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  814772:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  814776:	89 c8                	mov    %ecx,%eax
  814778:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  81477c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814780:	48 89 c7             	mov    %rax,%rdi
  814783:	48 b8 f4 01 81 00 00 	movabs $0x8101f4,%rax
  81478a:	00 00 00 
  81478d:	ff d0                	callq  *%rax
  81478f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  814793:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814798:	75 07                	jne    8147a1 <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  81479a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81479f:	eb 26                	jmp    8147c7 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  8147a1:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  8147a5:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8147a9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8147ad:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8147b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147b5:	49 89 f8             	mov    %rdi,%r8
  8147b8:	48 89 c7             	mov    %rax,%rdi
  8147bb:	48 b8 c9 47 81 00 00 	movabs $0x8147c9,%rax
  8147c2:	00 00 00 
  8147c5:	ff d0                	callq  *%rax
}
  8147c7:	c9                   	leaveq 
  8147c8:	c3                   	retq   

00000000008147c9 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  8147c9:	55                   	push   %rbp
  8147ca:	48 89 e5             	mov    %rsp,%rbp
  8147cd:	48 83 ec 50          	sub    $0x50,%rsp
  8147d1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8147d5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8147d9:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8147dd:	89 c8                	mov    %ecx,%eax
  8147df:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8147e3:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  8147e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147eb:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8147ef:	66 85 c0             	test   %ax,%ax
  8147f2:	75 37                	jne    81482b <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8147f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147f8:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8147fc:	0f b7 d0             	movzwl %ax,%edx
  8147ff:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  814803:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814807:	48 89 ce             	mov    %rcx,%rsi
  81480a:	48 89 c7             	mov    %rax,%rdi
  81480d:	48 b8 87 4a 81 00 00 	movabs $0x814a87,%rax
  814814:	00 00 00 
  814817:	ff d0                	callq  *%rax
  814819:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  81481c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  814820:	74 09                	je     81482b <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  814822:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  814826:	e9 5a 02 00 00       	jmpq   814a85 <udp_sendto_if+0x2bc>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  81482b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81482f:	be 08 00 00 00       	mov    $0x8,%esi
  814834:	48 89 c7             	mov    %rax,%rdi
  814837:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81483e:	00 00 00 
  814841:	ff d0                	callq  *%rax
  814843:	84 c0                	test   %al,%al
  814845:	74 4c                	je     814893 <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  814847:	ba 00 00 00 00       	mov    $0x0,%edx
  81484c:	be 08 00 00 00       	mov    $0x8,%esi
  814851:	bf 01 00 00 00       	mov    $0x1,%edi
  814856:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81485d:	00 00 00 
  814860:	ff d0                	callq  *%rax
  814862:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  814866:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81486b:	75 0a                	jne    814877 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  81486d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  814872:	e9 0e 02 00 00       	jmpq   814a85 <udp_sendto_if+0x2bc>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  814877:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81487b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81487f:	48 89 d6             	mov    %rdx,%rsi
  814882:	48 89 c7             	mov    %rax,%rdi
  814885:	48 b8 87 d4 80 00 00 	movabs $0x80d487,%rax
  81488c:	00 00 00 
  81488f:	ff d0                	callq  *%rax
  814891:	eb 08                	jmp    81489b <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  814893:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814897:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  81489b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81489f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8148a3:	66 83 f8 07          	cmp    $0x7,%ax
  8148a7:	77 2a                	ja     8148d3 <udp_sendto_if+0x10a>
  8148a9:	48 ba 48 1e 82 00 00 	movabs $0x821e48,%rdx
  8148b0:	00 00 00 
  8148b3:	be b2 01 00 00       	mov    $0x1b2,%esi
  8148b8:	48 bf 1c 1e 82 00 00 	movabs $0x821e1c,%rdi
  8148bf:	00 00 00 
  8148c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8148c7:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8148ce:	00 00 00 
  8148d1:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  8148d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8148d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8148db:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  8148df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8148e3:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8148e7:	0f b7 c0             	movzwl %ax,%eax
  8148ea:	89 c7                	mov    %eax,%edi
  8148ec:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8148f3:	00 00 00 
  8148f6:	ff d0                	callq  *%rax
  8148f8:	89 c2                	mov    %eax,%edx
  8148fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8148fe:	66 89 10             	mov    %dx,(%rax)
  udphdr->dest = htons(dst_port);
  814901:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  814905:	89 c7                	mov    %eax,%edi
  814907:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81490e:	00 00 00 
  814911:	ff d0                	callq  *%rax
  814913:	89 c2                	mov    %eax,%edx
  814915:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814919:	66 89 50 02          	mov    %dx,0x2(%rax)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  81491d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814921:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  814927:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81492b:	48 85 c0             	test   %rax,%rax
  81492e:	74 0a                	je     81493a <udp_sendto_if+0x171>
  814930:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814934:	8b 00                	mov    (%rax),%eax
  814936:	85 c0                	test   %eax,%eax
  814938:	75 0e                	jne    814948 <udp_sendto_if+0x17f>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81493a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81493e:	48 83 c0 08          	add    $0x8,%rax
  814942:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814946:	eb 48                	jmp    814990 <udp_sendto_if+0x1c7>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  814948:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81494c:	8b 10                	mov    (%rax),%edx
  81494e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814952:	8b 40 08             	mov    0x8(%rax),%eax
  814955:	39 c2                	cmp    %eax,%edx
  814957:	74 2f                	je     814988 <udp_sendto_if+0x1bf>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  814959:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81495d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  814961:	74 1b                	je     81497e <udp_sendto_if+0x1b5>
        /* free the header pbuf */
        pbuf_free(q);
  814963:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814967:	48 89 c7             	mov    %rax,%rdi
  81496a:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814971:	00 00 00 
  814974:	ff d0                	callq  *%rax
        q = NULL;
  814976:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81497d:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  81497e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  814983:	e9 fd 00 00 00       	jmpq   814a85 <udp_sendto_if+0x2bc>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  814988:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81498c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  814990:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814994:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814998:	0f b7 c0             	movzwl %ax,%eax
  81499b:	89 c7                	mov    %eax,%edi
  81499d:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8149a4:	00 00 00 
  8149a7:	ff d0                	callq  *%rax
  8149a9:	89 c2                	mov    %eax,%edx
  8149ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8149af:	66 89 50 04          	mov    %dx,0x4(%rax)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8149b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8149b7:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8149bb:	0f b6 c0             	movzbl %al,%eax
  8149be:	83 e0 01             	and    $0x1,%eax
  8149c1:	85 c0                	test   %eax,%eax
  8149c3:	75 4f                	jne    814a14 <udp_sendto_if+0x24b>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  8149c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149c9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8149cd:	0f b7 c8             	movzwl %ax,%ecx
  8149d0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8149d4:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8149d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149dc:	41 89 c8             	mov    %ecx,%r8d
  8149df:	b9 11 00 00 00       	mov    $0x11,%ecx
  8149e4:	48 89 c7             	mov    %rax,%rdi
  8149e7:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  8149ee:	00 00 00 
  8149f1:	ff d0                	callq  *%rax
  8149f3:	89 c2                	mov    %eax,%edx
  8149f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8149f9:	66 89 50 06          	mov    %dx,0x6(%rax)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  8149fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814a01:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  814a05:	66 85 c0             	test   %ax,%ax
  814a08:	75 0a                	jne    814a14 <udp_sendto_if+0x24b>
  814a0a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814a0e:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  814a14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814a18:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  814a1c:	0f b6 f8             	movzbl %al,%edi
  814a1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814a23:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814a27:	0f b6 c8             	movzbl %al,%ecx
  814a2a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  814a2e:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  814a32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a36:	48 83 ec 08          	sub    $0x8,%rsp
  814a3a:	ff 75 b8             	pushq  -0x48(%rbp)
  814a3d:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  814a43:	41 89 f8             	mov    %edi,%r8d
  814a46:	48 89 c7             	mov    %rax,%rdi
  814a49:	48 b8 29 07 81 00 00 	movabs $0x810729,%rax
  814a50:	00 00 00 
  814a53:	ff d0                	callq  *%rax
  814a55:	48 83 c4 10          	add    $0x10,%rsp
  814a59:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  814a5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a60:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  814a64:	74 1b                	je     814a81 <udp_sendto_if+0x2b8>
    /* free the header pbuf */
    pbuf_free(q);
  814a66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a6a:	48 89 c7             	mov    %rax,%rdi
  814a6d:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814a74:	00 00 00 
  814a77:	ff d0                	callq  *%rax
    q = NULL;
  814a79:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  814a80:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  814a81:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  814a85:	c9                   	leaveq 
  814a86:	c3                   	retq   

0000000000814a87 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  814a87:	55                   	push   %rbp
  814a88:	48 89 e5             	mov    %rsp,%rbp
  814a8b:	48 83 ec 30          	sub    $0x30,%rsp
  814a8f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  814a93:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  814a97:	89 d0                	mov    %edx,%eax
  814a99:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  814a9d:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  814aa1:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814aa8:	00 00 00 
  814aab:	48 8b 00             	mov    (%rax),%rax
  814aae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814ab2:	eb 4a                	jmp    814afe <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  814ab4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ab8:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  814abc:	75 34                	jne    814af2 <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  814abe:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  814ac2:	74 2a                	je     814aee <udp_bind+0x67>
  814ac4:	48 ba 76 1e 82 00 00 	movabs $0x821e76,%rdx
  814acb:	00 00 00 
  814ace:	be 41 02 00 00       	mov    $0x241,%esi
  814ad3:	48 bf 1c 1e 82 00 00 	movabs $0x821e1c,%rdi
  814ada:	00 00 00 
  814add:	b8 00 00 00 00       	mov    $0x0,%eax
  814ae2:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  814ae9:	00 00 00 
  814aec:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  814aee:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  814af2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814af6:	48 8b 40 10          	mov    0x10(%rax),%rax
  814afa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814afe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814b03:	75 af                	jne    814ab4 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  814b05:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814b0a:	74 08                	je     814b14 <udp_bind+0x8d>
  814b0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814b10:	8b 00                	mov    (%rax),%eax
  814b12:	eb 05                	jmp    814b19 <udp_bind+0x92>
  814b14:	b8 00 00 00 00       	mov    $0x0,%eax
  814b19:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814b1d:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  814b1f:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  814b24:	75 6e                	jne    814b94 <udp_bind+0x10d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  814b26:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  814b2c:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814b33:	00 00 00 
  814b36:	48 8b 00             	mov    (%rax),%rax
  814b39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  814b3d:	eb 38                	jmp    814b77 <udp_bind+0xf0>
      if (ipcb->local_port == port) {
  814b3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814b43:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814b47:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  814b4b:	75 1e                	jne    814b6b <udp_bind+0xe4>
        /* port is already used by another udp_pcb */
        port++;
  814b4d:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  814b51:	83 c0 01             	add    $0x1,%eax
  814b54:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  814b58:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814b5f:	00 00 00 
  814b62:	48 8b 00             	mov    (%rax),%rax
  814b65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814b69:	eb 0c                	jmp    814b77 <udp_bind+0xf0>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  814b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814b6f:	48 8b 40 10          	mov    0x10(%rax),%rax
  814b73:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  814b77:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814b7c:	74 08                	je     814b86 <udp_bind+0xff>
  814b7e:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  814b84:	75 b9                	jne    814b3f <udp_bind+0xb8>
    }
    if (ipcb != NULL) {
  814b86:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814b8b:	74 07                	je     814b94 <udp_bind+0x10d>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  814b8d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  814b92:	eb 3d                	jmp    814bd1 <udp_bind+0x14a>
    }
  }
  pcb->local_port = port;
  814b94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b98:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  814b9c:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  814ba0:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  814ba4:	75 26                	jne    814bcc <udp_bind+0x145>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  814ba6:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814bad:	00 00 00 
  814bb0:	48 8b 10             	mov    (%rax),%rdx
  814bb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bb7:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  814bbb:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814bc2:	00 00 00 
  814bc5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814bc9:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  814bcc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  814bd1:	c9                   	leaveq 
  814bd2:	c3                   	retq   

0000000000814bd3 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  814bd3:	55                   	push   %rbp
  814bd4:	48 89 e5             	mov    %rsp,%rbp
  814bd7:	48 83 ec 30          	sub    $0x30,%rsp
  814bdb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  814bdf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  814be3:	89 d0                	mov    %edx,%eax
  814be5:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  814be9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bed:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814bf1:	66 85 c0             	test   %ax,%ax
  814bf4:	75 37                	jne    814c2d <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  814bf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bfa:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814bfe:	0f b7 d0             	movzwl %ax,%edx
  814c01:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  814c05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c09:	48 89 ce             	mov    %rcx,%rsi
  814c0c:	48 89 c7             	mov    %rax,%rdi
  814c0f:	48 b8 87 4a 81 00 00 	movabs $0x814a87,%rax
  814c16:	00 00 00 
  814c19:	ff d0                	callq  *%rax
  814c1b:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  814c1e:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  814c22:	74 09                	je     814c2d <udp_connect+0x5a>
      return err;
  814c24:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  814c28:	e9 9d 00 00 00       	jmpq   814cca <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  814c2d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814c32:	74 08                	je     814c3c <udp_connect+0x69>
  814c34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814c38:	8b 00                	mov    (%rax),%eax
  814c3a:	eb 05                	jmp    814c41 <udp_connect+0x6e>
  814c3c:	b8 00 00 00 00       	mov    $0x0,%eax
  814c41:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814c45:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  814c48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c4c:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  814c50:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  814c54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c58:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814c5c:	83 c8 04             	or     $0x4,%eax
  814c5f:	89 c2                	mov    %eax,%edx
  814c61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c65:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  814c68:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814c6f:	00 00 00 
  814c72:	48 8b 00             	mov    (%rax),%rax
  814c75:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814c79:	eb 1d                	jmp    814c98 <udp_connect+0xc5>
    if (pcb == ipcb) {
  814c7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c7f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  814c83:	75 07                	jne    814c8c <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  814c85:	b8 00 00 00 00       	mov    $0x0,%eax
  814c8a:	eb 3e                	jmp    814cca <udp_connect+0xf7>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  814c8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814c90:	48 8b 40 10          	mov    0x10(%rax),%rax
  814c94:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814c98:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814c9d:	75 dc                	jne    814c7b <udp_connect+0xa8>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  814c9f:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814ca6:	00 00 00 
  814ca9:	48 8b 10             	mov    (%rax),%rdx
  814cac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cb0:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  814cb4:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814cbb:	00 00 00 
  814cbe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814cc2:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  814cc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  814cca:	c9                   	leaveq 
  814ccb:	c3                   	retq   

0000000000814ccc <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  814ccc:	55                   	push   %rbp
  814ccd:	48 89 e5             	mov    %rsp,%rbp
  814cd0:	48 83 ec 08          	sub    $0x8,%rsp
  814cd4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  814cd8:	48 b8 28 1a 82 00 00 	movabs $0x821a28,%rax
  814cdf:	00 00 00 
  814ce2:	8b 10                	mov    (%rax),%edx
  814ce4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814ce8:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  814ceb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814cef:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  814cf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814cf9:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814cfd:	83 e0 fb             	and    $0xfffffffb,%eax
  814d00:	89 c2                	mov    %eax,%edx
  814d02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d06:	88 50 18             	mov    %dl,0x18(%rax)
}
  814d09:	c9                   	leaveq 
  814d0a:	c3                   	retq   

0000000000814d0b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  814d0b:	55                   	push   %rbp
  814d0c:	48 89 e5             	mov    %rsp,%rbp
  814d0f:	48 83 ec 18          	sub    $0x18,%rsp
  814d13:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  814d17:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  814d1b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  814d1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d23:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814d27:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  814d2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814d33:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  814d37:	c9                   	leaveq 
  814d38:	c3                   	retq   

0000000000814d39 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  814d39:	55                   	push   %rbp
  814d3a:	48 89 e5             	mov    %rsp,%rbp
  814d3d:	48 83 ec 20          	sub    $0x20,%rsp
  814d41:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  814d45:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814d4c:	00 00 00 
  814d4f:	48 8b 00             	mov    (%rax),%rax
  814d52:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  814d56:	75 20                	jne    814d78 <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  814d58:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814d5f:	00 00 00 
  814d62:	48 8b 00             	mov    (%rax),%rax
  814d65:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814d69:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814d70:	00 00 00 
  814d73:	48 89 10             	mov    %rdx,(%rax)
  814d76:	eb 51                	jmp    814dc9 <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  814d78:	48 b8 40 a0 b5 00 00 	movabs $0xb5a040,%rax
  814d7f:	00 00 00 
  814d82:	48 8b 00             	mov    (%rax),%rax
  814d85:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814d89:	eb 37                	jmp    814dc2 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  814d8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d8f:	48 8b 40 10          	mov    0x10(%rax),%rax
  814d93:	48 85 c0             	test   %rax,%rax
  814d96:	74 1e                	je     814db6 <udp_remove+0x7d>
  814d98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d9c:	48 8b 40 10          	mov    0x10(%rax),%rax
  814da0:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  814da4:	75 10                	jne    814db6 <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  814da6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814daa:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814dae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814db2:	48 89 50 10          	mov    %rdx,0x10(%rax)
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  814db6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814dba:	48 8b 40 10          	mov    0x10(%rax),%rax
  814dbe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814dc2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814dc7:	75 c2                	jne    814d8b <udp_remove+0x52>
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  814dc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dcd:	48 89 c6             	mov    %rax,%rsi
  814dd0:	bf 01 00 00 00       	mov    $0x1,%edi
  814dd5:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  814ddc:	00 00 00 
  814ddf:	ff d0                	callq  *%rax
}
  814de1:	c9                   	leaveq 
  814de2:	c3                   	retq   

0000000000814de3 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  814de3:	55                   	push   %rbp
  814de4:	48 89 e5             	mov    %rsp,%rbp
  814de7:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  814deb:	bf 01 00 00 00       	mov    $0x1,%edi
  814df0:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  814df7:	00 00 00 
  814dfa:	ff d0                	callq  *%rax
  814dfc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  814e00:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814e05:	74 25                	je     814e2c <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  814e07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814e0b:	ba 30 00 00 00       	mov    $0x30,%edx
  814e10:	be 00 00 00 00       	mov    $0x0,%esi
  814e15:	48 89 c7             	mov    %rax,%rdi
  814e18:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  814e1f:	00 00 00 
  814e22:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  814e24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814e28:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  814e2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  814e30:	c9                   	leaveq 
  814e31:	c3                   	retq   

0000000000814e32 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  814e32:	55                   	push   %rbp
  814e33:	48 89 e5             	mov    %rsp,%rbp
  814e36:	48 83 ec 20          	sub    $0x20,%rsp
  814e3a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  814e3e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814e43:	75 2a                	jne    814e6f <free_etharp_q+0x3d>
  814e45:	48 ba 94 1e 82 00 00 	movabs $0x821e94,%rdx
  814e4c:	00 00 00 
  814e4f:	be 93 00 00 00       	mov    $0x93,%esi
  814e54:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  814e5b:	00 00 00 
  814e5e:	b8 00 00 00 00       	mov    $0x0,%eax
  814e63:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  814e6a:	00 00 00 
  814e6d:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  814e6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e73:	48 8b 40 08          	mov    0x8(%rax),%rax
  814e77:	48 85 c0             	test   %rax,%rax
  814e7a:	75 2a                	jne    814ea6 <free_etharp_q+0x74>
  814e7c:	48 ba b6 1e 82 00 00 	movabs $0x821eb6,%rdx
  814e83:	00 00 00 
  814e86:	be 94 00 00 00       	mov    $0x94,%esi
  814e8b:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  814e92:	00 00 00 
  814e95:	b8 00 00 00 00       	mov    $0x0,%eax
  814e9a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  814ea1:	00 00 00 
  814ea4:	ff d1                	callq  *%rcx
  while (q) {
  814ea6:	eb 79                	jmp    814f21 <free_etharp_q+0xef>
    r = q;
  814ea8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814eac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  814eb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814eb4:	48 8b 00             	mov    (%rax),%rax
  814eb7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  814ebb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814ebf:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ec3:	48 85 c0             	test   %rax,%rax
  814ec6:	75 2a                	jne    814ef2 <free_etharp_q+0xc0>
  814ec8:	48 ba c3 1e 82 00 00 	movabs $0x821ec3,%rdx
  814ecf:	00 00 00 
  814ed2:	be 98 00 00 00       	mov    $0x98,%esi
  814ed7:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  814ede:	00 00 00 
  814ee1:	b8 00 00 00 00       	mov    $0x0,%eax
  814ee6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  814eed:	00 00 00 
  814ef0:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  814ef2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814ef6:	48 8b 40 08          	mov    0x8(%rax),%rax
  814efa:	48 89 c7             	mov    %rax,%rdi
  814efd:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  814f04:	00 00 00 
  814f07:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  814f09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f0d:	48 89 c6             	mov    %rax,%rsi
  814f10:	bf 0a 00 00 00       	mov    $0xa,%edi
  814f15:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  814f1c:	00 00 00 
  814f1f:	ff d0                	callq  *%rax
  while (q) {
  814f21:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814f26:	75 80                	jne    814ea8 <free_etharp_q+0x76>
  }
}
  814f28:	c9                   	leaveq 
  814f29:	c3                   	retq   

0000000000814f2a <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  814f2a:	55                   	push   %rbp
  814f2b:	48 89 e5             	mov    %rsp,%rbp
  814f2e:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  814f32:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  814f36:	e9 df 01 00 00       	jmpq   81511a <etharp_tmr+0x1f0>
    arp_table[i].ctime++;
  814f3b:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  814f3f:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  814f46:	00 00 00 
  814f49:	48 63 ca             	movslq %edx,%rcx
  814f4c:	48 89 c8             	mov    %rcx,%rax
  814f4f:	48 c1 e0 02          	shl    $0x2,%rax
  814f53:	48 01 c8             	add    %rcx,%rax
  814f56:	48 c1 e0 03          	shl    $0x3,%rax
  814f5a:	48 01 f0             	add    %rsi,%rax
  814f5d:	48 83 c0 10          	add    $0x10,%rax
  814f61:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  814f65:	8d 48 01             	lea    0x1(%rax),%ecx
  814f68:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  814f6f:	00 00 00 
  814f72:	48 63 d2             	movslq %edx,%rdx
  814f75:	48 89 d0             	mov    %rdx,%rax
  814f78:	48 c1 e0 02          	shl    $0x2,%rax
  814f7c:	48 01 d0             	add    %rdx,%rax
  814f7f:	48 c1 e0 03          	shl    $0x3,%rax
  814f83:	48 01 f0             	add    %rsi,%rax
  814f86:	48 83 c0 10          	add    $0x10,%rax
  814f8a:	88 48 08             	mov    %cl,0x8(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  814f8d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  814f91:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  814f98:	00 00 00 
  814f9b:	48 63 d0             	movslq %eax,%rdx
  814f9e:	48 89 d0             	mov    %rdx,%rax
  814fa1:	48 c1 e0 02          	shl    $0x2,%rax
  814fa5:	48 01 d0             	add    %rdx,%rax
  814fa8:	48 c1 e0 03          	shl    $0x3,%rax
  814fac:	48 01 c8             	add    %rcx,%rax
  814faf:	48 83 c0 10          	add    $0x10,%rax
  814fb3:	8b 40 04             	mov    0x4(%rax),%eax
  814fb6:	83 f8 02             	cmp    $0x2,%eax
  814fb9:	75 2e                	jne    814fe9 <etharp_tmr+0xbf>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  814fbb:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  814fbf:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  814fc6:	00 00 00 
  814fc9:	48 63 d0             	movslq %eax,%rdx
  814fcc:	48 89 d0             	mov    %rdx,%rax
  814fcf:	48 c1 e0 02          	shl    $0x2,%rax
  814fd3:	48 01 d0             	add    %rdx,%rax
  814fd6:	48 c1 e0 03          	shl    $0x3,%rax
  814fda:	48 01 c8             	add    %rcx,%rax
  814fdd:	48 83 c0 10          	add    $0x10,%rax
  814fe1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  814fe5:	3c ef                	cmp    $0xef,%al
  814fe7:	77 64                	ja     81504d <etharp_tmr+0x123>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  814fe9:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  814fed:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  814ff4:	00 00 00 
  814ff7:	48 63 d0             	movslq %eax,%rdx
  814ffa:	48 89 d0             	mov    %rdx,%rax
  814ffd:	48 c1 e0 02          	shl    $0x2,%rax
  815001:	48 01 d0             	add    %rdx,%rax
  815004:	48 c1 e0 03          	shl    $0x3,%rax
  815008:	48 01 c8             	add    %rcx,%rax
  81500b:	48 83 c0 10          	add    $0x10,%rax
  81500f:	8b 40 04             	mov    0x4(%rax),%eax
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815012:	83 f8 01             	cmp    $0x1,%eax
  815015:	0f 85 e6 00 00 00    	jne    815101 <etharp_tmr+0x1d7>
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  81501b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81501f:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815026:	00 00 00 
  815029:	48 63 d0             	movslq %eax,%rdx
  81502c:	48 89 d0             	mov    %rdx,%rax
  81502f:	48 c1 e0 02          	shl    $0x2,%rax
  815033:	48 01 d0             	add    %rdx,%rax
  815036:	48 c1 e0 03          	shl    $0x3,%rax
  81503a:	48 01 c8             	add    %rcx,%rax
  81503d:	48 83 c0 10          	add    $0x10,%rax
  815041:	0f b6 40 08          	movzbl 0x8(%rax),%eax
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815045:	3c 01                	cmp    $0x1,%al
  815047:	0f 86 b4 00 00 00    	jbe    815101 <etharp_tmr+0x1d7>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  81504d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815051:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815058:	00 00 00 
  81505b:	48 63 d0             	movslq %eax,%rdx
  81505e:	48 89 d0             	mov    %rdx,%rax
  815061:	48 c1 e0 02          	shl    $0x2,%rax
  815065:	48 01 d0             	add    %rdx,%rax
  815068:	48 c1 e0 03          	shl    $0x3,%rax
  81506c:	48 01 c8             	add    %rcx,%rax
  81506f:	48 8b 00             	mov    (%rax),%rax
  815072:	48 85 c0             	test   %rax,%rax
  815075:	74 5d                	je     8150d4 <etharp_tmr+0x1aa>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  815077:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81507b:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815082:	00 00 00 
  815085:	48 63 d0             	movslq %eax,%rdx
  815088:	48 89 d0             	mov    %rdx,%rax
  81508b:	48 c1 e0 02          	shl    $0x2,%rax
  81508f:	48 01 d0             	add    %rdx,%rax
  815092:	48 c1 e0 03          	shl    $0x3,%rax
  815096:	48 01 c8             	add    %rcx,%rax
  815099:	48 8b 00             	mov    (%rax),%rax
  81509c:	48 89 c7             	mov    %rax,%rdi
  81509f:	48 b8 32 4e 81 00 00 	movabs $0x814e32,%rax
  8150a6:	00 00 00 
  8150a9:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  8150ab:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8150af:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8150b6:	00 00 00 
  8150b9:	48 63 d0             	movslq %eax,%rdx
  8150bc:	48 89 d0             	mov    %rdx,%rax
  8150bf:	48 c1 e0 02          	shl    $0x2,%rax
  8150c3:	48 01 d0             	add    %rdx,%rax
  8150c6:	48 c1 e0 03          	shl    $0x3,%rax
  8150ca:	48 01 c8             	add    %rcx,%rax
  8150cd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8150d4:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8150d8:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8150df:	00 00 00 
  8150e2:	48 63 d0             	movslq %eax,%rdx
  8150e5:	48 89 d0             	mov    %rdx,%rax
  8150e8:	48 c1 e0 02          	shl    $0x2,%rax
  8150ec:	48 01 d0             	add    %rdx,%rax
  8150ef:	48 c1 e0 03          	shl    $0x3,%rax
  8150f3:	48 01 c8             	add    %rcx,%rax
  8150f6:	48 83 c0 10          	add    $0x10,%rax
  8150fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815101:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815105:	48 63 d0             	movslq %eax,%rdx
  815108:	48 89 d0             	mov    %rdx,%rax
  81510b:	48 c1 e0 02          	shl    $0x2,%rax
  81510f:	48 01 d0             	add    %rdx,%rax
  815112:	48 c1 e0 03          	shl    $0x3,%rax
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815116:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  81511a:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  81511e:	0f 86 17 fe ff ff    	jbe    814f3b <etharp_tmr+0x11>
        /* resend an ARP query here? */
    }
#endif
  }
}
  815124:	c9                   	leaveq 
  815125:	c3                   	retq   

0000000000815126 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  815126:	55                   	push   %rbp
  815127:	48 89 e5             	mov    %rsp,%rbp
  81512a:	48 83 ec 20          	sub    $0x20,%rsp
  81512e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815132:	89 f0                	mov    %esi,%eax
  815134:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  815137:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  81513b:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  81513f:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  815143:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815147:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  81514b:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  81514f:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  815153:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  815157:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81515c:	0f 84 87 00 00 00    	je     8151e9 <find_entry+0xc3>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  815162:	48 b8 50 a8 b4 00 00 	movabs $0xb4a850,%rax
  815169:	00 00 00 
  81516c:	0f b6 00             	movzbl (%rax),%eax
  81516f:	0f b6 c0             	movzbl %al,%eax
  815172:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815179:	00 00 00 
  81517c:	48 63 d0             	movslq %eax,%rdx
  81517f:	48 89 d0             	mov    %rdx,%rax
  815182:	48 c1 e0 02          	shl    $0x2,%rax
  815186:	48 01 d0             	add    %rdx,%rax
  815189:	48 c1 e0 03          	shl    $0x3,%rax
  81518d:	48 01 c8             	add    %rcx,%rax
  815190:	48 83 c0 10          	add    $0x10,%rax
  815194:	8b 40 04             	mov    0x4(%rax),%eax
  815197:	83 f8 02             	cmp    $0x2,%eax
  81519a:	75 4d                	jne    8151e9 <find_entry+0xc3>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  81519c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8151a0:	8b 08                	mov    (%rax),%ecx
  8151a2:	48 b8 50 a8 b4 00 00 	movabs $0xb4a850,%rax
  8151a9:	00 00 00 
  8151ac:	0f b6 00             	movzbl (%rax),%eax
  8151af:	0f b6 c0             	movzbl %al,%eax
  8151b2:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  8151b9:	00 00 00 
  8151bc:	48 63 d0             	movslq %eax,%rdx
  8151bf:	48 89 d0             	mov    %rdx,%rax
  8151c2:	48 c1 e0 02          	shl    $0x2,%rax
  8151c6:	48 01 d0             	add    %rdx,%rax
  8151c9:	48 c1 e0 03          	shl    $0x3,%rax
  8151cd:	48 01 f0             	add    %rsi,%rax
  8151d0:	8b 40 08             	mov    0x8(%rax),%eax
  8151d3:	39 c1                	cmp    %eax,%ecx
  8151d5:	75 12                	jne    8151e9 <find_entry+0xc3>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  8151d7:	48 b8 50 a8 b4 00 00 	movabs $0xb4a850,%rax
  8151de:	00 00 00 
  8151e1:	0f b6 00             	movzbl (%rax),%eax
  8151e4:	e9 cf 04 00 00       	jmpq   8156b8 <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8151e9:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  8151ed:	e9 aa 02 00 00       	jmpq   81549c <find_entry+0x376>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8151f2:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  8151f6:	75 39                	jne    815231 <find_entry+0x10b>
  8151f8:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8151fc:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815203:	00 00 00 
  815206:	48 63 d0             	movslq %eax,%rdx
  815209:	48 89 d0             	mov    %rdx,%rax
  81520c:	48 c1 e0 02          	shl    $0x2,%rax
  815210:	48 01 d0             	add    %rdx,%rax
  815213:	48 c1 e0 03          	shl    $0x3,%rax
  815217:	48 01 c8             	add    %rcx,%rax
  81521a:	48 83 c0 10          	add    $0x10,%rax
  81521e:	8b 40 04             	mov    0x4(%rax),%eax
  815221:	85 c0                	test   %eax,%eax
  815223:	75 0c                	jne    815231 <find_entry+0x10b>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815225:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815229:	88 45 fd             	mov    %al,-0x3(%rbp)
  81522c:	e9 67 02 00 00       	jmpq   815498 <find_entry+0x372>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815231:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815235:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  81523c:	00 00 00 
  81523f:	48 63 d0             	movslq %eax,%rdx
  815242:	48 89 d0             	mov    %rdx,%rax
  815245:	48 c1 e0 02          	shl    $0x2,%rax
  815249:	48 01 d0             	add    %rdx,%rax
  81524c:	48 c1 e0 03          	shl    $0x3,%rax
  815250:	48 01 c8             	add    %rcx,%rax
  815253:	48 83 c0 10          	add    $0x10,%rax
  815257:	8b 40 04             	mov    0x4(%rax),%eax
  81525a:	83 f8 01             	cmp    $0x1,%eax
  81525d:	0f 85 51 01 00 00    	jne    8153b4 <find_entry+0x28e>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815263:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815268:	74 48                	je     8152b2 <find_entry+0x18c>
  81526a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81526e:	8b 08                	mov    (%rax),%ecx
  815270:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815274:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  81527b:	00 00 00 
  81527e:	48 63 d0             	movslq %eax,%rdx
  815281:	48 89 d0             	mov    %rdx,%rax
  815284:	48 c1 e0 02          	shl    $0x2,%rax
  815288:	48 01 d0             	add    %rdx,%rax
  81528b:	48 c1 e0 03          	shl    $0x3,%rax
  81528f:	48 01 f0             	add    %rsi,%rax
  815292:	8b 40 08             	mov    0x8(%rax),%eax
  815295:	39 c1                	cmp    %eax,%ecx
  815297:	75 19                	jne    8152b2 <find_entry+0x18c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815299:	48 b8 50 a8 b4 00 00 	movabs $0xb4a850,%rax
  8152a0:	00 00 00 
  8152a3:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  8152a7:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8152a9:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8152ad:	e9 06 04 00 00       	jmpq   8156b8 <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8152b2:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8152b6:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8152bd:	00 00 00 
  8152c0:	48 63 d0             	movslq %eax,%rdx
  8152c3:	48 89 d0             	mov    %rdx,%rax
  8152c6:	48 c1 e0 02          	shl    $0x2,%rax
  8152ca:	48 01 d0             	add    %rdx,%rax
  8152cd:	48 c1 e0 03          	shl    $0x3,%rax
  8152d1:	48 01 c8             	add    %rcx,%rax
  8152d4:	48 8b 00             	mov    (%rax),%rax
  8152d7:	48 85 c0             	test   %rax,%rax
  8152da:	74 6c                	je     815348 <find_entry+0x222>
        if (arp_table[i].ctime >= age_queue) {
  8152dc:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8152e0:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8152e7:	00 00 00 
  8152ea:	48 63 d0             	movslq %eax,%rdx
  8152ed:	48 89 d0             	mov    %rdx,%rax
  8152f0:	48 c1 e0 02          	shl    $0x2,%rax
  8152f4:	48 01 d0             	add    %rdx,%rax
  8152f7:	48 c1 e0 03          	shl    $0x3,%rax
  8152fb:	48 01 c8             	add    %rcx,%rax
  8152fe:	48 83 c0 10          	add    $0x10,%rax
  815302:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815306:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815309:	0f 82 89 01 00 00    	jb     815498 <find_entry+0x372>
          old_queue = i;
  81530f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815313:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  815316:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81531a:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815321:	00 00 00 
  815324:	48 63 d0             	movslq %eax,%rdx
  815327:	48 89 d0             	mov    %rdx,%rax
  81532a:	48 c1 e0 02          	shl    $0x2,%rax
  81532e:	48 01 d0             	add    %rdx,%rax
  815331:	48 c1 e0 03          	shl    $0x3,%rax
  815335:	48 01 c8             	add    %rcx,%rax
  815338:	48 83 c0 10          	add    $0x10,%rax
  81533c:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815340:	88 45 f8             	mov    %al,-0x8(%rbp)
  815343:	e9 50 01 00 00       	jmpq   815498 <find_entry+0x372>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815348:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81534c:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815353:	00 00 00 
  815356:	48 63 d0             	movslq %eax,%rdx
  815359:	48 89 d0             	mov    %rdx,%rax
  81535c:	48 c1 e0 02          	shl    $0x2,%rax
  815360:	48 01 d0             	add    %rdx,%rax
  815363:	48 c1 e0 03          	shl    $0x3,%rax
  815367:	48 01 c8             	add    %rcx,%rax
  81536a:	48 83 c0 10          	add    $0x10,%rax
  81536e:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815372:	3a 45 fb             	cmp    -0x5(%rbp),%al
  815375:	0f 82 1d 01 00 00    	jb     815498 <find_entry+0x372>
          old_pending = i;
  81537b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81537f:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  815382:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815386:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  81538d:	00 00 00 
  815390:	48 63 d0             	movslq %eax,%rdx
  815393:	48 89 d0             	mov    %rdx,%rax
  815396:	48 c1 e0 02          	shl    $0x2,%rax
  81539a:	48 01 d0             	add    %rdx,%rax
  81539d:	48 c1 e0 03          	shl    $0x3,%rax
  8153a1:	48 01 c8             	add    %rcx,%rax
  8153a4:	48 83 c0 10          	add    $0x10,%rax
  8153a8:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  8153ac:	88 45 fb             	mov    %al,-0x5(%rbp)
  8153af:	e9 e4 00 00 00       	jmpq   815498 <find_entry+0x372>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8153b4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8153b8:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8153bf:	00 00 00 
  8153c2:	48 63 d0             	movslq %eax,%rdx
  8153c5:	48 89 d0             	mov    %rdx,%rax
  8153c8:	48 c1 e0 02          	shl    $0x2,%rax
  8153cc:	48 01 d0             	add    %rdx,%rax
  8153cf:	48 c1 e0 03          	shl    $0x3,%rax
  8153d3:	48 01 c8             	add    %rcx,%rax
  8153d6:	48 83 c0 10          	add    $0x10,%rax
  8153da:	8b 40 04             	mov    0x4(%rax),%eax
  8153dd:	83 f8 02             	cmp    $0x2,%eax
  8153e0:	0f 85 b2 00 00 00    	jne    815498 <find_entry+0x372>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8153e6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8153eb:	74 48                	je     815435 <find_entry+0x30f>
  8153ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153f1:	8b 08                	mov    (%rax),%ecx
  8153f3:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8153f7:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  8153fe:	00 00 00 
  815401:	48 63 d0             	movslq %eax,%rdx
  815404:	48 89 d0             	mov    %rdx,%rax
  815407:	48 c1 e0 02          	shl    $0x2,%rax
  81540b:	48 01 d0             	add    %rdx,%rax
  81540e:	48 c1 e0 03          	shl    $0x3,%rax
  815412:	48 01 f0             	add    %rsi,%rax
  815415:	8b 40 08             	mov    0x8(%rax),%eax
  815418:	39 c1                	cmp    %eax,%ecx
  81541a:	75 19                	jne    815435 <find_entry+0x30f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  81541c:	48 b8 50 a8 b4 00 00 	movabs $0xb4a850,%rax
  815423:	00 00 00 
  815426:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  81542a:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  81542c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815430:	e9 83 02 00 00       	jmpq   8156b8 <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  815435:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815439:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815440:	00 00 00 
  815443:	48 63 d0             	movslq %eax,%rdx
  815446:	48 89 d0             	mov    %rdx,%rax
  815449:	48 c1 e0 02          	shl    $0x2,%rax
  81544d:	48 01 d0             	add    %rdx,%rax
  815450:	48 c1 e0 03          	shl    $0x3,%rax
  815454:	48 01 c8             	add    %rcx,%rax
  815457:	48 83 c0 10          	add    $0x10,%rax
  81545b:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81545f:	3a 45 fa             	cmp    -0x6(%rbp),%al
  815462:	72 34                	jb     815498 <find_entry+0x372>
        old_stable = i;
  815464:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815468:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  81546b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81546f:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815476:	00 00 00 
  815479:	48 63 d0             	movslq %eax,%rdx
  81547c:	48 89 d0             	mov    %rdx,%rax
  81547f:	48 c1 e0 02          	shl    $0x2,%rax
  815483:	48 01 d0             	add    %rdx,%rax
  815486:	48 c1 e0 03          	shl    $0x3,%rax
  81548a:	48 01 c8             	add    %rcx,%rax
  81548d:	48 83 c0 10          	add    $0x10,%rax
  815491:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815495:	88 45 fa             	mov    %al,-0x6(%rbp)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815498:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  81549c:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  8154a0:	0f 86 4c fd ff ff    	jbe    8151f2 <find_entry+0xcc>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8154a6:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  8154aa:	75 0b                	jne    8154b7 <find_entry+0x391>
  8154ac:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  8154b0:	83 e0 01             	and    $0x1,%eax
  8154b3:	85 c0                	test   %eax,%eax
  8154b5:	74 0b                	je     8154c2 <find_entry+0x39c>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8154b7:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  8154bb:	83 e0 02             	and    $0x2,%eax
  8154be:	85 c0                	test   %eax,%eax
  8154c0:	74 0a                	je     8154cc <find_entry+0x3a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  8154c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8154c7:	e9 ec 01 00 00       	jmpq   8156b8 <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8154cc:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  8154d0:	7f 0c                	jg     8154de <find_entry+0x3b8>
    i = empty;
  8154d2:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  8154d6:	88 45 fc             	mov    %al,-0x4(%rbp)
  8154d9:	e9 ea 00 00 00       	jmpq   8155c8 <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  8154de:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  8154e2:	7f 5f                	jg     815543 <find_entry+0x41d>
    /* recycle oldest stable*/
    i = old_stable;
  8154e4:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  8154e8:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  8154eb:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8154ef:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8154f6:	00 00 00 
  8154f9:	48 63 d0             	movslq %eax,%rdx
  8154fc:	48 89 d0             	mov    %rdx,%rax
  8154ff:	48 c1 e0 02          	shl    $0x2,%rax
  815503:	48 01 d0             	add    %rdx,%rax
  815506:	48 c1 e0 03          	shl    $0x3,%rax
  81550a:	48 01 c8             	add    %rcx,%rax
  81550d:	48 8b 00             	mov    (%rax),%rax
  815510:	48 85 c0             	test   %rax,%rax
  815513:	0f 84 af 00 00 00    	je     8155c8 <find_entry+0x4a2>
  815519:	48 ba d0 1e 82 00 00 	movabs $0x821ed0,%rdx
  815520:	00 00 00 
  815523:	be 75 01 00 00       	mov    $0x175,%esi
  815528:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  81552f:	00 00 00 
  815532:	b8 00 00 00 00       	mov    $0x0,%eax
  815537:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81553e:	00 00 00 
  815541:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  815543:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815547:	7f 09                	jg     815552 <find_entry+0x42c>
    /* recycle oldest pending */
    i = old_pending;
  815549:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81554d:	88 45 fc             	mov    %al,-0x4(%rbp)
  815550:	eb 76                	jmp    8155c8 <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  815552:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  815556:	7f 66                	jg     8155be <find_entry+0x498>
    /* recycle oldest pending */
    i = old_queue;
  815558:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  81555c:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  81555f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815563:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  81556a:	00 00 00 
  81556d:	48 63 d0             	movslq %eax,%rdx
  815570:	48 89 d0             	mov    %rdx,%rax
  815573:	48 c1 e0 02          	shl    $0x2,%rax
  815577:	48 01 d0             	add    %rdx,%rax
  81557a:	48 c1 e0 03          	shl    $0x3,%rax
  81557e:	48 01 c8             	add    %rcx,%rax
  815581:	48 8b 00             	mov    (%rax),%rax
  815584:	48 89 c7             	mov    %rax,%rdi
  815587:	48 b8 32 4e 81 00 00 	movabs $0x814e32,%rax
  81558e:	00 00 00 
  815591:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  815593:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815597:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  81559e:	00 00 00 
  8155a1:	48 63 d0             	movslq %eax,%rdx
  8155a4:	48 89 d0             	mov    %rdx,%rax
  8155a7:	48 c1 e0 02          	shl    $0x2,%rax
  8155ab:	48 01 d0             	add    %rdx,%rax
  8155ae:	48 c1 e0 03          	shl    $0x3,%rax
  8155b2:	48 01 c8             	add    %rcx,%rax
  8155b5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8155bc:	eb 0a                	jmp    8155c8 <find_entry+0x4a2>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  8155be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8155c3:	e9 f0 00 00 00       	jmpq   8156b8 <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8155c8:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  8155cc:	76 2a                	jbe    8155f8 <find_entry+0x4d2>
  8155ce:	48 ba e7 1e 82 00 00 	movabs $0x821ee7,%rdx
  8155d5:	00 00 00 
  8155d8:	be 8b 01 00 00       	mov    $0x18b,%esi
  8155dd:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  8155e4:	00 00 00 
  8155e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8155ec:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8155f3:	00 00 00 
  8155f6:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8155f8:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8155fc:	48 63 d0             	movslq %eax,%rdx
  8155ff:	48 89 d0             	mov    %rdx,%rax
  815602:	48 c1 e0 02          	shl    $0x2,%rax
  815606:	48 01 d0             	add    %rdx,%rax
  815609:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  81560d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815611:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815618:	00 00 00 
  81561b:	48 63 d0             	movslq %eax,%rdx
  81561e:	48 89 d0             	mov    %rdx,%rax
  815621:	48 c1 e0 02          	shl    $0x2,%rax
  815625:	48 01 d0             	add    %rdx,%rax
  815628:	48 c1 e0 03          	shl    $0x3,%rax
  81562c:	48 01 c8             	add    %rcx,%rax
  81562f:	48 83 c0 10          	add    $0x10,%rax
  815633:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  81563a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81563f:	74 39                	je     81567a <find_entry+0x554>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  815641:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815645:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81564a:	74 08                	je     815654 <find_entry+0x52e>
  81564c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815650:	8b 08                	mov    (%rax),%ecx
  815652:	eb 05                	jmp    815659 <find_entry+0x533>
  815654:	b9 00 00 00 00       	mov    $0x0,%ecx
  815659:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  815660:	00 00 00 
  815663:	48 63 d2             	movslq %edx,%rdx
  815666:	48 89 d0             	mov    %rdx,%rax
  815669:	48 c1 e0 02          	shl    $0x2,%rax
  81566d:	48 01 d0             	add    %rdx,%rax
  815670:	48 c1 e0 03          	shl    $0x3,%rax
  815674:	48 01 f0             	add    %rsi,%rax
  815677:	89 48 08             	mov    %ecx,0x8(%rax)
  }
  arp_table[i].ctime = 0;
  81567a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81567e:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815685:	00 00 00 
  815688:	48 63 d0             	movslq %eax,%rdx
  81568b:	48 89 d0             	mov    %rdx,%rax
  81568e:	48 c1 e0 02          	shl    $0x2,%rax
  815692:	48 01 d0             	add    %rdx,%rax
  815695:	48 c1 e0 03          	shl    $0x3,%rax
  815699:	48 01 c8             	add    %rcx,%rax
  81569c:	48 83 c0 10          	add    $0x10,%rax
  8156a0:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  8156a4:	48 b8 50 a8 b4 00 00 	movabs $0xb4a850,%rax
  8156ab:	00 00 00 
  8156ae:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  8156b2:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  8156b4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  8156b8:	c9                   	leaveq 
  8156b9:	c3                   	retq   

00000000008156ba <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8156ba:	55                   	push   %rbp
  8156bb:	48 89 e5             	mov    %rsp,%rbp
  8156be:	48 83 ec 30          	sub    $0x30,%rsp
  8156c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8156c6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8156ca:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8156ce:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  8156d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8156d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8156da:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8156de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156e2:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8156e6:	3c 06                	cmp    $0x6,%al
  8156e8:	74 2a                	je     815714 <etharp_send_ip+0x5a>
  8156ea:	48 ba 00 1f 82 00 00 	movabs $0x821f00,%rdx
  8156f1:	00 00 00 
  8156f4:	be b3 01 00 00       	mov    $0x1b3,%esi
  8156f9:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  815700:	00 00 00 
  815703:	b8 00 00 00 00       	mov    $0x0,%eax
  815708:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81570f:	00 00 00 
  815712:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  815714:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  815718:	eb 43                	jmp    81575d <etharp_send_ip+0xa3>
    k--;
  81571a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81571e:	83 e8 01             	sub    $0x1,%eax
  815721:	88 45 ff             	mov    %al,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  815724:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815728:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81572c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  815730:	48 98                	cltq   
  815732:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815736:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81573a:	48 63 c6             	movslq %esi,%rax
  81573d:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  815740:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815744:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815748:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81574c:	48 98                	cltq   
  81574e:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815752:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815756:	48 63 c6             	movslq %esi,%rax
  815759:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  while(k > 0) {
  81575d:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  815761:	75 b7                	jne    81571a <etharp_send_ip+0x60>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  815763:	bf 00 08 00 00       	mov    $0x800,%edi
  815768:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81576f:	00 00 00 
  815772:	ff d0                	callq  *%rax
  815774:	89 c2                	mov    %eax,%edx
  815776:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81577a:	66 89 50 0c          	mov    %dx,0xc(%rax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  81577e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815782:	48 8b 40 28          	mov    0x28(%rax),%rax
  815786:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  81578a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81578e:	48 89 ce             	mov    %rcx,%rsi
  815791:	48 89 d7             	mov    %rdx,%rdi
  815794:	ff d0                	callq  *%rax
}
  815796:	c9                   	leaveq 
  815797:	c3                   	retq   

0000000000815798 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  815798:	55                   	push   %rbp
  815799:	48 89 e5             	mov    %rsp,%rbp
  81579c:	53                   	push   %rbx
  81579d:	48 83 ec 48          	sub    $0x48,%rsp
  8157a1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8157a5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8157a9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8157ad:	89 c8                	mov    %ecx,%eax
  8157af:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8157b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8157b6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8157ba:	3c 06                	cmp    $0x6,%al
  8157bc:	74 2a                	je     8157e8 <update_arp_entry+0x50>
  8157be:	48 ba 48 1f 82 00 00 	movabs $0x821f48,%rdx
  8157c5:	00 00 00 
  8157c8:	be d9 01 00 00       	mov    $0x1d9,%esi
  8157cd:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  8157d4:	00 00 00 
  8157d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8157dc:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8157e3:	00 00 00 
  8157e6:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8157e8:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8157ed:	74 56                	je     815845 <update_arp_entry+0xad>
  8157ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8157f3:	8b 00                	mov    (%rax),%eax
  8157f5:	85 c0                	test   %eax,%eax
  8157f7:	74 4c                	je     815845 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8157f9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8157fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815801:	48 89 d6             	mov    %rdx,%rsi
  815804:	48 89 c7             	mov    %rax,%rdi
  815807:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  81580e:	00 00 00 
  815811:	ff d0                	callq  *%rax
  if (ip_addr_isany(ipaddr) ||
  815813:	84 c0                	test   %al,%al
  815815:	75 2e                	jne    815845 <update_arp_entry+0xad>
      ip_addr_ismulticast(ipaddr)) {
  815817:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81581b:	8b 18                	mov    (%rax),%ebx
  81581d:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  815822:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  815829:	00 00 00 
  81582c:	ff d0                	callq  *%rax
  81582e:	21 c3                	and    %eax,%ebx
  815830:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  815835:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81583c:	00 00 00 
  81583f:	ff d0                	callq  *%rax
      ip_addr_isbroadcast(ipaddr, netif) ||
  815841:	39 c3                	cmp    %eax,%ebx
  815843:	75 0a                	jne    81584f <update_arp_entry+0xb7>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  815845:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  81584a:	e9 f0 01 00 00       	jmpq   815a3f <update_arp_entry+0x2a7>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  81584f:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  815853:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815857:	89 d6                	mov    %edx,%esi
  815859:	48 89 c7             	mov    %rax,%rdi
  81585c:	48 b8 26 51 81 00 00 	movabs $0x815126,%rax
  815863:	00 00 00 
  815866:	ff d0                	callq  *%rax
  815868:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  81586b:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81586f:	79 09                	jns    81587a <update_arp_entry+0xe2>
    return (err_t)i;
  815871:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  815875:	e9 c5 01 00 00       	jmpq   815a3f <update_arp_entry+0x2a7>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  81587a:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81587e:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815885:	00 00 00 
  815888:	48 63 d0             	movslq %eax,%rdx
  81588b:	48 89 d0             	mov    %rdx,%rax
  81588e:	48 c1 e0 02          	shl    $0x2,%rax
  815892:	48 01 d0             	add    %rdx,%rax
  815895:	48 c1 e0 03          	shl    $0x3,%rax
  815899:	48 01 c8             	add    %rcx,%rax
  81589c:	48 83 c0 10          	add    $0x10,%rax
  8158a0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  8158a7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8158ab:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8158b2:	00 00 00 
  8158b5:	48 63 d0             	movslq %eax,%rdx
  8158b8:	48 89 d0             	mov    %rdx,%rax
  8158bb:	48 c1 e0 02          	shl    $0x2,%rax
  8158bf:	48 01 d0             	add    %rdx,%rax
  8158c2:	48 c1 e0 03          	shl    $0x3,%rax
  8158c6:	48 01 c8             	add    %rcx,%rax
  8158c9:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8158cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8158d1:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8158d4:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  8158d8:	eb 48                	jmp    815922 <update_arp_entry+0x18a>
    k--;
  8158da:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8158de:	83 e8 01             	sub    $0x1,%eax
  8158e1:	88 45 ef             	mov    %al,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8158e4:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  8158e9:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  8158ed:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8158f1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8158f5:	48 98                	cltq   
  8158f7:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8158fb:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  815902:	00 00 00 
  815905:	48 63 ff             	movslq %edi,%rdi
  815908:	49 63 d0             	movslq %r8d,%rdx
  81590b:	48 89 d0             	mov    %rdx,%rax
  81590e:	48 c1 e0 02          	shl    $0x2,%rax
  815912:	48 01 d0             	add    %rdx,%rax
  815915:	48 c1 e0 03          	shl    $0x3,%rax
  815919:	48 01 f8             	add    %rdi,%rax
  81591c:	48 01 f0             	add    %rsi,%rax
  81591f:	88 48 0c             	mov    %cl,0xc(%rax)
  while (k > 0) {
  815922:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  815926:	75 b2                	jne    8158da <update_arp_entry+0x142>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  815928:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81592c:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815933:	00 00 00 
  815936:	48 63 d0             	movslq %eax,%rdx
  815939:	48 89 d0             	mov    %rdx,%rax
  81593c:	48 c1 e0 02          	shl    $0x2,%rax
  815940:	48 01 d0             	add    %rdx,%rax
  815943:	48 c1 e0 03          	shl    $0x3,%rax
  815947:	48 01 c8             	add    %rcx,%rax
  81594a:	48 83 c0 10          	add    $0x10,%rax
  81594e:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  815952:	e9 b5 00 00 00       	jmpq   815a0c <update_arp_entry+0x274>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  815957:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81595b:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815962:	00 00 00 
  815965:	48 63 d0             	movslq %eax,%rdx
  815968:	48 89 d0             	mov    %rdx,%rax
  81596b:	48 c1 e0 02          	shl    $0x2,%rax
  81596f:	48 01 d0             	add    %rdx,%rax
  815972:	48 c1 e0 03          	shl    $0x3,%rax
  815976:	48 01 c8             	add    %rcx,%rax
  815979:	48 8b 00             	mov    (%rax),%rax
  81597c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  815980:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  815984:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815988:	48 8b 08             	mov    (%rax),%rcx
  81598b:	48 be c0 a6 b4 00 00 	movabs $0xb4a6c0,%rsi
  815992:	00 00 00 
  815995:	48 63 d2             	movslq %edx,%rdx
  815998:	48 89 d0             	mov    %rdx,%rax
  81599b:	48 c1 e0 02          	shl    $0x2,%rax
  81599f:	48 01 d0             	add    %rdx,%rax
  8159a2:	48 c1 e0 03          	shl    $0x3,%rax
  8159a6:	48 01 f0             	add    %rsi,%rax
  8159a9:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  8159ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8159b0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8159b4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8159b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8159bc:	48 89 c6             	mov    %rax,%rsi
  8159bf:	bf 0a 00 00 00       	mov    $0xa,%edi
  8159c4:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  8159cb:	00 00 00 
  8159ce:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8159d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8159d4:	48 8d 78 41          	lea    0x41(%rax),%rdi
  8159d8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8159dc:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8159e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8159e4:	48 89 d1             	mov    %rdx,%rcx
  8159e7:	48 89 fa             	mov    %rdi,%rdx
  8159ea:	48 89 c7             	mov    %rax,%rdi
  8159ed:	48 b8 ba 56 81 00 00 	movabs $0x8156ba,%rax
  8159f4:	00 00 00 
  8159f7:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  8159f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8159fd:	48 89 c7             	mov    %rax,%rdi
  815a00:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  815a07:	00 00 00 
  815a0a:	ff d0                	callq  *%rax
  while (arp_table[i].q != NULL) {
  815a0c:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  815a10:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815a17:	00 00 00 
  815a1a:	48 63 d0             	movslq %eax,%rdx
  815a1d:	48 89 d0             	mov    %rdx,%rax
  815a20:	48 c1 e0 02          	shl    $0x2,%rax
  815a24:	48 01 d0             	add    %rdx,%rax
  815a27:	48 c1 e0 03          	shl    $0x3,%rax
  815a2b:	48 01 c8             	add    %rcx,%rax
  815a2e:	48 8b 00             	mov    (%rax),%rax
  815a31:	48 85 c0             	test   %rax,%rax
  815a34:	0f 85 1d ff ff ff    	jne    815957 <update_arp_entry+0x1bf>
  }
#endif
  return ERR_OK;
  815a3a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  815a3f:	48 83 c4 48          	add    $0x48,%rsp
  815a43:	5b                   	pop    %rbx
  815a44:	5d                   	pop    %rbp
  815a45:	c3                   	retq   

0000000000815a46 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  815a46:	55                   	push   %rbp
  815a47:	48 89 e5             	mov    %rsp,%rbp
  815a4a:	48 83 ec 30          	sub    $0x30,%rsp
  815a4e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815a52:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815a56:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  815a5a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  815a5e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815a62:	be 02 00 00 00       	mov    $0x2,%esi
  815a67:	48 89 c7             	mov    %rax,%rdi
  815a6a:	48 b8 26 51 81 00 00 	movabs $0x815126,%rax
  815a71:	00 00 00 
  815a74:	ff d0                	callq  *%rax
  815a76:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  815a79:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  815a7d:	0f 88 8e 00 00 00    	js     815b11 <etharp_find_addr+0xcb>
  815a83:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  815a87:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  815a8e:	00 00 00 
  815a91:	48 63 d0             	movslq %eax,%rdx
  815a94:	48 89 d0             	mov    %rdx,%rax
  815a97:	48 c1 e0 02          	shl    $0x2,%rax
  815a9b:	48 01 d0             	add    %rdx,%rax
  815a9e:	48 c1 e0 03          	shl    $0x3,%rax
  815aa2:	48 01 c8             	add    %rcx,%rax
  815aa5:	48 83 c0 10          	add    $0x10,%rax
  815aa9:	8b 40 04             	mov    0x4(%rax),%eax
  815aac:	83 f8 02             	cmp    $0x2,%eax
  815aaf:	75 60                	jne    815b11 <etharp_find_addr+0xcb>
      *eth_ret = &arp_table[i].ethaddr;
  815ab1:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  815ab5:	48 63 d0             	movslq %eax,%rdx
  815ab8:	48 89 d0             	mov    %rdx,%rax
  815abb:	48 c1 e0 02          	shl    $0x2,%rax
  815abf:	48 01 d0             	add    %rdx,%rax
  815ac2:	48 c1 e0 03          	shl    $0x3,%rax
  815ac6:	48 ba c0 a6 b4 00 00 	movabs $0xb4a6c0,%rdx
  815acd:	00 00 00 
  815ad0:	48 01 d0             	add    %rdx,%rax
  815ad3:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  815ad7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815adb:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  815ade:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  815ae2:	48 63 d0             	movslq %eax,%rdx
  815ae5:	48 89 d0             	mov    %rdx,%rax
  815ae8:	48 c1 e0 02          	shl    $0x2,%rax
  815aec:	48 01 d0             	add    %rdx,%rax
  815aef:	48 c1 e0 03          	shl    $0x3,%rax
  815af3:	48 ba c0 a6 b4 00 00 	movabs $0xb4a6c0,%rdx
  815afa:	00 00 00 
  815afd:	48 01 d0             	add    %rdx,%rax
  815b00:	48 8d 50 08          	lea    0x8(%rax),%rdx
  815b04:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815b08:	48 89 10             	mov    %rdx,(%rax)
      return i;
  815b0b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b0f:	eb 05                	jmp    815b16 <etharp_find_addr+0xd0>
  }
  return -1;
  815b11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  815b16:	c9                   	leaveq 
  815b17:	c3                   	retq   

0000000000815b18 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  815b18:	55                   	push   %rbp
  815b19:	48 89 e5             	mov    %rsp,%rbp
  815b1c:	48 83 ec 20          	sub    $0x20,%rsp
  815b20:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815b24:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  815b28:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815b2d:	75 2a                	jne    815b59 <etharp_ip_input+0x41>
  815b2f:	48 ba 6f 1f 82 00 00 	movabs $0x821f6f,%rdx
  815b36:	00 00 00 
  815b39:	be 48 02 00 00       	mov    $0x248,%esi
  815b3e:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  815b45:	00 00 00 
  815b48:	b8 00 00 00 00       	mov    $0x0,%eax
  815b4d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  815b54:	00 00 00 
  815b57:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  815b59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815b5d:	48 8b 40 08          	mov    0x8(%rax),%rax
  815b61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  815b65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b69:	8b 50 1c             	mov    0x1c(%rax),%edx
  815b6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b70:	8b 40 08             	mov    0x8(%rax),%eax
  815b73:	31 c2                	xor    %eax,%edx
  815b75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b79:	8b 40 0c             	mov    0xc(%rax),%eax
  815b7c:	21 d0                	and    %edx,%eax
  815b7e:	85 c0                	test   %eax,%eax
  815b80:	74 02                	je     815b84 <etharp_ip_input+0x6c>
    /* do nothing */
    return;
  815b82:	eb 28                	jmp    815bac <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  815b84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b88:	48 8d 50 06          	lea    0x6(%rax),%rdx
  815b8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b90:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  815b94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b98:	b9 00 00 00 00       	mov    $0x0,%ecx
  815b9d:	48 89 c7             	mov    %rax,%rdi
  815ba0:	48 b8 98 57 81 00 00 	movabs $0x815798,%rax
  815ba7:	00 00 00 
  815baa:	ff d0                	callq  *%rax
}
  815bac:	c9                   	leaveq 
  815bad:	c3                   	retq   

0000000000815bae <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  815bae:	55                   	push   %rbp
  815baf:	48 89 e5             	mov    %rsp,%rbp
  815bb2:	53                   	push   %rbx
  815bb3:	48 83 ec 58          	sub    $0x58,%rsp
  815bb7:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  815bbb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  815bbf:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  815bc3:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  815bc8:	75 2a                	jne    815bf4 <etharp_arp_input+0x46>
  815bca:	48 ba 6f 1f 82 00 00 	movabs $0x821f6f,%rdx
  815bd1:	00 00 00 
  815bd4:	be 75 02 00 00       	mov    $0x275,%esi
  815bd9:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  815be0:	00 00 00 
  815be3:	b8 00 00 00 00       	mov    $0x0,%eax
  815be8:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  815bef:	00 00 00 
  815bf2:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  815bf4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815bf8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  815bfc:	66 83 f8 29          	cmp    $0x29,%ax
  815c00:	77 18                	ja     815c1a <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  815c02:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815c06:	48 89 c7             	mov    %rax,%rdi
  815c09:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  815c10:	00 00 00 
  815c13:	ff d0                	callq  *%rax
    return;
  815c15:	e9 d5 02 00 00       	jmpq   815eef <etharp_arp_input+0x341>
  }

  hdr = p->payload;
  815c1a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815c1e:	48 8b 40 08          	mov    0x8(%rax),%rax
  815c22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  815c26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815c2a:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  815c2e:	bf 01 00 00 00       	mov    $0x1,%edi
  815c33:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  815c3a:	00 00 00 
  815c3d:	ff d0                	callq  *%rax
  815c3f:	66 39 c3             	cmp    %ax,%bx
  815c42:	75 5a                	jne    815c9e <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  815c44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815c48:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  815c4c:	bf 04 06 00 00       	mov    $0x604,%edi
  815c51:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  815c58:	00 00 00 
  815c5b:	ff d0                	callq  *%rax
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  815c5d:	66 39 c3             	cmp    %ax,%bx
  815c60:	75 3c                	jne    815c9e <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  815c62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815c66:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  815c6a:	bf 00 08 00 00       	mov    $0x800,%edi
  815c6f:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  815c76:	00 00 00 
  815c79:	ff d0                	callq  *%rax
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  815c7b:	66 39 c3             	cmp    %ax,%bx
  815c7e:	75 1e                	jne    815c9e <etharp_arp_input+0xf0>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  815c80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815c84:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  815c88:	bf 06 08 00 00       	mov    $0x806,%edi
  815c8d:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  815c94:	00 00 00 
  815c97:	ff d0                	callq  *%rax
      (hdr->proto != htons(ETHTYPE_IP)) ||
  815c99:	66 39 c3             	cmp    %ax,%bx
  815c9c:	74 18                	je     815cb6 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  815c9e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815ca2:	48 89 c7             	mov    %rax,%rdi
  815ca5:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  815cac:	00 00 00 
  815caf:	ff d0                	callq  *%rax
    return;
  815cb1:	e9 39 02 00 00       	jmpq   815eef <etharp_arp_input+0x341>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  815cb6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815cba:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  815cbe:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  815cc2:	ba 04 00 00 00       	mov    $0x4,%edx
  815cc7:	48 89 ce             	mov    %rcx,%rsi
  815cca:	48 89 c7             	mov    %rax,%rdi
  815ccd:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  815cd4:	00 00 00 
  815cd7:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  815cd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815cdd:	48 8d 48 26          	lea    0x26(%rax),%rcx
  815ce1:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  815ce5:	ba 04 00 00 00       	mov    $0x4,%edx
  815cea:	48 89 ce             	mov    %rcx,%rsi
  815ced:	48 89 c7             	mov    %rax,%rdi
  815cf0:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  815cf7:	00 00 00 
  815cfa:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  815cfc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815d00:	8b 40 08             	mov    0x8(%rax),%eax
  815d03:	85 c0                	test   %eax,%eax
  815d05:	75 06                	jne    815d0d <etharp_arp_input+0x15f>
    for_us = 0;
  815d07:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  815d0b:	eb 12                	jmp    815d1f <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  815d0d:	8b 55 c0             	mov    -0x40(%rbp),%edx
  815d10:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815d14:	8b 40 08             	mov    0x8(%rax),%eax
  815d17:	39 c2                	cmp    %eax,%edx
  815d19:	0f 94 c0             	sete   %al
  815d1c:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  815d1f:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  815d23:	74 26                	je     815d4b <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  815d25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815d29:	48 8d 50 16          	lea    0x16(%rax),%rdx
  815d2d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  815d31:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815d35:	b9 01 00 00 00       	mov    $0x1,%ecx
  815d3a:	48 89 c7             	mov    %rax,%rdi
  815d3d:	48 b8 98 57 81 00 00 	movabs $0x815798,%rax
  815d44:	00 00 00 
  815d47:	ff d0                	callq  *%rax
  815d49:	eb 24                	jmp    815d6f <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  815d4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815d4f:	48 8d 50 16          	lea    0x16(%rax),%rdx
  815d53:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  815d57:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815d5b:	b9 00 00 00 00       	mov    $0x0,%ecx
  815d60:	48 89 c7             	mov    %rax,%rdi
  815d63:	48 b8 98 57 81 00 00 	movabs $0x815798,%rax
  815d6a:	00 00 00 
  815d6d:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  815d6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815d73:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  815d77:	0f b7 c0             	movzwl %ax,%eax
  815d7a:	89 c7                	mov    %eax,%edi
  815d7c:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  815d83:	00 00 00 
  815d86:	ff d0                	callq  *%rax
  815d88:	0f b7 c0             	movzwl %ax,%eax
  815d8b:	83 f8 01             	cmp    $0x1,%eax
  815d8e:	74 0e                	je     815d9e <etharp_arp_input+0x1f0>
  815d90:	83 f8 02             	cmp    $0x2,%eax
  815d93:	0f 84 28 01 00 00    	je     815ec1 <etharp_arp_input+0x313>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  815d99:	e9 3e 01 00 00       	jmpq   815edc <etharp_arp_input+0x32e>
    if (for_us) {
  815d9e:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  815da2:	0f 84 17 01 00 00    	je     815ebf <etharp_arp_input+0x311>
      hdr->opcode = htons(ARP_REPLY);
  815da8:	bf 02 00 00 00       	mov    $0x2,%edi
  815dad:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  815db4:	00 00 00 
  815db7:	ff d0                	callq  *%rax
  815db9:	89 c2                	mov    %eax,%edx
  815dbb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815dbf:	66 89 50 14          	mov    %dx,0x14(%rax)
      hdr->dipaddr = hdr->sipaddr;
  815dc3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815dc7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815dcb:	8b 52 1c             	mov    0x1c(%rdx),%edx
  815dce:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  815dd1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815dd5:	48 8d 50 08          	lea    0x8(%rax),%rdx
  815dd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815ddd:	8b 12                	mov    (%rdx),%edx
  815ddf:	89 50 1c             	mov    %edx,0x1c(%rax)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  815de2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815de6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815dea:	3c 06                	cmp    $0x6,%al
  815dec:	74 2a                	je     815e18 <etharp_arp_input+0x26a>
  815dee:	48 ba 00 1f 82 00 00 	movabs $0x821f00,%rdx
  815df5:	00 00 00 
  815df8:	be c7 02 00 00       	mov    $0x2c7,%esi
  815dfd:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  815e04:	00 00 00 
  815e07:	b8 00 00 00 00       	mov    $0x0,%eax
  815e0c:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  815e13:	00 00 00 
  815e16:	ff d1                	callq  *%rcx
      i = ETHARP_HWADDR_LEN;
  815e18:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      while(i > 0) {
  815e1c:	eb 7f                	jmp    815e9d <etharp_arp_input+0x2ef>
        i--;
  815e1e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815e22:	83 e8 01             	sub    $0x1,%eax
  815e25:	88 45 ef             	mov    %al,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  815e28:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  815e2c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815e30:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815e34:	48 98                	cltq   
  815e36:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  815e3b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815e3f:	48 63 c6             	movslq %esi,%rax
  815e42:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  815e46:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  815e4a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815e4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815e52:	48 98                	cltq   
  815e54:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  815e59:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815e5d:	48 63 c6             	movslq %esi,%rax
  815e60:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  815e63:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  815e67:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815e6b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  815e6f:	48 98                	cltq   
  815e71:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815e75:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815e79:	48 63 c6             	movslq %esi,%rax
  815e7c:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  815e80:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  815e84:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815e88:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  815e8c:	48 98                	cltq   
  815e8e:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815e92:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815e96:	48 63 c6             	movslq %esi,%rax
  815e99:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      while(i > 0) {
  815e9d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  815ea1:	0f 85 77 ff ff ff    	jne    815e1e <etharp_arp_input+0x270>
      netif->linkoutput(netif, p);
  815ea7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815eab:	48 8b 40 28          	mov    0x28(%rax),%rax
  815eaf:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  815eb3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  815eb7:	48 89 ce             	mov    %rcx,%rsi
  815eba:	48 89 d7             	mov    %rdx,%rdi
  815ebd:	ff d0                	callq  *%rax
    break;
  815ebf:	eb 1b                	jmp    815edc <etharp_arp_input+0x32e>
    dhcp_arp_reply(netif, &sipaddr);
  815ec1:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  815ec5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815ec9:	48 89 d6             	mov    %rdx,%rsi
  815ecc:	48 89 c7             	mov    %rax,%rdi
  815ecf:	48 b8 84 97 80 00 00 	movabs $0x809784,%rax
  815ed6:	00 00 00 
  815ed9:	ff d0                	callq  *%rax
    break;
  815edb:	90                   	nop
  }
  /* free ARP packet */
  pbuf_free(p);
  815edc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815ee0:	48 89 c7             	mov    %rax,%rdi
  815ee3:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  815eea:	00 00 00 
  815eed:	ff d0                	callq  *%rax
}
  815eef:	48 83 c4 58          	add    $0x58,%rsp
  815ef3:	5b                   	pop    %rbx
  815ef4:	5d                   	pop    %rbp
  815ef5:	c3                   	retq   

0000000000815ef6 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  815ef6:	55                   	push   %rbp
  815ef7:	48 89 e5             	mov    %rsp,%rbp
  815efa:	53                   	push   %rbx
  815efb:	48 83 ec 38          	sub    $0x38,%rsp
  815eff:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  815f03:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  815f07:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  815f0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815f0f:	be 0e 00 00 00       	mov    $0xe,%esi
  815f14:	48 89 c7             	mov    %rax,%rdi
  815f17:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  815f1e:	00 00 00 
  815f21:	ff d0                	callq  *%rax
  815f23:	84 c0                	test   %al,%al
  815f25:	74 0a                	je     815f31 <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  815f27:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  815f2c:	e9 50 01 00 00       	jmpq   816081 <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  815f31:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  815f38:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  815f39:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  815f3d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815f41:	48 89 d6             	mov    %rdx,%rsi
  815f44:	48 89 c7             	mov    %rax,%rdi
  815f47:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  815f4e:	00 00 00 
  815f51:	ff d0                	callq  *%rax
  815f53:	84 c0                	test   %al,%al
  815f55:	74 13                	je     815f6a <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  815f57:	48 b8 88 1e 82 00 00 	movabs $0x821e88,%rax
  815f5e:	00 00 00 
  815f61:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  815f65:	e9 ee 00 00 00       	jmpq   816058 <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  815f6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815f6e:	8b 18                	mov    (%rax),%ebx
  815f70:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  815f75:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  815f7c:	00 00 00 
  815f7f:	ff d0                	callq  *%rax
  815f81:	21 c3                	and    %eax,%ebx
  815f83:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  815f88:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  815f8f:	00 00 00 
  815f92:	ff d0                	callq  *%rax
  815f94:	39 c3                	cmp    %eax,%ebx
  815f96:	75 64                	jne    815ffc <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  815f98:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  815f9c:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  815fa0:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  815fa4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815fa8:	8b 00                	mov    (%rax),%eax
  815faa:	89 c7                	mov    %eax,%edi
  815fac:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  815fb3:	00 00 00 
  815fb6:	ff d0                	callq  *%rax
  815fb8:	c1 e8 10             	shr    $0x10,%eax
  815fbb:	83 e0 7f             	and    $0x7f,%eax
  815fbe:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  815fc1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815fc5:	8b 00                	mov    (%rax),%eax
  815fc7:	89 c7                	mov    %eax,%edi
  815fc9:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  815fd0:	00 00 00 
  815fd3:	ff d0                	callq  *%rax
  815fd5:	c1 e8 08             	shr    $0x8,%eax
  815fd8:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  815fdb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815fdf:	8b 00                	mov    (%rax),%eax
  815fe1:	89 c7                	mov    %eax,%edi
  815fe3:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  815fea:	00 00 00 
  815fed:	ff d0                	callq  *%rax
  815fef:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  815ff2:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  815ff6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  815ffa:	eb 5c                	jmp    816058 <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  815ffc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816000:	8b 10                	mov    (%rax),%edx
  816002:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816006:	8b 40 08             	mov    0x8(%rax),%eax
  816009:	31 c2                	xor    %eax,%edx
  81600b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81600f:	8b 40 0c             	mov    0xc(%rax),%eax
  816012:	21 d0                	and    %edx,%eax
  816014:	85 c0                	test   %eax,%eax
  816016:	74 20                	je     816038 <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  816018:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81601c:	8b 40 10             	mov    0x10(%rax),%eax
  81601f:	85 c0                	test   %eax,%eax
  816021:	74 0e                	je     816031 <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816023:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816027:	48 83 c0 10          	add    $0x10,%rax
  81602b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  81602f:	eb 07                	jmp    816038 <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816031:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816036:	eb 49                	jmp    816081 <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  816038:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81603c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816040:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816044:	48 89 ce             	mov    %rcx,%rsi
  816047:	48 89 c7             	mov    %rax,%rdi
  81604a:	48 b8 88 60 81 00 00 	movabs $0x816088,%rax
  816051:	00 00 00 
  816054:	ff d0                	callq  *%rax
  816056:	eb 29                	jmp    816081 <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  816058:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81605c:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816060:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816064:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  816068:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81606c:	48 89 d1             	mov    %rdx,%rcx
  81606f:	48 89 fa             	mov    %rdi,%rdx
  816072:	48 89 c7             	mov    %rax,%rdi
  816075:	48 b8 ba 56 81 00 00 	movabs $0x8156ba,%rax
  81607c:	00 00 00 
  81607f:	ff d0                	callq  *%rax
}
  816081:	48 83 c4 38          	add    $0x38,%rsp
  816085:	5b                   	pop    %rbx
  816086:	5d                   	pop    %rbp
  816087:	c3                   	retq   

0000000000816088 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  816088:	55                   	push   %rbp
  816089:	48 89 e5             	mov    %rsp,%rbp
  81608c:	53                   	push   %rbx
  81608d:	48 83 ec 68          	sub    $0x68,%rsp
  816091:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  816095:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  816099:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  81609d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8160a1:	48 83 c0 41          	add    $0x41,%rax
  8160a5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  8160a9:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8160ad:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8160b1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8160b5:	48 89 d6             	mov    %rdx,%rsi
  8160b8:	48 89 c7             	mov    %rax,%rdi
  8160bb:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  8160c2:	00 00 00 
  8160c5:	ff d0                	callq  *%rax
  8160c7:	84 c0                	test   %al,%al
  8160c9:	75 3f                	jne    81610a <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  8160cb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8160cf:	8b 18                	mov    (%rax),%ebx
  8160d1:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8160d6:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8160dd:	00 00 00 
  8160e0:	ff d0                	callq  *%rax
  8160e2:	21 c3                	and    %eax,%ebx
  8160e4:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8160e9:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  8160f0:	00 00 00 
  8160f3:	ff d0                	callq  *%rax
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8160f5:	39 c3                	cmp    %eax,%ebx
  8160f7:	74 11                	je     81610a <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  8160f9:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8160fe:	74 0a                	je     81610a <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  816100:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816104:	8b 00                	mov    (%rax),%eax
  816106:	85 c0                	test   %eax,%eax
  816108:	75 0a                	jne    816114 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  81610a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  81610f:	e9 1f 04 00 00       	jmpq   816533 <etharp_query+0x4ab>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816114:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816118:	be 01 00 00 00       	mov    $0x1,%esi
  81611d:	48 89 c7             	mov    %rax,%rdi
  816120:	48 b8 26 51 81 00 00 	movabs $0x815126,%rax
  816127:	00 00 00 
  81612a:	ff d0                	callq  *%rax
  81612c:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  81612f:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816133:	79 09                	jns    81613e <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816135:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  816139:	e9 f5 03 00 00       	jmpq   816533 <etharp_query+0x4ab>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  81613e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816142:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  816149:	00 00 00 
  81614c:	48 63 d0             	movslq %eax,%rdx
  81614f:	48 89 d0             	mov    %rdx,%rax
  816152:	48 c1 e0 02          	shl    $0x2,%rax
  816156:	48 01 d0             	add    %rdx,%rax
  816159:	48 c1 e0 03          	shl    $0x3,%rax
  81615d:	48 01 c8             	add    %rcx,%rax
  816160:	48 83 c0 10          	add    $0x10,%rax
  816164:	8b 40 04             	mov    0x4(%rax),%eax
  816167:	85 c0                	test   %eax,%eax
  816169:	75 2d                	jne    816198 <etharp_query+0x110>
    arp_table[i].state = ETHARP_STATE_PENDING;
  81616b:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81616f:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  816176:	00 00 00 
  816179:	48 63 d0             	movslq %eax,%rdx
  81617c:	48 89 d0             	mov    %rdx,%rax
  81617f:	48 c1 e0 02          	shl    $0x2,%rax
  816183:	48 01 d0             	add    %rdx,%rax
  816186:	48 c1 e0 03          	shl    $0x3,%rax
  81618a:	48 01 c8             	add    %rcx,%rax
  81618d:	48 83 c0 10          	add    $0x10,%rax
  816191:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  816198:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81619c:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8161a3:	00 00 00 
  8161a6:	48 63 d0             	movslq %eax,%rdx
  8161a9:	48 89 d0             	mov    %rdx,%rax
  8161ac:	48 c1 e0 02          	shl    $0x2,%rax
  8161b0:	48 01 d0             	add    %rdx,%rax
  8161b3:	48 c1 e0 03          	shl    $0x3,%rax
  8161b7:	48 01 c8             	add    %rcx,%rax
  8161ba:	48 83 c0 10          	add    $0x10,%rax
  8161be:	8b 40 04             	mov    0x4(%rax),%eax
  8161c1:	83 f8 01             	cmp    $0x1,%eax
  8161c4:	74 58                	je     81621e <etharp_query+0x196>
  8161c6:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8161ca:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8161d1:	00 00 00 
  8161d4:	48 63 d0             	movslq %eax,%rdx
  8161d7:	48 89 d0             	mov    %rdx,%rax
  8161da:	48 c1 e0 02          	shl    $0x2,%rax
  8161de:	48 01 d0             	add    %rdx,%rax
  8161e1:	48 c1 e0 03          	shl    $0x3,%rax
  8161e5:	48 01 c8             	add    %rcx,%rax
  8161e8:	48 83 c0 10          	add    $0x10,%rax
  8161ec:	8b 40 04             	mov    0x4(%rax),%eax
  8161ef:	83 f8 02             	cmp    $0x2,%eax
  8161f2:	74 2a                	je     81621e <etharp_query+0x196>
  8161f4:	48 ba 80 1f 82 00 00 	movabs $0x821f80,%rdx
  8161fb:	00 00 00 
  8161fe:	be 92 03 00 00       	mov    $0x392,%esi
  816203:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  81620a:	00 00 00 
  81620d:	b8 00 00 00 00       	mov    $0x0,%eax
  816212:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  816219:	00 00 00 
  81621c:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  81621e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816222:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  816229:	00 00 00 
  81622c:	48 63 d0             	movslq %eax,%rdx
  81622f:	48 89 d0             	mov    %rdx,%rax
  816232:	48 c1 e0 02          	shl    $0x2,%rax
  816236:	48 01 d0             	add    %rdx,%rax
  816239:	48 c1 e0 03          	shl    $0x3,%rax
  81623d:	48 01 c8             	add    %rcx,%rax
  816240:	48 83 c0 10          	add    $0x10,%rax
  816244:	8b 40 04             	mov    0x4(%rax),%eax
  816247:	83 f8 01             	cmp    $0x1,%eax
  81624a:	74 07                	je     816253 <etharp_query+0x1cb>
  81624c:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816251:	75 1d                	jne    816270 <etharp_query+0x1e8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816253:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816257:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81625b:	48 89 d6             	mov    %rdx,%rsi
  81625e:	48 89 c7             	mov    %rax,%rdi
  816261:	48 b8 7a 67 81 00 00 	movabs $0x81677a,%rax
  816268:	00 00 00 
  81626b:	ff d0                	callq  *%rax
  81626d:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816270:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816275:	0f 84 b4 02 00 00    	je     81652f <etharp_query+0x4a7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  81627b:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81627f:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  816286:	00 00 00 
  816289:	48 63 d0             	movslq %eax,%rdx
  81628c:	48 89 d0             	mov    %rdx,%rax
  81628f:	48 c1 e0 02          	shl    $0x2,%rax
  816293:	48 01 d0             	add    %rdx,%rax
  816296:	48 c1 e0 03          	shl    $0x3,%rax
  81629a:	48 01 c8             	add    %rcx,%rax
  81629d:	48 83 c0 10          	add    $0x10,%rax
  8162a1:	8b 40 04             	mov    0x4(%rax),%eax
  8162a4:	83 f8 02             	cmp    $0x2,%eax
  8162a7:	75 49                	jne    8162f2 <etharp_query+0x26a>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  8162a9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8162ad:	48 63 d0             	movslq %eax,%rdx
  8162b0:	48 89 d0             	mov    %rdx,%rax
  8162b3:	48 c1 e0 02          	shl    $0x2,%rax
  8162b7:	48 01 d0             	add    %rdx,%rax
  8162ba:	48 c1 e0 03          	shl    $0x3,%rax
  8162be:	48 ba c0 a6 b4 00 00 	movabs $0xb4a6c0,%rdx
  8162c5:	00 00 00 
  8162c8:	48 01 d0             	add    %rdx,%rax
  8162cb:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  8162cf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8162d3:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8162d7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8162db:	48 89 c7             	mov    %rax,%rdi
  8162de:	48 b8 ba 56 81 00 00 	movabs $0x8156ba,%rax
  8162e5:	00 00 00 
  8162e8:	ff d0                	callq  *%rax
  8162ea:	88 45 ef             	mov    %al,-0x11(%rbp)
  8162ed:	e9 3d 02 00 00       	jmpq   81652f <etharp_query+0x4a7>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8162f2:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8162f6:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8162fd:	00 00 00 
  816300:	48 63 d0             	movslq %eax,%rdx
  816303:	48 89 d0             	mov    %rdx,%rax
  816306:	48 c1 e0 02          	shl    $0x2,%rax
  81630a:	48 01 d0             	add    %rdx,%rax
  81630d:	48 c1 e0 03          	shl    $0x3,%rax
  816311:	48 01 c8             	add    %rcx,%rax
  816314:	48 83 c0 10          	add    $0x10,%rax
  816318:	8b 40 04             	mov    0x4(%rax),%eax
  81631b:	83 f8 01             	cmp    $0x1,%eax
  81631e:	0f 85 0b 02 00 00    	jne    81652f <etharp_query+0x4a7>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816324:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  81632b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81632f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816333:	eb 6b                	jmp    8163a0 <etharp_query+0x318>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816335:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816339:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  81633d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816341:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816345:	66 39 c2             	cmp    %ax,%dx
  816348:	75 36                	jne    816380 <etharp_query+0x2f8>
  81634a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81634e:	48 8b 00             	mov    (%rax),%rax
  816351:	48 85 c0             	test   %rax,%rax
  816354:	74 2a                	je     816380 <etharp_query+0x2f8>
  816356:	48 ba a8 1f 82 00 00 	movabs $0x821fa8,%rdx
  81635d:	00 00 00 
  816360:	be b1 03 00 00       	mov    $0x3b1,%esi
  816365:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  81636c:	00 00 00 
  81636f:	b8 00 00 00 00       	mov    $0x0,%eax
  816374:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81637b:	00 00 00 
  81637e:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816380:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816384:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  816388:	3c 01                	cmp    $0x1,%al
  81638a:	74 09                	je     816395 <etharp_query+0x30d>
          copy_needed = 1;
  81638c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  816393:	eb 12                	jmp    8163a7 <etharp_query+0x31f>
        }
        p = p->next;
  816395:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816399:	48 8b 00             	mov    (%rax),%rax
  81639c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  8163a0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8163a5:	75 8e                	jne    816335 <etharp_query+0x2ad>
      }
      if(copy_needed) {
  8163a7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8163ab:	74 69                	je     816416 <etharp_query+0x38e>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  8163ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163b1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8163b5:	0f b7 c0             	movzwl %ax,%eax
  8163b8:	ba 00 00 00 00       	mov    $0x0,%edx
  8163bd:	89 c6                	mov    %eax,%esi
  8163bf:	bf 03 00 00 00       	mov    $0x3,%edi
  8163c4:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  8163cb:	00 00 00 
  8163ce:	ff d0                	callq  *%rax
  8163d0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  8163d4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8163d9:	74 56                	je     816431 <etharp_query+0x3a9>
          if (pbuf_copy(p, q) != ERR_OK) {
  8163db:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8163df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163e3:	48 89 d6             	mov    %rdx,%rsi
  8163e6:	48 89 c7             	mov    %rax,%rdi
  8163e9:	48 b8 dc d5 80 00 00 	movabs $0x80d5dc,%rax
  8163f0:	00 00 00 
  8163f3:	ff d0                	callq  *%rax
  8163f5:	84 c0                	test   %al,%al
  8163f7:	74 38                	je     816431 <etharp_query+0x3a9>
            pbuf_free(p);
  8163f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163fd:	48 89 c7             	mov    %rax,%rdi
  816400:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  816407:	00 00 00 
  81640a:	ff d0                	callq  *%rax
            p = NULL;
  81640c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  816413:	00 
  816414:	eb 1b                	jmp    816431 <etharp_query+0x3a9>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  816416:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81641a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  81641e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816422:	48 89 c7             	mov    %rax,%rdi
  816425:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  81642c:	00 00 00 
  81642f:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  816431:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816436:	0f 84 f3 00 00 00    	je     81652f <etharp_query+0x4a7>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  81643c:	bf 0a 00 00 00       	mov    $0xa,%edi
  816441:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  816448:	00 00 00 
  81644b:	ff d0                	callq  *%rax
  81644d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  816451:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816456:	0f 84 c0 00 00 00    	je     81651c <etharp_query+0x494>
          new_entry->next = 0;
  81645c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816460:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  816467:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81646b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81646f:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  816473:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816477:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  81647e:	00 00 00 
  816481:	48 63 d0             	movslq %eax,%rdx
  816484:	48 89 d0             	mov    %rdx,%rax
  816487:	48 c1 e0 02          	shl    $0x2,%rax
  81648b:	48 01 d0             	add    %rdx,%rax
  81648e:	48 c1 e0 03          	shl    $0x3,%rax
  816492:	48 01 c8             	add    %rcx,%rax
  816495:	48 8b 00             	mov    (%rax),%rax
  816498:	48 85 c0             	test   %rax,%rax
  81649b:	74 4f                	je     8164ec <etharp_query+0x464>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  81649d:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8164a1:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8164a8:	00 00 00 
  8164ab:	48 63 d0             	movslq %eax,%rdx
  8164ae:	48 89 d0             	mov    %rdx,%rax
  8164b1:	48 c1 e0 02          	shl    $0x2,%rax
  8164b5:	48 01 d0             	add    %rdx,%rax
  8164b8:	48 c1 e0 03          	shl    $0x3,%rax
  8164bc:	48 01 c8             	add    %rcx,%rax
  8164bf:	48 8b 00             	mov    (%rax),%rax
  8164c2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  8164c6:	eb 0b                	jmp    8164d3 <etharp_query+0x44b>
              r = r->next;
  8164c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8164cc:	48 8b 00             	mov    (%rax),%rax
  8164cf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  8164d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8164d7:	48 8b 00             	mov    (%rax),%rax
  8164da:	48 85 c0             	test   %rax,%rax
  8164dd:	75 e9                	jne    8164c8 <etharp_query+0x440>
            }
            r->next = new_entry;
  8164df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8164e3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8164e7:	48 89 10             	mov    %rdx,(%rax)
  8164ea:	eb 2a                	jmp    816516 <etharp_query+0x48e>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  8164ec:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8164f0:	48 b9 c0 a6 b4 00 00 	movabs $0xb4a6c0,%rcx
  8164f7:	00 00 00 
  8164fa:	48 63 d0             	movslq %eax,%rdx
  8164fd:	48 89 d0             	mov    %rdx,%rax
  816500:	48 c1 e0 02          	shl    $0x2,%rax
  816504:	48 01 d0             	add    %rdx,%rax
  816507:	48 c1 e0 03          	shl    $0x3,%rax
  81650b:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  81650f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816513:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  816516:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81651a:	eb 13                	jmp    81652f <etharp_query+0x4a7>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  81651c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816520:	48 89 c7             	mov    %rax,%rdi
  816523:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81652a:	00 00 00 
  81652d:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  81652f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  816533:	48 83 c4 68          	add    $0x68,%rsp
  816537:	5b                   	pop    %rbx
  816538:	5d                   	pop    %rbp
  816539:	c3                   	retq   

000000000081653a <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  81653a:	55                   	push   %rbp
  81653b:	48 89 e5             	mov    %rsp,%rbp
  81653e:	48 83 ec 60          	sub    $0x60,%rsp
  816542:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816546:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81654a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81654e:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  816552:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  816556:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  81655a:	8b 45 18             	mov    0x18(%rbp),%eax
  81655d:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  816561:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  816565:	ba 00 00 00 00       	mov    $0x0,%edx
  81656a:	be 2a 00 00 00       	mov    $0x2a,%esi
  81656f:	bf 02 00 00 00       	mov    $0x2,%edi
  816574:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81657b:	00 00 00 
  81657e:	ff d0                	callq  *%rax
  816580:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  816584:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  816589:	75 0a                	jne    816595 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  81658b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816590:	e9 e3 01 00 00       	jmpq   816778 <etharp_raw+0x23e>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  816595:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816599:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81659d:	66 83 f8 29          	cmp    $0x29,%ax
  8165a1:	77 2a                	ja     8165cd <etharp_raw+0x93>
  8165a3:	48 ba c8 1f 82 00 00 	movabs $0x821fc8,%rdx
  8165aa:	00 00 00 
  8165ad:	be 1c 04 00 00       	mov    $0x41c,%esi
  8165b2:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  8165b9:	00 00 00 
  8165bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8165c1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8165c8:	00 00 00 
  8165cb:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  8165cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8165d1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8165d5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  8165d9:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  8165dd:	89 c7                	mov    %eax,%edi
  8165df:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8165e6:	00 00 00 
  8165e9:	ff d0                	callq  *%rax
  8165eb:	89 c2                	mov    %eax,%edx
  8165ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8165f1:	66 89 50 14          	mov    %dx,0x14(%rax)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8165f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8165f9:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8165fd:	3c 06                	cmp    $0x6,%al
  8165ff:	74 2a                	je     81662b <etharp_raw+0xf1>
  816601:	48 ba 00 1f 82 00 00 	movabs $0x821f00,%rdx
  816608:	00 00 00 
  81660b:	be 23 04 00 00       	mov    $0x423,%esi
  816610:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  816617:	00 00 00 
  81661a:	b8 00 00 00 00       	mov    $0x0,%eax
  81661f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  816626:	00 00 00 
  816629:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  81662b:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  81662f:	eb 7d                	jmp    8166ae <etharp_raw+0x174>
    k--;
  816631:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816635:	83 e8 01             	sub    $0x1,%eax
  816638:	88 45 ff             	mov    %al,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  81663b:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81663f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816643:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  816647:	48 98                	cltq   
  816649:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81664d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816651:	48 63 c6             	movslq %esi,%rax
  816654:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  816658:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81665c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816660:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816664:	48 98                	cltq   
  816666:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81666a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81666e:	48 63 c6             	movslq %esi,%rax
  816671:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  816675:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816679:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81667d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816681:	48 98                	cltq   
  816683:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816687:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81668b:	48 63 c6             	movslq %esi,%rax
  81668e:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  816691:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816695:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816699:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81669d:	48 98                	cltq   
  81669f:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8166a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8166a7:	48 63 c6             	movslq %esi,%rax
  8166aa:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  while(k > 0) {
  8166ae:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8166b2:	0f 85 79 ff ff ff    	jne    816631 <etharp_raw+0xf7>
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8166b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8166bc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8166c0:	8b 12                	mov    (%rdx),%edx
  8166c2:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8166c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8166c9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8166cd:	8b 12                	mov    (%rdx),%edx
  8166cf:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8166d2:	bf 01 00 00 00       	mov    $0x1,%edi
  8166d7:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8166de:	00 00 00 
  8166e1:	ff d0                	callq  *%rax
  8166e3:	89 c2                	mov    %eax,%edx
  8166e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8166e9:	66 89 50 0e          	mov    %dx,0xe(%rax)
  hdr->proto = htons(ETHTYPE_IP);
  8166ed:	bf 00 08 00 00       	mov    $0x800,%edi
  8166f2:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  8166f9:	00 00 00 
  8166fc:	ff d0                	callq  *%rax
  8166fe:	89 c2                	mov    %eax,%edx
  816700:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816704:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  816708:	bf 04 06 00 00       	mov    $0x604,%edi
  81670d:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  816714:	00 00 00 
  816717:	ff d0                	callq  *%rax
  816719:	89 c2                	mov    %eax,%edx
  81671b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81671f:	66 89 50 12          	mov    %dx,0x12(%rax)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  816723:	bf 06 08 00 00       	mov    $0x806,%edi
  816728:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81672f:	00 00 00 
  816732:	ff d0                	callq  *%rax
  816734:	89 c2                	mov    %eax,%edx
  816736:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81673a:	66 89 50 0c          	mov    %dx,0xc(%rax)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  81673e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816742:	48 8b 40 28          	mov    0x28(%rax),%rax
  816746:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81674a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81674e:	48 89 ce             	mov    %rcx,%rsi
  816751:	48 89 d7             	mov    %rdx,%rdi
  816754:	ff d0                	callq  *%rax
  816756:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  816759:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81675d:	48 89 c7             	mov    %rax,%rdi
  816760:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  816767:	00 00 00 
  81676a:	ff d0                	callq  *%rax
  p = NULL;
  81676c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  816773:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  816774:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  816778:	c9                   	leaveq 
  816779:	c3                   	retq   

000000000081677a <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  81677a:	55                   	push   %rbp
  81677b:	48 89 e5             	mov    %rsp,%rbp
  81677e:	48 83 ec 10          	sub    $0x10,%rsp
  816782:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  816786:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  81678a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81678e:	48 8d 48 08          	lea    0x8(%rax),%rcx
  816792:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816796:	48 8d 50 41          	lea    0x41(%rax),%rdx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  81679a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81679e:	48 8d 70 41          	lea    0x41(%rax),%rsi
  8167a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8167a6:	6a 01                	pushq  $0x1
  8167a8:	ff 75 f0             	pushq  -0x10(%rbp)
  8167ab:	49 b9 8e 1e 82 00 00 	movabs $0x821e8e,%r9
  8167b2:	00 00 00 
  8167b5:	49 89 c8             	mov    %rcx,%r8
  8167b8:	48 89 d1             	mov    %rdx,%rcx
  8167bb:	48 ba 88 1e 82 00 00 	movabs $0x821e88,%rdx
  8167c2:	00 00 00 
  8167c5:	48 89 c7             	mov    %rax,%rdi
  8167c8:	48 b8 3a 65 81 00 00 	movabs $0x81653a,%rax
  8167cf:	00 00 00 
  8167d2:	ff d0                	callq  *%rax
  8167d4:	48 83 c4 10          	add    $0x10,%rsp
                    ipaddr, ARP_REQUEST);
}
  8167d8:	c9                   	leaveq 
  8167d9:	c3                   	retq   

00000000008167da <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  8167da:	55                   	push   %rbp
  8167db:	48 89 e5             	mov    %rsp,%rbp
  8167de:	48 83 ec 20          	sub    $0x20,%rsp
  8167e2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8167e6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  8167ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8167ee:	48 8b 40 08          	mov    0x8(%rax),%rax
  8167f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  8167f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8167fa:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8167fe:	0f b7 c0             	movzwl %ax,%eax
  816801:	89 c7                	mov    %eax,%edi
  816803:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81680a:	00 00 00 
  81680d:	ff d0                	callq  *%rax
  81680f:	0f b7 c0             	movzwl %ax,%eax
  816812:	3d 00 08 00 00       	cmp    $0x800,%eax
  816817:	74 10                	je     816829 <ethernet_input+0x4f>
  816819:	3d 06 08 00 00       	cmp    $0x806,%eax
  81681e:	0f 84 81 00 00 00    	je     8168a5 <ethernet_input+0xcb>
  816824:	e9 a0 00 00 00       	jmpq   8168c9 <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  816829:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81682d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816831:	48 89 d6             	mov    %rdx,%rsi
  816834:	48 89 c7             	mov    %rax,%rdi
  816837:	48 b8 18 5b 81 00 00 	movabs $0x815b18,%rax
  81683e:	00 00 00 
  816841:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  816843:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816847:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  81684c:	48 89 c7             	mov    %rax,%rdi
  81684f:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  816856:	00 00 00 
  816859:	ff d0                	callq  *%rax
  81685b:	84 c0                	test   %al,%al
  81685d:	74 2a                	je     816889 <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  81685f:	48 ba 00 20 82 00 00 	movabs $0x822000,%rdx
  816866:	00 00 00 
  816869:	be 7e 04 00 00       	mov    $0x47e,%esi
  81686e:	48 bf 9e 1e 82 00 00 	movabs $0x821e9e,%rdi
  816875:	00 00 00 
  816878:	b8 00 00 00 00       	mov    $0x0,%eax
  81687d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  816884:	00 00 00 
  816887:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  816889:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81688d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816891:	48 89 d6             	mov    %rdx,%rsi
  816894:	48 89 c7             	mov    %rax,%rdi
  816897:	48 b8 a6 02 81 00 00 	movabs $0x8102a6,%rax
  81689e:	00 00 00 
  8168a1:	ff d0                	callq  *%rax
      }
      break;
  8168a3:	eb 40                	jmp    8168e5 <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  8168a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168a9:	48 8d 48 41          	lea    0x41(%rax),%rcx
  8168ad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8168b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168b5:	48 89 ce             	mov    %rcx,%rsi
  8168b8:	48 89 c7             	mov    %rax,%rdi
  8168bb:	48 b8 ae 5b 81 00 00 	movabs $0x815bae,%rax
  8168c2:	00 00 00 
  8168c5:	ff d0                	callq  *%rax
      break;
  8168c7:	eb 1c                	jmp    8168e5 <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  8168c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8168cd:	48 89 c7             	mov    %rax,%rdi
  8168d0:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8168d7:	00 00 00 
  8168da:	ff d0                	callq  *%rax
      p = NULL;
  8168dc:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8168e3:	00 
      break;
  8168e4:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  8168e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8168ea:	c9                   	leaveq 
  8168eb:	c3                   	retq   

00000000008168ec <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  8168ec:	55                   	push   %rbp
  8168ed:	48 89 e5             	mov    %rsp,%rbp
  8168f0:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  8168f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    for (i = 0; i < NSEM; i++) {
  8168fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  816902:	e9 ea 00 00 00       	jmpq   8169f1 <sys_init+0x105>
	sems[i].freed = 1;
  816907:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  81690e:	00 00 00 
  816911:	8b 55 fc             	mov    -0x4(%rbp),%edx
  816914:	48 63 d2             	movslq %edx,%rdx
  816917:	48 c1 e2 05          	shl    $0x5,%rdx
  81691b:	48 01 d0             	add    %rdx,%rax
  81691e:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  816924:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  81692b:	00 00 00 
  81692e:	48 8b 00             	mov    (%rax),%rax
  816931:	48 ba 80 a8 b4 00 00 	movabs $0xb4a880,%rdx
  816938:	00 00 00 
  81693b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81693e:	48 63 c9             	movslq %ecx,%rcx
  816941:	48 c1 e1 05          	shl    $0x5,%rcx
  816945:	48 01 ca             	add    %rcx,%rdx
  816948:	48 83 c2 10          	add    $0x10,%rdx
  81694c:	48 89 02             	mov    %rax,(%rdx)
  81694f:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  816956:	00 00 00 
  816959:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81695c:	48 63 d2             	movslq %edx,%rdx
  81695f:	48 c1 e2 05          	shl    $0x5,%rdx
  816963:	48 01 d0             	add    %rdx,%rax
  816966:	48 83 c0 10          	add    $0x10,%rax
  81696a:	48 8b 00             	mov    (%rax),%rax
  81696d:	48 85 c0             	test   %rax,%rax
  816970:	74 2c                	je     81699e <sys_init+0xb2>
  816972:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  816979:	00 00 00 
  81697c:	48 8b 00             	mov    (%rax),%rax
  81697f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  816982:	48 63 d2             	movslq %edx,%rdx
  816985:	48 c1 e2 05          	shl    $0x5,%rdx
  816989:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  81698d:	48 ba 80 a8 b4 00 00 	movabs $0xb4a880,%rdx
  816994:	00 00 00 
  816997:	48 01 ca             	add    %rcx,%rdx
  81699a:	48 89 50 18          	mov    %rdx,0x18(%rax)
  81699e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8169a1:	48 98                	cltq   
  8169a3:	48 c1 e0 05          	shl    $0x5,%rax
  8169a7:	48 89 c2             	mov    %rax,%rdx
  8169aa:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8169b1:	00 00 00 
  8169b4:	48 01 c2             	add    %rax,%rdx
  8169b7:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  8169be:	00 00 00 
  8169c1:	48 89 10             	mov    %rdx,(%rax)
  8169c4:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8169cb:	00 00 00 
  8169ce:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8169d1:	48 63 d2             	movslq %edx,%rdx
  8169d4:	48 c1 e2 05          	shl    $0x5,%rdx
  8169d8:	48 01 d0             	add    %rdx,%rax
  8169db:	48 83 c0 10          	add    $0x10,%rax
  8169df:	48 bf 80 c8 b4 00 00 	movabs $0xb4c880,%rdi
  8169e6:	00 00 00 
  8169e9:	48 89 78 08          	mov    %rdi,0x8(%rax)
    for (i = 0; i < NSEM; i++) {
  8169ed:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8169f1:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  8169f8:	0f 8e 09 ff ff ff    	jle    816907 <sys_init+0x1b>
    }

    for (i = 0; i < NMBOX; i++) {
  8169fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  816a05:	e9 60 01 00 00       	jmpq   816b6a <sys_init+0x27e>
	mboxes[i].freed = 1;
  816a0a:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816a11:	00 00 00 
  816a14:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816a17:	48 63 d0             	movslq %eax,%rdx
  816a1a:	48 89 d0             	mov    %rdx,%rax
  816a1d:	48 c1 e0 03          	shl    $0x3,%rax
  816a21:	48 01 d0             	add    %rdx,%rax
  816a24:	48 c1 e0 02          	shl    $0x2,%rax
  816a28:	48 01 d0             	add    %rdx,%rax
  816a2b:	48 c1 e0 03          	shl    $0x3,%rax
  816a2f:	48 01 c8             	add    %rcx,%rax
  816a32:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  816a38:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816a3f:	00 00 00 
  816a42:	48 8b 08             	mov    (%rax),%rcx
  816a45:	48 be c0 c8 b4 00 00 	movabs $0xb4c8c0,%rsi
  816a4c:	00 00 00 
  816a4f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816a52:	48 63 d0             	movslq %eax,%rdx
  816a55:	48 89 d0             	mov    %rdx,%rax
  816a58:	48 c1 e0 03          	shl    $0x3,%rax
  816a5c:	48 01 d0             	add    %rdx,%rax
  816a5f:	48 c1 e0 02          	shl    $0x2,%rax
  816a63:	48 01 d0             	add    %rdx,%rax
  816a66:	48 c1 e0 03          	shl    $0x3,%rax
  816a6a:	48 01 f0             	add    %rsi,%rax
  816a6d:	48 05 10 01 00 00    	add    $0x110,%rax
  816a73:	48 89 48 08          	mov    %rcx,0x8(%rax)
  816a77:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816a7e:	00 00 00 
  816a81:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816a84:	48 63 d0             	movslq %eax,%rdx
  816a87:	48 89 d0             	mov    %rdx,%rax
  816a8a:	48 c1 e0 03          	shl    $0x3,%rax
  816a8e:	48 01 d0             	add    %rdx,%rax
  816a91:	48 c1 e0 02          	shl    $0x2,%rax
  816a95:	48 01 d0             	add    %rdx,%rax
  816a98:	48 c1 e0 03          	shl    $0x3,%rax
  816a9c:	48 01 c8             	add    %rcx,%rax
  816a9f:	48 05 10 01 00 00    	add    $0x110,%rax
  816aa5:	48 8b 40 08          	mov    0x8(%rax),%rax
  816aa9:	48 85 c0             	test   %rax,%rax
  816aac:	74 47                	je     816af5 <sys_init+0x209>
  816aae:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816ab5:	00 00 00 
  816ab8:	48 8b 08             	mov    (%rax),%rcx
  816abb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816abe:	48 63 d0             	movslq %eax,%rdx
  816ac1:	48 89 d0             	mov    %rdx,%rax
  816ac4:	48 c1 e0 03          	shl    $0x3,%rax
  816ac8:	48 01 d0             	add    %rdx,%rax
  816acb:	48 c1 e0 02          	shl    $0x2,%rax
  816acf:	48 01 d0             	add    %rdx,%rax
  816ad2:	48 c1 e0 03          	shl    $0x3,%rax
  816ad6:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  816add:	48 b8 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rax
  816ae4:	00 00 00 
  816ae7:	48 01 d0             	add    %rdx,%rax
  816aea:	48 83 c0 08          	add    $0x8,%rax
  816aee:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  816af5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816af8:	48 63 d0             	movslq %eax,%rdx
  816afb:	48 89 d0             	mov    %rdx,%rax
  816afe:	48 c1 e0 03          	shl    $0x3,%rax
  816b02:	48 01 d0             	add    %rdx,%rax
  816b05:	48 c1 e0 02          	shl    $0x2,%rax
  816b09:	48 01 d0             	add    %rdx,%rax
  816b0c:	48 c1 e0 03          	shl    $0x3,%rax
  816b10:	48 ba c0 c8 b4 00 00 	movabs $0xb4c8c0,%rdx
  816b17:	00 00 00 
  816b1a:	48 01 c2             	add    %rax,%rdx
  816b1d:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816b24:	00 00 00 
  816b27:	48 89 10             	mov    %rdx,(%rax)
  816b2a:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816b31:	00 00 00 
  816b34:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816b37:	48 63 d0             	movslq %eax,%rdx
  816b3a:	48 89 d0             	mov    %rdx,%rax
  816b3d:	48 c1 e0 03          	shl    $0x3,%rax
  816b41:	48 01 d0             	add    %rdx,%rax
  816b44:	48 c1 e0 02          	shl    $0x2,%rax
  816b48:	48 01 d0             	add    %rdx,%rax
  816b4b:	48 c1 e0 03          	shl    $0x3,%rax
  816b4f:	48 01 c8             	add    %rcx,%rax
  816b52:	48 05 10 01 00 00    	add    $0x110,%rax
  816b58:	48 be c0 5c b5 00 00 	movabs $0xb55cc0,%rsi
  816b5f:	00 00 00 
  816b62:	48 89 70 10          	mov    %rsi,0x10(%rax)
    for (i = 0; i < NMBOX; i++) {
  816b66:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  816b6a:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  816b6e:	0f 8e 96 fe ff ff    	jle    816a0a <sys_init+0x11e>
    }
}
  816b74:	c9                   	leaveq 
  816b75:	c3                   	retq   

0000000000816b76 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  816b76:	55                   	push   %rbp
  816b77:	48 89 e5             	mov    %rsp,%rbp
  816b7a:	48 83 ec 20          	sub    $0x20,%rsp
  816b7e:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  816b81:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  816b85:	7e 35                	jle    816bbc <sys_mbox_new+0x46>
  816b87:	48 b9 28 20 82 00 00 	movabs $0x822028,%rcx
  816b8e:	00 00 00 
  816b91:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  816b98:	00 00 00 
  816b9b:	be 45 00 00 00       	mov    $0x45,%esi
  816ba0:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  816ba7:	00 00 00 
  816baa:	b8 00 00 00 00       	mov    $0x0,%eax
  816baf:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  816bb6:	00 00 00 
  816bb9:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  816bbc:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816bc3:	00 00 00 
  816bc6:	48 8b 00             	mov    (%rax),%rax
  816bc9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  816bcd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  816bd2:	75 25                	jne    816bf9 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  816bd4:	48 bf 70 20 82 00 00 	movabs $0x822070,%rdi
  816bdb:	00 00 00 
  816bde:	b8 00 00 00 00       	mov    $0x0,%eax
  816be3:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  816bea:	00 00 00 
  816bed:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  816bef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816bf4:	e9 5f 01 00 00       	jmpq   816d58 <sys_mbox_new+0x1e2>
    }
    LIST_REMOVE(mbe, link);
  816bf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816bfd:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  816c04:	48 85 c0             	test   %rax,%rax
  816c07:	74 1d                	je     816c26 <sys_mbox_new+0xb0>
  816c09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816c0d:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  816c14:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  816c18:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  816c1f:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  816c26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816c2a:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  816c31:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  816c35:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  816c3c:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  816c3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816c43:	8b 00                	mov    (%rax),%eax
  816c45:	85 c0                	test   %eax,%eax
  816c47:	75 35                	jne    816c7e <sys_mbox_new+0x108>
  816c49:	48 b9 96 20 82 00 00 	movabs $0x822096,%rcx
  816c50:	00 00 00 
  816c53:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  816c5a:	00 00 00 
  816c5d:	be 4c 00 00 00       	mov    $0x4c,%esi
  816c62:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  816c69:	00 00 00 
  816c6c:	b8 00 00 00 00       	mov    $0x0,%eax
  816c71:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  816c78:	00 00 00 
  816c7b:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  816c7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816c82:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  816c88:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  816c8c:	48 b8 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rax
  816c93:	00 00 00 
  816c96:	48 29 c2             	sub    %rax,%rdx
  816c99:	48 89 d0             	mov    %rdx,%rax
  816c9c:	48 c1 f8 03          	sar    $0x3,%rax
  816ca0:	48 89 c2             	mov    %rax,%rdx
  816ca3:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  816caa:	ba c1 14 
  816cad:	48 0f af c2          	imul   %rdx,%rax
  816cb1:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  816cb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816cb8:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  816cbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816cc3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  816cca:	bf 00 00 00 00       	mov    $0x0,%edi
  816ccf:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  816cd6:	00 00 00 
  816cd9:	ff d0                	callq  *%rax
  816cdb:	89 c2                	mov    %eax,%edx
  816cdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816ce1:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  816ce7:	bf 20 00 00 00       	mov    $0x20,%edi
  816cec:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  816cf3:	00 00 00 
  816cf6:	ff d0                	callq  *%rax
  816cf8:	89 c2                	mov    %eax,%edx
  816cfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816cfe:	89 90 14 01 00 00    	mov    %edx,0x114(%rax)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  816d04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816d08:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  816d0e:	83 f8 ff             	cmp    $0xffffffff,%eax
  816d11:	74 0f                	je     816d22 <sys_mbox_new+0x1ac>
	mbe->free_msg == SYS_SEM_NULL)
  816d13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816d17:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    if (mbe->queued_msg == SYS_SEM_NULL ||
  816d1d:	83 f8 ff             	cmp    $0xffffffff,%eax
  816d20:	75 33                	jne    816d55 <sys_mbox_new+0x1df>
    {
	sys_mbox_free(i);
  816d22:	8b 45 f4             	mov    -0xc(%rbp),%eax
  816d25:	89 c7                	mov    %eax,%edi
  816d27:	48 b8 5a 6d 81 00 00 	movabs $0x816d5a,%rax
  816d2e:	00 00 00 
  816d31:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  816d33:	48 bf a8 20 82 00 00 	movabs $0x8220a8,%rdi
  816d3a:	00 00 00 
  816d3d:	b8 00 00 00 00       	mov    $0x0,%eax
  816d42:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  816d49:	00 00 00 
  816d4c:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  816d4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816d53:	eb 03                	jmp    816d58 <sys_mbox_new+0x1e2>
    }
    return i;
  816d55:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  816d58:	c9                   	leaveq 
  816d59:	c3                   	retq   

0000000000816d5a <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  816d5a:	55                   	push   %rbp
  816d5b:	48 89 e5             	mov    %rsp,%rbp
  816d5e:	48 83 ec 10          	sub    $0x10,%rsp
  816d62:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!mboxes[mbox].freed);
  816d65:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816d6c:	00 00 00 
  816d6f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816d72:	48 63 d0             	movslq %eax,%rdx
  816d75:	48 89 d0             	mov    %rdx,%rax
  816d78:	48 c1 e0 03          	shl    $0x3,%rax
  816d7c:	48 01 d0             	add    %rdx,%rax
  816d7f:	48 c1 e0 02          	shl    $0x2,%rax
  816d83:	48 01 d0             	add    %rdx,%rax
  816d86:	48 c1 e0 03          	shl    $0x3,%rax
  816d8a:	48 01 c8             	add    %rcx,%rax
  816d8d:	8b 00                	mov    (%rax),%eax
  816d8f:	85 c0                	test   %eax,%eax
  816d91:	74 35                	je     816dc8 <sys_mbox_free+0x6e>
  816d93:	48 b9 d1 20 82 00 00 	movabs $0x8220d1,%rcx
  816d9a:	00 00 00 
  816d9d:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  816da4:	00 00 00 
  816da7:	be 62 00 00 00       	mov    $0x62,%esi
  816dac:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  816db3:	00 00 00 
  816db6:	b8 00 00 00 00       	mov    $0x0,%eax
  816dbb:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  816dc2:	00 00 00 
  816dc5:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  816dc8:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816dcf:	00 00 00 
  816dd2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816dd5:	48 63 d0             	movslq %eax,%rdx
  816dd8:	48 89 d0             	mov    %rdx,%rax
  816ddb:	48 c1 e0 03          	shl    $0x3,%rax
  816ddf:	48 01 d0             	add    %rdx,%rax
  816de2:	48 c1 e0 02          	shl    $0x2,%rax
  816de6:	48 01 d0             	add    %rdx,%rax
  816de9:	48 c1 e0 03          	shl    $0x3,%rax
  816ded:	48 01 c8             	add    %rcx,%rax
  816df0:	48 05 10 01 00 00    	add    $0x110,%rax
  816df6:	8b 00                	mov    (%rax),%eax
  816df8:	89 c7                	mov    %eax,%edi
  816dfa:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  816e01:	00 00 00 
  816e04:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  816e06:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816e0d:	00 00 00 
  816e10:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816e13:	48 63 d0             	movslq %eax,%rdx
  816e16:	48 89 d0             	mov    %rdx,%rax
  816e19:	48 c1 e0 03          	shl    $0x3,%rax
  816e1d:	48 01 d0             	add    %rdx,%rax
  816e20:	48 c1 e0 02          	shl    $0x2,%rax
  816e24:	48 01 d0             	add    %rdx,%rax
  816e27:	48 c1 e0 03          	shl    $0x3,%rax
  816e2b:	48 01 c8             	add    %rcx,%rax
  816e2e:	48 05 10 01 00 00    	add    $0x110,%rax
  816e34:	8b 40 04             	mov    0x4(%rax),%eax
  816e37:	89 c7                	mov    %eax,%edi
  816e39:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  816e40:	00 00 00 
  816e43:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  816e45:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816e4c:	00 00 00 
  816e4f:	48 8b 08             	mov    (%rax),%rcx
  816e52:	48 be c0 c8 b4 00 00 	movabs $0xb4c8c0,%rsi
  816e59:	00 00 00 
  816e5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816e5f:	48 63 d0             	movslq %eax,%rdx
  816e62:	48 89 d0             	mov    %rdx,%rax
  816e65:	48 c1 e0 03          	shl    $0x3,%rax
  816e69:	48 01 d0             	add    %rdx,%rax
  816e6c:	48 c1 e0 02          	shl    $0x2,%rax
  816e70:	48 01 d0             	add    %rdx,%rax
  816e73:	48 c1 e0 03          	shl    $0x3,%rax
  816e77:	48 01 f0             	add    %rsi,%rax
  816e7a:	48 05 10 01 00 00    	add    $0x110,%rax
  816e80:	48 89 48 08          	mov    %rcx,0x8(%rax)
  816e84:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816e8b:	00 00 00 
  816e8e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816e91:	48 63 d0             	movslq %eax,%rdx
  816e94:	48 89 d0             	mov    %rdx,%rax
  816e97:	48 c1 e0 03          	shl    $0x3,%rax
  816e9b:	48 01 d0             	add    %rdx,%rax
  816e9e:	48 c1 e0 02          	shl    $0x2,%rax
  816ea2:	48 01 d0             	add    %rdx,%rax
  816ea5:	48 c1 e0 03          	shl    $0x3,%rax
  816ea9:	48 01 c8             	add    %rcx,%rax
  816eac:	48 05 10 01 00 00    	add    $0x110,%rax
  816eb2:	48 8b 40 08          	mov    0x8(%rax),%rax
  816eb6:	48 85 c0             	test   %rax,%rax
  816eb9:	74 47                	je     816f02 <sys_mbox_free+0x1a8>
  816ebb:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816ec2:	00 00 00 
  816ec5:	48 8b 08             	mov    (%rax),%rcx
  816ec8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816ecb:	48 63 d0             	movslq %eax,%rdx
  816ece:	48 89 d0             	mov    %rdx,%rax
  816ed1:	48 c1 e0 03          	shl    $0x3,%rax
  816ed5:	48 01 d0             	add    %rdx,%rax
  816ed8:	48 c1 e0 02          	shl    $0x2,%rax
  816edc:	48 01 d0             	add    %rdx,%rax
  816edf:	48 c1 e0 03          	shl    $0x3,%rax
  816ee3:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  816eea:	48 b8 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rax
  816ef1:	00 00 00 
  816ef4:	48 01 d0             	add    %rdx,%rax
  816ef7:	48 83 c0 08          	add    $0x8,%rax
  816efb:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  816f02:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816f05:	48 63 d0             	movslq %eax,%rdx
  816f08:	48 89 d0             	mov    %rdx,%rax
  816f0b:	48 c1 e0 03          	shl    $0x3,%rax
  816f0f:	48 01 d0             	add    %rdx,%rax
  816f12:	48 c1 e0 02          	shl    $0x2,%rax
  816f16:	48 01 d0             	add    %rdx,%rax
  816f19:	48 c1 e0 03          	shl    $0x3,%rax
  816f1d:	48 ba c0 c8 b4 00 00 	movabs $0xb4c8c0,%rdx
  816f24:	00 00 00 
  816f27:	48 01 c2             	add    %rax,%rdx
  816f2a:	48 b8 c0 5c b5 00 00 	movabs $0xb55cc0,%rax
  816f31:	00 00 00 
  816f34:	48 89 10             	mov    %rdx,(%rax)
  816f37:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816f3e:	00 00 00 
  816f41:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816f44:	48 63 d0             	movslq %eax,%rdx
  816f47:	48 89 d0             	mov    %rdx,%rax
  816f4a:	48 c1 e0 03          	shl    $0x3,%rax
  816f4e:	48 01 d0             	add    %rdx,%rax
  816f51:	48 c1 e0 02          	shl    $0x2,%rax
  816f55:	48 01 d0             	add    %rdx,%rax
  816f58:	48 c1 e0 03          	shl    $0x3,%rax
  816f5c:	48 01 c8             	add    %rcx,%rax
  816f5f:	48 05 10 01 00 00    	add    $0x110,%rax
  816f65:	48 be c0 5c b5 00 00 	movabs $0xb55cc0,%rsi
  816f6c:	00 00 00 
  816f6f:	48 89 70 10          	mov    %rsi,0x10(%rax)
    mboxes[mbox].freed = 1;
  816f73:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  816f7a:	00 00 00 
  816f7d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816f80:	48 63 d0             	movslq %eax,%rdx
  816f83:	48 89 d0             	mov    %rdx,%rax
  816f86:	48 c1 e0 03          	shl    $0x3,%rax
  816f8a:	48 01 d0             	add    %rdx,%rax
  816f8d:	48 c1 e0 02          	shl    $0x2,%rax
  816f91:	48 01 d0             	add    %rdx,%rax
  816f94:	48 c1 e0 03          	shl    $0x3,%rax
  816f98:	48 01 c8             	add    %rcx,%rax
  816f9b:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  816fa1:	c9                   	leaveq 
  816fa2:	c3                   	retq   

0000000000816fa3 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  816fa3:	55                   	push   %rbp
  816fa4:	48 89 e5             	mov    %rsp,%rbp
  816fa7:	48 83 ec 10          	sub    $0x10,%rsp
  816fab:	89 7d fc             	mov    %edi,-0x4(%rbp)
  816fae:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  816fb2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816fb6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816fb9:	48 89 d6             	mov    %rdx,%rsi
  816fbc:	89 c7                	mov    %eax,%edi
  816fbe:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  816fc5:	00 00 00 
  816fc8:	ff d0                	callq  *%rax
  816fca:	84 c0                	test   %al,%al
  816fcc:	74 35                	je     817003 <sys_mbox_post+0x60>
  816fce:	48 b9 e8 20 82 00 00 	movabs $0x8220e8,%rcx
  816fd5:	00 00 00 
  816fd8:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  816fdf:	00 00 00 
  816fe2:	be 6c 00 00 00       	mov    $0x6c,%esi
  816fe7:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  816fee:	00 00 00 
  816ff1:	b8 00 00 00 00       	mov    $0x0,%eax
  816ff6:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  816ffd:	00 00 00 
  817000:	41 ff d0             	callq  *%r8
}
  817003:	c9                   	leaveq 
  817004:	c3                   	retq   

0000000000817005 <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  817005:	55                   	push   %rbp
  817006:	48 89 e5             	mov    %rsp,%rbp
  817009:	48 83 ec 20          	sub    $0x20,%rsp
  81700d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817010:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817014:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  81701b:	00 00 00 
  81701e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817021:	48 63 d0             	movslq %eax,%rdx
  817024:	48 89 d0             	mov    %rdx,%rax
  817027:	48 c1 e0 03          	shl    $0x3,%rax
  81702b:	48 01 d0             	add    %rdx,%rax
  81702e:	48 c1 e0 02          	shl    $0x2,%rax
  817032:	48 01 d0             	add    %rdx,%rax
  817035:	48 c1 e0 03          	shl    $0x3,%rax
  817039:	48 01 c8             	add    %rcx,%rax
  81703c:	8b 00                	mov    (%rax),%eax
  81703e:	85 c0                	test   %eax,%eax
  817040:	74 35                	je     817077 <sys_mbox_trypost+0x72>
  817042:	48 b9 d1 20 82 00 00 	movabs $0x8220d1,%rcx
  817049:	00 00 00 
  81704c:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  817053:	00 00 00 
  817056:	be 72 00 00 00       	mov    $0x72,%esi
  81705b:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817062:	00 00 00 
  817065:	b8 00 00 00 00       	mov    $0x0,%eax
  81706a:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817071:	00 00 00 
  817074:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  817077:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  81707e:	00 00 00 
  817081:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817084:	48 63 d0             	movslq %eax,%rdx
  817087:	48 89 d0             	mov    %rdx,%rax
  81708a:	48 c1 e0 03          	shl    $0x3,%rax
  81708e:	48 01 d0             	add    %rdx,%rax
  817091:	48 c1 e0 02          	shl    $0x2,%rax
  817095:	48 01 d0             	add    %rdx,%rax
  817098:	48 c1 e0 03          	shl    $0x3,%rax
  81709c:	48 01 c8             	add    %rcx,%rax
  81709f:	48 05 10 01 00 00    	add    $0x110,%rax
  8170a5:	8b 40 04             	mov    0x4(%rax),%eax
  8170a8:	be 00 00 00 00       	mov    $0x0,%esi
  8170ad:	89 c7                	mov    %eax,%edi
  8170af:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  8170b6:	00 00 00 
  8170b9:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  8170bb:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  8170c2:	00 00 00 
  8170c5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8170c8:	48 63 d0             	movslq %eax,%rdx
  8170cb:	48 89 d0             	mov    %rdx,%rax
  8170ce:	48 c1 e0 03          	shl    $0x3,%rax
  8170d2:	48 01 d0             	add    %rdx,%rax
  8170d5:	48 c1 e0 02          	shl    $0x2,%rax
  8170d9:	48 01 d0             	add    %rdx,%rax
  8170dc:	48 c1 e0 03          	shl    $0x3,%rax
  8170e0:	48 01 c8             	add    %rcx,%rax
  8170e3:	8b 48 08             	mov    0x8(%rax),%ecx
  8170e6:	48 be c0 c8 b4 00 00 	movabs $0xb4c8c0,%rsi
  8170ed:	00 00 00 
  8170f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8170f3:	48 63 d0             	movslq %eax,%rdx
  8170f6:	48 89 d0             	mov    %rdx,%rax
  8170f9:	48 c1 e0 03          	shl    $0x3,%rax
  8170fd:	48 01 d0             	add    %rdx,%rax
  817100:	48 c1 e0 02          	shl    $0x2,%rax
  817104:	48 01 d0             	add    %rdx,%rax
  817107:	48 c1 e0 03          	shl    $0x3,%rax
  81710b:	48 01 f0             	add    %rsi,%rax
  81710e:	8b 40 04             	mov    0x4(%rax),%eax
  817111:	39 c1                	cmp    %eax,%ecx
  817113:	75 0a                	jne    81711f <sys_mbox_trypost+0x11a>
	return ERR_MEM;
  817115:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81711a:	e9 4a 01 00 00       	jmpq   817269 <sys_mbox_trypost+0x264>

    int slot = mboxes[mbox].nextq;
  81711f:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  817126:	00 00 00 
  817129:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81712c:	48 63 d0             	movslq %eax,%rdx
  81712f:	48 89 d0             	mov    %rdx,%rax
  817132:	48 c1 e0 03          	shl    $0x3,%rax
  817136:	48 01 d0             	add    %rdx,%rax
  817139:	48 c1 e0 02          	shl    $0x2,%rax
  81713d:	48 01 d0             	add    %rdx,%rax
  817140:	48 c1 e0 03          	shl    $0x3,%rax
  817144:	48 01 c8             	add    %rcx,%rax
  817147:	8b 40 08             	mov    0x8(%rax),%eax
  81714a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  81714d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817150:	8d 50 01             	lea    0x1(%rax),%edx
  817153:	89 d0                	mov    %edx,%eax
  817155:	c1 f8 1f             	sar    $0x1f,%eax
  817158:	c1 e8 1b             	shr    $0x1b,%eax
  81715b:	01 c2                	add    %eax,%edx
  81715d:	83 e2 1f             	and    $0x1f,%edx
  817160:	29 c2                	sub    %eax,%edx
  817162:	89 d0                	mov    %edx,%eax
  817164:	89 c6                	mov    %eax,%esi
  817166:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  81716d:	00 00 00 
  817170:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817173:	48 63 d0             	movslq %eax,%rdx
  817176:	48 89 d0             	mov    %rdx,%rax
  817179:	48 c1 e0 03          	shl    $0x3,%rax
  81717d:	48 01 d0             	add    %rdx,%rax
  817180:	48 c1 e0 02          	shl    $0x2,%rax
  817184:	48 01 d0             	add    %rdx,%rax
  817187:	48 c1 e0 03          	shl    $0x3,%rax
  81718b:	48 01 c8             	add    %rcx,%rax
  81718e:	89 70 08             	mov    %esi,0x8(%rax)
    mboxes[mbox].msg[slot] = msg;
  817191:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  817198:	00 00 00 
  81719b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81719e:	48 63 f0             	movslq %eax,%rsi
  8171a1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8171a4:	48 63 d0             	movslq %eax,%rdx
  8171a7:	48 89 d0             	mov    %rdx,%rax
  8171aa:	48 c1 e0 03          	shl    $0x3,%rax
  8171ae:	48 01 d0             	add    %rdx,%rax
  8171b1:	48 c1 e0 02          	shl    $0x2,%rax
  8171b5:	48 01 d0             	add    %rdx,%rax
  8171b8:	48 01 f0             	add    %rsi,%rax
  8171bb:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8171bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8171c3:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  8171c7:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  8171ce:	00 00 00 
  8171d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8171d4:	48 63 d0             	movslq %eax,%rdx
  8171d7:	48 89 d0             	mov    %rdx,%rax
  8171da:	48 c1 e0 03          	shl    $0x3,%rax
  8171de:	48 01 d0             	add    %rdx,%rax
  8171e1:	48 c1 e0 02          	shl    $0x2,%rax
  8171e5:	48 01 d0             	add    %rdx,%rax
  8171e8:	48 c1 e0 03          	shl    $0x3,%rax
  8171ec:	48 01 c8             	add    %rcx,%rax
  8171ef:	8b 40 04             	mov    0x4(%rax),%eax
  8171f2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8171f5:	75 2f                	jne    817226 <sys_mbox_trypost+0x221>
	mboxes[mbox].head = slot;
  8171f7:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  8171fe:	00 00 00 
  817201:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817204:	48 63 d0             	movslq %eax,%rdx
  817207:	48 89 d0             	mov    %rdx,%rax
  81720a:	48 c1 e0 03          	shl    $0x3,%rax
  81720e:	48 01 d0             	add    %rdx,%rax
  817211:	48 c1 e0 02          	shl    $0x2,%rax
  817215:	48 01 d0             	add    %rdx,%rax
  817218:	48 c1 e0 03          	shl    $0x3,%rax
  81721c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  817220:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817223:	89 42 04             	mov    %eax,0x4(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  817226:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  81722d:	00 00 00 
  817230:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817233:	48 63 d0             	movslq %eax,%rdx
  817236:	48 89 d0             	mov    %rdx,%rax
  817239:	48 c1 e0 03          	shl    $0x3,%rax
  81723d:	48 01 d0             	add    %rdx,%rax
  817240:	48 c1 e0 02          	shl    $0x2,%rax
  817244:	48 01 d0             	add    %rdx,%rax
  817247:	48 c1 e0 03          	shl    $0x3,%rax
  81724b:	48 01 c8             	add    %rcx,%rax
  81724e:	48 05 10 01 00 00    	add    $0x110,%rax
  817254:	8b 00                	mov    (%rax),%eax
  817256:	89 c7                	mov    %eax,%edi
  817258:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81725f:	00 00 00 
  817262:	ff d0                	callq  *%rax

    return ERR_OK;
  817264:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817269:	c9                   	leaveq 
  81726a:	c3                   	retq   

000000000081726b <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  81726b:	55                   	push   %rbp
  81726c:	48 89 e5             	mov    %rsp,%rbp
  81726f:	48 83 ec 20          	sub    $0x20,%rsp
  817273:	89 f8                	mov    %edi,%eax
  817275:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  817278:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  81727f:	00 00 00 
  817282:	48 8b 00             	mov    (%rax),%rax
  817285:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817289:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81728e:	75 25                	jne    8172b5 <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817290:	48 bf 10 21 82 00 00 	movabs $0x822110,%rdi
  817297:	00 00 00 
  81729a:	b8 00 00 00 00       	mov    $0x0,%eax
  81729f:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8172a6:	00 00 00 
  8172a9:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  8172ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8172b0:	e9 b2 00 00 00       	jmpq   817367 <sys_sem_new+0xfc>
    }
    LIST_REMOVE(se, link);
  8172b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172b9:	48 8b 40 10          	mov    0x10(%rax),%rax
  8172bd:	48 85 c0             	test   %rax,%rax
  8172c0:	74 14                	je     8172d6 <sys_sem_new+0x6b>
  8172c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172c6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8172ca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8172ce:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8172d2:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8172d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172da:	48 8b 40 18          	mov    0x18(%rax),%rax
  8172de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8172e2:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8172e6:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  8172e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172ed:	8b 00                	mov    (%rax),%eax
  8172ef:	85 c0                	test   %eax,%eax
  8172f1:	75 35                	jne    817328 <sys_sem_new+0xbd>
  8172f3:	48 b9 36 21 82 00 00 	movabs $0x822136,%rcx
  8172fa:	00 00 00 
  8172fd:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  817304:	00 00 00 
  817307:	be 8d 00 00 00       	mov    $0x8d,%esi
  81730c:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817313:	00 00 00 
  817316:	b8 00 00 00 00       	mov    $0x0,%eax
  81731b:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817322:	00 00 00 
  817325:	41 ff d0             	callq  *%r8
    se->freed = 0;
  817328:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81732c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  817332:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  817336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81733a:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  81733e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817342:	8b 40 04             	mov    0x4(%rax),%eax
  817345:	8d 50 01             	lea    0x1(%rax),%edx
  817348:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81734c:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  81734f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817353:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  81735a:	00 00 00 
  81735d:	48 29 c2             	sub    %rax,%rdx
  817360:	48 89 d0             	mov    %rdx,%rax
  817363:	48 c1 f8 05          	sar    $0x5,%rax
}
  817367:	c9                   	leaveq 
  817368:	c3                   	retq   

0000000000817369 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817369:	55                   	push   %rbp
  81736a:	48 89 e5             	mov    %rsp,%rbp
  81736d:	48 83 ec 10          	sub    $0x10,%rsp
  817371:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817374:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  81737b:	00 00 00 
  81737e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817381:	48 63 d2             	movslq %edx,%rdx
  817384:	48 c1 e2 05          	shl    $0x5,%rdx
  817388:	48 01 d0             	add    %rdx,%rax
  81738b:	8b 00                	mov    (%rax),%eax
  81738d:	85 c0                	test   %eax,%eax
  81738f:	74 35                	je     8173c6 <sys_sem_free+0x5d>
  817391:	48 b9 40 21 82 00 00 	movabs $0x822140,%rcx
  817398:	00 00 00 
  81739b:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  8173a2:	00 00 00 
  8173a5:	be 98 00 00 00       	mov    $0x98,%esi
  8173aa:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  8173b1:	00 00 00 
  8173b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8173b9:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  8173c0:	00 00 00 
  8173c3:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  8173c6:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8173cd:	00 00 00 
  8173d0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8173d3:	48 63 d2             	movslq %edx,%rdx
  8173d6:	48 c1 e2 05          	shl    $0x5,%rdx
  8173da:	48 01 d0             	add    %rdx,%rax
  8173dd:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  8173e3:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8173ea:	00 00 00 
  8173ed:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8173f0:	48 63 d2             	movslq %edx,%rdx
  8173f3:	48 c1 e2 05          	shl    $0x5,%rdx
  8173f7:	48 01 d0             	add    %rdx,%rax
  8173fa:	8b 40 04             	mov    0x4(%rax),%eax
  8173fd:	8d 50 01             	lea    0x1(%rax),%edx
  817400:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817407:	00 00 00 
  81740a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81740d:	48 63 c9             	movslq %ecx,%rcx
  817410:	48 c1 e1 05          	shl    $0x5,%rcx
  817414:	48 01 c8             	add    %rcx,%rax
  817417:	89 50 04             	mov    %edx,0x4(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  81741a:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  817421:	00 00 00 
  817424:	48 8b 00             	mov    (%rax),%rax
  817427:	48 ba 80 a8 b4 00 00 	movabs $0xb4a880,%rdx
  81742e:	00 00 00 
  817431:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817434:	48 63 c9             	movslq %ecx,%rcx
  817437:	48 c1 e1 05          	shl    $0x5,%rcx
  81743b:	48 01 ca             	add    %rcx,%rdx
  81743e:	48 83 c2 10          	add    $0x10,%rdx
  817442:	48 89 02             	mov    %rax,(%rdx)
  817445:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  81744c:	00 00 00 
  81744f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817452:	48 63 d2             	movslq %edx,%rdx
  817455:	48 c1 e2 05          	shl    $0x5,%rdx
  817459:	48 01 d0             	add    %rdx,%rax
  81745c:	48 83 c0 10          	add    $0x10,%rax
  817460:	48 8b 00             	mov    (%rax),%rax
  817463:	48 85 c0             	test   %rax,%rax
  817466:	74 2c                	je     817494 <sys_sem_free+0x12b>
  817468:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  81746f:	00 00 00 
  817472:	48 8b 00             	mov    (%rax),%rax
  817475:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817478:	48 63 d2             	movslq %edx,%rdx
  81747b:	48 c1 e2 05          	shl    $0x5,%rdx
  81747f:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  817483:	48 ba 80 a8 b4 00 00 	movabs $0xb4a880,%rdx
  81748a:	00 00 00 
  81748d:	48 01 ca             	add    %rcx,%rdx
  817490:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817494:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817497:	48 98                	cltq   
  817499:	48 c1 e0 05          	shl    $0x5,%rax
  81749d:	48 89 c2             	mov    %rax,%rdx
  8174a0:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8174a7:	00 00 00 
  8174aa:	48 01 c2             	add    %rax,%rdx
  8174ad:	48 b8 80 c8 b4 00 00 	movabs $0xb4c880,%rax
  8174b4:	00 00 00 
  8174b7:	48 89 10             	mov    %rdx,(%rax)
  8174ba:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8174c1:	00 00 00 
  8174c4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8174c7:	48 63 d2             	movslq %edx,%rdx
  8174ca:	48 c1 e2 05          	shl    $0x5,%rdx
  8174ce:	48 01 d0             	add    %rdx,%rax
  8174d1:	48 83 c0 10          	add    $0x10,%rax
  8174d5:	48 be 80 c8 b4 00 00 	movabs $0xb4c880,%rsi
  8174dc:	00 00 00 
  8174df:	48 89 70 08          	mov    %rsi,0x8(%rax)
}
  8174e3:	c9                   	leaveq 
  8174e4:	c3                   	retq   

00000000008174e5 <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  8174e5:	55                   	push   %rbp
  8174e6:	48 89 e5             	mov    %rsp,%rbp
  8174e9:	48 83 ec 10          	sub    $0x10,%rsp
  8174ed:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  8174f0:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8174f7:	00 00 00 
  8174fa:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8174fd:	48 63 d2             	movslq %edx,%rdx
  817500:	48 c1 e2 05          	shl    $0x5,%rdx
  817504:	48 01 d0             	add    %rdx,%rax
  817507:	8b 00                	mov    (%rax),%eax
  817509:	85 c0                	test   %eax,%eax
  81750b:	74 35                	je     817542 <sys_sem_signal+0x5d>
  81750d:	48 b9 40 21 82 00 00 	movabs $0x822140,%rcx
  817514:	00 00 00 
  817517:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  81751e:	00 00 00 
  817521:	be a1 00 00 00       	mov    $0xa1,%esi
  817526:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  81752d:	00 00 00 
  817530:	b8 00 00 00 00       	mov    $0x0,%eax
  817535:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  81753c:	00 00 00 
  81753f:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  817542:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817549:	00 00 00 
  81754c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81754f:	48 63 d2             	movslq %edx,%rdx
  817552:	48 c1 e2 05          	shl    $0x5,%rdx
  817556:	48 01 d0             	add    %rdx,%rax
  817559:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81755d:	8d 50 01             	lea    0x1(%rax),%edx
  817560:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817567:	00 00 00 
  81756a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81756d:	48 63 c9             	movslq %ecx,%rcx
  817570:	48 c1 e1 05          	shl    $0x5,%rcx
  817574:	48 01 c8             	add    %rcx,%rax
  817577:	66 89 50 08          	mov    %dx,0x8(%rax)
    if (sems[sem].waiters) {
  81757b:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817582:	00 00 00 
  817585:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817588:	48 63 d2             	movslq %edx,%rdx
  81758b:	48 c1 e2 05          	shl    $0x5,%rdx
  81758f:	48 01 d0             	add    %rdx,%rax
  817592:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  817596:	66 85 c0             	test   %ax,%ax
  817599:	74 49                	je     8175e4 <sys_sem_signal+0xff>
	sems[sem].waiters = 0;
  81759b:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8175a2:	00 00 00 
  8175a5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8175a8:	48 63 d2             	movslq %edx,%rdx
  8175ab:	48 c1 e2 05          	shl    $0x5,%rdx
  8175af:	48 01 d0             	add    %rdx,%rax
  8175b2:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
	thread_wakeup(&sems[sem].v);
  8175b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8175bb:	48 98                	cltq   
  8175bd:	48 c1 e0 05          	shl    $0x5,%rax
  8175c1:	48 89 c2             	mov    %rax,%rdx
  8175c4:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8175cb:	00 00 00 
  8175ce:	48 01 d0             	add    %rdx,%rax
  8175d1:	48 83 c0 08          	add    $0x8,%rax
  8175d5:	48 89 c7             	mov    %rax,%rdi
  8175d8:	48 b8 4f 80 81 00 00 	movabs $0x81804f,%rax
  8175df:	00 00 00 
  8175e2:	ff d0                	callq  *%rax
    }
}
  8175e4:	c9                   	leaveq 
  8175e5:	c3                   	retq   

00000000008175e6 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  8175e6:	55                   	push   %rbp
  8175e7:	48 89 e5             	mov    %rsp,%rbp
  8175ea:	48 83 ec 30          	sub    $0x30,%rsp
  8175ee:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8175f1:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  8175f4:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8175fb:	00 00 00 
  8175fe:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817601:	48 63 d2             	movslq %edx,%rdx
  817604:	48 c1 e2 05          	shl    $0x5,%rdx
  817608:	48 01 d0             	add    %rdx,%rax
  81760b:	8b 00                	mov    (%rax),%eax
  81760d:	85 c0                	test   %eax,%eax
  81760f:	74 35                	je     817646 <sys_arch_sem_wait+0x60>
  817611:	48 b9 40 21 82 00 00 	movabs $0x822140,%rcx
  817618:	00 00 00 
  81761b:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  817622:	00 00 00 
  817625:	be ac 00 00 00       	mov    $0xac,%esi
  81762a:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817631:	00 00 00 
  817634:	b8 00 00 00 00       	mov    $0x0,%eax
  817639:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817640:	00 00 00 
  817643:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  817646:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  81764d:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817654:	00 00 00 
  817657:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81765a:	48 63 d2             	movslq %edx,%rdx
  81765d:	48 c1 e2 05          	shl    $0x5,%rdx
  817661:	48 01 d0             	add    %rdx,%rax
  817664:	8b 40 04             	mov    0x4(%rax),%eax
  817667:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  81766a:	e9 7c 01 00 00       	jmpq   8177eb <sys_arch_sem_wait+0x205>
	if (sems[sem].counter > 0) {
  81766f:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817676:	00 00 00 
  817679:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81767c:	48 63 d2             	movslq %edx,%rdx
  81767f:	48 c1 e2 05          	shl    $0x5,%rdx
  817683:	48 01 d0             	add    %rdx,%rax
  817686:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81768a:	66 85 c0             	test   %ax,%ax
  81768d:	74 41                	je     8176d0 <sys_arch_sem_wait+0xea>
	    sems[sem].counter--;
  81768f:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817696:	00 00 00 
  817699:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81769c:	48 63 d2             	movslq %edx,%rdx
  81769f:	48 c1 e2 05          	shl    $0x5,%rdx
  8176a3:	48 01 d0             	add    %rdx,%rax
  8176a6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8176aa:	8d 50 ff             	lea    -0x1(%rax),%edx
  8176ad:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  8176b4:	00 00 00 
  8176b7:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8176ba:	48 63 c9             	movslq %ecx,%rcx
  8176bd:	48 c1 e1 05          	shl    $0x5,%rcx
  8176c1:	48 01 c8             	add    %rcx,%rax
  8176c4:	66 89 50 08          	mov    %dx,0x8(%rax)
	    return waited;
  8176c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176cb:	e9 36 01 00 00       	jmpq   817806 <sys_arch_sem_wait+0x220>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  8176d0:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  8176d4:	75 0a                	jne    8176e0 <sys_arch_sem_wait+0xfa>
	    return SYS_ARCH_TIMEOUT;
  8176d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8176db:	e9 26 01 00 00       	jmpq   817806 <sys_arch_sem_wait+0x220>
	} else {
	    uint32_t a = sys_time_msec();
  8176e0:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  8176e7:	00 00 00 
  8176ea:	ff d0                	callq  *%rax
  8176ec:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  8176ef:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8176f3:	74 0f                	je     817704 <sys_arch_sem_wait+0x11e>
  8176f5:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8176f8:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8176fb:	89 c2                	mov    %eax,%edx
  8176fd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817700:	01 d0                	add    %edx,%eax
  817702:	eb 05                	jmp    817709 <sys_arch_sem_wait+0x123>
  817704:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817709:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  81770c:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817713:	00 00 00 
  817716:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817719:	48 63 d2             	movslq %edx,%rdx
  81771c:	48 c1 e2 05          	shl    $0x5,%rdx
  817720:	48 01 d0             	add    %rdx,%rax
  817723:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%rax)
	    uint32_t cur_v = sems[sem].v;
  817729:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817730:	00 00 00 
  817733:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817736:	48 63 d2             	movslq %edx,%rdx
  817739:	48 c1 e2 05          	shl    $0x5,%rdx
  81773d:	48 01 d0             	add    %rdx,%rax
  817740:	8b 40 08             	mov    0x8(%rax),%eax
  817743:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  817746:	48 b8 2d 7f 81 00 00 	movabs $0x817f2d,%rax
  81774d:	00 00 00 
  817750:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  817752:	8b 45 dc             	mov    -0x24(%rbp),%eax
  817755:	48 98                	cltq   
  817757:	48 c1 e0 05          	shl    $0x5,%rax
  81775b:	48 89 c2             	mov    %rax,%rdx
  81775e:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817765:	00 00 00 
  817768:	48 01 d0             	add    %rdx,%rax
  81776b:	48 8d 48 08          	lea    0x8(%rax),%rcx
  81776f:	8b 55 f0             	mov    -0x10(%rbp),%edx
  817772:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817775:	89 c6                	mov    %eax,%esi
  817777:	48 89 cf             	mov    %rcx,%rdi
  81777a:	48 b8 a2 80 81 00 00 	movabs $0x8180a2,%rax
  817781:	00 00 00 
  817784:	ff d0                	callq  *%rax
	    lwip_core_lock();
  817786:	48 b8 27 7f 81 00 00 	movabs $0x817f27,%rax
  81778d:	00 00 00 
  817790:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  817792:	48 b8 80 a8 b4 00 00 	movabs $0xb4a880,%rax
  817799:	00 00 00 
  81779c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81779f:	48 63 d2             	movslq %edx,%rdx
  8177a2:	48 c1 e2 05          	shl    $0x5,%rdx
  8177a6:	48 01 d0             	add    %rdx,%rax
  8177a9:	8b 40 04             	mov    0x4(%rax),%eax
  8177ac:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  8177af:	74 22                	je     8177d3 <sys_arch_sem_wait+0x1ed>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  8177b1:	48 bf 58 21 82 00 00 	movabs $0x822158,%rdi
  8177b8:	00 00 00 
  8177bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8177c0:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8177c7:	00 00 00 
  8177ca:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  8177cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8177d1:	eb 33                	jmp    817806 <sys_arch_sem_wait+0x220>
	    }
	    uint32_t b = sys_time_msec();
  8177d3:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  8177da:	00 00 00 
  8177dd:	ff d0                	callq  *%rax
  8177df:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  8177e2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8177e5:	2b 45 f4             	sub    -0xc(%rbp),%eax
  8177e8:	01 45 fc             	add    %eax,-0x4(%rbp)
    while (tm_msec == 0 || waited < tm_msec) {
  8177eb:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8177ef:	0f 84 7a fe ff ff    	je     81766f <sys_arch_sem_wait+0x89>
  8177f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8177f8:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  8177fb:	0f 82 6e fe ff ff    	jb     81766f <sys_arch_sem_wait+0x89>
	}
    }

    return SYS_ARCH_TIMEOUT;
  817801:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  817806:	c9                   	leaveq 
  817807:	c3                   	retq   

0000000000817808 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  817808:	55                   	push   %rbp
  817809:	48 89 e5             	mov    %rsp,%rbp
  81780c:	48 83 ec 20          	sub    $0x20,%rsp
  817810:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817813:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  817817:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  81781a:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  817821:	00 00 00 
  817824:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817827:	48 63 d0             	movslq %eax,%rdx
  81782a:	48 89 d0             	mov    %rdx,%rax
  81782d:	48 c1 e0 03          	shl    $0x3,%rax
  817831:	48 01 d0             	add    %rdx,%rax
  817834:	48 c1 e0 02          	shl    $0x2,%rax
  817838:	48 01 d0             	add    %rdx,%rax
  81783b:	48 c1 e0 03          	shl    $0x3,%rax
  81783f:	48 01 c8             	add    %rcx,%rax
  817842:	8b 00                	mov    (%rax),%eax
  817844:	85 c0                	test   %eax,%eax
  817846:	74 35                	je     81787d <sys_arch_mbox_fetch+0x75>
  817848:	48 b9 d1 20 82 00 00 	movabs $0x8220d1,%rcx
  81784f:	00 00 00 
  817852:	48 ba 39 20 82 00 00 	movabs $0x822039,%rdx
  817859:	00 00 00 
  81785c:	be ce 00 00 00       	mov    $0xce,%esi
  817861:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817868:	00 00 00 
  81786b:	b8 00 00 00 00       	mov    $0x0,%eax
  817870:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817877:	00 00 00 
  81787a:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  81787d:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  817884:	00 00 00 
  817887:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81788a:	48 63 d0             	movslq %eax,%rdx
  81788d:	48 89 d0             	mov    %rdx,%rax
  817890:	48 c1 e0 03          	shl    $0x3,%rax
  817894:	48 01 d0             	add    %rdx,%rax
  817897:	48 c1 e0 02          	shl    $0x2,%rax
  81789b:	48 01 d0             	add    %rdx,%rax
  81789e:	48 c1 e0 03          	shl    $0x3,%rax
  8178a2:	48 01 c8             	add    %rcx,%rax
  8178a5:	48 05 10 01 00 00    	add    $0x110,%rax
  8178ab:	8b 00                	mov    (%rax),%eax
  8178ad:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8178b0:	89 d6                	mov    %edx,%esi
  8178b2:	89 c7                	mov    %eax,%edi
  8178b4:	48 b8 e6 75 81 00 00 	movabs $0x8175e6,%rax
  8178bb:	00 00 00 
  8178be:	ff d0                	callq  *%rax
  8178c0:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  8178c3:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8178c7:	75 08                	jne    8178d1 <sys_arch_mbox_fetch+0xc9>
	return waited;
  8178c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8178cc:	e9 ad 01 00 00       	jmpq   817a7e <sys_arch_mbox_fetch+0x276>

    int slot = mboxes[mbox].head;
  8178d1:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  8178d8:	00 00 00 
  8178db:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178de:	48 63 d0             	movslq %eax,%rdx
  8178e1:	48 89 d0             	mov    %rdx,%rax
  8178e4:	48 c1 e0 03          	shl    $0x3,%rax
  8178e8:	48 01 d0             	add    %rdx,%rax
  8178eb:	48 c1 e0 02          	shl    $0x2,%rax
  8178ef:	48 01 d0             	add    %rdx,%rax
  8178f2:	48 c1 e0 03          	shl    $0x3,%rax
  8178f6:	48 01 c8             	add    %rcx,%rax
  8178f9:	8b 40 04             	mov    0x4(%rax),%eax
  8178fc:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  8178ff:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  817903:	75 2a                	jne    81792f <sys_arch_mbox_fetch+0x127>
	panic("lwip: sys_arch_mbox_fetch: no message");
  817905:	48 ba 88 21 82 00 00 	movabs $0x822188,%rdx
  81790c:	00 00 00 
  81790f:	be d6 00 00 00       	mov    $0xd6,%esi
  817914:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  81791b:	00 00 00 
  81791e:	b8 00 00 00 00       	mov    $0x0,%eax
  817923:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81792a:	00 00 00 
  81792d:	ff d1                	callq  *%rcx
    if (msg)
  81792f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  817934:	74 39                	je     81796f <sys_arch_mbox_fetch+0x167>
	*msg = mboxes[mbox].msg[slot];
  817936:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  81793d:	00 00 00 
  817940:	8b 45 f8             	mov    -0x8(%rbp),%eax
  817943:	48 63 f0             	movslq %eax,%rsi
  817946:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817949:	48 63 d0             	movslq %eax,%rdx
  81794c:	48 89 d0             	mov    %rdx,%rax
  81794f:	48 c1 e0 03          	shl    $0x3,%rax
  817953:	48 01 d0             	add    %rdx,%rax
  817956:	48 c1 e0 02          	shl    $0x2,%rax
  81795a:	48 01 d0             	add    %rdx,%rax
  81795d:	48 01 f0             	add    %rsi,%rax
  817960:	48 83 c0 02          	add    $0x2,%rax
  817964:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  817968:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81796c:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  81796f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  817972:	8d 50 01             	lea    0x1(%rax),%edx
  817975:	89 d0                	mov    %edx,%eax
  817977:	c1 f8 1f             	sar    $0x1f,%eax
  81797a:	c1 e8 1b             	shr    $0x1b,%eax
  81797d:	01 c2                	add    %eax,%edx
  81797f:	83 e2 1f             	and    $0x1f,%edx
  817982:	29 c2                	sub    %eax,%edx
  817984:	89 d0                	mov    %edx,%eax
  817986:	89 c6                	mov    %eax,%esi
  817988:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  81798f:	00 00 00 
  817992:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817995:	48 63 d0             	movslq %eax,%rdx
  817998:	48 89 d0             	mov    %rdx,%rax
  81799b:	48 c1 e0 03          	shl    $0x3,%rax
  81799f:	48 01 d0             	add    %rdx,%rax
  8179a2:	48 c1 e0 02          	shl    $0x2,%rax
  8179a6:	48 01 d0             	add    %rdx,%rax
  8179a9:	48 c1 e0 03          	shl    $0x3,%rax
  8179ad:	48 01 c8             	add    %rcx,%rax
  8179b0:	89 70 04             	mov    %esi,0x4(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  8179b3:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  8179ba:	00 00 00 
  8179bd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179c0:	48 63 d0             	movslq %eax,%rdx
  8179c3:	48 89 d0             	mov    %rdx,%rax
  8179c6:	48 c1 e0 03          	shl    $0x3,%rax
  8179ca:	48 01 d0             	add    %rdx,%rax
  8179cd:	48 c1 e0 02          	shl    $0x2,%rax
  8179d1:	48 01 d0             	add    %rdx,%rax
  8179d4:	48 c1 e0 03          	shl    $0x3,%rax
  8179d8:	48 01 c8             	add    %rcx,%rax
  8179db:	8b 48 04             	mov    0x4(%rax),%ecx
  8179de:	48 be c0 c8 b4 00 00 	movabs $0xb4c8c0,%rsi
  8179e5:	00 00 00 
  8179e8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179eb:	48 63 d0             	movslq %eax,%rdx
  8179ee:	48 89 d0             	mov    %rdx,%rax
  8179f1:	48 c1 e0 03          	shl    $0x3,%rax
  8179f5:	48 01 d0             	add    %rdx,%rax
  8179f8:	48 c1 e0 02          	shl    $0x2,%rax
  8179fc:	48 01 d0             	add    %rdx,%rax
  8179ff:	48 c1 e0 03          	shl    $0x3,%rax
  817a03:	48 01 f0             	add    %rsi,%rax
  817a06:	8b 40 08             	mov    0x8(%rax),%eax
  817a09:	39 c1                	cmp    %eax,%ecx
  817a0b:	75 2f                	jne    817a3c <sys_arch_mbox_fetch+0x234>
	mboxes[mbox].head = -1;
  817a0d:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  817a14:	00 00 00 
  817a17:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a1a:	48 63 d0             	movslq %eax,%rdx
  817a1d:	48 89 d0             	mov    %rdx,%rax
  817a20:	48 c1 e0 03          	shl    $0x3,%rax
  817a24:	48 01 d0             	add    %rdx,%rax
  817a27:	48 c1 e0 02          	shl    $0x2,%rax
  817a2b:	48 01 d0             	add    %rdx,%rax
  817a2e:	48 c1 e0 03          	shl    $0x3,%rax
  817a32:	48 01 c8             	add    %rcx,%rax
  817a35:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  817a3c:	48 b9 c0 c8 b4 00 00 	movabs $0xb4c8c0,%rcx
  817a43:	00 00 00 
  817a46:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a49:	48 63 d0             	movslq %eax,%rdx
  817a4c:	48 89 d0             	mov    %rdx,%rax
  817a4f:	48 c1 e0 03          	shl    $0x3,%rax
  817a53:	48 01 d0             	add    %rdx,%rax
  817a56:	48 c1 e0 02          	shl    $0x2,%rax
  817a5a:	48 01 d0             	add    %rdx,%rax
  817a5d:	48 c1 e0 03          	shl    $0x3,%rax
  817a61:	48 01 c8             	add    %rcx,%rax
  817a64:	48 05 10 01 00 00    	add    $0x110,%rax
  817a6a:	8b 40 04             	mov    0x4(%rax),%eax
  817a6d:	89 c7                	mov    %eax,%edi
  817a6f:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  817a76:	00 00 00 
  817a79:	ff d0                	callq  *%rax
    return waited;
  817a7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  817a7e:	c9                   	leaveq 
  817a7f:	c3                   	retq   

0000000000817a80 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  817a80:	55                   	push   %rbp
  817a81:	48 89 e5             	mov    %rsp,%rbp
  817a84:	48 83 ec 10          	sub    $0x10,%rsp
  817a88:	89 7d fc             	mov    %edi,-0x4(%rbp)
  817a8b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  817a8f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  817a93:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a96:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  817a9b:	48 89 ce             	mov    %rcx,%rsi
  817a9e:	89 c7                	mov    %eax,%edi
  817aa0:	48 b8 08 78 81 00 00 	movabs $0x817808,%rax
  817aa7:	00 00 00 
  817aaa:	ff d0                	callq  *%rax
}
  817aac:	c9                   	leaveq 
  817aad:	c3                   	retq   

0000000000817aae <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  817aae:	55                   	push   %rbp
  817aaf:	48 89 e5             	mov    %rsp,%rbp
  817ab2:	48 83 ec 20          	sub    $0x20,%rsp
  817ab6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  817aba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817abe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  817ac2:	48 b8 27 7f 81 00 00 	movabs $0x817f27,%rax
  817ac9:	00 00 00 
  817acc:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  817ace:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ad2:	48 8b 00             	mov    (%rax),%rax
  817ad5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817ad9:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  817add:	48 89 d7             	mov    %rdx,%rdi
  817ae0:	ff d0                	callq  *%rax
    lwip_core_unlock();
  817ae2:	48 b8 2d 7f 81 00 00 	movabs $0x817f2d,%rax
  817ae9:	00 00 00 
  817aec:	ff d0                	callq  *%rax
    free(lt);
  817aee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817af2:	48 89 c7             	mov    %rax,%rdi
  817af5:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  817afc:	00 00 00 
  817aff:	ff d0                	callq  *%rax
}
  817b01:	c9                   	leaveq 
  817b02:	c3                   	retq   

0000000000817b03 <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  817b03:	55                   	push   %rbp
  817b04:	48 89 e5             	mov    %rsp,%rbp
  817b07:	48 83 ec 30          	sub    $0x30,%rsp
  817b0b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  817b0f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  817b13:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  817b17:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  817b1a:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  817b1e:	bf 10 00 00 00       	mov    $0x10,%edi
  817b23:	48 b8 31 43 80 00 00 	movabs $0x804331,%rax
  817b2a:	00 00 00 
  817b2d:	ff d0                	callq  *%rax
  817b2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  817b33:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817b38:	75 2a                	jne    817b64 <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  817b3a:	48 ba b0 21 82 00 00 	movabs $0x8221b0,%rdx
  817b41:	00 00 00 
  817b44:	be fd 00 00 00       	mov    $0xfd,%esi
  817b49:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817b50:	00 00 00 
  817b53:	b8 00 00 00 00       	mov    $0x0,%eax
  817b58:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  817b5f:	00 00 00 
  817b62:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  817b64:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  817b6b:	7e 30                	jle    817b9d <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  817b6d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  817b70:	89 c1                	mov    %eax,%ecx
  817b72:	48 ba de 21 82 00 00 	movabs $0x8221de,%rdx
  817b79:	00 00 00 
  817b7c:	be 00 01 00 00       	mov    $0x100,%esi
  817b81:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817b88:	00 00 00 
  817b8b:	b8 00 00 00 00       	mov    $0x0,%eax
  817b90:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817b97:	00 00 00 
  817b9a:	41 ff d0             	callq  *%r8

    lt->func = thread;
  817b9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ba1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  817ba5:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  817ba8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817bac:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  817bb0:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  817bb4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817bb8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  817bbc:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  817bc0:	48 89 d1             	mov    %rdx,%rcx
  817bc3:	48 ba ae 7a 81 00 00 	movabs $0x817aae,%rdx
  817bca:	00 00 00 
  817bcd:	48 89 c7             	mov    %rax,%rdi
  817bd0:	48 b8 17 83 81 00 00 	movabs $0x818317,%rax
  817bd7:	00 00 00 
  817bda:	ff d0                	callq  *%rax
  817bdc:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  817bdf:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  817be3:	79 3f                	jns    817c24 <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  817be5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817be8:	89 c7                	mov    %eax,%edi
  817bea:	48 b8 a5 89 81 00 00 	movabs $0x8189a5,%rax
  817bf1:	00 00 00 
  817bf4:	ff d0                	callq  *%rax
  817bf6:	48 89 c1             	mov    %rax,%rcx
  817bf9:	48 ba f0 21 82 00 00 	movabs $0x8221f0,%rdx
  817c00:	00 00 00 
  817c03:	be 09 01 00 00       	mov    $0x109,%esi
  817c08:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817c0f:	00 00 00 
  817c12:	b8 00 00 00 00       	mov    $0x0,%eax
  817c17:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817c1e:	00 00 00 
  817c21:	41 ff d0             	callq  *%r8

    return tid;
  817c24:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  817c27:	c9                   	leaveq 
  817c28:	c3                   	retq   

0000000000817c29 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  817c29:	55                   	push   %rbp
  817c2a:	48 89 e5             	mov    %rsp,%rbp
  817c2d:	48 83 ec 20          	sub    $0x20,%rsp
  817c31:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  817c34:	48 b8 27 7f 81 00 00 	movabs $0x817f27,%rax
  817c3b:	00 00 00 
  817c3e:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  817c40:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817c43:	89 ca                	mov    %ecx,%edx
  817c45:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  817c4a:	48 0f af c2          	imul   %rdx,%rax
  817c4e:	48 c1 e8 20          	shr    $0x20,%rax
  817c52:	c1 e8 08             	shr    $0x8,%eax
  817c55:	89 c2                	mov    %eax,%edx
  817c57:	c1 e2 08             	shl    $0x8,%edx
  817c5a:	01 c2                	add    %eax,%edx
  817c5c:	89 c8                	mov    %ecx,%eax
  817c5e:	29 d0                	sub    %edx,%eax
  817c60:	48 ba 00 5d b5 00 00 	movabs $0xb55d00,%rdx
  817c67:	00 00 00 
  817c6a:	89 c0                	mov    %eax,%eax
  817c6c:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  817c70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  817c74:	eb 60                	jmp    817cd6 <timeout_cleanup+0xad>
	if (t->tid == tid) {
  817c76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817c7a:	8b 00                	mov    (%rax),%eax
  817c7c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  817c7f:	75 49                	jne    817cca <timeout_cleanup+0xa1>
	    LIST_REMOVE(t, link);
  817c81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817c85:	48 8b 40 10          	mov    0x10(%rax),%rax
  817c89:	48 85 c0             	test   %rax,%rax
  817c8c:	74 14                	je     817ca2 <timeout_cleanup+0x79>
  817c8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817c92:	48 8b 40 10          	mov    0x10(%rax),%rax
  817c96:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817c9a:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817c9e:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817ca2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ca6:	48 8b 40 18          	mov    0x18(%rax),%rax
  817caa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817cae:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817cb2:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  817cb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817cb9:	48 89 c7             	mov    %rax,%rdi
  817cbc:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  817cc3:	00 00 00 
  817cc6:	ff d0                	callq  *%rax
	    goto done;
  817cc8:	eb 13                	jmp    817cdd <timeout_cleanup+0xb4>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  817cca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817cce:	48 8b 40 10          	mov    0x10(%rax),%rax
  817cd2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  817cd6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817cdb:	75 99                	jne    817c76 <timeout_cleanup+0x4d>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  817cdd:	48 b8 2d 7f 81 00 00 	movabs $0x817f2d,%rax
  817ce4:	00 00 00 
  817ce7:	ff d0                	callq  *%rax
}
  817ce9:	c9                   	leaveq 
  817cea:	c3                   	retq   

0000000000817ceb <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  817ceb:	55                   	push   %rbp
  817cec:	48 89 e5             	mov    %rsp,%rbp
  817cef:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  817cf3:	48 b8 3a 80 81 00 00 	movabs $0x81803a,%rax
  817cfa:	00 00 00 
  817cfd:	ff d0                	callq  *%rax
  817cff:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  817d02:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817d05:	89 ca                	mov    %ecx,%edx
  817d07:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  817d0c:	48 0f af c2          	imul   %rdx,%rax
  817d10:	48 c1 e8 20          	shr    $0x20,%rax
  817d14:	c1 e8 08             	shr    $0x8,%eax
  817d17:	89 c2                	mov    %eax,%edx
  817d19:	c1 e2 08             	shl    $0x8,%edx
  817d1c:	01 c2                	add    %eax,%edx
  817d1e:	89 c8                	mov    %ecx,%eax
  817d20:	29 d0                	sub    %edx,%eax
  817d22:	48 ba 00 5d b5 00 00 	movabs $0xb55d00,%rdx
  817d29:	00 00 00 
  817d2c:	89 c0                	mov    %eax,%eax
  817d2e:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  817d32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  817d36:	eb 1c                	jmp    817d54 <sys_arch_timeouts+0x69>
	if (t->tid == tid)
  817d38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d3c:	8b 00                	mov    (%rax),%eax
  817d3e:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  817d41:	75 05                	jne    817d48 <sys_arch_timeouts+0x5d>
	    goto out;
  817d43:	e9 d5 01 00 00       	jmpq   817f1d <sys_arch_timeouts+0x232>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  817d48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d4c:	48 8b 40 10          	mov    0x10(%rax),%rax
  817d50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  817d54:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817d59:	75 dd                	jne    817d38 <sys_arch_timeouts+0x4d>

    t = malloc(sizeof(*t));
  817d5b:	bf 20 00 00 00       	mov    $0x20,%edi
  817d60:	48 b8 31 43 80 00 00 	movabs $0x804331,%rax
  817d67:	00 00 00 
  817d6a:	ff d0                	callq  *%rax
  817d6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  817d70:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817d75:	75 2a                	jne    817da1 <sys_arch_timeouts+0xb6>
	panic("sys_arch_timeouts: cannot malloc");
  817d77:	48 ba 20 22 82 00 00 	movabs $0x822220,%rdx
  817d7e:	00 00 00 
  817d81:	be 2c 01 00 00       	mov    $0x12c,%esi
  817d86:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817d8d:	00 00 00 
  817d90:	b8 00 00 00 00       	mov    $0x0,%eax
  817d95:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  817d9c:	00 00 00 
  817d9f:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  817da1:	48 bf 29 7c 81 00 00 	movabs $0x817c29,%rdi
  817da8:	00 00 00 
  817dab:	48 b8 d0 81 81 00 00 	movabs $0x8181d0,%rax
  817db2:	00 00 00 
  817db5:	ff d0                	callq  *%rax
  817db7:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  817dba:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  817dbe:	79 3f                	jns    817dff <sys_arch_timeouts+0x114>
	panic("thread_onhalt failed: %s", e2s(r));
  817dc0:	8b 45 f0             	mov    -0x10(%rbp),%eax
  817dc3:	89 c7                	mov    %eax,%edi
  817dc5:	48 b8 a5 89 81 00 00 	movabs $0x8189a5,%rax
  817dcc:	00 00 00 
  817dcf:	ff d0                	callq  *%rax
  817dd1:	48 89 c1             	mov    %rax,%rcx
  817dd4:	48 ba 41 22 82 00 00 	movabs $0x822241,%rdx
  817ddb:	00 00 00 
  817dde:	be 30 01 00 00       	mov    $0x130,%esi
  817de3:	48 bf 4e 20 82 00 00 	movabs $0x82204e,%rdi
  817dea:	00 00 00 
  817ded:	b8 00 00 00 00       	mov    $0x0,%eax
  817df2:	49 b8 e0 0e 80 00 00 	movabs $0x800ee0,%r8
  817df9:	00 00 00 
  817dfc:	41 ff d0             	callq  *%r8

    t->tid = tid;
  817dff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e03:	8b 55 f4             	mov    -0xc(%rbp),%edx
  817e06:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  817e08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e0c:	48 83 c0 08          	add    $0x8,%rax
  817e10:	ba 08 00 00 00       	mov    $0x8,%edx
  817e15:	be 00 00 00 00       	mov    $0x0,%esi
  817e1a:	48 89 c7             	mov    %rax,%rdi
  817e1d:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  817e24:	00 00 00 
  817e27:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  817e29:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817e2c:	89 ca                	mov    %ecx,%edx
  817e2e:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  817e33:	48 0f af c2          	imul   %rdx,%rax
  817e37:	48 c1 e8 20          	shr    $0x20,%rax
  817e3b:	c1 e8 08             	shr    $0x8,%eax
  817e3e:	89 c2                	mov    %eax,%edx
  817e40:	c1 e2 08             	shl    $0x8,%edx
  817e43:	01 c2                	add    %eax,%edx
  817e45:	89 c8                	mov    %ecx,%eax
  817e47:	29 d0                	sub    %edx,%eax
  817e49:	48 ba 00 5d b5 00 00 	movabs $0xb55d00,%rdx
  817e50:	00 00 00 
  817e53:	89 c0                	mov    %eax,%eax
  817e55:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  817e59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e5d:	48 89 50 10          	mov    %rdx,0x10(%rax)
  817e61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e65:	48 8b 40 10          	mov    0x10(%rax),%rax
  817e69:	48 85 c0             	test   %rax,%rax
  817e6c:	74 3c                	je     817eaa <sys_arch_timeouts+0x1bf>
  817e6e:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817e71:	89 ca                	mov    %ecx,%edx
  817e73:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  817e78:	48 0f af c2          	imul   %rdx,%rax
  817e7c:	48 c1 e8 20          	shr    $0x20,%rax
  817e80:	c1 e8 08             	shr    $0x8,%eax
  817e83:	89 c2                	mov    %eax,%edx
  817e85:	c1 e2 08             	shl    $0x8,%edx
  817e88:	01 c2                	add    %eax,%edx
  817e8a:	89 c8                	mov    %ecx,%eax
  817e8c:	29 d0                	sub    %edx,%eax
  817e8e:	48 ba 00 5d b5 00 00 	movabs $0xb55d00,%rdx
  817e95:	00 00 00 
  817e98:	89 c0                	mov    %eax,%eax
  817e9a:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  817e9e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817ea2:	48 83 c2 10          	add    $0x10,%rdx
  817ea6:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817eaa:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817ead:	89 ca                	mov    %ecx,%edx
  817eaf:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  817eb4:	48 0f af c2          	imul   %rdx,%rax
  817eb8:	48 c1 e8 20          	shr    $0x20,%rax
  817ebc:	c1 e8 08             	shr    $0x8,%eax
  817ebf:	89 c2                	mov    %eax,%edx
  817ec1:	c1 e2 08             	shl    $0x8,%edx
  817ec4:	01 c2                	add    %eax,%edx
  817ec6:	89 c8                	mov    %ecx,%eax
  817ec8:	29 d0                	sub    %edx,%eax
  817eca:	48 ba 00 5d b5 00 00 	movabs $0xb55d00,%rdx
  817ed1:	00 00 00 
  817ed4:	89 c1                	mov    %eax,%ecx
  817ed6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817eda:	48 89 04 ca          	mov    %rax,(%rdx,%rcx,8)
  817ede:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817ee1:	89 ca                	mov    %ecx,%edx
  817ee3:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  817ee8:	48 0f af c2          	imul   %rdx,%rax
  817eec:	48 c1 e8 20          	shr    $0x20,%rax
  817ef0:	c1 e8 08             	shr    $0x8,%eax
  817ef3:	89 c2                	mov    %eax,%edx
  817ef5:	c1 e2 08             	shl    $0x8,%edx
  817ef8:	01 c2                	add    %eax,%edx
  817efa:	89 c8                	mov    %ecx,%eax
  817efc:	29 d0                	sub    %edx,%eax
  817efe:	89 c0                	mov    %eax,%eax
  817f00:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  817f07:	00 
  817f08:	48 b8 00 5d b5 00 00 	movabs $0xb55d00,%rax
  817f0f:	00 00 00 
  817f12:	48 01 c2             	add    %rax,%rdx
  817f15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f19:	48 89 50 18          	mov    %rdx,0x18(%rax)

out:
    return &t->tmo;
  817f1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f21:	48 83 c0 08          	add    $0x8,%rax
}
  817f25:	c9                   	leaveq 
  817f26:	c3                   	retq   

0000000000817f27 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  817f27:	55                   	push   %rbp
  817f28:	48 89 e5             	mov    %rsp,%rbp
}
  817f2b:	5d                   	pop    %rbp
  817f2c:	c3                   	retq   

0000000000817f2d <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  817f2d:	55                   	push   %rbp
  817f2e:	48 89 e5             	mov    %rsp,%rbp
}
  817f31:	5d                   	pop    %rbp
  817f32:	c3                   	retq   

0000000000817f33 <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  817f33:	55                   	push   %rbp
  817f34:	48 89 e5             	mov    %rsp,%rbp
  817f37:	48 83 ec 08          	sub    $0x8,%rsp
  817f3b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  817f3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f43:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  817f4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f4e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  817f55:	00 
}
  817f56:	c9                   	leaveq 
  817f57:	c3                   	retq   

0000000000817f58 <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  817f58:	55                   	push   %rbp
  817f59:	48 89 e5             	mov    %rsp,%rbp
  817f5c:	48 83 ec 10          	sub    $0x10,%rsp
  817f60:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  817f64:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  817f68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  817f6c:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  817f73:	00 00 00 00 
    if (!tq->tq_first) {
  817f77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f7b:	48 8b 00             	mov    (%rax),%rax
  817f7e:	48 85 c0             	test   %rax,%rax
  817f81:	75 19                	jne    817f9c <threadq_push+0x44>
	tq->tq_first = tc;
  817f83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f87:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817f8b:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  817f8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f92:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817f96:	48 89 50 08          	mov    %rdx,0x8(%rax)
  817f9a:	eb 1f                	jmp    817fbb <threadq_push+0x63>
    } else {
	tq->tq_last->tc_queue_link = tc;
  817f9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fa0:	48 8b 40 08          	mov    0x8(%rax),%rax
  817fa4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817fa8:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  817faf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fb3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817fb7:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  817fbb:	c9                   	leaveq 
  817fbc:	c3                   	retq   

0000000000817fbd <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  817fbd:	55                   	push   %rbp
  817fbe:	48 89 e5             	mov    %rsp,%rbp
  817fc1:	48 83 ec 18          	sub    $0x18,%rsp
  817fc5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  817fc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817fcd:	48 8b 00             	mov    (%rax),%rax
  817fd0:	48 85 c0             	test   %rax,%rax
  817fd3:	75 07                	jne    817fdc <threadq_pop+0x1f>
	return 0;
  817fd5:	b8 00 00 00 00       	mov    $0x0,%eax
  817fda:	eb 30                	jmp    81800c <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  817fdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817fe0:	48 8b 00             	mov    (%rax),%rax
  817fe3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  817fe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817feb:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  817ff2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817ff6:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  817ff9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ffd:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818004:	00 00 00 00 
    return tc;
  818008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81800c:	c9                   	leaveq 
  81800d:	c3                   	retq   

000000000081800e <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  81800e:	55                   	push   %rbp
  81800f:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  818012:	48 bf 20 65 b5 00 00 	movabs $0xb56520,%rdi
  818019:	00 00 00 
  81801c:	48 b8 33 7f 81 00 00 	movabs $0x817f33,%rax
  818023:	00 00 00 
  818026:	ff d0                	callq  *%rax
    max_tid = 0;
  818028:	48 b8 10 65 b5 00 00 	movabs $0xb56510,%rax
  81802f:	00 00 00 
  818032:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  818038:	5d                   	pop    %rbp
  818039:	c3                   	retq   

000000000081803a <thread_id>:

uint32_t
thread_id(void) {
  81803a:	55                   	push   %rbp
  81803b:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  81803e:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818045:	00 00 00 
  818048:	48 8b 00             	mov    (%rax),%rax
  81804b:	8b 00                	mov    (%rax),%eax
}
  81804d:	5d                   	pop    %rbp
  81804e:	c3                   	retq   

000000000081804f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  81804f:	55                   	push   %rbp
  818050:	48 89 e5             	mov    %rsp,%rbp
  818053:	48 83 ec 18          	sub    $0x18,%rsp
  818057:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  81805b:	48 b8 20 65 b5 00 00 	movabs $0xb56520,%rax
  818062:	00 00 00 
  818065:	48 8b 00             	mov    (%rax),%rax
  818068:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  81806c:	eb 2b                	jmp    818099 <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  81806e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818072:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  818079:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81807d:	75 0b                	jne    81808a <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  81807f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818083:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  81808a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81808e:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818095:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  818099:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81809e:	75 ce                	jne    81806e <thread_wakeup+0x1f>
    }
}
  8180a0:	c9                   	leaveq 
  8180a1:	c3                   	retq   

00000000008180a2 <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  8180a2:	55                   	push   %rbp
  8180a3:	48 89 e5             	mov    %rsp,%rbp
  8180a6:	48 83 ec 20          	sub    $0x20,%rsp
  8180aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8180ae:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8180b1:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  8180b4:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  8180bb:	00 00 00 
  8180be:	ff d0                	callq  *%rax
  8180c0:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  8180c3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8180c6:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  8180c9:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  8180d0:	00 00 00 
  8180d3:	48 8b 00             	mov    (%rax),%rax
  8180d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8180da:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  8180e1:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  8180e8:	00 00 00 
  8180eb:	48 8b 00             	mov    (%rax),%rax
  8180ee:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  8180f5:	eb 53                	jmp    81814a <thread_wait+0xa8>
	if (p < s)
  8180f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8180fa:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  8180fd:	73 02                	jae    818101 <thread_wait+0x5f>
	    break;
  8180ff:	eb 51                	jmp    818152 <thread_wait+0xb0>
	if (addr && *addr != val)
  818101:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818106:	74 0d                	je     818115 <thread_wait+0x73>
  818108:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81810c:	8b 00                	mov    (%rax),%eax
  81810e:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  818111:	74 02                	je     818115 <thread_wait+0x73>
	    break;
  818113:	eb 3d                	jmp    818152 <thread_wait+0xb0>
	if (cur_tc->tc_wakeup)
  818115:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  81811c:	00 00 00 
  81811f:	48 8b 00             	mov    (%rax),%rax
  818122:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818129:	84 c0                	test   %al,%al
  81812b:	74 02                	je     81812f <thread_wait+0x8d>
	    break;
  81812d:	eb 23                	jmp    818152 <thread_wait+0xb0>

	thread_yield();
  81812f:	48 b8 9c 85 81 00 00 	movabs $0x81859c,%rax
  818136:	00 00 00 
  818139:	ff d0                	callq  *%rax
	p = sys_time_msec();
  81813b:	48 b8 60 28 80 00 00 	movabs $0x802860,%rax
  818142:	00 00 00 
  818145:	ff d0                	callq  *%rax
  818147:	89 45 fc             	mov    %eax,-0x4(%rbp)
    while (p < msec) {
  81814a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81814d:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  818150:	72 a5                	jb     8180f7 <thread_wait+0x55>
    }

    cur_tc->tc_wait_addr = 0;
  818152:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818159:	00 00 00 
  81815c:	48 8b 00             	mov    (%rax),%rax
  81815f:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  818166:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  81816a:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818171:	00 00 00 
  818174:	48 8b 00             	mov    (%rax),%rax
  818177:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  81817e:	c9                   	leaveq 
  81817f:	c3                   	retq   

0000000000818180 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818180:	55                   	push   %rbp
  818181:	48 89 e5             	mov    %rsp,%rbp
  818184:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818188:	48 b8 20 65 b5 00 00 	movabs $0xb56520,%rax
  81818f:	00 00 00 
  818192:	48 8b 00             	mov    (%rax),%rax
  818195:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818199:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  8181a0:	eb 22                	jmp    8181c4 <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  8181a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8181a6:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  8181ad:	84 c0                	test   %al,%al
  8181af:	74 04                	je     8181b5 <thread_wakeups_pending+0x35>
	    ++n;
  8181b1:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  8181b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8181b9:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8181c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  8181c4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8181c9:	75 d7                	jne    8181a2 <thread_wakeups_pending+0x22>
    }
    return n;
  8181cb:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8181ce:	c9                   	leaveq 
  8181cf:	c3                   	retq   

00000000008181d0 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  8181d0:	55                   	push   %rbp
  8181d1:	48 89 e5             	mov    %rsp,%rbp
  8181d4:	48 83 ec 08          	sub    $0x8,%rsp
  8181d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  8181dc:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  8181e3:	00 00 00 
  8181e6:	48 8b 00             	mov    (%rax),%rax
  8181e9:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  8181ef:	83 f8 03             	cmp    $0x3,%eax
  8181f2:	7e 07                	jle    8181fb <thread_onhalt+0x2b>
	return -E_NO_MEM;
  8181f4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8181f9:	eb 3d                	jmp    818238 <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  8181fb:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818202:	00 00 00 
  818205:	48 8b 08             	mov    (%rax),%rcx
  818208:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  81820f:	00 00 00 
  818212:	48 8b 00             	mov    (%rax),%rax
  818215:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  81821b:	8d 72 01             	lea    0x1(%rdx),%esi
  81821e:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%rax)
  818224:	48 63 c2             	movslq %edx,%rax
  818227:	48 8d 50 18          	lea    0x18(%rax),%rdx
  81822b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81822f:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    return 0;
  818233:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818238:	c9                   	leaveq 
  818239:	c3                   	retq   

000000000081823a <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  81823a:	55                   	push   %rbp
  81823b:	48 89 e5             	mov    %rsp,%rbp
  81823e:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  818242:	48 b8 10 65 b5 00 00 	movabs $0xb56510,%rax
  818249:	00 00 00 
  81824c:	8b 00                	mov    (%rax),%eax
  81824e:	8d 48 01             	lea    0x1(%rax),%ecx
  818251:	48 ba 10 65 b5 00 00 	movabs $0xb56510,%rdx
  818258:	00 00 00 
  81825b:	89 0a                	mov    %ecx,(%rdx)
  81825d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (max_tid == (uint32_t)~0)
  818260:	48 b8 10 65 b5 00 00 	movabs $0xb56510,%rax
  818267:	00 00 00 
  81826a:	8b 00                	mov    (%rax),%eax
  81826c:	83 f8 ff             	cmp    $0xffffffff,%eax
  81826f:	75 2a                	jne    81829b <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818271:	48 ba 5a 22 82 00 00 	movabs $0x82225a,%rdx
  818278:	00 00 00 
  81827b:	be 54 00 00 00       	mov    $0x54,%esi
  818280:	48 bf 78 22 82 00 00 	movabs $0x822278,%rdi
  818287:	00 00 00 
  81828a:	b8 00 00 00 00       	mov    $0x0,%eax
  81828f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  818296:	00 00 00 
  818299:	ff d1                	callq  *%rcx
    return tid;
  81829b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  81829e:	c9                   	leaveq 
  81829f:	c3                   	retq   

00000000008182a0 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  8182a0:	55                   	push   %rbp
  8182a1:	48 89 e5             	mov    %rsp,%rbp
  8182a4:	48 83 ec 10          	sub    $0x10,%rsp
  8182a8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8182ac:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  8182b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8182b4:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8182b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8182bc:	ba 1f 00 00 00       	mov    $0x1f,%edx
  8182c1:	48 89 c6             	mov    %rax,%rsi
  8182c4:	48 89 cf             	mov    %rcx,%rdi
  8182c7:	48 b8 45 1d 80 00 00 	movabs $0x801d45,%rax
  8182ce:	00 00 00 
  8182d1:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  8182d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8182d7:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  8182db:	c9                   	leaveq 
  8182dc:	c3                   	retq   

00000000008182dd <thread_entry>:

static void
thread_entry(void) {
  8182dd:	55                   	push   %rbp
  8182de:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  8182e1:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  8182e8:	00 00 00 
  8182eb:	48 8b 00             	mov    (%rax),%rax
  8182ee:	48 8b 40 30          	mov    0x30(%rax),%rax
  8182f2:	48 ba 18 65 b5 00 00 	movabs $0xb56518,%rdx
  8182f9:	00 00 00 
  8182fc:	48 8b 12             	mov    (%rdx),%rdx
  8182ff:	8b 52 38             	mov    0x38(%rdx),%edx
  818302:	89 d2                	mov    %edx,%edx
  818304:	48 89 d7             	mov    %rdx,%rdi
  818307:	ff d0                	callq  *%rax
    thread_halt();
  818309:	48 b8 22 85 81 00 00 	movabs $0x818522,%rax
  818310:	00 00 00 
  818313:	ff d0                	callq  *%rax
}
  818315:	5d                   	pop    %rbp
  818316:	c3                   	retq   

0000000000818317 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  818317:	55                   	push   %rbp
  818318:	48 89 e5             	mov    %rsp,%rbp
  81831b:	48 83 ec 30          	sub    $0x30,%rsp
  81831f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818323:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818327:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81832b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  81832f:	bf f0 00 00 00       	mov    $0xf0,%edi
  818334:	48 b8 31 43 80 00 00 	movabs $0x804331,%rax
  81833b:	00 00 00 
  81833e:	ff d0                	callq  *%rax
  818340:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  818344:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818349:	75 0a                	jne    818355 <thread_create+0x3e>
	return -E_NO_MEM;
  81834b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818350:	e9 52 01 00 00       	jmpq   8184a7 <thread_create+0x190>

    memset(tc, 0, sizeof(struct thread_context));
  818355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818359:	ba f0 00 00 00       	mov    $0xf0,%edx
  81835e:	be 00 00 00 00       	mov    $0x0,%esi
  818363:	48 89 c7             	mov    %rax,%rdi
  818366:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  81836d:	00 00 00 
  818370:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  818372:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818376:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81837a:	48 89 d6             	mov    %rdx,%rsi
  81837d:	48 89 c7             	mov    %rax,%rdi
  818380:	48 b8 a0 82 81 00 00 	movabs $0x8182a0,%rax
  818387:	00 00 00 
  81838a:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  81838c:	48 b8 3a 82 81 00 00 	movabs $0x81823a,%rax
  818393:	00 00 00 
  818396:	ff d0                	callq  *%rax
  818398:	89 c2                	mov    %eax,%edx
  81839a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81839e:	89 10                	mov    %edx,(%rax)

    tc->tc_stack_bottom = malloc(stack_size);
  8183a0:	bf 00 10 00 00       	mov    $0x1000,%edi
  8183a5:	48 b8 31 43 80 00 00 	movabs $0x804331,%rax
  8183ac:	00 00 00 
  8183af:	ff d0                	callq  *%rax
  8183b1:	48 89 c2             	mov    %rax,%rdx
  8183b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183b8:	48 89 50 08          	mov    %rdx,0x8(%rax)
    if (!tc->tc_stack_bottom) {
  8183bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8183c4:	48 85 c0             	test   %rax,%rax
  8183c7:	75 1d                	jne    8183e6 <thread_create+0xcf>
	free(tc);
  8183c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183cd:	48 89 c7             	mov    %rax,%rdi
  8183d0:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  8183d7:	00 00 00 
  8183da:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  8183dc:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8183e1:	e9 c1 00 00 00       	jmpq   8184a7 <thread_create+0x190>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  8183e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183ea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8183ee:	48 05 00 10 00 00    	add    $0x1000,%rax
  8183f4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  8183f8:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  8183fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818401:	ba 08 00 00 00       	mov    $0x8,%edx
  818406:	be 00 00 00 00       	mov    $0x0,%esi
  81840b:	48 89 c7             	mov    %rax,%rdi
  81840e:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  818415:	00 00 00 
  818418:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  81841a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81841e:	48 83 c0 40          	add    $0x40,%rax
  818422:	ba 70 00 00 00       	mov    $0x70,%edx
  818427:	be 00 00 00 00       	mov    $0x0,%esi
  81842c:	48 89 c7             	mov    %rax,%rdi
  81842f:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  818436:	00 00 00 
  818439:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  81843b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81843f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818443:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  818447:	48 ba dd 82 81 00 00 	movabs $0x8182dd,%rdx
  81844e:	00 00 00 
  818451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818455:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  818459:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81845d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  818461:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  818465:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818469:	89 c2                	mov    %eax,%edx
  81846b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81846f:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  818472:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818476:	48 89 c6             	mov    %rax,%rsi
  818479:	48 bf 20 65 b5 00 00 	movabs $0xb56520,%rdi
  818480:	00 00 00 
  818483:	48 b8 58 7f 81 00 00 	movabs $0x817f58,%rax
  81848a:	00 00 00 
  81848d:	ff d0                	callq  *%rax

    if (tid)
  81848f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818494:	74 0c                	je     8184a2 <thread_create+0x18b>
	*tid = tc->tc_tid;
  818496:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81849a:	8b 10                	mov    (%rax),%edx
  81849c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8184a0:	89 10                	mov    %edx,(%rax)
    return 0;
  8184a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8184a7:	c9                   	leaveq 
  8184a8:	c3                   	retq   

00000000008184a9 <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  8184a9:	55                   	push   %rbp
  8184aa:	48 89 e5             	mov    %rsp,%rbp
  8184ad:	48 83 ec 20          	sub    $0x20,%rsp
  8184b1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  8184b5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8184ba:	75 02                	jne    8184be <thread_clean+0x15>
  8184bc:	eb 62                	jmp    818520 <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  8184be:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8184c5:	eb 20                	jmp    8184e7 <thread_clean+0x3e>
	tc->tc_onhalt[i](tc->tc_tid);
  8184c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8184cb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8184ce:	48 63 d2             	movslq %edx,%rdx
  8184d1:	48 83 c2 18          	add    $0x18,%rdx
  8184d5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8184d9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8184dd:	8b 12                	mov    (%rdx),%edx
  8184df:	89 d7                	mov    %edx,%edi
  8184e1:	ff d0                	callq  *%rax
    for (i = 0; i < tc->tc_nonhalt; i++)
  8184e3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8184e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8184eb:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  8184f1:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8184f4:	7f d1                	jg     8184c7 <thread_clean+0x1e>
    free(tc->tc_stack_bottom);
  8184f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8184fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8184fe:	48 89 c7             	mov    %rax,%rdi
  818501:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  818508:	00 00 00 
  81850b:	ff d0                	callq  *%rax
    free(tc);
  81850d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818511:	48 89 c7             	mov    %rax,%rdi
  818514:	48 b8 a3 46 80 00 00 	movabs $0x8046a3,%rax
  81851b:	00 00 00 
  81851e:	ff d0                	callq  *%rax
}
  818520:	c9                   	leaveq 
  818521:	c3                   	retq   

0000000000818522 <thread_halt>:

void
thread_halt() {
  818522:	55                   	push   %rbp
  818523:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  818526:	48 bf 30 65 b5 00 00 	movabs $0xb56530,%rdi
  81852d:	00 00 00 
  818530:	48 b8 bd 7f 81 00 00 	movabs $0x817fbd,%rax
  818537:	00 00 00 
  81853a:	ff d0                	callq  *%rax
  81853c:	48 89 c7             	mov    %rax,%rdi
  81853f:	48 b8 a9 84 81 00 00 	movabs $0x8184a9,%rax
  818546:	00 00 00 
  818549:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  81854b:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818552:	00 00 00 
  818555:	48 8b 00             	mov    (%rax),%rax
  818558:	48 89 c6             	mov    %rax,%rsi
  81855b:	48 bf 30 65 b5 00 00 	movabs $0xb56530,%rdi
  818562:	00 00 00 
  818565:	48 b8 58 7f 81 00 00 	movabs $0x817f58,%rax
  81856c:	00 00 00 
  81856f:	ff d0                	callq  *%rax
    cur_tc = NULL;
  818571:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818578:	00 00 00 
  81857b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  818582:	48 b8 9c 85 81 00 00 	movabs $0x81859c,%rax
  818589:	00 00 00 
  81858c:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  81858e:	48 b8 bd 0e 80 00 00 	movabs $0x800ebd,%rax
  818595:	00 00 00 
  818598:	ff d0                	callq  *%rax
}
  81859a:	5d                   	pop    %rbp
  81859b:	c3                   	retq   

000000000081859c <thread_yield>:

void
thread_yield(void) {
  81859c:	55                   	push   %rbp
  81859d:	48 89 e5             	mov    %rsp,%rbp
  8185a0:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  8185a4:	48 bf 20 65 b5 00 00 	movabs $0xb56520,%rdi
  8185ab:	00 00 00 
  8185ae:	48 b8 bd 7f 81 00 00 	movabs $0x817fbd,%rax
  8185b5:	00 00 00 
  8185b8:	ff d0                	callq  *%rax
  8185ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  8185be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8185c3:	75 05                	jne    8185ca <thread_yield+0x2e>
	return;
  8185c5:	e9 94 00 00 00       	jmpq   81865e <thread_yield+0xc2>

    if (cur_tc) {
  8185ca:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  8185d1:	00 00 00 
  8185d4:	48 8b 00             	mov    (%rax),%rax
  8185d7:	48 85 c0             	test   %rax,%rax
  8185da:	74 4c                	je     818628 <thread_yield+0x8c>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  8185dc:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  8185e3:	00 00 00 
  8185e6:	48 8b 00             	mov    (%rax),%rax
  8185e9:	48 83 c0 40          	add    $0x40,%rax
  8185ed:	48 89 c7             	mov    %rax,%rdi
  8185f0:	48 b8 c0 88 81 00 00 	movabs $0x8188c0,%rax
  8185f7:	00 00 00 
  8185fa:	ff d0                	callq  *%rax
  8185fc:	85 c0                	test   %eax,%eax
  8185fe:	74 02                	je     818602 <thread_yield+0x66>
	    return;
  818600:	eb 5c                	jmp    81865e <thread_yield+0xc2>
	threadq_push(&thread_queue, cur_tc);
  818602:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818609:	00 00 00 
  81860c:	48 8b 00             	mov    (%rax),%rax
  81860f:	48 89 c6             	mov    %rax,%rsi
  818612:	48 bf 20 65 b5 00 00 	movabs $0xb56520,%rdi
  818619:	00 00 00 
  81861c:	48 b8 58 7f 81 00 00 	movabs $0x817f58,%rax
  818623:	00 00 00 
  818626:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  818628:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  81862f:	00 00 00 
  818632:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818636:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  818639:	48 b8 18 65 b5 00 00 	movabs $0xb56518,%rax
  818640:	00 00 00 
  818643:	48 8b 00             	mov    (%rax),%rax
  818646:	48 83 c0 40          	add    $0x40,%rax
  81864a:	be 01 00 00 00       	mov    $0x1,%esi
  81864f:	48 89 c7             	mov    %rax,%rdi
  818652:	48 b8 10 89 81 00 00 	movabs $0x818910,%rax
  818659:	00 00 00 
  81865c:	ff d0                	callq  *%rax
}
  81865e:	c9                   	leaveq 
  81865f:	c3                   	retq   

0000000000818660 <print_jb>:

static void
print_jb(struct thread_context *tc) {
  818660:	55                   	push   %rbp
  818661:	48 89 e5             	mov    %rsp,%rbp
  818664:	48 83 ec 10          	sub    $0x10,%rsp
  818668:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  81866c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818670:	48 83 c0 10          	add    $0x10,%rax
  818674:	48 89 c6             	mov    %rax,%rsi
  818677:	48 bf 93 22 82 00 00 	movabs $0x822293,%rdi
  81867e:	00 00 00 
  818681:	b8 00 00 00 00       	mov    $0x0,%eax
  818686:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  81868d:	00 00 00 
  818690:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  818692:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818696:	48 8b 40 40          	mov    0x40(%rax),%rax
  81869a:	48 89 c6             	mov    %rax,%rsi
  81869d:	48 bf af 22 82 00 00 	movabs $0x8222af,%rdi
  8186a4:	00 00 00 
  8186a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8186ac:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8186b3:	00 00 00 
  8186b6:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  8186b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186bc:	48 8b 40 48          	mov    0x48(%rax),%rax
  8186c0:	48 89 c6             	mov    %rax,%rsi
  8186c3:	48 bf b9 22 82 00 00 	movabs $0x8222b9,%rdi
  8186ca:	00 00 00 
  8186cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8186d2:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8186d9:	00 00 00 
  8186dc:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  8186de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186e2:	48 8b 40 50          	mov    0x50(%rax),%rax
  8186e6:	48 89 c6             	mov    %rax,%rsi
  8186e9:	48 bf c3 22 82 00 00 	movabs $0x8222c3,%rdi
  8186f0:	00 00 00 
  8186f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8186f8:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8186ff:	00 00 00 
  818702:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  818704:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818708:	48 8b 40 58          	mov    0x58(%rax),%rax
  81870c:	48 89 c6             	mov    %rax,%rsi
  81870f:	48 bf cd 22 82 00 00 	movabs $0x8222cd,%rdi
  818716:	00 00 00 
  818719:	b8 00 00 00 00       	mov    $0x0,%eax
  81871e:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  818725:	00 00 00 
  818728:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  81872a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81872e:	48 8b 40 60          	mov    0x60(%rax),%rax
  818732:	48 89 c6             	mov    %rax,%rsi
  818735:	48 bf d7 22 82 00 00 	movabs $0x8222d7,%rdi
  81873c:	00 00 00 
  81873f:	b8 00 00 00 00       	mov    $0x0,%eax
  818744:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  81874b:	00 00 00 
  81874e:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  818750:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818754:	48 8b 40 68          	mov    0x68(%rax),%rax
  818758:	48 89 c6             	mov    %rax,%rsi
  81875b:	48 bf e1 22 82 00 00 	movabs $0x8222e1,%rdi
  818762:	00 00 00 
  818765:	b8 00 00 00 00       	mov    $0x0,%eax
  81876a:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  818771:	00 00 00 
  818774:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  818776:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81877a:	48 8b 40 70          	mov    0x70(%rax),%rax
  81877e:	48 89 c6             	mov    %rax,%rsi
  818781:	48 bf eb 22 82 00 00 	movabs $0x8222eb,%rdi
  818788:	00 00 00 
  81878b:	b8 00 00 00 00       	mov    $0x0,%eax
  818790:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  818797:	00 00 00 
  81879a:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  81879c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187a0:	48 8b 40 78          	mov    0x78(%rax),%rax
  8187a4:	48 89 c6             	mov    %rax,%rsi
  8187a7:	48 bf f5 22 82 00 00 	movabs $0x8222f5,%rdi
  8187ae:	00 00 00 
  8187b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8187b6:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8187bd:	00 00 00 
  8187c0:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  8187c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187c6:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8187cd:	48 89 c6             	mov    %rax,%rsi
  8187d0:	48 bf ff 22 82 00 00 	movabs $0x8222ff,%rdi
  8187d7:	00 00 00 
  8187da:	b8 00 00 00 00       	mov    $0x0,%eax
  8187df:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8187e6:	00 00 00 
  8187e9:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  8187eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187ef:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8187f6:	48 89 c6             	mov    %rax,%rsi
  8187f9:	48 bf 09 23 82 00 00 	movabs $0x822309,%rdi
  818800:	00 00 00 
  818803:	b8 00 00 00 00       	mov    $0x0,%eax
  818808:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  81880f:	00 00 00 
  818812:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  818814:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818818:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81881f:	48 89 c6             	mov    %rax,%rsi
  818822:	48 bf 13 23 82 00 00 	movabs $0x822313,%rdi
  818829:	00 00 00 
  81882c:	b8 00 00 00 00       	mov    $0x0,%eax
  818831:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  818838:	00 00 00 
  81883b:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  81883d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818841:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  818848:	48 89 c6             	mov    %rax,%rsi
  81884b:	48 bf 1d 23 82 00 00 	movabs $0x82231d,%rdi
  818852:	00 00 00 
  818855:	b8 00 00 00 00       	mov    $0x0,%eax
  81885a:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  818861:	00 00 00 
  818864:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  818866:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81886a:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  818871:	48 89 c6             	mov    %rax,%rsi
  818874:	48 bf 27 23 82 00 00 	movabs $0x822327,%rdi
  81887b:	00 00 00 
  81887e:	b8 00 00 00 00       	mov    $0x0,%eax
  818883:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  81888a:	00 00 00 
  81888d:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  81888f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818893:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81889a:	48 89 c6             	mov    %rax,%rsi
  81889d:	48 bf 30 23 82 00 00 	movabs $0x822330,%rdi
  8188a4:	00 00 00 
  8188a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8188ac:	48 ba 19 11 80 00 00 	movabs $0x801119,%rdx
  8188b3:	00 00 00 
  8188b6:	ff d2                	callq  *%rdx
}
  8188b8:	c9                   	leaveq 
  8188b9:	c3                   	retq   
  8188ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000008188c0 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  8188c0:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  8188c3:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  8188c7:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  8188ca:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  8188cf:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  8188d3:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  8188d7:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  8188db:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  8188df:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  8188e3:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  8188e7:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  8188eb:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  8188ef:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  8188f3:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  8188f7:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  8188fb:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  8188ff:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  818903:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  81890a:	c3                   	retq   
  81890b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000818910 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  818910:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  818913:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  818916:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  818919:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  81891d:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  818921:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  818925:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  818929:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  81892d:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  818931:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  818935:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  818939:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  81893d:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  818941:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  818945:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  818949:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  81894d:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  818950:	ff e1                	jmpq   *%rcx

0000000000818952 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  818952:	55                   	push   %rbp
  818953:	48 89 e5             	mov    %rsp,%rbp
  818956:	48 83 ec 20          	sub    $0x20,%rsp
  81895a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  81895e:	48 b8 c0 65 b5 00 00 	movabs $0xb565c0,%rax
  818965:	00 00 00 
  818968:	8b 00                	mov    (%rax),%eax
  81896a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  81896d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818970:	89 c7                	mov    %eax,%edi
  818972:	48 b8 a5 89 81 00 00 	movabs $0x8189a5,%rax
  818979:	00 00 00 
  81897c:	ff d0                	callq  *%rax
  81897e:	48 89 c2             	mov    %rax,%rdx
  818981:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818985:	48 89 c6             	mov    %rax,%rsi
  818988:	48 bf 1d 28 82 00 00 	movabs $0x82281d,%rdi
  81898f:	00 00 00 
  818992:	b8 00 00 00 00       	mov    $0x0,%eax
  818997:	48 b9 19 11 80 00 00 	movabs $0x801119,%rcx
  81899e:	00 00 00 
  8189a1:	ff d1                	callq  *%rcx
}
  8189a3:	c9                   	leaveq 
  8189a4:	c3                   	retq   

00000000008189a5 <e2s>:

const char *
e2s(int err) {
  8189a5:	55                   	push   %rbp
  8189a6:	48 89 e5             	mov    %rsp,%rbp
  8189a9:	48 83 ec 08          	sub    $0x8,%rsp
  8189ad:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  8189b0:	48 b8 00 72 82 00 00 	movabs $0x827200,%rax
  8189b7:	00 00 00 
  8189ba:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8189bd:	48 63 d2             	movslq %edx,%rdx
  8189c0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  8189c4:	c9                   	leaveq 
  8189c5:	c3                   	retq   

00000000008189c6 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  8189c6:	55                   	push   %rbp
  8189c7:	48 89 e5             	mov    %rsp,%rbp
  8189ca:	48 83 ec 08          	sub    $0x8,%rsp
  8189ce:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  8189d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189d6:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  8189da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189de:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  8189e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189e8:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  8189ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189f0:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  8189f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189f8:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  8189fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a00:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  818a04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a08:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  818a0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a10:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  818a14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a18:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  818a1c:	c9                   	leaveq 
  818a1d:	c3                   	retq   

0000000000818a1e <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  818a1e:	55                   	push   %rbp
  818a1f:	48 89 e5             	mov    %rsp,%rbp
  818a22:	48 83 ec 40          	sub    $0x40,%rsp
  818a26:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  818a2a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  818a2e:	ba 07 00 00 00       	mov    $0x7,%edx
  818a33:	be 00 00 00 10       	mov    $0x10000000,%esi
  818a38:	bf 00 00 00 00       	mov    $0x0,%edi
  818a3d:	48 b8 e0 25 80 00 00 	movabs $0x8025e0,%rax
  818a44:	00 00 00 
  818a47:	ff d0                	callq  *%rax
  818a49:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  818a4c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  818a50:	79 2a                	jns    818a7c <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  818a52:	48 ba 28 28 82 00 00 	movabs $0x822828,%rdx
  818a59:	00 00 00 
  818a5c:	be 55 00 00 00       	mov    $0x55,%esi
  818a61:	48 bf 4f 28 82 00 00 	movabs $0x82284f,%rdi
  818a68:	00 00 00 
  818a6b:	b8 00 00 00 00       	mov    $0x0,%eax
  818a70:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  818a77:	00 00 00 
  818a7a:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  818a7c:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  818a83:	10 

    struct jif *jif;
    jif = netif->state;
  818a84:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  818a88:	48 8b 40 30          	mov    0x30(%rax),%rax
  818a8c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  818a90:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  818a94:	48 83 c0 04          	add    $0x4,%rax
  818a98:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  818a9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  818aa3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  818aa7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  818aab:	e9 a0 00 00 00       	jmpq   818b50 <low_level_output+0x132>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  818ab0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818ab4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  818ab8:	0f b7 d0             	movzwl %ax,%edx
  818abb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818abe:	01 d0                	add    %edx,%eax
  818ac0:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  818ac5:	7e 3e                	jle    818b05 <low_level_output+0xe7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  818ac7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818acb:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  818acf:	0f b7 c0             	movzwl %ax,%eax
  818ad2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818ad5:	41 89 d0             	mov    %edx,%r8d
  818ad8:	89 c1                	mov    %eax,%ecx
  818ada:	48 ba 68 28 82 00 00 	movabs $0x822868,%rdx
  818ae1:	00 00 00 
  818ae4:	be 64 00 00 00       	mov    $0x64,%esi
  818ae9:	48 bf 4f 28 82 00 00 	movabs $0x82284f,%rdi
  818af0:	00 00 00 
  818af3:	b8 00 00 00 00       	mov    $0x0,%eax
  818af8:	49 b9 e0 0e 80 00 00 	movabs $0x800ee0,%r9
  818aff:	00 00 00 
  818b02:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  818b05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818b09:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  818b0d:	0f b7 d0             	movzwl %ax,%edx
  818b10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818b14:	48 8b 40 08          	mov    0x8(%rax),%rax
  818b18:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  818b1b:	48 63 f1             	movslq %ecx,%rsi
  818b1e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  818b22:	48 01 f1             	add    %rsi,%rcx
  818b25:	48 89 c6             	mov    %rax,%rsi
  818b28:	48 89 cf             	mov    %rcx,%rdi
  818b2b:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  818b32:	00 00 00 
  818b35:	ff d0                	callq  *%rax
	txsize += q->len;
  818b37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818b3b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  818b3f:	0f b7 c0             	movzwl %ax,%eax
  818b42:	01 45 fc             	add    %eax,-0x4(%rbp)
    for (q = p; q != NULL; q = q->next) {
  818b45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818b49:	48 8b 00             	mov    (%rax),%rax
  818b4c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  818b50:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  818b55:	0f 85 55 ff ff ff    	jne    818ab0 <low_level_output+0x92>
    }

    pkt->jp_len = txsize;
  818b5b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  818b5f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818b62:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  818b64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818b68:	8b 40 08             	mov    0x8(%rax),%eax
  818b6b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818b6f:	b9 07 00 00 00       	mov    $0x7,%ecx
  818b74:	be 0b 00 00 00       	mov    $0xb,%esi
  818b79:	89 c7                	mov    %eax,%edi
  818b7b:	48 b8 66 2a 80 00 00 	movabs $0x802a66,%rax
  818b82:	00 00 00 
  818b85:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  818b87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  818b8b:	48 89 c6             	mov    %rax,%rsi
  818b8e:	bf 00 00 00 00       	mov    $0x0,%edi
  818b93:	48 b8 92 26 80 00 00 	movabs $0x802692,%rax
  818b9a:	00 00 00 
  818b9d:	ff d0                	callq  *%rax

    return ERR_OK;
  818b9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818ba4:	c9                   	leaveq 
  818ba5:	c3                   	retq   

0000000000818ba6 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  818ba6:	55                   	push   %rbp
  818ba7:	48 89 e5             	mov    %rsp,%rbp
  818baa:	48 83 ec 50          	sub    $0x50,%rsp
  818bae:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  818bb2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  818bb6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  818bba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  818bbe:	8b 00                	mov    (%rax),%eax
  818bc0:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  818bc4:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  818bc8:	0f b7 c0             	movzwl %ax,%eax
  818bcb:	ba 03 00 00 00       	mov    $0x3,%edx
  818bd0:	89 c6                	mov    %eax,%esi
  818bd2:	bf 03 00 00 00       	mov    $0x3,%edi
  818bd7:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  818bde:	00 00 00 
  818be1:	ff d0                	callq  *%rax
  818be3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  818be7:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  818bec:	75 0a                	jne    818bf8 <low_level_input+0x52>
	return 0;
  818bee:	b8 00 00 00 00       	mov    $0x0,%eax
  818bf3:	e9 8a 00 00 00       	jmpq   818c82 <low_level_input+0xdc>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  818bf8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  818bfc:	48 83 c0 04          	add    $0x4,%rax
  818c00:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  818c04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  818c0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818c0f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  818c13:	eb 62                	jmp    818c77 <low_level_input+0xd1>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  818c15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818c19:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  818c1d:	0f b7 c0             	movzwl %ax,%eax
  818c20:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  818c23:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  818c27:	2b 45 fc             	sub    -0x4(%rbp),%eax
  818c2a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  818c2d:	7d 0a                	jge    818c39 <low_level_input+0x93>
	    bytes = len - copied;
  818c2f:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  818c33:	2b 45 fc             	sub    -0x4(%rbp),%eax
  818c36:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  818c39:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818c3c:	48 63 d0             	movslq %eax,%rdx
  818c3f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818c42:	48 63 c8             	movslq %eax,%rcx
  818c45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  818c49:	48 01 c1             	add    %rax,%rcx
  818c4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818c50:	48 8b 40 08          	mov    0x8(%rax),%rax
  818c54:	48 89 ce             	mov    %rcx,%rsi
  818c57:	48 89 c7             	mov    %rax,%rdi
  818c5a:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  818c61:	00 00 00 
  818c64:	ff d0                	callq  *%rax
	copied += bytes;
  818c66:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818c69:	01 45 fc             	add    %eax,-0x4(%rbp)
    for (q = p; q != NULL; q = q->next) {
  818c6c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818c70:	48 8b 00             	mov    (%rax),%rax
  818c73:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  818c77:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  818c7c:	75 97                	jne    818c15 <low_level_input+0x6f>
    }

    return p;
  818c7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  818c82:	c9                   	leaveq 
  818c83:	c3                   	retq   

0000000000818c84 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  818c84:	55                   	push   %rbp
  818c85:	48 89 e5             	mov    %rsp,%rbp
  818c88:	48 83 ec 20          	sub    $0x20,%rsp
  818c8c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818c90:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  818c94:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  818c98:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818c9c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  818ca0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ca4:	48 89 ce             	mov    %rcx,%rsi
  818ca7:	48 89 c7             	mov    %rax,%rdi
  818caa:	48 b8 f6 5e 81 00 00 	movabs $0x815ef6,%rax
  818cb1:	00 00 00 
  818cb4:	ff d0                	callq  *%rax
}
  818cb6:	c9                   	leaveq 
  818cb7:	c3                   	retq   

0000000000818cb8 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  818cb8:	55                   	push   %rbp
  818cb9:	48 89 e5             	mov    %rsp,%rbp
  818cbc:	48 83 ec 30          	sub    $0x30,%rsp
  818cc0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  818cc4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  818cc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818ccc:	48 8b 40 30          	mov    0x30(%rax),%rax
  818cd0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  818cd4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818cd8:	48 89 c7             	mov    %rax,%rdi
  818cdb:	48 b8 a6 8b 81 00 00 	movabs $0x818ba6,%rax
  818ce2:	00 00 00 
  818ce5:	ff d0                	callq  *%rax
  818ce7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  818ceb:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  818cf0:	75 05                	jne    818cf7 <jif_input+0x3f>
  818cf2:	e9 ba 00 00 00       	jmpq   818db1 <jif_input+0xf9>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  818cf7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818cfb:	48 8b 40 08          	mov    0x8(%rax),%rax
  818cff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  818d03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d07:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  818d0b:	0f b7 c0             	movzwl %ax,%eax
  818d0e:	89 c7                	mov    %eax,%edi
  818d10:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  818d17:	00 00 00 
  818d1a:	ff d0                	callq  *%rax
  818d1c:	0f b7 c0             	movzwl %ax,%eax
  818d1f:	3d 00 08 00 00       	cmp    $0x800,%eax
  818d24:	74 09                	je     818d2f <jif_input+0x77>
  818d26:	3d 06 08 00 00       	cmp    $0x806,%eax
  818d2b:	74 4e                	je     818d7b <jif_input+0xc3>
  818d2d:	eb 6f                	jmp    818d9e <jif_input+0xe6>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  818d2f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818d33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818d37:	48 89 d6             	mov    %rdx,%rsi
  818d3a:	48 89 c7             	mov    %rax,%rdi
  818d3d:	48 b8 18 5b 81 00 00 	movabs $0x815b18,%rax
  818d44:	00 00 00 
  818d47:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  818d49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818d4d:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  818d52:	48 89 c7             	mov    %rax,%rdi
  818d55:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  818d5c:	00 00 00 
  818d5f:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  818d61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818d65:	48 8b 40 18          	mov    0x18(%rax),%rax
  818d69:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  818d6d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818d71:	48 89 ce             	mov    %rcx,%rsi
  818d74:	48 89 d7             	mov    %rdx,%rdi
  818d77:	ff d0                	callq  *%rax
	break;
  818d79:	eb 36                	jmp    818db1 <jif_input+0xf9>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  818d7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d7f:	48 8b 08             	mov    (%rax),%rcx
  818d82:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818d86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818d8a:	48 89 ce             	mov    %rcx,%rsi
  818d8d:	48 89 c7             	mov    %rax,%rdi
  818d90:	48 b8 ae 5b 81 00 00 	movabs $0x815bae,%rax
  818d97:	00 00 00 
  818d9a:	ff d0                	callq  *%rax
	break;
  818d9c:	eb 13                	jmp    818db1 <jif_input+0xf9>

    default:
	pbuf_free(p);
  818d9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818da2:	48 89 c7             	mov    %rax,%rdi
  818da5:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  818dac:	00 00 00 
  818daf:	ff d0                	callq  *%rax
    }
}
  818db1:	c9                   	leaveq 
  818db2:	c3                   	retq   

0000000000818db3 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  818db3:	55                   	push   %rbp
  818db4:	48 89 e5             	mov    %rsp,%rbp
  818db7:	48 83 ec 30          	sub    $0x30,%rsp
  818dbb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  818dbf:	bf 10 00 00 00       	mov    $0x10,%edi
  818dc4:	48 b8 bb bd 80 00 00 	movabs $0x80bdbb,%rax
  818dcb:	00 00 00 
  818dce:	ff d0                	callq  *%rax
  818dd0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (jif == NULL) {
  818dd4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818dd9:	75 0a                	jne    818de5 <jif_init+0x32>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  818ddb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818de0:	e9 ce 00 00 00       	jmpq   818eb3 <jif_init+0x100>
    }

    output_envid = (envid_t *)netif->state;
  818de5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818de9:	48 8b 40 30          	mov    0x30(%rax),%rax
  818ded:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    netif->state = jif;
  818df1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818df5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818df9:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  818dfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818e01:	48 b9 84 8c 81 00 00 	movabs $0x818c84,%rcx
  818e08:	00 00 00 
  818e0b:	48 89 48 20          	mov    %rcx,0x20(%rax)
    netif->linkoutput = low_level_output;
  818e0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818e13:	48 be 1e 8a 81 00 00 	movabs $0x818a1e,%rsi
  818e1a:	00 00 00 
  818e1d:	48 89 70 28          	mov    %rsi,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  818e21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818e25:	48 83 c0 4b          	add    $0x4b,%rax
  818e29:	ba 02 00 00 00       	mov    $0x2,%edx
  818e2e:	48 be 91 28 82 00 00 	movabs $0x822891,%rsi
  818e35:	00 00 00 
  818e38:	48 89 c7             	mov    %rax,%rdi
  818e3b:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  818e42:	00 00 00 
  818e45:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  818e47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818e4b:	48 8d 50 41          	lea    0x41(%rax),%rdx
  818e4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e53:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  818e56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818e5a:	8b 10                	mov    (%rax),%edx
  818e5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e60:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  818e63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818e67:	48 89 c7             	mov    %rax,%rdi
  818e6a:	48 b8 c6 89 81 00 00 	movabs $0x8189c6,%rax
  818e71:	00 00 00 
  818e74:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  818e76:	48 bf 94 28 82 00 00 	movabs $0x822894,%rdi
  818e7d:	00 00 00 
  818e80:	48 b8 36 20 81 00 00 	movabs $0x812036,%rax
  818e87:	00 00 00 
  818e8a:	ff d0                	callq  *%rax
  818e8c:	89 45 ec             	mov    %eax,-0x14(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  818e8f:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  818e93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  818e97:	ba 00 00 00 00       	mov    $0x0,%edx
  818e9c:	48 89 ce             	mov    %rcx,%rsi
  818e9f:	48 89 c7             	mov    %rax,%rdi
  818ea2:	48 b8 88 60 81 00 00 	movabs $0x816088,%rax
  818ea9:	00 00 00 
  818eac:	ff d0                	callq  *%rax

    return ERR_OK;
  818eae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818eb3:	c9                   	leaveq 
  818eb4:	c3                   	retq   

0000000000818eb5 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  818eb5:	55                   	push   %rbp
  818eb6:	48 89 e5             	mov    %rsp,%rbp
  818eb9:	48 83 ec 40          	sub    $0x40,%rsp
  818ebd:	89 7d cc             	mov    %edi,-0x34(%rbp)
  818ec0:	89 f0                	mov    %esi,%eax
  818ec2:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  818ec6:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  818ec9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  818ecd:	8b 45 cc             	mov    -0x34(%rbp),%eax
  818ed0:	48 89 d6             	mov    %rdx,%rsi
  818ed3:	89 c7                	mov    %eax,%edi
  818ed5:	48 b8 37 a5 81 00 00 	movabs $0x81a537,%rax
  818edc:	00 00 00 
  818edf:	ff d0                	callq  *%rax
  818ee1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  818ee5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818eea:	0f 84 62 01 00 00    	je     819052 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  818ef0:	48 b8 ee a4 81 00 00 	movabs $0x81a4ee,%rax
  818ef7:	00 00 00 
  818efa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  818efe:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  818f02:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  818f05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f09:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  818f0d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  818f11:	48 89 c7             	mov    %rax,%rdi
  818f14:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  818f1b:	00 00 00 
  818f1e:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  818f20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f24:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  818f28:	84 c0                	test   %al,%al
  818f2a:	0f 84 22 01 00 00    	je     819052 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  818f30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f34:	48 8b 40 08          	mov    0x8(%rax),%rax
  818f38:	48 85 c0             	test   %rax,%rax
  818f3b:	74 2a                	je     818f67 <netconn_new_with_proto_and_callback+0xb2>
  818f3d:	48 ba a0 28 82 00 00 	movabs $0x8228a0,%rdx
  818f44:	00 00 00 
  818f47:	be 52 00 00 00       	mov    $0x52,%esi
  818f4c:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  818f53:	00 00 00 
  818f56:	b8 00 00 00 00       	mov    $0x0,%eax
  818f5b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  818f62:	00 00 00 
  818f65:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  818f67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f6b:	8b 40 14             	mov    0x14(%rax),%eax
  818f6e:	83 f8 ff             	cmp    $0xffffffff,%eax
  818f71:	75 2a                	jne    818f9d <netconn_new_with_proto_and_callback+0xe8>
  818f73:	48 ba d8 28 82 00 00 	movabs $0x8228d8,%rdx
  818f7a:	00 00 00 
  818f7d:	be 53 00 00 00       	mov    $0x53,%esi
  818f82:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  818f89:	00 00 00 
  818f8c:	b8 00 00 00 00       	mov    $0x0,%eax
  818f91:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  818f98:	00 00 00 
  818f9b:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  818f9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fa1:	8b 40 18             	mov    0x18(%rax),%eax
  818fa4:	83 f8 ff             	cmp    $0xffffffff,%eax
  818fa7:	75 2a                	jne    818fd3 <netconn_new_with_proto_and_callback+0x11e>
  818fa9:	48 ba f1 28 82 00 00 	movabs $0x8228f1,%rdx
  818fb0:	00 00 00 
  818fb3:	be 54 00 00 00       	mov    $0x54,%esi
  818fb8:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  818fbf:	00 00 00 
  818fc2:	b8 00 00 00 00       	mov    $0x0,%eax
  818fc7:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  818fce:	00 00 00 
  818fd1:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  818fd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fd7:	8b 40 1c             	mov    0x1c(%rax),%eax
  818fda:	83 f8 ff             	cmp    $0xffffffff,%eax
  818fdd:	74 2a                	je     819009 <netconn_new_with_proto_and_callback+0x154>
  818fdf:	48 ba 08 29 82 00 00 	movabs $0x822908,%rdx
  818fe6:	00 00 00 
  818fe9:	be 55 00 00 00       	mov    $0x55,%esi
  818fee:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  818ff5:	00 00 00 
  818ff8:	b8 00 00 00 00       	mov    $0x0,%eax
  818ffd:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819004:	00 00 00 
  819007:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  819009:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81900d:	8b 40 14             	mov    0x14(%rax),%eax
  819010:	89 c7                	mov    %eax,%edi
  819012:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  819019:	00 00 00 
  81901c:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  81901e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819022:	8b 40 18             	mov    0x18(%rax),%eax
  819025:	89 c7                	mov    %eax,%edi
  819027:	48 b8 5a 6d 81 00 00 	movabs $0x816d5a,%rax
  81902e:	00 00 00 
  819031:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  819033:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819037:	48 89 c6             	mov    %rax,%rsi
  81903a:	bf 07 00 00 00       	mov    $0x7,%edi
  81903f:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  819046:	00 00 00 
  819049:	ff d0                	callq  *%rax
      return NULL;
  81904b:	b8 00 00 00 00       	mov    $0x0,%eax
  819050:	eb 04                	jmp    819056 <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  819052:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819056:	c9                   	leaveq 
  819057:	c3                   	retq   

0000000000819058 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  819058:	55                   	push   %rbp
  819059:	48 89 e5             	mov    %rsp,%rbp
  81905c:	48 83 ec 40          	sub    $0x40,%rsp
  819060:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  819064:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819069:	75 07                	jne    819072 <netconn_delete+0x1a>
    return ERR_OK;
  81906b:	b8 00 00 00 00       	mov    $0x0,%eax
  819070:	eb 4d                	jmp    8190bf <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  819072:	48 b8 05 ab 81 00 00 	movabs $0x81ab05,%rax
  819079:	00 00 00 
  81907c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819080:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819084:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819088:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81908c:	48 89 c7             	mov    %rax,%rdi
  81908f:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  819096:	00 00 00 
  819099:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  81909b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81909f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8190a6:	00 
  netconn_free(conn);
  8190a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8190ab:	48 89 c7             	mov    %rax,%rdi
  8190ae:	48 b8 6f a6 81 00 00 	movabs $0x81a66f,%rax
  8190b5:	00 00 00 
  8190b8:	ff d0                	callq  *%rax

  return ERR_OK;
  8190ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8190bf:	c9                   	leaveq 
  8190c0:	c3                   	retq   

00000000008190c1 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  8190c1:	55                   	push   %rbp
  8190c2:	48 89 e5             	mov    %rsp,%rbp
  8190c5:	48 83 ec 10          	sub    $0x10,%rsp
  8190c9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  8190cd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8190d2:	75 2a                	jne    8190fe <netconn_type+0x3d>
  8190d4:	48 ba 29 29 82 00 00 	movabs $0x822929,%rdx
  8190db:	00 00 00 
  8190de:	be 84 00 00 00       	mov    $0x84,%esi
  8190e3:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  8190ea:	00 00 00 
  8190ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8190f2:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8190f9:	00 00 00 
  8190fc:	ff d1                	callq  *%rcx
  return conn->type;
  8190fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819102:	8b 00                	mov    (%rax),%eax
}
  819104:	c9                   	leaveq 
  819105:	c3                   	retq   

0000000000819106 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  819106:	55                   	push   %rbp
  819107:	48 89 e5             	mov    %rsp,%rbp
  81910a:	48 83 ec 50          	sub    $0x50,%rsp
  81910e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819112:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819116:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  81911a:	89 c8                	mov    %ecx,%eax
  81911c:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  81911f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819124:	75 2a                	jne    819150 <netconn_getaddr+0x4a>
  819126:	48 ba 44 29 82 00 00 	movabs $0x822944,%rdx
  81912d:	00 00 00 
  819130:	be 98 00 00 00       	mov    $0x98,%esi
  819135:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81913c:	00 00 00 
  81913f:	b8 00 00 00 00       	mov    $0x0,%eax
  819144:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81914b:	00 00 00 
  81914e:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  819150:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  819155:	75 2a                	jne    819181 <netconn_getaddr+0x7b>
  819157:	48 ba 62 29 82 00 00 	movabs $0x822962,%rdx
  81915e:	00 00 00 
  819161:	be 99 00 00 00       	mov    $0x99,%esi
  819166:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81916d:	00 00 00 
  819170:	b8 00 00 00 00       	mov    $0x0,%eax
  819175:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81917c:	00 00 00 
  81917f:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819181:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819186:	75 2a                	jne    8191b2 <netconn_getaddr+0xac>
  819188:	48 ba 80 29 82 00 00 	movabs $0x822980,%rdx
  81918f:	00 00 00 
  819192:	be 9a 00 00 00       	mov    $0x9a,%esi
  819197:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81919e:	00 00 00 
  8191a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8191a6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8191ad:	00 00 00 
  8191b0:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  8191b2:	48 b8 ad b6 81 00 00 	movabs $0x81b6ad,%rax
  8191b9:	00 00 00 
  8191bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8191c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8191c4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  8191c8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8191cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  8191d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8191d4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  8191d8:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  8191dc:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  8191df:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8191e3:	48 89 c7             	mov    %rax,%rdi
  8191e6:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  8191ed:	00 00 00 
  8191f0:	ff d0                	callq  *%rax

  return conn->err;
  8191f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8191f6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  8191fa:	c9                   	leaveq 
  8191fb:	c3                   	retq   

00000000008191fc <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  8191fc:	55                   	push   %rbp
  8191fd:	48 89 e5             	mov    %rsp,%rbp
  819200:	48 83 ec 50          	sub    $0x50,%rsp
  819204:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819208:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81920c:	89 d0                	mov    %edx,%eax
  81920e:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819212:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819217:	75 2a                	jne    819243 <netconn_bind+0x47>
  819219:	48 ba 9e 29 82 00 00 	movabs $0x82299e,%rdx
  819220:	00 00 00 
  819223:	be b5 00 00 00       	mov    $0xb5,%esi
  819228:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81922f:	00 00 00 
  819232:	b8 00 00 00 00       	mov    $0x0,%eax
  819237:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81923e:	00 00 00 
  819241:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  819243:	48 b8 43 ac 81 00 00 	movabs $0x81ac43,%rax
  81924a:	00 00 00 
  81924d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819251:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819255:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819259:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81925d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819261:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819265:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819269:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81926d:	48 89 c7             	mov    %rax,%rdi
  819270:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  819277:	00 00 00 
  81927a:	ff d0                	callq  *%rax
  return conn->err;
  81927c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819280:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819284:	c9                   	leaveq 
  819285:	c3                   	retq   

0000000000819286 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819286:	55                   	push   %rbp
  819287:	48 89 e5             	mov    %rsp,%rbp
  81928a:	48 83 ec 50          	sub    $0x50,%rsp
  81928e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819292:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819296:	89 d0                	mov    %edx,%eax
  819298:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  81929c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8192a1:	75 2a                	jne    8192cd <netconn_connect+0x47>
  8192a3:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  8192aa:	00 00 00 
  8192ad:	be cc 00 00 00       	mov    $0xcc,%esi
  8192b2:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  8192b9:	00 00 00 
  8192bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8192c1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8192c8:	00 00 00 
  8192cb:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  8192cd:	48 b8 ee ad 81 00 00 	movabs $0x81adee,%rax
  8192d4:	00 00 00 
  8192d7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8192db:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8192df:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  8192e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8192e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  8192eb:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  8192ef:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  8192f3:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8192f7:	48 89 c7             	mov    %rax,%rdi
  8192fa:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  819301:	00 00 00 
  819304:	ff d0                	callq  *%rax
  return conn->err;
  819306:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81930a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81930e:	c9                   	leaveq 
  81930f:	c3                   	retq   

0000000000819310 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  819310:	55                   	push   %rbp
  819311:	48 89 e5             	mov    %rsp,%rbp
  819314:	48 83 ec 40          	sub    $0x40,%rsp
  819318:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  81931c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819321:	75 2a                	jne    81934d <netconn_disconnect+0x3d>
  819323:	48 ba d8 29 82 00 00 	movabs $0x8229d8,%rdx
  81932a:	00 00 00 
  81932d:	be e2 00 00 00       	mov    $0xe2,%esi
  819332:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  819339:	00 00 00 
  81933c:	b8 00 00 00 00       	mov    $0x0,%eax
  819341:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819348:	00 00 00 
  81934b:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  81934d:	48 b8 5b af 81 00 00 	movabs $0x81af5b,%rax
  819354:	00 00 00 
  819357:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81935b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81935f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  819363:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819367:	48 89 c7             	mov    %rax,%rdi
  81936a:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  819371:	00 00 00 
  819374:	ff d0                	callq  *%rax
  return conn->err;
  819376:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81937a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81937e:	c9                   	leaveq 
  81937f:	c3                   	retq   

0000000000819380 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  819380:	55                   	push   %rbp
  819381:	48 89 e5             	mov    %rsp,%rbp
  819384:	48 83 ec 40          	sub    $0x40,%rsp
  819388:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81938c:	89 f0                	mov    %esi,%eax
  81938e:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  819391:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819396:	75 2a                	jne    8193c2 <netconn_listen_with_backlog+0x42>
  819398:	48 ba f9 29 82 00 00 	movabs $0x8229f9,%rdx
  81939f:	00 00 00 
  8193a2:	be fa 00 00 00       	mov    $0xfa,%esi
  8193a7:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  8193ae:	00 00 00 
  8193b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8193b6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8193bd:	00 00 00 
  8193c0:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  8193c2:	48 b8 ae af 81 00 00 	movabs $0x81afae,%rax
  8193c9:	00 00 00 
  8193cc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8193d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8193d4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  8193d8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8193dc:	48 89 c7             	mov    %rax,%rdi
  8193df:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  8193e6:	00 00 00 
  8193e9:	ff d0                	callq  *%rax
  return conn->err;
  8193eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8193ef:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  8193f3:	c9                   	leaveq 
  8193f4:	c3                   	retq   

00000000008193f5 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  8193f5:	55                   	push   %rbp
  8193f6:	48 89 e5             	mov    %rsp,%rbp
  8193f9:	48 83 ec 20          	sub    $0x20,%rsp
  8193fd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  819401:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819406:	75 2a                	jne    819432 <netconn_accept+0x3d>
  819408:	48 ba 16 2a 82 00 00 	movabs $0x822a16,%rdx
  81940f:	00 00 00 
  819412:	be 10 01 00 00       	mov    $0x110,%esi
  819417:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81941e:	00 00 00 
  819421:	b8 00 00 00 00       	mov    $0x0,%eax
  819426:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81942d:	00 00 00 
  819430:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  819432:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819436:	8b 40 1c             	mov    0x1c(%rax),%eax
  819439:	83 f8 ff             	cmp    $0xffffffff,%eax
  81943c:	75 2a                	jne    819468 <netconn_accept+0x73>
  81943e:	48 ba 38 2a 82 00 00 	movabs $0x822a38,%rdx
  819445:	00 00 00 
  819448:	be 11 01 00 00       	mov    $0x111,%esi
  81944d:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  819454:	00 00 00 
  819457:	b8 00 00 00 00       	mov    $0x0,%eax
  81945c:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819463:	00 00 00 
  819466:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  819468:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81946c:	8b 40 1c             	mov    0x1c(%rax),%eax
  81946f:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  819473:	ba 00 00 00 00       	mov    $0x0,%edx
  819478:	48 89 ce             	mov    %rcx,%rsi
  81947b:	89 c7                	mov    %eax,%edi
  81947d:	48 b8 08 78 81 00 00 	movabs $0x817808,%rax
  819484:	00 00 00 
  819487:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  819489:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81948d:	48 8b 40 38          	mov    0x38(%rax),%rax
  819491:	48 85 c0             	test   %rax,%rax
  819494:	74 1b                	je     8194b1 <netconn_accept+0xbc>
  819496:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81949a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81949e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8194a2:	ba 00 00 00 00       	mov    $0x0,%edx
  8194a7:	be 01 00 00 00       	mov    $0x1,%esi
  8194ac:	48 89 cf             	mov    %rcx,%rdi
  8194af:	ff d0                	callq  *%rax
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  8194b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8194b5:	c9                   	leaveq 
  8194b6:	c3                   	retq   

00000000008194b7 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  8194b7:	55                   	push   %rbp
  8194b8:	48 89 e5             	mov    %rsp,%rbp
  8194bb:	48 83 ec 50          	sub    $0x50,%rsp
  8194bf:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  8194c3:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8194ca:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  8194cb:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8194d0:	75 2a                	jne    8194fc <netconn_recv+0x45>
  8194d2:	48 ba 5b 2a 82 00 00 	movabs $0x822a5b,%rdx
  8194d9:	00 00 00 
  8194dc:	be 3a 01 00 00       	mov    $0x13a,%esi
  8194e1:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  8194e8:	00 00 00 
  8194eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8194f0:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8194f7:	00 00 00 
  8194fa:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  8194fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819500:	8b 40 18             	mov    0x18(%rax),%eax
  819503:	83 f8 ff             	cmp    $0xffffffff,%eax
  819506:	75 12                	jne    81951a <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  819508:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81950c:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  819510:	b8 00 00 00 00       	mov    $0x0,%eax
  819515:	e9 21 02 00 00       	jmpq   81973b <netconn_recv+0x284>
  }

  if (ERR_IS_FATAL(conn->err)) {
  81951a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81951e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819522:	3c fc                	cmp    $0xfc,%al
  819524:	7d 0a                	jge    819530 <netconn_recv+0x79>
    return NULL;
  819526:	b8 00 00 00 00       	mov    $0x0,%eax
  81952b:	e9 0b 02 00 00       	jmpq   81973b <netconn_recv+0x284>
  }

  if (conn->type == NETCONN_TCP) {
  819530:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819534:	8b 00                	mov    (%rax),%eax
  819536:	83 f8 10             	cmp    $0x10,%eax
  819539:	0f 85 80 01 00 00    	jne    8196bf <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  81953f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819543:	8b 40 04             	mov    0x4(%rax),%eax
  819546:	83 f8 02             	cmp    $0x2,%eax
  819549:	75 12                	jne    81955d <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  81954b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81954f:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  819553:	b8 00 00 00 00       	mov    $0x0,%eax
  819558:	e9 de 01 00 00       	jmpq   81973b <netconn_recv+0x284>
    }

    buf = memp_malloc(MEMP_NETBUF);
  81955d:	bf 06 00 00 00       	mov    $0x6,%edi
  819562:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  819569:	00 00 00 
  81956c:	ff d0                	callq  *%rax
  81956e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  819572:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819576:	48 85 c0             	test   %rax,%rax
  819579:	75 12                	jne    81958d <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  81957b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81957f:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  819583:	b8 00 00 00 00       	mov    $0x0,%eax
  819588:	e9 ae 01 00 00       	jmpq   81973b <netconn_recv+0x284>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  81958d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819591:	8b 40 18             	mov    0x18(%rax),%eax
  819594:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  819598:	ba 00 00 00 00       	mov    $0x0,%edx
  81959d:	48 89 ce             	mov    %rcx,%rsi
  8195a0:	89 c7                	mov    %eax,%edi
  8195a2:	48 b8 08 78 81 00 00 	movabs $0x817808,%rax
  8195a9:	00 00 00 
  8195ac:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  8195ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8195b2:	48 85 c0             	test   %rax,%rax
  8195b5:	74 24                	je     8195db <netconn_recv+0x124>
      len = p->tot_len;
  8195b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8195bb:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8195bf:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  8195c3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8195c7:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8195cb:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  8195cf:	89 c2                	mov    %eax,%edx
  8195d1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8195d5:	66 89 50 24          	mov    %dx,0x24(%rax)
  8195d9:	eb 06                	jmp    8195e1 <netconn_recv+0x12a>
    } else {
      len = 0;
  8195db:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  8195e1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8195e5:	48 8b 40 38          	mov    0x38(%rax),%rax
  8195e9:	48 85 c0             	test   %rax,%rax
  8195ec:	74 1a                	je     819608 <netconn_recv+0x151>
  8195ee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8195f2:	48 8b 40 38          	mov    0x38(%rax),%rax
  8195f6:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  8195fa:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8195fe:	be 01 00 00 00       	mov    $0x1,%esi
  819603:	48 89 cf             	mov    %rcx,%rdi
  819606:	ff d0                	callq  *%rax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  819608:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81960c:	48 85 c0             	test   %rax,%rax
  81960f:	75 36                	jne    819647 <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  819611:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819615:	48 89 c6             	mov    %rax,%rsi
  819618:	bf 06 00 00 00       	mov    $0x6,%edi
  81961d:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  819624:	00 00 00 
  819627:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  819629:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81962d:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819631:	84 c0                	test   %al,%al
  819633:	75 08                	jne    81963d <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  819635:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819639:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  81963d:	b8 00 00 00 00       	mov    $0x0,%eax
  819642:	e9 f4 00 00 00       	jmpq   81973b <netconn_recv+0x284>
    }

    buf->p = p;
  819647:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81964b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81964f:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  819652:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819656:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81965a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  81965e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819662:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  819668:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81966c:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  819673:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  819674:	48 b8 e7 b2 81 00 00 	movabs $0x81b2e7,%rax
  81967b:	00 00 00 
  81967e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  819682:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819686:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  81968a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81968e:	48 85 c0             	test   %rax,%rax
  819691:	74 11                	je     8196a4 <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  819693:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819697:	48 8b 00             	mov    (%rax),%rax
  81969a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81969e:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  8196a2:	eb 06                	jmp    8196aa <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  8196a4:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  8196aa:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8196ae:	48 89 c7             	mov    %rax,%rdi
  8196b1:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  8196b8:	00 00 00 
  8196bb:	ff d0                	callq  *%rax
  8196bd:	eb 78                	jmp    819737 <netconn_recv+0x280>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  8196bf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8196c3:	8b 40 18             	mov    0x18(%rax),%eax
  8196c6:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  8196ca:	ba 00 00 00 00       	mov    $0x0,%edx
  8196cf:	48 89 ce             	mov    %rcx,%rsi
  8196d2:	89 c7                	mov    %eax,%edi
  8196d4:	48 b8 08 78 81 00 00 	movabs $0x817808,%rax
  8196db:	00 00 00 
  8196de:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  8196e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8196e4:	48 85 c0             	test   %rax,%rax
  8196e7:	74 4e                	je     819737 <netconn_recv+0x280>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  8196e9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8196ed:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  8196f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8196f5:	48 8b 00             	mov    (%rax),%rax
  8196f8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8196fc:	29 c2                	sub    %eax,%edx
  8196fe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819702:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  819706:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81970a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81970e:	48 85 c0             	test   %rax,%rax
  819711:	74 24                	je     819737 <netconn_recv+0x280>
  819713:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819717:	48 8b 40 38          	mov    0x38(%rax),%rax
  81971b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81971f:	48 8b 12             	mov    (%rdx),%rdx
  819722:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  819726:	0f b7 d2             	movzwl %dx,%edx
  819729:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81972d:	be 01 00 00 00       	mov    $0x1,%esi
  819732:	48 89 cf             	mov    %rcx,%rdi
  819735:	ff d0                	callq  *%rax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  819737:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  81973b:	c9                   	leaveq 
  81973c:	c3                   	retq   

000000000081973d <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  81973d:	55                   	push   %rbp
  81973e:	48 89 e5             	mov    %rsp,%rbp
  819741:	48 83 ec 20          	sub    $0x20,%rsp
  819745:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  819749:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81974d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  819751:	89 c8                	mov    %ecx,%eax
  819753:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  819757:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81975c:	74 34                	je     819792 <netconn_sendto+0x55>
    buf->addr = addr;
  81975e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819762:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819766:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81976a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81976e:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  819772:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  819776:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81977a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81977e:	48 89 d6             	mov    %rdx,%rsi
  819781:	48 89 c7             	mov    %rax,%rdi
  819784:	48 b8 99 97 81 00 00 	movabs $0x819799,%rax
  81978b:	00 00 00 
  81978e:	ff d0                	callq  *%rax
  819790:	eb 05                	jmp    819797 <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  819792:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  819797:	c9                   	leaveq 
  819798:	c3                   	retq   

0000000000819799 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  819799:	55                   	push   %rbp
  81979a:	48 89 e5             	mov    %rsp,%rbp
  81979d:	48 83 ec 40          	sub    $0x40,%rsp
  8197a1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8197a5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  8197a9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8197ae:	75 2a                	jne    8197da <netconn_send+0x41>
  8197b0:	48 ba 76 2a 82 00 00 	movabs $0x822a76,%rdx
  8197b7:	00 00 00 
  8197ba:	be b9 01 00 00       	mov    $0x1b9,%esi
  8197bf:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  8197c6:	00 00 00 
  8197c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8197ce:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  8197d5:	00 00 00 
  8197d8:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  8197da:	48 b8 58 b1 81 00 00 	movabs $0x81b158,%rax
  8197e1:	00 00 00 
  8197e4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8197e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8197ec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  8197f0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8197f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  8197f8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8197fc:	48 89 c7             	mov    %rax,%rdi
  8197ff:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  819806:	00 00 00 
  819809:	ff d0                	callq  *%rax
  return conn->err;
  81980b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81980f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819813:	c9                   	leaveq 
  819814:	c3                   	retq   

0000000000819815 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  819815:	55                   	push   %rbp
  819816:	48 89 e5             	mov    %rsp,%rbp
  819819:	48 83 ec 50          	sub    $0x50,%rsp
  81981d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819821:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819825:	89 55 bc             	mov    %edx,-0x44(%rbp)
  819828:	89 c8                	mov    %ecx,%eax
  81982a:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  81982d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819832:	75 2a                	jne    81985e <netconn_write+0x49>
  819834:	48 ba 91 2a 82 00 00 	movabs $0x822a91,%rdx
  81983b:	00 00 00 
  81983e:	be d3 01 00 00       	mov    $0x1d3,%esi
  819843:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81984a:	00 00 00 
  81984d:	b8 00 00 00 00       	mov    $0x0,%eax
  819852:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819859:	00 00 00 
  81985c:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  81985e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819862:	8b 00                	mov    (%rax),%eax
  819864:	83 f8 10             	cmp    $0x10,%eax
  819867:	74 2a                	je     819893 <netconn_write+0x7e>
  819869:	48 ba b0 2a 82 00 00 	movabs $0x822ab0,%rdx
  819870:	00 00 00 
  819873:	be d4 01 00 00       	mov    $0x1d4,%esi
  819878:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  81987f:	00 00 00 
  819882:	b8 00 00 00 00       	mov    $0x0,%eax
  819887:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81988e:	00 00 00 
  819891:	ff d1                	callq  *%rcx

  msg.function = do_write;
  819893:	48 b8 0c b6 81 00 00 	movabs $0x81b60c,%rax
  81989a:	00 00 00 
  81989d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8198a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198a5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  8198a9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8198ad:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  8198b1:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  8198b5:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  8198b8:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8198bb:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  8198be:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8198c2:	48 89 c7             	mov    %rax,%rdi
  8198c5:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  8198cc:	00 00 00 
  8198cf:	ff d0                	callq  *%rax
  return conn->err;
  8198d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198d5:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  8198d9:	c9                   	leaveq 
  8198da:	c3                   	retq   

00000000008198db <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  8198db:	55                   	push   %rbp
  8198dc:	48 89 e5             	mov    %rsp,%rbp
  8198df:	48 83 ec 40          	sub    $0x40,%rsp
  8198e3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  8198e7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8198ec:	75 2a                	jne    819918 <netconn_close+0x3d>
  8198ee:	48 ba d2 2a 82 00 00 	movabs $0x822ad2,%rdx
  8198f5:	00 00 00 
  8198f8:	be ed 01 00 00       	mov    $0x1ed,%esi
  8198fd:	48 bf c1 28 82 00 00 	movabs $0x8228c1,%rdi
  819904:	00 00 00 
  819907:	b8 00 00 00 00       	mov    $0x0,%eax
  81990c:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819913:	00 00 00 
  819916:	ff d1                	callq  *%rcx

  msg.function = do_close;
  819918:	48 b8 31 b8 81 00 00 	movabs $0x81b831,%rax
  81991f:	00 00 00 
  819922:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819926:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81992a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81992e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819932:	48 89 c7             	mov    %rax,%rdi
  819935:	48 b8 d0 80 80 00 00 	movabs $0x8080d0,%rax
  81993c:	00 00 00 
  81993f:	ff d0                	callq  *%rax
  return conn->err;
  819941:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819945:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819949:	c9                   	leaveq 
  81994a:	c3                   	retq   

000000000081994b <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81994b:	55                   	push   %rbp
  81994c:	48 89 e5             	mov    %rsp,%rbp
  81994f:	48 83 ec 40          	sub    $0x40,%rsp
  819953:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819957:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81995b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81995f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  819963:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819967:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81996b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819970:	0f 84 74 01 00 00    	je     819aea <recv_raw+0x19f>
  819976:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81997a:	8b 40 18             	mov    0x18(%rax),%eax
  81997d:	83 f8 ff             	cmp    $0xffffffff,%eax
  819980:	0f 84 64 01 00 00    	je     819aea <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  819986:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81998a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81998e:	0f b7 c0             	movzwl %ax,%eax
  819991:	ba 00 00 00 00       	mov    $0x0,%edx
  819996:	89 c6                	mov    %eax,%esi
  819998:	bf 03 00 00 00       	mov    $0x3,%edi
  81999d:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  8199a4:	00 00 00 
  8199a7:	ff d0                	callq  *%rax
  8199a9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  8199ad:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8199b2:	74 39                	je     8199ed <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  8199b4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8199b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8199bc:	48 89 d6             	mov    %rdx,%rsi
  8199bf:	48 89 c7             	mov    %rax,%rdi
  8199c2:	48 b8 dc d5 80 00 00 	movabs $0x80d5dc,%rax
  8199c9:	00 00 00 
  8199cc:	ff d0                	callq  *%rax
  8199ce:	84 c0                	test   %al,%al
  8199d0:	74 1b                	je     8199ed <recv_raw+0xa2>
        pbuf_free(q);
  8199d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8199d6:	48 89 c7             	mov    %rax,%rdi
  8199d9:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  8199e0:	00 00 00 
  8199e3:	ff d0                	callq  *%rax
        q = NULL;
  8199e5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8199ec:	00 
      }
    }

    if(q != NULL) {
  8199ed:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8199f2:	0f 84 f2 00 00 00    	je     819aea <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  8199f8:	bf 06 00 00 00       	mov    $0x6,%edi
  8199fd:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  819a04:	00 00 00 
  819a07:	ff d0                	callq  *%rax
  819a09:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  819a0d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819a12:	75 1d                	jne    819a31 <recv_raw+0xe6>
        pbuf_free(q);
  819a14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a18:	48 89 c7             	mov    %rax,%rdi
  819a1b:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  819a22:	00 00 00 
  819a25:	ff d0                	callq  *%rax
        return 0;
  819a27:	b8 00 00 00 00       	mov    $0x0,%eax
  819a2c:	e9 be 00 00 00       	jmpq   819aef <recv_raw+0x1a4>
      }

      buf->p = q;
  819a31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a35:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819a39:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  819a3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a40:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819a44:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  819a48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a4c:	48 8b 40 08          	mov    0x8(%rax),%rax
  819a50:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  819a54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a58:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  819a5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819a60:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  819a64:	0f b6 d0             	movzbl %al,%edx
  819a67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a6b:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  819a6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a73:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  819a77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a7b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819a7f:	01 c2                	add    %eax,%edx
  819a81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a85:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  819a89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a8d:	48 8b 40 38          	mov    0x38(%rax),%rax
  819a91:	48 85 c0             	test   %rax,%rax
  819a94:	74 21                	je     819ab7 <recv_raw+0x16c>
  819a96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a9a:	48 8b 40 38          	mov    0x38(%rax),%rax
  819a9e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819aa2:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  819aa6:	0f b7 d2             	movzwl %dx,%edx
  819aa9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  819aad:	be 00 00 00 00       	mov    $0x0,%esi
  819ab2:	48 89 cf             	mov    %rcx,%rdi
  819ab5:	ff d0                	callq  *%rax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  819ab7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819abb:	8b 40 18             	mov    0x18(%rax),%eax
  819abe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819ac2:	48 89 d6             	mov    %rdx,%rsi
  819ac5:	89 c7                	mov    %eax,%edi
  819ac7:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  819ace:	00 00 00 
  819ad1:	ff d0                	callq  *%rax
  819ad3:	84 c0                	test   %al,%al
  819ad5:	74 13                	je     819aea <recv_raw+0x19f>
        netbuf_delete(buf);
  819ad7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819adb:	48 89 c7             	mov    %rax,%rdi
  819ade:	48 b8 b5 82 80 00 00 	movabs $0x8082b5,%rax
  819ae5:	00 00 00 
  819ae8:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  819aea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819aef:	c9                   	leaveq 
  819af0:	c3                   	retq   

0000000000819af1 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  819af1:	55                   	push   %rbp
  819af2:	48 89 e5             	mov    %rsp,%rbp
  819af5:	48 83 ec 40          	sub    $0x40,%rsp
  819af9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  819afd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  819b01:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  819b05:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  819b09:	44 89 c0             	mov    %r8d,%eax
  819b0c:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  819b10:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  819b15:	75 2a                	jne    819b41 <recv_udp+0x50>
  819b17:	48 ba f0 2a 82 00 00 	movabs $0x822af0,%rdx
  819b1e:	00 00 00 
  819b21:	be 8e 00 00 00       	mov    $0x8e,%esi
  819b26:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819b2d:	00 00 00 
  819b30:	b8 00 00 00 00       	mov    $0x0,%eax
  819b35:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819b3c:	00 00 00 
  819b3f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  819b41:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819b46:	75 2a                	jne    819b72 <recv_udp+0x81>
  819b48:	48 ba 30 2b 82 00 00 	movabs $0x822b30,%rdx
  819b4f:	00 00 00 
  819b52:	be 8f 00 00 00       	mov    $0x8f,%esi
  819b57:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819b5e:	00 00 00 
  819b61:	b8 00 00 00 00       	mov    $0x0,%eax
  819b66:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819b6d:	00 00 00 
  819b70:	ff d1                	callq  *%rcx
  conn = arg;
  819b72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819b76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  819b7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b7e:	48 8b 40 08          	mov    0x8(%rax),%rax
  819b82:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  819b86:	74 2a                	je     819bb2 <recv_udp+0xc1>
  819b88:	48 ba 4f 2b 82 00 00 	movabs $0x822b4f,%rdx
  819b8f:	00 00 00 
  819b92:	be 91 00 00 00       	mov    $0x91,%esi
  819b97:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819b9e:	00 00 00 
  819ba1:	b8 00 00 00 00       	mov    $0x0,%eax
  819ba6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819bad:	00 00 00 
  819bb0:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  819bb2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819bb7:	74 0c                	je     819bc5 <recv_udp+0xd4>
  819bb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819bbd:	8b 40 18             	mov    0x18(%rax),%eax
  819bc0:	83 f8 ff             	cmp    $0xffffffff,%eax
  819bc3:	75 18                	jne    819bdd <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  819bc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819bc9:	48 89 c7             	mov    %rax,%rdi
  819bcc:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  819bd3:	00 00 00 
  819bd6:	ff d0                	callq  *%rax
    return;
  819bd8:	e9 df 00 00 00       	jmpq   819cbc <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  819bdd:	bf 06 00 00 00       	mov    $0x6,%edi
  819be2:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  819be9:	00 00 00 
  819bec:	ff d0                	callq  *%rax
  819bee:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  819bf2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819bf7:	75 18                	jne    819c11 <recv_udp+0x120>
    pbuf_free(p);
  819bf9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819bfd:	48 89 c7             	mov    %rax,%rdi
  819c00:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  819c07:	00 00 00 
  819c0a:	ff d0                	callq  *%rax
    return;
  819c0c:	e9 ab 00 00 00       	jmpq   819cbc <recv_udp+0x1cb>
  } else {
    buf->p = p;
  819c11:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819c15:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  819c19:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  819c1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819c20:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  819c24:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  819c28:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819c2c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  819c30:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  819c34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819c38:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  819c3c:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  819c40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c44:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  819c48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819c4c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819c50:	01 c2                	add    %eax,%edx
  819c52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c56:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  819c5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c5e:	48 8b 40 38          	mov    0x38(%rax),%rax
  819c62:	48 85 c0             	test   %rax,%rax
  819c65:	74 21                	je     819c88 <recv_udp+0x197>
  819c67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c6b:	48 8b 40 38          	mov    0x38(%rax),%rax
  819c6f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  819c73:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  819c77:	0f b7 d2             	movzwl %dx,%edx
  819c7a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  819c7e:	be 00 00 00 00       	mov    $0x0,%esi
  819c83:	48 89 cf             	mov    %rcx,%rdi
  819c86:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  819c88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c8c:	8b 40 18             	mov    0x18(%rax),%eax
  819c8f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819c93:	48 89 d6             	mov    %rdx,%rsi
  819c96:	89 c7                	mov    %eax,%edi
  819c98:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  819c9f:	00 00 00 
  819ca2:	ff d0                	callq  *%rax
  819ca4:	84 c0                	test   %al,%al
  819ca6:	74 14                	je     819cbc <recv_udp+0x1cb>
    netbuf_delete(buf);
  819ca8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819cac:	48 89 c7             	mov    %rax,%rdi
  819caf:	48 b8 b5 82 80 00 00 	movabs $0x8082b5,%rax
  819cb6:	00 00 00 
  819cb9:	ff d0                	callq  *%rax
    return;
  819cbb:	90                   	nop
  }
}
  819cbc:	c9                   	leaveq 
  819cbd:	c3                   	retq   

0000000000819cbe <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  819cbe:	55                   	push   %rbp
  819cbf:	48 89 e5             	mov    %rsp,%rbp
  819cc2:	48 83 ec 30          	sub    $0x30,%rsp
  819cc6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  819cca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  819cce:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  819cd2:	89 c8                	mov    %ecx,%eax
  819cd4:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  819cd7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  819cdc:	75 2a                	jne    819d08 <recv_tcp+0x4a>
  819cde:	48 ba 70 2b 82 00 00 	movabs $0x822b70,%rdx
  819ce5:	00 00 00 
  819ce8:	be c1 00 00 00       	mov    $0xc1,%esi
  819ced:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819cf4:	00 00 00 
  819cf7:	b8 00 00 00 00       	mov    $0x0,%eax
  819cfc:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819d03:	00 00 00 
  819d06:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  819d08:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819d0d:	75 2a                	jne    819d39 <recv_tcp+0x7b>
  819d0f:	48 ba 98 2b 82 00 00 	movabs $0x822b98,%rdx
  819d16:	00 00 00 
  819d19:	be c2 00 00 00       	mov    $0xc2,%esi
  819d1e:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819d25:	00 00 00 
  819d28:	b8 00 00 00 00       	mov    $0x0,%eax
  819d2d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819d34:	00 00 00 
  819d37:	ff d1                	callq  *%rcx
  conn = arg;
  819d39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819d3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  819d41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819d45:	48 8b 40 08          	mov    0x8(%rax),%rax
  819d49:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  819d4d:	74 2a                	je     819d79 <recv_tcp+0xbb>
  819d4f:	48 ba b7 2b 82 00 00 	movabs $0x822bb7,%rdx
  819d56:	00 00 00 
  819d59:	be c4 00 00 00       	mov    $0xc4,%esi
  819d5e:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819d65:	00 00 00 
  819d68:	b8 00 00 00 00       	mov    $0x0,%eax
  819d6d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819d74:	00 00 00 
  819d77:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  819d79:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819d7e:	74 0c                	je     819d8c <recv_tcp+0xce>
  819d80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819d84:	8b 40 18             	mov    0x18(%rax),%eax
  819d87:	83 f8 ff             	cmp    $0xffffffff,%eax
  819d8a:	75 0a                	jne    819d96 <recv_tcp+0xd8>
    return ERR_VAL;
  819d8c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  819d91:	e9 8f 00 00 00       	jmpq   819e25 <recv_tcp+0x167>
  }

  conn->err = err;
  819d96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819d9a:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  819d9e:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  819da1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  819da6:	74 24                	je     819dcc <recv_tcp+0x10e>
    len = p->tot_len;
  819da8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819dac:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819db0:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  819db4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819db8:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  819dbc:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  819dc0:	01 c2                	add    %eax,%edx
  819dc2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819dc6:	66 89 50 24          	mov    %dx,0x24(%rax)
  819dca:	eb 06                	jmp    819dd2 <recv_tcp+0x114>
  } else {
    len = 0;
  819dcc:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  819dd2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819dd6:	48 8b 40 38          	mov    0x38(%rax),%rax
  819dda:	48 85 c0             	test   %rax,%rax
  819ddd:	74 1a                	je     819df9 <recv_tcp+0x13b>
  819ddf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819de3:	48 8b 40 38          	mov    0x38(%rax),%rax
  819de7:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  819deb:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  819def:	be 00 00 00 00       	mov    $0x0,%esi
  819df4:	48 89 cf             	mov    %rcx,%rdi
  819df7:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  819df9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819dfd:	8b 40 18             	mov    0x18(%rax),%eax
  819e00:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  819e04:	48 89 d6             	mov    %rdx,%rsi
  819e07:	89 c7                	mov    %eax,%edi
  819e09:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  819e10:	00 00 00 
  819e13:	ff d0                	callq  *%rax
  819e15:	84 c0                	test   %al,%al
  819e17:	74 07                	je     819e20 <recv_tcp+0x162>
    return ERR_MEM;
  819e19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  819e1e:	eb 05                	jmp    819e25 <recv_tcp+0x167>
  }

  return ERR_OK;
  819e20:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819e25:	c9                   	leaveq 
  819e26:	c3                   	retq   

0000000000819e27 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  819e27:	55                   	push   %rbp
  819e28:	48 89 e5             	mov    %rsp,%rbp
  819e2b:	48 83 ec 20          	sub    $0x20,%rsp
  819e2f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  819e33:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  819e37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819e3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  819e3f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819e44:	75 2a                	jne    819e70 <poll_tcp+0x49>
  819e46:	48 ba d5 2b 82 00 00 	movabs $0x822bd5,%rdx
  819e4d:	00 00 00 
  819e50:	be eb 00 00 00       	mov    $0xeb,%esi
  819e55:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819e5c:	00 00 00 
  819e5f:	b8 00 00 00 00       	mov    $0x0,%eax
  819e64:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819e6b:	00 00 00 
  819e6e:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  819e70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819e74:	8b 40 04             	mov    0x4(%rax),%eax
  819e77:	83 f8 01             	cmp    $0x1,%eax
  819e7a:	75 15                	jne    819e91 <poll_tcp+0x6a>
    do_writemore(conn);
  819e7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819e80:	48 89 c7             	mov    %rax,%rdi
  819e83:	48 b8 61 b3 81 00 00 	movabs $0x81b361,%rax
  819e8a:	00 00 00 
  819e8d:	ff d0                	callq  *%rax
  819e8f:	eb 1f                	jmp    819eb0 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  819e91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819e95:	8b 40 04             	mov    0x4(%rax),%eax
  819e98:	83 f8 04             	cmp    $0x4,%eax
  819e9b:	75 13                	jne    819eb0 <poll_tcp+0x89>
    do_close_internal(conn);
  819e9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819ea1:	48 89 c7             	mov    %rax,%rdi
  819ea4:	48 b8 d9 a7 81 00 00 	movabs $0x81a7d9,%rax
  819eab:	00 00 00 
  819eae:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  819eb0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819eb5:	c9                   	leaveq 
  819eb6:	c3                   	retq   

0000000000819eb7 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  819eb7:	55                   	push   %rbp
  819eb8:	48 89 e5             	mov    %rsp,%rbp
  819ebb:	48 83 ec 30          	sub    $0x30,%rsp
  819ebf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  819ec3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  819ec7:	89 d0                	mov    %edx,%eax
  819ec9:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  819ecd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819ed1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  819ed5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819eda:	75 2a                	jne    819f06 <sent_tcp+0x4f>
  819edc:	48 ba d5 2b 82 00 00 	movabs $0x822bd5,%rdx
  819ee3:	00 00 00 
  819ee6:	be 03 01 00 00       	mov    $0x103,%esi
  819eeb:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819ef2:	00 00 00 
  819ef5:	b8 00 00 00 00       	mov    $0x0,%eax
  819efa:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819f01:	00 00 00 
  819f04:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  819f06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f0a:	8b 40 04             	mov    0x4(%rax),%eax
  819f0d:	83 f8 01             	cmp    $0x1,%eax
  819f10:	75 4c                	jne    819f5e <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  819f12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f16:	48 8b 40 08          	mov    0x8(%rax),%rax
  819f1a:	48 85 c0             	test   %rax,%rax
  819f1d:	75 2a                	jne    819f49 <sent_tcp+0x92>
  819f1f:	48 ba e2 2b 82 00 00 	movabs $0x822be2,%rdx
  819f26:	00 00 00 
  819f29:	be 06 01 00 00       	mov    $0x106,%esi
  819f2e:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  819f35:	00 00 00 
  819f38:	b8 00 00 00 00       	mov    $0x0,%eax
  819f3d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  819f44:	00 00 00 
  819f47:	ff d1                	callq  *%rcx
    do_writemore(conn);
  819f49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f4d:	48 89 c7             	mov    %rax,%rdi
  819f50:	48 b8 61 b3 81 00 00 	movabs $0x81b361,%rax
  819f57:	00 00 00 
  819f5a:	ff d0                	callq  *%rax
  819f5c:	eb 1f                	jmp    819f7d <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  819f5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f62:	8b 40 04             	mov    0x4(%rax),%eax
  819f65:	83 f8 04             	cmp    $0x4,%eax
  819f68:	75 13                	jne    819f7d <sent_tcp+0xc6>
    do_close_internal(conn);
  819f6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f6e:	48 89 c7             	mov    %rax,%rdi
  819f71:	48 b8 d9 a7 81 00 00 	movabs $0x81a7d9,%rax
  819f78:	00 00 00 
  819f7b:	ff d0                	callq  *%rax
  }

  if (conn) {
  819f7d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819f82:	74 46                	je     819fca <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  819f84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f88:	48 8b 40 08          	mov    0x8(%rax),%rax
  819f8c:	48 85 c0             	test   %rax,%rax
  819f8f:	74 39                	je     819fca <sent_tcp+0x113>
  819f91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f95:	48 8b 40 08          	mov    0x8(%rax),%rax
  819f99:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  819f9d:	66 3d a0 2d          	cmp    $0x2da0,%ax
  819fa1:	76 27                	jbe    819fca <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  819fa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819fa7:	48 8b 40 38          	mov    0x38(%rax),%rax
  819fab:	48 85 c0             	test   %rax,%rax
  819fae:	74 1a                	je     819fca <sent_tcp+0x113>
  819fb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819fb4:	48 8b 40 38          	mov    0x38(%rax),%rax
  819fb8:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  819fbc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  819fc0:	be 02 00 00 00       	mov    $0x2,%esi
  819fc5:	48 89 cf             	mov    %rcx,%rdi
  819fc8:	ff d0                	callq  *%rax
    }
  }
  
  return ERR_OK;
  819fca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819fcf:	c9                   	leaveq 
  819fd0:	c3                   	retq   

0000000000819fd1 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  819fd1:	55                   	push   %rbp
  819fd2:	48 89 e5             	mov    %rsp,%rbp
  819fd5:	48 83 ec 20          	sub    $0x20,%rsp
  819fd9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  819fdd:	89 f0                	mov    %esi,%eax
  819fdf:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  819fe2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819fe6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  819fea:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819fef:	75 2a                	jne    81a01b <err_tcp+0x4a>
  819ff1:	48 ba d5 2b 82 00 00 	movabs $0x822bd5,%rdx
  819ff8:	00 00 00 
  819ffb:	be 22 01 00 00       	mov    $0x122,%esi
  81a000:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a007:	00 00 00 
  81a00a:	b8 00 00 00 00       	mov    $0x0,%eax
  81a00f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a016:	00 00 00 
  81a019:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81a01b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a01f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a026:	00 

  conn->err = err;
  81a027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a02b:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81a02f:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81a032:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a036:	8b 40 18             	mov    0x18(%rax),%eax
  81a039:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a03c:	74 42                	je     81a080 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a03e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a042:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a046:	48 85 c0             	test   %rax,%rax
  81a049:	74 1b                	je     81a066 <err_tcp+0x95>
  81a04b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a04f:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a053:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a057:	ba 00 00 00 00       	mov    $0x0,%edx
  81a05c:	be 00 00 00 00       	mov    $0x0,%esi
  81a061:	48 89 cf             	mov    %rcx,%rdi
  81a064:	ff d0                	callq  *%rax
    sys_mbox_post(conn->recvmbox, NULL);
  81a066:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a06a:	8b 40 18             	mov    0x18(%rax),%eax
  81a06d:	be 00 00 00 00       	mov    $0x0,%esi
  81a072:	89 c7                	mov    %eax,%edi
  81a074:	48 b8 a3 6f 81 00 00 	movabs $0x816fa3,%rax
  81a07b:	00 00 00 
  81a07e:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81a080:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a084:	8b 40 14             	mov    0x14(%rax),%eax
  81a087:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a08a:	74 2c                	je     81a0b8 <err_tcp+0xe7>
  81a08c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a090:	8b 40 04             	mov    0x4(%rax),%eax
  81a093:	83 f8 03             	cmp    $0x3,%eax
  81a096:	75 20                	jne    81a0b8 <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81a098:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a09c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81a0a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a0a7:	8b 40 14             	mov    0x14(%rax),%eax
  81a0aa:	89 c7                	mov    %eax,%edi
  81a0ac:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81a0b3:	00 00 00 
  81a0b6:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81a0b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a0bc:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a0bf:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a0c2:	74 42                	je     81a106 <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a0c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a0c8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a0cc:	48 85 c0             	test   %rax,%rax
  81a0cf:	74 1b                	je     81a0ec <err_tcp+0x11b>
  81a0d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a0d5:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a0d9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a0dd:	ba 00 00 00 00       	mov    $0x0,%edx
  81a0e2:	be 00 00 00 00       	mov    $0x0,%esi
  81a0e7:	48 89 cf             	mov    %rcx,%rdi
  81a0ea:	ff d0                	callq  *%rax
    sys_mbox_post(conn->acceptmbox, NULL);
  81a0ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a0f0:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a0f3:	be 00 00 00 00       	mov    $0x0,%esi
  81a0f8:	89 c7                	mov    %eax,%edi
  81a0fa:	48 b8 a3 6f 81 00 00 	movabs $0x816fa3,%rax
  81a101:	00 00 00 
  81a104:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81a106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a10a:	8b 40 04             	mov    0x4(%rax),%eax
  81a10d:	83 f8 01             	cmp    $0x1,%eax
  81a110:	74 0c                	je     81a11e <err_tcp+0x14d>
  81a112:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a116:	8b 40 04             	mov    0x4(%rax),%eax
  81a119:	83 f8 04             	cmp    $0x4,%eax
  81a11c:	75 20                	jne    81a13e <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81a11e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a122:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81a129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a12d:	8b 40 14             	mov    0x14(%rax),%eax
  81a130:	89 c7                	mov    %eax,%edi
  81a132:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81a139:	00 00 00 
  81a13c:	ff d0                	callq  *%rax
  }
}
  81a13e:	c9                   	leaveq 
  81a13f:	c3                   	retq   

000000000081a140 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81a140:	55                   	push   %rbp
  81a141:	48 89 e5             	mov    %rsp,%rbp
  81a144:	48 83 ec 20          	sub    $0x20,%rsp
  81a148:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81a14c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a150:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a154:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81a158:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a15c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a160:	48 89 d6             	mov    %rdx,%rsi
  81a163:	48 89 c7             	mov    %rax,%rdi
  81a166:	48 b8 ed fc 80 00 00 	movabs $0x80fced,%rax
  81a16d:	00 00 00 
  81a170:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81a172:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a176:	48 be be 9c 81 00 00 	movabs $0x819cbe,%rsi
  81a17d:	00 00 00 
  81a180:	48 89 c7             	mov    %rax,%rdi
  81a183:	48 b8 0b fd 80 00 00 	movabs $0x80fd0b,%rax
  81a18a:	00 00 00 
  81a18d:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81a18f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a193:	48 be b7 9e 81 00 00 	movabs $0x819eb7,%rsi
  81a19a:	00 00 00 
  81a19d:	48 89 c7             	mov    %rax,%rdi
  81a1a0:	48 b8 2c fd 80 00 00 	movabs $0x80fd2c,%rax
  81a1a7:	00 00 00 
  81a1aa:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81a1ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1b0:	ba 04 00 00 00       	mov    $0x4,%edx
  81a1b5:	48 be 27 9e 81 00 00 	movabs $0x819e27,%rsi
  81a1bc:	00 00 00 
  81a1bf:	48 89 c7             	mov    %rax,%rdi
  81a1c2:	48 b8 8c fd 80 00 00 	movabs $0x80fd8c,%rax
  81a1c9:	00 00 00 
  81a1cc:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81a1ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1d2:	48 be d1 9f 81 00 00 	movabs $0x819fd1,%rsi
  81a1d9:	00 00 00 
  81a1dc:	48 89 c7             	mov    %rax,%rdi
  81a1df:	48 b8 4d fd 80 00 00 	movabs $0x80fd4d,%rax
  81a1e6:	00 00 00 
  81a1e9:	ff d0                	callq  *%rax
}
  81a1eb:	c9                   	leaveq 
  81a1ec:	c3                   	retq   

000000000081a1ed <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81a1ed:	55                   	push   %rbp
  81a1ee:	48 89 e5             	mov    %rsp,%rbp
  81a1f1:	48 83 ec 30          	sub    $0x30,%rsp
  81a1f5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a1f9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a1fd:	89 d0                	mov    %edx,%eax
  81a1ff:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81a202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a206:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81a20a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a20e:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a211:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a214:	75 2a                	jne    81a240 <accept_function+0x53>
  81a216:	48 ba f8 2b 82 00 00 	movabs $0x822bf8,%rdx
  81a21d:	00 00 00 
  81a220:	be 65 01 00 00       	mov    $0x165,%esi
  81a225:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a22c:	00 00 00 
  81a22f:	b8 00 00 00 00       	mov    $0x0,%eax
  81a234:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a23b:	00 00 00 
  81a23e:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81a240:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a244:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81a248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a24c:	8b 00                	mov    (%rax),%eax
  81a24e:	48 89 d6             	mov    %rdx,%rsi
  81a251:	89 c7                	mov    %eax,%edi
  81a253:	48 b8 37 a5 81 00 00 	movabs $0x81a537,%rax
  81a25a:	00 00 00 
  81a25d:	ff d0                	callq  *%rax
  81a25f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81a263:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a268:	75 0a                	jne    81a274 <accept_function+0x87>
    return ERR_MEM;
  81a26a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a26f:	e9 9d 00 00 00       	jmpq   81a311 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81a274:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a278:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81a27c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81a280:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a284:	48 89 c7             	mov    %rax,%rdi
  81a287:	48 b8 40 a1 81 00 00 	movabs $0x81a140,%rax
  81a28e:	00 00 00 
  81a291:	ff d0                	callq  *%rax
  newconn->err = err;
  81a293:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a297:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81a29b:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a29e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a2a2:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a2a6:	48 85 c0             	test   %rax,%rax
  81a2a9:	74 1b                	je     81a2c6 <accept_function+0xd9>
  81a2ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a2af:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a2b3:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a2b7:	ba 00 00 00 00       	mov    $0x0,%edx
  81a2bc:	be 00 00 00 00       	mov    $0x0,%esi
  81a2c1:	48 89 cf             	mov    %rcx,%rdi
  81a2c4:	ff d0                	callq  *%rax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81a2c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a2ca:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a2cd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a2d1:	48 89 d6             	mov    %rdx,%rsi
  81a2d4:	89 c7                	mov    %eax,%edi
  81a2d6:	48 b8 05 70 81 00 00 	movabs $0x817005,%rax
  81a2dd:	00 00 00 
  81a2e0:	ff d0                	callq  *%rax
  81a2e2:	84 c0                	test   %al,%al
  81a2e4:	74 26                	je     81a30c <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81a2e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2ea:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a2f1:	00 
    netconn_free(newconn);
  81a2f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2f6:	48 89 c7             	mov    %rax,%rdi
  81a2f9:	48 b8 6f a6 81 00 00 	movabs $0x81a66f,%rax
  81a300:	00 00 00 
  81a303:	ff d0                	callq  *%rax
    return ERR_MEM;
  81a305:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a30a:	eb 05                	jmp    81a311 <accept_function+0x124>
  }
  return ERR_OK;
  81a30c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a311:	c9                   	leaveq 
  81a312:	c3                   	retq   

000000000081a313 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81a313:	55                   	push   %rbp
  81a314:	48 89 e5             	mov    %rsp,%rbp
  81a317:	53                   	push   %rbx
  81a318:	48 83 ec 18          	sub    $0x18,%rsp
  81a31c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81a320:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a324:	48 8b 00             	mov    (%rax),%rax
  81a327:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81a32b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a32f:	48 8b 00             	mov    (%rax),%rax
  81a332:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a336:	48 85 c0             	test   %rax,%rax
  81a339:	74 2a                	je     81a365 <pcb_new+0x52>
  81a33b:	48 ba 28 2c 82 00 00 	movabs $0x822c28,%rdx
  81a342:	00 00 00 
  81a345:	be 8a 01 00 00       	mov    $0x18a,%esi
  81a34a:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a351:	00 00 00 
  81a354:	b8 00 00 00 00       	mov    $0x0,%eax
  81a359:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a360:	00 00 00 
  81a363:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81a365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a369:	48 8b 00             	mov    (%rax),%rax
  81a36c:	8b 00                	mov    (%rax),%eax
  81a36e:	25 f0 00 00 00       	and    $0xf0,%eax
  81a373:	83 f8 20             	cmp    $0x20,%eax
  81a376:	0f 84 87 00 00 00    	je     81a403 <pcb_new+0xf0>
  81a37c:	83 f8 40             	cmp    $0x40,%eax
  81a37f:	74 0e                	je     81a38f <pcb_new+0x7c>
  81a381:	83 f8 10             	cmp    $0x10,%eax
  81a384:	0f 84 fa 00 00 00    	je     81a484 <pcb_new+0x171>
  81a38a:	e9 41 01 00 00       	jmpq   81a4d0 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81a38f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a393:	48 8b 18             	mov    (%rax),%rbx
  81a396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a39a:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81a39e:	0f b6 c0             	movzbl %al,%eax
  81a3a1:	89 c7                	mov    %eax,%edi
  81a3a3:	48 b8 f9 f5 81 00 00 	movabs $0x81f5f9,%rax
  81a3aa:	00 00 00 
  81a3ad:	ff d0                	callq  *%rax
  81a3af:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81a3b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a3b7:	48 8b 00             	mov    (%rax),%rax
  81a3ba:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a3be:	48 85 c0             	test   %rax,%rax
  81a3c1:	75 10                	jne    81a3d3 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81a3c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a3c7:	48 8b 00             	mov    (%rax),%rax
  81a3ca:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81a3ce:	e9 09 01 00 00       	jmpq   81a4dc <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81a3d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a3d7:	48 8b 10             	mov    (%rax),%rdx
  81a3da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a3de:	48 8b 00             	mov    (%rax),%rax
  81a3e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a3e5:	48 be 4b 99 81 00 00 	movabs $0x81994b,%rsi
  81a3ec:	00 00 00 
  81a3ef:	48 89 c7             	mov    %rax,%rdi
  81a3f2:	48 b8 41 f3 81 00 00 	movabs $0x81f341,%rax
  81a3f9:	00 00 00 
  81a3fc:	ff d0                	callq  *%rax
     break;
  81a3fe:	e9 d9 00 00 00       	jmpq   81a4dc <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81a403:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a407:	48 8b 18             	mov    (%rax),%rbx
  81a40a:	48 b8 e3 4d 81 00 00 	movabs $0x814de3,%rax
  81a411:	00 00 00 
  81a414:	ff d0                	callq  *%rax
  81a416:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81a41a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a41e:	48 8b 00             	mov    (%rax),%rax
  81a421:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a425:	48 85 c0             	test   %rax,%rax
  81a428:	75 10                	jne    81a43a <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81a42a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a42e:	48 8b 00             	mov    (%rax),%rax
  81a431:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81a435:	e9 a2 00 00 00       	jmpq   81a4dc <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81a43a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a43e:	48 8b 00             	mov    (%rax),%rax
  81a441:	8b 00                	mov    (%rax),%eax
  81a443:	83 f8 22             	cmp    $0x22,%eax
  81a446:	75 0f                	jne    81a457 <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81a448:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a44c:	48 8b 00             	mov    (%rax),%rax
  81a44f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a453:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81a457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a45b:	48 8b 10             	mov    (%rax),%rdx
  81a45e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a462:	48 8b 00             	mov    (%rax),%rax
  81a465:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a469:	48 be f1 9a 81 00 00 	movabs $0x819af1,%rsi
  81a470:	00 00 00 
  81a473:	48 89 c7             	mov    %rax,%rdi
  81a476:	48 b8 0b 4d 81 00 00 	movabs $0x814d0b,%rax
  81a47d:	00 00 00 
  81a480:	ff d0                	callq  *%rax
     break;
  81a482:	eb 58                	jmp    81a4dc <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81a484:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a488:	48 8b 18             	mov    (%rax),%rbx
  81a48b:	48 b8 d6 fc 80 00 00 	movabs $0x80fcd6,%rax
  81a492:	00 00 00 
  81a495:	ff d0                	callq  *%rax
  81a497:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81a49b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a49f:	48 8b 00             	mov    (%rax),%rax
  81a4a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a4a6:	48 85 c0             	test   %rax,%rax
  81a4a9:	75 0d                	jne    81a4b8 <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81a4ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4af:	48 8b 00             	mov    (%rax),%rax
  81a4b2:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81a4b6:	eb 24                	jmp    81a4dc <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81a4b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4bc:	48 8b 00             	mov    (%rax),%rax
  81a4bf:	48 89 c7             	mov    %rax,%rdi
  81a4c2:	48 b8 40 a1 81 00 00 	movabs $0x81a140,%rax
  81a4c9:	00 00 00 
  81a4cc:	ff d0                	callq  *%rax
     break;
  81a4ce:	eb 0c                	jmp    81a4dc <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81a4d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4d4:	48 8b 00             	mov    (%rax),%rax
  81a4d7:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81a4db:	90                   	nop
   }

  return msg->conn->err;
  81a4dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4e0:	48 8b 00             	mov    (%rax),%rax
  81a4e3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a4e7:	48 83 c4 18          	add    $0x18,%rsp
  81a4eb:	5b                   	pop    %rbx
  81a4ec:	5d                   	pop    %rbp
  81a4ed:	c3                   	retq   

000000000081a4ee <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81a4ee:	55                   	push   %rbp
  81a4ef:	48 89 e5             	mov    %rsp,%rbp
  81a4f2:	48 83 ec 10          	sub    $0x10,%rsp
  81a4f6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81a4fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4fe:	48 8b 00             	mov    (%rax),%rax
  81a501:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a505:	48 85 c0             	test   %rax,%rax
  81a508:	75 13                	jne    81a51d <do_newconn+0x2f>
     pcb_new(msg);
  81a50a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a50e:	48 89 c7             	mov    %rax,%rdi
  81a511:	48 b8 13 a3 81 00 00 	movabs $0x81a313,%rax
  81a518:	00 00 00 
  81a51b:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81a51d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a521:	48 8b 00             	mov    (%rax),%rax
  81a524:	8b 40 14             	mov    0x14(%rax),%eax
  81a527:	89 c7                	mov    %eax,%edi
  81a529:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81a530:	00 00 00 
  81a533:	ff d0                	callq  *%rax
}
  81a535:	c9                   	leaveq 
  81a536:	c3                   	retq   

000000000081a537 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81a537:	55                   	push   %rbp
  81a538:	48 89 e5             	mov    %rsp,%rbp
  81a53b:	48 83 ec 20          	sub    $0x20,%rsp
  81a53f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81a542:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81a546:	bf 07 00 00 00       	mov    $0x7,%edi
  81a54b:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  81a552:	00 00 00 
  81a555:	ff d0                	callq  *%rax
  81a557:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81a55b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a560:	75 0a                	jne    81a56c <netconn_alloc+0x35>
    return NULL;
  81a562:	b8 00 00 00 00       	mov    $0x0,%eax
  81a567:	e9 01 01 00 00       	jmpq   81a66d <netconn_alloc+0x136>
  }

  conn->err = ERR_OK;
  81a56c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a570:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81a574:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a578:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81a57b:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81a57d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a581:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a588:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81a589:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81a590:	bf 00 00 00 00       	mov    $0x0,%edi
  81a595:	48 b8 6b 72 81 00 00 	movabs $0x81726b,%rax
  81a59c:	00 00 00 
  81a59f:	ff d0                	callq  *%rax
  81a5a1:	89 c2                	mov    %eax,%edx
  81a5a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5a7:	89 50 14             	mov    %edx,0x14(%rax)
  81a5aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5ae:	8b 40 14             	mov    0x14(%rax),%eax
  81a5b1:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a5b4:	75 22                	jne    81a5d8 <netconn_alloc+0xa1>
    memp_free(MEMP_NETCONN, conn);
  81a5b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5ba:	48 89 c6             	mov    %rax,%rsi
  81a5bd:	bf 07 00 00 00       	mov    $0x7,%edi
  81a5c2:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81a5c9:	00 00 00 
  81a5cc:	ff d0                	callq  *%rax
    return NULL;
  81a5ce:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5d3:	e9 95 00 00 00       	jmpq   81a66d <netconn_alloc+0x136>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81a5d8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81a5db:	89 c7                	mov    %eax,%edi
  81a5dd:	48 b8 76 6b 81 00 00 	movabs $0x816b76,%rax
  81a5e4:	00 00 00 
  81a5e7:	ff d0                	callq  *%rax
  81a5e9:	89 c2                	mov    %eax,%edx
  81a5eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5ef:	89 50 18             	mov    %edx,0x18(%rax)
  81a5f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5f6:	8b 40 18             	mov    0x18(%rax),%eax
  81a5f9:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a5fc:	75 34                	jne    81a632 <netconn_alloc+0xfb>
    sys_sem_free(conn->op_completed);
  81a5fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a602:	8b 40 14             	mov    0x14(%rax),%eax
  81a605:	89 c7                	mov    %eax,%edi
  81a607:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  81a60e:	00 00 00 
  81a611:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81a613:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a617:	48 89 c6             	mov    %rax,%rsi
  81a61a:	bf 07 00 00 00       	mov    $0x7,%edi
  81a61f:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81a626:	00 00 00 
  81a629:	ff d0                	callq  *%rax
    return NULL;
  81a62b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a630:	eb 3b                	jmp    81a66d <netconn_alloc+0x136>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81a632:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a636:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81a63d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a641:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81a648:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a64c:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81a653:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a657:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81a65b:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81a65f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a663:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81a669:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81a66d:	c9                   	leaveq 
  81a66e:	c3                   	retq   

000000000081a66f <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81a66f:	55                   	push   %rbp
  81a670:	48 89 e5             	mov    %rsp,%rbp
  81a673:	48 83 ec 20          	sub    $0x20,%rsp
  81a677:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81a67b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a67f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a683:	48 85 c0             	test   %rax,%rax
  81a686:	74 2a                	je     81a6b2 <netconn_free+0x43>
  81a688:	48 ba 48 2c 82 00 00 	movabs $0x822c48,%rdx
  81a68f:	00 00 00 
  81a692:	be 26 02 00 00       	mov    $0x226,%esi
  81a697:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a69e:	00 00 00 
  81a6a1:	b8 00 00 00 00       	mov    $0x0,%eax
  81a6a6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a6ad:	00 00 00 
  81a6b0:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81a6b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a6b6:	8b 40 18             	mov    0x18(%rax),%eax
  81a6b9:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a6bc:	74 7f                	je     81a73d <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81a6be:	eb 3c                	jmp    81a6fc <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81a6c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a6c4:	8b 00                	mov    (%rax),%eax
  81a6c6:	83 f8 10             	cmp    $0x10,%eax
  81a6c9:	75 1e                	jne    81a6e9 <netconn_free+0x7a>
        if(mem != NULL) {
  81a6cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6cf:	48 85 c0             	test   %rax,%rax
  81a6d2:	74 28                	je     81a6fc <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81a6d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6d8:	48 89 c7             	mov    %rax,%rdi
  81a6db:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81a6e2:	00 00 00 
  81a6e5:	ff d0                	callq  *%rax
  81a6e7:	eb 13                	jmp    81a6fc <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81a6e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ed:	48 89 c7             	mov    %rax,%rdi
  81a6f0:	48 b8 b5 82 80 00 00 	movabs $0x8082b5,%rax
  81a6f7:	00 00 00 
  81a6fa:	ff d0                	callq  *%rax
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81a6fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a700:	8b 40 18             	mov    0x18(%rax),%eax
  81a703:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81a707:	48 89 d6             	mov    %rdx,%rsi
  81a70a:	89 c7                	mov    %eax,%edi
  81a70c:	48 b8 80 7a 81 00 00 	movabs $0x817a80,%rax
  81a713:	00 00 00 
  81a716:	ff d0                	callq  *%rax
  81a718:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a71b:	75 a3                	jne    81a6c0 <netconn_free+0x51>
      }
    }
    sys_mbox_free(conn->recvmbox);
  81a71d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a721:	8b 40 18             	mov    0x18(%rax),%eax
  81a724:	89 c7                	mov    %eax,%edi
  81a726:	48 b8 5a 6d 81 00 00 	movabs $0x816d5a,%rax
  81a72d:	00 00 00 
  81a730:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81a732:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a736:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81a73d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a741:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a744:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a747:	74 56                	je     81a79f <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81a749:	eb 13                	jmp    81a75e <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81a74b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a74f:	48 89 c7             	mov    %rax,%rdi
  81a752:	48 b8 58 90 81 00 00 	movabs $0x819058,%rax
  81a759:	00 00 00 
  81a75c:	ff d0                	callq  *%rax
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81a75e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a762:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a765:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81a769:	48 89 d6             	mov    %rdx,%rsi
  81a76c:	89 c7                	mov    %eax,%edi
  81a76e:	48 b8 80 7a 81 00 00 	movabs $0x817a80,%rax
  81a775:	00 00 00 
  81a778:	ff d0                	callq  *%rax
  81a77a:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a77d:	75 cc                	jne    81a74b <netconn_free+0xdc>
    }
    sys_mbox_free(conn->acceptmbox);
  81a77f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a783:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a786:	89 c7                	mov    %eax,%edi
  81a788:	48 b8 5a 6d 81 00 00 	movabs $0x816d5a,%rax
  81a78f:	00 00 00 
  81a792:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81a794:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a798:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81a79f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7a3:	8b 40 14             	mov    0x14(%rax),%eax
  81a7a6:	89 c7                	mov    %eax,%edi
  81a7a8:	48 b8 69 73 81 00 00 	movabs $0x817369,%rax
  81a7af:	00 00 00 
  81a7b2:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81a7b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7b8:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81a7bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7c3:	48 89 c6             	mov    %rax,%rsi
  81a7c6:	bf 07 00 00 00       	mov    $0x7,%edi
  81a7cb:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81a7d2:	00 00 00 
  81a7d5:	ff d0                	callq  *%rax
}
  81a7d7:	c9                   	leaveq 
  81a7d8:	c3                   	retq   

000000000081a7d9 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81a7d9:	55                   	push   %rbp
  81a7da:	48 89 e5             	mov    %rsp,%rbp
  81a7dd:	48 83 ec 20          	sub    $0x20,%rsp
  81a7e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81a7e5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a7ea:	75 2a                	jne    81a816 <do_close_internal+0x3d>
  81a7ec:	48 ba 76 2c 82 00 00 	movabs $0x822c76,%rdx
  81a7f3:	00 00 00 
  81a7f6:	be 53 02 00 00       	mov    $0x253,%esi
  81a7fb:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a802:	00 00 00 
  81a805:	b8 00 00 00 00       	mov    $0x0,%eax
  81a80a:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a811:	00 00 00 
  81a814:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81a816:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a81a:	8b 00                	mov    (%rax),%eax
  81a81c:	83 f8 10             	cmp    $0x10,%eax
  81a81f:	74 2a                	je     81a84b <do_close_internal+0x72>
  81a821:	48 ba 83 2c 82 00 00 	movabs $0x822c83,%rdx
  81a828:	00 00 00 
  81a82b:	be 54 02 00 00       	mov    $0x254,%esi
  81a830:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a837:	00 00 00 
  81a83a:	b8 00 00 00 00       	mov    $0x0,%eax
  81a83f:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a846:	00 00 00 
  81a849:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81a84b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a84f:	8b 40 04             	mov    0x4(%rax),%eax
  81a852:	83 f8 04             	cmp    $0x4,%eax
  81a855:	74 2a                	je     81a881 <do_close_internal+0xa8>
  81a857:	48 ba a8 2c 82 00 00 	movabs $0x822ca8,%rdx
  81a85e:	00 00 00 
  81a861:	be 55 02 00 00       	mov    $0x255,%esi
  81a866:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a86d:	00 00 00 
  81a870:	b8 00 00 00 00       	mov    $0x0,%eax
  81a875:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a87c:	00 00 00 
  81a87f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81a881:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a885:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a889:	48 85 c0             	test   %rax,%rax
  81a88c:	75 2a                	jne    81a8b8 <do_close_internal+0xdf>
  81a88e:	48 ba cc 2c 82 00 00 	movabs $0x822ccc,%rdx
  81a895:	00 00 00 
  81a898:	be 56 02 00 00       	mov    $0x256,%esi
  81a89d:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81a8a4:	00 00 00 
  81a8a7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8ac:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81a8b3:	00 00 00 
  81a8b6:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81a8b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8c0:	be 00 00 00 00       	mov    $0x0,%esi
  81a8c5:	48 89 c7             	mov    %rax,%rdi
  81a8c8:	48 b8 ed fc 80 00 00 	movabs $0x80fced,%rax
  81a8cf:	00 00 00 
  81a8d2:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81a8d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8dc:	8b 40 18             	mov    0x18(%rax),%eax
  81a8df:	83 f8 01             	cmp    $0x1,%eax
  81a8e2:	75 21                	jne    81a905 <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81a8e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8ec:	be 00 00 00 00       	mov    $0x0,%esi
  81a8f1:	48 89 c7             	mov    %rax,%rdi
  81a8f4:	48 b8 6e fd 80 00 00 	movabs $0x80fd6e,%rax
  81a8fb:	00 00 00 
  81a8fe:	ff d0                	callq  *%rax
  81a900:	e9 91 00 00 00       	jmpq   81a996 <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81a905:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a909:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a90d:	be 00 00 00 00       	mov    $0x0,%esi
  81a912:	48 89 c7             	mov    %rax,%rdi
  81a915:	48 b8 0b fd 80 00 00 	movabs $0x80fd0b,%rax
  81a91c:	00 00 00 
  81a91f:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81a921:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a925:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a929:	be 00 00 00 00       	mov    $0x0,%esi
  81a92e:	48 89 c7             	mov    %rax,%rdi
  81a931:	48 b8 6e fd 80 00 00 	movabs $0x80fd6e,%rax
  81a938:	00 00 00 
  81a93b:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81a93d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a941:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a945:	be 00 00 00 00       	mov    $0x0,%esi
  81a94a:	48 89 c7             	mov    %rax,%rdi
  81a94d:	48 b8 2c fd 80 00 00 	movabs $0x80fd2c,%rax
  81a954:	00 00 00 
  81a957:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81a959:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a95d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a961:	ba 04 00 00 00       	mov    $0x4,%edx
  81a966:	be 00 00 00 00       	mov    $0x0,%esi
  81a96b:	48 89 c7             	mov    %rax,%rdi
  81a96e:	48 b8 8c fd 80 00 00 	movabs $0x80fd8c,%rax
  81a975:	00 00 00 
  81a978:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81a97a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a97e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a982:	be 00 00 00 00       	mov    $0x0,%esi
  81a987:	48 89 c7             	mov    %rax,%rdi
  81a98a:	48 b8 4d fd 80 00 00 	movabs $0x80fd4d,%rax
  81a991:	00 00 00 
  81a994:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81a996:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a99a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a99e:	48 89 c7             	mov    %rax,%rdi
  81a9a1:	48 b8 8c e0 80 00 00 	movabs $0x80e08c,%rax
  81a9a8:	00 00 00 
  81a9ab:	ff d0                	callq  *%rax
  81a9ad:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81a9b0:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81a9b4:	0f 85 89 00 00 00    	jne    81aa43 <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81a9ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9be:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81a9c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9c9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a9d0:	00 
    conn->err = ERR_OK;
  81a9d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9d5:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a9d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9dd:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a9e1:	48 85 c0             	test   %rax,%rax
  81a9e4:	74 1b                	je     81aa01 <do_close_internal+0x228>
  81a9e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9ea:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a9ee:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81a9f2:	ba 00 00 00 00       	mov    $0x0,%edx
  81a9f7:	be 00 00 00 00       	mov    $0x0,%esi
  81a9fc:	48 89 cf             	mov    %rcx,%rdi
  81a9ff:	ff d0                	callq  *%rax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81aa01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa05:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aa09:	48 85 c0             	test   %rax,%rax
  81aa0c:	74 1b                	je     81aa29 <do_close_internal+0x250>
  81aa0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa12:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aa16:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81aa1a:	ba 00 00 00 00       	mov    $0x0,%edx
  81aa1f:	be 02 00 00 00       	mov    $0x2,%esi
  81aa24:	48 89 cf             	mov    %rcx,%rdi
  81aa27:	ff d0                	callq  *%rax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81aa29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa2d:	8b 40 14             	mov    0x14(%rax),%eax
  81aa30:	89 c7                	mov    %eax,%edi
  81aa32:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81aa39:	00 00 00 
  81aa3c:	ff d0                	callq  *%rax
  81aa3e:	e9 c0 00 00 00       	jmpq   81ab03 <do_close_internal+0x32a>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81aa43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa47:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa4b:	8b 40 18             	mov    0x18(%rax),%eax
  81aa4e:	83 f8 01             	cmp    $0x1,%eax
  81aa51:	75 2a                	jne    81aa7d <do_close_internal+0x2a4>
  81aa53:	48 ba e0 2c 82 00 00 	movabs $0x822ce0,%rdx
  81aa5a:	00 00 00 
  81aa5d:	be 75 02 00 00       	mov    $0x275,%esi
  81aa62:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81aa69:	00 00 00 
  81aa6c:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa71:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81aa78:	00 00 00 
  81aa7b:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81aa7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa81:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa85:	48 be b7 9e 81 00 00 	movabs $0x819eb7,%rsi
  81aa8c:	00 00 00 
  81aa8f:	48 89 c7             	mov    %rax,%rdi
  81aa92:	48 b8 2c fd 80 00 00 	movabs $0x80fd2c,%rax
  81aa99:	00 00 00 
  81aa9c:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81aa9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aaa2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aaa6:	ba 04 00 00 00       	mov    $0x4,%edx
  81aaab:	48 be 27 9e 81 00 00 	movabs $0x819e27,%rsi
  81aab2:	00 00 00 
  81aab5:	48 89 c7             	mov    %rax,%rdi
  81aab8:	48 b8 8c fd 80 00 00 	movabs $0x80fd8c,%rax
  81aabf:	00 00 00 
  81aac2:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81aac4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aac8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aacc:	48 be d1 9f 81 00 00 	movabs $0x819fd1,%rsi
  81aad3:	00 00 00 
  81aad6:	48 89 c7             	mov    %rax,%rdi
  81aad9:	48 b8 4d fd 80 00 00 	movabs $0x80fd4d,%rax
  81aae0:	00 00 00 
  81aae3:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81aae5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aae9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aaed:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81aaf1:	48 89 d6             	mov    %rdx,%rsi
  81aaf4:	48 89 c7             	mov    %rax,%rdi
  81aaf7:	48 b8 ed fc 80 00 00 	movabs $0x80fced,%rax
  81aafe:	00 00 00 
  81ab01:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81ab03:	c9                   	leaveq 
  81ab04:	c3                   	retq   

000000000081ab05 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81ab05:	55                   	push   %rbp
  81ab06:	48 89 e5             	mov    %rsp,%rbp
  81ab09:	48 83 ec 10          	sub    $0x10,%rsp
  81ab0d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81ab11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab15:	48 8b 00             	mov    (%rax),%rax
  81ab18:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab1c:	48 85 c0             	test   %rax,%rax
  81ab1f:	0f 84 93 00 00 00    	je     81abb8 <do_delconn+0xb3>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81ab25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab29:	48 8b 00             	mov    (%rax),%rax
  81ab2c:	8b 00                	mov    (%rax),%eax
  81ab2e:	25 f0 00 00 00       	and    $0xf0,%eax
  81ab33:	83 f8 20             	cmp    $0x20,%eax
  81ab36:	74 28                	je     81ab60 <do_delconn+0x5b>
  81ab38:	83 f8 40             	cmp    $0x40,%eax
  81ab3b:	74 07                	je     81ab44 <do_delconn+0x3f>
  81ab3d:	83 f8 10             	cmp    $0x10,%eax
  81ab40:	74 4d                	je     81ab8f <do_delconn+0x8a>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
#endif /* LWIP_TCP */
    default:
      break;
  81ab42:	eb 74                	jmp    81abb8 <do_delconn+0xb3>
      raw_remove(msg->conn->pcb.raw);
  81ab44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab48:	48 8b 00             	mov    (%rax),%rax
  81ab4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab4f:	48 89 c7             	mov    %rax,%rdi
  81ab52:	48 b8 4f f5 81 00 00 	movabs $0x81f54f,%rax
  81ab59:	00 00 00 
  81ab5c:	ff d0                	callq  *%rax
      break;
  81ab5e:	eb 58                	jmp    81abb8 <do_delconn+0xb3>
      msg->conn->pcb.udp->recv_arg = NULL;
  81ab60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab64:	48 8b 00             	mov    (%rax),%rax
  81ab67:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab6b:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81ab72:	00 
      udp_remove(msg->conn->pcb.udp);
  81ab73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab77:	48 8b 00             	mov    (%rax),%rax
  81ab7a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab7e:	48 89 c7             	mov    %rax,%rdi
  81ab81:	48 b8 39 4d 81 00 00 	movabs $0x814d39,%rax
  81ab88:	00 00 00 
  81ab8b:	ff d0                	callq  *%rax
      break;
  81ab8d:	eb 29                	jmp    81abb8 <do_delconn+0xb3>
      msg->conn->state = NETCONN_CLOSE;
  81ab8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab93:	48 8b 00             	mov    (%rax),%rax
  81ab96:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81ab9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aba1:	48 8b 00             	mov    (%rax),%rax
  81aba4:	48 89 c7             	mov    %rax,%rdi
  81aba7:	48 b8 d9 a7 81 00 00 	movabs $0x81a7d9,%rax
  81abae:	00 00 00 
  81abb1:	ff d0                	callq  *%rax
      return;
  81abb3:	e9 89 00 00 00       	jmpq   81ac41 <do_delconn+0x13c>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81abb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abbc:	48 8b 00             	mov    (%rax),%rax
  81abbf:	48 8b 40 38          	mov    0x38(%rax),%rax
  81abc3:	48 85 c0             	test   %rax,%rax
  81abc6:	74 21                	je     81abe9 <do_delconn+0xe4>
  81abc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abcc:	48 8b 00             	mov    (%rax),%rax
  81abcf:	48 8b 40 38          	mov    0x38(%rax),%rax
  81abd3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81abd7:	48 8b 0a             	mov    (%rdx),%rcx
  81abda:	ba 00 00 00 00       	mov    $0x0,%edx
  81abdf:	be 00 00 00 00       	mov    $0x0,%esi
  81abe4:	48 89 cf             	mov    %rcx,%rdi
  81abe7:	ff d0                	callq  *%rax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81abe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abed:	48 8b 00             	mov    (%rax),%rax
  81abf0:	48 8b 40 38          	mov    0x38(%rax),%rax
  81abf4:	48 85 c0             	test   %rax,%rax
  81abf7:	74 21                	je     81ac1a <do_delconn+0x115>
  81abf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abfd:	48 8b 00             	mov    (%rax),%rax
  81ac00:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ac04:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ac08:	48 8b 0a             	mov    (%rdx),%rcx
  81ac0b:	ba 00 00 00 00       	mov    $0x0,%edx
  81ac10:	be 02 00 00 00       	mov    $0x2,%esi
  81ac15:	48 89 cf             	mov    %rcx,%rdi
  81ac18:	ff d0                	callq  *%rax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81ac1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac1e:	48 8b 00             	mov    (%rax),%rax
  81ac21:	8b 40 14             	mov    0x14(%rax),%eax
  81ac24:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ac27:	74 18                	je     81ac41 <do_delconn+0x13c>
    sys_sem_signal(msg->conn->op_completed);
  81ac29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac2d:	48 8b 00             	mov    (%rax),%rax
  81ac30:	8b 40 14             	mov    0x14(%rax),%eax
  81ac33:	89 c7                	mov    %eax,%edi
  81ac35:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81ac3c:	00 00 00 
  81ac3f:	ff d0                	callq  *%rax
  }
}
  81ac41:	c9                   	leaveq 
  81ac42:	c3                   	retq   

000000000081ac43 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81ac43:	55                   	push   %rbp
  81ac44:	48 89 e5             	mov    %rsp,%rbp
  81ac47:	53                   	push   %rbx
  81ac48:	48 83 ec 18          	sub    $0x18,%rsp
  81ac4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81ac50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac54:	48 8b 00             	mov    (%rax),%rax
  81ac57:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81ac5b:	3c fc                	cmp    $0xfc,%al
  81ac5d:	0f 8c eb 00 00 00    	jl     81ad4e <do_bind+0x10b>
    if (msg->conn->pcb.tcp != NULL) {
  81ac63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac67:	48 8b 00             	mov    (%rax),%rax
  81ac6a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac6e:	48 85 c0             	test   %rax,%rax
  81ac71:	0f 84 cc 00 00 00    	je     81ad43 <do_bind+0x100>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81ac77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac7b:	48 8b 00             	mov    (%rax),%rax
  81ac7e:	8b 00                	mov    (%rax),%eax
  81ac80:	25 f0 00 00 00       	and    $0xf0,%eax
  81ac85:	83 f8 20             	cmp    $0x20,%eax
  81ac88:	74 40                	je     81acca <do_bind+0x87>
  81ac8a:	83 f8 40             	cmp    $0x40,%eax
  81ac8d:	74 0a                	je     81ac99 <do_bind+0x56>
  81ac8f:	83 f8 10             	cmp    $0x10,%eax
  81ac92:	74 72                	je     81ad06 <do_bind+0xc3>
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  81ac94:	e9 a8 00 00 00       	jmpq   81ad41 <do_bind+0xfe>
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81ac99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac9d:	48 8b 18             	mov    (%rax),%rbx
  81aca0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aca4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81aca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acac:	48 8b 00             	mov    (%rax),%rax
  81acaf:	48 8b 40 08          	mov    0x8(%rax),%rax
  81acb3:	48 89 d6             	mov    %rdx,%rsi
  81acb6:	48 89 c7             	mov    %rax,%rdi
  81acb9:	48 b8 de f2 81 00 00 	movabs $0x81f2de,%rax
  81acc0:	00 00 00 
  81acc3:	ff d0                	callq  *%rax
  81acc5:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81acc8:	eb 77                	jmp    81ad41 <do_bind+0xfe>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81acca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acce:	48 8b 18             	mov    (%rax),%rbx
  81acd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acd5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81acd9:	0f b7 d0             	movzwl %ax,%edx
  81acdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ace0:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81ace4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ace8:	48 8b 00             	mov    (%rax),%rax
  81aceb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81acef:	48 89 ce             	mov    %rcx,%rsi
  81acf2:	48 89 c7             	mov    %rax,%rdi
  81acf5:	48 b8 87 4a 81 00 00 	movabs $0x814a87,%rax
  81acfc:	00 00 00 
  81acff:	ff d0                	callq  *%rax
  81ad01:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81ad04:	eb 3b                	jmp    81ad41 <do_bind+0xfe>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81ad06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad0a:	48 8b 18             	mov    (%rax),%rbx
  81ad0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad11:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ad15:	0f b7 d0             	movzwl %ax,%edx
  81ad18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad1c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81ad20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad24:	48 8b 00             	mov    (%rax),%rax
  81ad27:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ad2b:	48 89 ce             	mov    %rcx,%rsi
  81ad2e:	48 89 c7             	mov    %rax,%rdi
  81ad31:	48 b8 db e4 80 00 00 	movabs $0x80e4db,%rax
  81ad38:	00 00 00 
  81ad3b:	ff d0                	callq  *%rax
  81ad3d:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81ad40:	90                   	nop
  81ad41:	eb 0b                	jmp    81ad4e <do_bind+0x10b>
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81ad43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad47:	48 8b 00             	mov    (%rax),%rax
  81ad4a:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81ad4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad52:	48 8b 00             	mov    (%rax),%rax
  81ad55:	8b 40 14             	mov    0x14(%rax),%eax
  81ad58:	89 c7                	mov    %eax,%edi
  81ad5a:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81ad61:	00 00 00 
  81ad64:	ff d0                	callq  *%rax
}
  81ad66:	48 83 c4 18          	add    $0x18,%rsp
  81ad6a:	5b                   	pop    %rbx
  81ad6b:	5d                   	pop    %rbp
  81ad6c:	c3                   	retq   

000000000081ad6d <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81ad6d:	55                   	push   %rbp
  81ad6e:	48 89 e5             	mov    %rsp,%rbp
  81ad71:	48 83 ec 30          	sub    $0x30,%rsp
  81ad75:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ad79:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81ad7d:	89 d0                	mov    %edx,%eax
  81ad7f:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81ad82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81ad8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ad8f:	75 07                	jne    81ad98 <do_connected+0x2b>
    return ERR_VAL;
  81ad91:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81ad96:	eb 54                	jmp    81adec <do_connected+0x7f>
  }

  conn->err = err;
  81ad98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad9c:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81ada0:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81ada3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ada7:	8b 00                	mov    (%rax),%eax
  81ada9:	83 f8 10             	cmp    $0x10,%eax
  81adac:	75 19                	jne    81adc7 <do_connected+0x5a>
  81adae:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81adb2:	75 13                	jne    81adc7 <do_connected+0x5a>
    setup_tcp(conn);
  81adb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adb8:	48 89 c7             	mov    %rax,%rdi
  81adbb:	48 b8 40 a1 81 00 00 	movabs $0x81a140,%rax
  81adc2:	00 00 00 
  81adc5:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81adc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adcb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81add2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81add6:	8b 40 14             	mov    0x14(%rax),%eax
  81add9:	89 c7                	mov    %eax,%edi
  81addb:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81ade2:	00 00 00 
  81ade5:	ff d0                	callq  *%rax
  return ERR_OK;
  81ade7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81adec:	c9                   	leaveq 
  81aded:	c3                   	retq   

000000000081adee <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81adee:	55                   	push   %rbp
  81adef:	48 89 e5             	mov    %rsp,%rbp
  81adf2:	53                   	push   %rbx
  81adf3:	48 83 ec 18          	sub    $0x18,%rsp
  81adf7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81adfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81adff:	48 8b 00             	mov    (%rax),%rax
  81ae02:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae06:	48 85 c0             	test   %rax,%rax
  81ae09:	75 1d                	jne    81ae28 <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81ae0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae0f:	48 8b 00             	mov    (%rax),%rax
  81ae12:	8b 40 14             	mov    0x14(%rax),%eax
  81ae15:	89 c7                	mov    %eax,%edi
  81ae17:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81ae1e:	00 00 00 
  81ae21:	ff d0                	callq  *%rax
    return;
  81ae23:	e9 2c 01 00 00       	jmpq   81af54 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81ae28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae2c:	48 8b 00             	mov    (%rax),%rax
  81ae2f:	8b 00                	mov    (%rax),%eax
  81ae31:	25 f0 00 00 00       	and    $0xf0,%eax
  81ae36:	83 f8 20             	cmp    $0x20,%eax
  81ae39:	74 5f                	je     81ae9a <do_connect+0xac>
  81ae3b:	83 f8 40             	cmp    $0x40,%eax
  81ae3e:	74 0e                	je     81ae4e <do_connect+0x60>
  81ae40:	83 f8 10             	cmp    $0x10,%eax
  81ae43:	0f 84 a5 00 00 00    	je     81aeee <do_connect+0x100>
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
#endif /* LWIP_TCP */
  default:
    break;
  81ae49:	e9 06 01 00 00       	jmpq   81af54 <do_connect+0x166>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81ae4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae52:	48 8b 18             	mov    (%rax),%rbx
  81ae55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae59:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ae5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae61:	48 8b 00             	mov    (%rax),%rax
  81ae64:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae68:	48 89 d6             	mov    %rdx,%rsi
  81ae6b:	48 89 c7             	mov    %rax,%rdi
  81ae6e:	48 b8 0f f3 81 00 00 	movabs $0x81f30f,%rax
  81ae75:	00 00 00 
  81ae78:	ff d0                	callq  *%rax
  81ae7a:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81ae7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae81:	48 8b 00             	mov    (%rax),%rax
  81ae84:	8b 40 14             	mov    0x14(%rax),%eax
  81ae87:	89 c7                	mov    %eax,%edi
  81ae89:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81ae90:	00 00 00 
  81ae93:	ff d0                	callq  *%rax
    break;
  81ae95:	e9 ba 00 00 00       	jmpq   81af54 <do_connect+0x166>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81ae9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae9e:	48 8b 18             	mov    (%rax),%rbx
  81aea1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aea5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81aea9:	0f b7 d0             	movzwl %ax,%edx
  81aeac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aeb0:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81aeb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aeb8:	48 8b 00             	mov    (%rax),%rax
  81aebb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aebf:	48 89 ce             	mov    %rcx,%rsi
  81aec2:	48 89 c7             	mov    %rax,%rdi
  81aec5:	48 b8 d3 4b 81 00 00 	movabs $0x814bd3,%rax
  81aecc:	00 00 00 
  81aecf:	ff d0                	callq  *%rax
  81aed1:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81aed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aed8:	48 8b 00             	mov    (%rax),%rax
  81aedb:	8b 40 14             	mov    0x14(%rax),%eax
  81aede:	89 c7                	mov    %eax,%edi
  81aee0:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81aee7:	00 00 00 
  81aeea:	ff d0                	callq  *%rax
    break;
  81aeec:	eb 66                	jmp    81af54 <do_connect+0x166>
    msg->conn->state = NETCONN_CONNECT;
  81aeee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aef2:	48 8b 00             	mov    (%rax),%rax
  81aef5:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81aefc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af00:	48 8b 00             	mov    (%rax),%rax
  81af03:	48 89 c7             	mov    %rax,%rdi
  81af06:	48 b8 40 a1 81 00 00 	movabs $0x81a140,%rax
  81af0d:	00 00 00 
  81af10:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81af12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af16:	48 8b 18             	mov    (%rax),%rbx
  81af19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af1d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81af21:	0f b7 d0             	movzwl %ax,%edx
  81af24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af28:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81af2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af30:	48 8b 00             	mov    (%rax),%rax
  81af33:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af37:	48 b9 6d ad 81 00 00 	movabs $0x81ad6d,%rcx
  81af3e:	00 00 00 
  81af41:	48 89 c7             	mov    %rax,%rdi
  81af44:	48 b8 0f ec 80 00 00 	movabs $0x80ec0f,%rax
  81af4b:	00 00 00 
  81af4e:	ff d0                	callq  *%rax
  81af50:	88 43 10             	mov    %al,0x10(%rbx)
    break;
  81af53:	90                   	nop
  }
}
  81af54:	48 83 c4 18          	add    $0x18,%rsp
  81af58:	5b                   	pop    %rbx
  81af59:	5d                   	pop    %rbp
  81af5a:	c3                   	retq   

000000000081af5b <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81af5b:	55                   	push   %rbp
  81af5c:	48 89 e5             	mov    %rsp,%rbp
  81af5f:	48 83 ec 10          	sub    $0x10,%rsp
  81af63:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81af67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af6b:	48 8b 00             	mov    (%rax),%rax
  81af6e:	8b 00                	mov    (%rax),%eax
  81af70:	25 f0 00 00 00       	and    $0xf0,%eax
  81af75:	83 f8 20             	cmp    $0x20,%eax
  81af78:	75 1a                	jne    81af94 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81af7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af7e:	48 8b 00             	mov    (%rax),%rax
  81af81:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af85:	48 89 c7             	mov    %rax,%rdi
  81af88:	48 b8 cc 4c 81 00 00 	movabs $0x814ccc,%rax
  81af8f:	00 00 00 
  81af92:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81af94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af98:	48 8b 00             	mov    (%rax),%rax
  81af9b:	8b 40 14             	mov    0x14(%rax),%eax
  81af9e:	89 c7                	mov    %eax,%edi
  81afa0:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81afa7:	00 00 00 
  81afaa:	ff d0                	callq  *%rax
}
  81afac:	c9                   	leaveq 
  81afad:	c3                   	retq   

000000000081afae <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81afae:	55                   	push   %rbp
  81afaf:	48 89 e5             	mov    %rsp,%rbp
  81afb2:	53                   	push   %rbx
  81afb3:	48 83 ec 28          	sub    $0x28,%rsp
  81afb7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81afbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81afbf:	48 8b 00             	mov    (%rax),%rax
  81afc2:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81afc6:	3c fc                	cmp    $0xfc,%al
  81afc8:	0f 8c 6b 01 00 00    	jl     81b139 <do_listen+0x18b>
    if (msg->conn->pcb.tcp != NULL) {
  81afce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81afd2:	48 8b 00             	mov    (%rax),%rax
  81afd5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81afd9:	48 85 c0             	test   %rax,%rax
  81afdc:	0f 84 57 01 00 00    	je     81b139 <do_listen+0x18b>
      if (msg->conn->type == NETCONN_TCP) {
  81afe2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81afe6:	48 8b 00             	mov    (%rax),%rax
  81afe9:	8b 00                	mov    (%rax),%eax
  81afeb:	83 f8 10             	cmp    $0x10,%eax
  81afee:	0f 85 45 01 00 00    	jne    81b139 <do_listen+0x18b>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81aff4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81aff8:	48 8b 00             	mov    (%rax),%rax
  81affb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81afff:	8b 40 18             	mov    0x18(%rax),%eax
  81b002:	85 c0                	test   %eax,%eax
  81b004:	0f 85 24 01 00 00    	jne    81b12e <do_listen+0x180>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81b00a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b00e:	48 8b 00             	mov    (%rax),%rax
  81b011:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b015:	be ff 00 00 00       	mov    $0xff,%esi
  81b01a:	48 89 c7             	mov    %rax,%rdi
  81b01d:	48 b8 5c e7 80 00 00 	movabs $0x80e75c,%rax
  81b024:	00 00 00 
  81b027:	ff d0                	callq  *%rax
  81b029:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81b02d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b032:	75 10                	jne    81b044 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81b034:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b038:	48 8b 00             	mov    (%rax),%rax
  81b03b:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81b03f:	e9 e8 00 00 00       	jmpq   81b12c <do_listen+0x17e>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81b044:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b048:	48 8b 00             	mov    (%rax),%rax
  81b04b:	8b 40 18             	mov    0x18(%rax),%eax
  81b04e:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b051:	74 26                	je     81b079 <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81b053:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b057:	48 8b 00             	mov    (%rax),%rax
  81b05a:	8b 40 18             	mov    0x18(%rax),%eax
  81b05d:	89 c7                	mov    %eax,%edi
  81b05f:	48 b8 5a 6d 81 00 00 	movabs $0x816d5a,%rax
  81b066:	00 00 00 
  81b069:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81b06b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b06f:	48 8b 00             	mov    (%rax),%rax
  81b072:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81b079:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b07d:	48 8b 00             	mov    (%rax),%rax
  81b080:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b083:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b086:	75 2e                	jne    81b0b6 <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81b088:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b08c:	48 8b 18             	mov    (%rax),%rbx
  81b08f:	bf 00 00 00 00       	mov    $0x0,%edi
  81b094:	48 b8 76 6b 81 00 00 	movabs $0x816b76,%rax
  81b09b:	00 00 00 
  81b09e:	ff d0                	callq  *%rax
  81b0a0:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81b0a3:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81b0a6:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b0a9:	75 0b                	jne    81b0b6 <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81b0ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b0af:	48 8b 00             	mov    (%rax),%rax
  81b0b2:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81b0b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b0ba:	48 8b 00             	mov    (%rax),%rax
  81b0bd:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b0c1:	84 c0                	test   %al,%al
  81b0c3:	75 67                	jne    81b12c <do_listen+0x17e>
              msg->conn->state = NETCONN_LISTEN;
  81b0c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b0c9:	48 8b 00             	mov    (%rax),%rax
  81b0cc:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81b0d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b0d7:	48 8b 00             	mov    (%rax),%rax
  81b0da:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b0de:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81b0e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b0e6:	48 8b 10             	mov    (%rax),%rdx
  81b0e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b0ed:	48 8b 00             	mov    (%rax),%rax
  81b0f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0f4:	48 89 d6             	mov    %rdx,%rsi
  81b0f7:	48 89 c7             	mov    %rax,%rdi
  81b0fa:	48 b8 ed fc 80 00 00 	movabs $0x80fced,%rax
  81b101:	00 00 00 
  81b104:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81b106:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b10a:	48 8b 00             	mov    (%rax),%rax
  81b10d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b111:	48 be ed a1 81 00 00 	movabs $0x81a1ed,%rsi
  81b118:	00 00 00 
  81b11b:	48 89 c7             	mov    %rax,%rdi
  81b11e:	48 b8 6e fd 80 00 00 	movabs $0x80fd6e,%rax
  81b125:	00 00 00 
  81b128:	ff d0                	callq  *%rax
  81b12a:	eb 0d                	jmp    81b139 <do_listen+0x18b>
  81b12c:	eb 0b                	jmp    81b139 <do_listen+0x18b>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81b12e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b132:	48 8b 00             	mov    (%rax),%rax
  81b135:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81b139:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b13d:	48 8b 00             	mov    (%rax),%rax
  81b140:	8b 40 14             	mov    0x14(%rax),%eax
  81b143:	89 c7                	mov    %eax,%edi
  81b145:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b14c:	00 00 00 
  81b14f:	ff d0                	callq  *%rax
}
  81b151:	48 83 c4 28          	add    $0x28,%rsp
  81b155:	5b                   	pop    %rbx
  81b156:	5d                   	pop    %rbp
  81b157:	c3                   	retq   

000000000081b158 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81b158:	55                   	push   %rbp
  81b159:	48 89 e5             	mov    %rsp,%rbp
  81b15c:	53                   	push   %rbx
  81b15d:	48 83 ec 18          	sub    $0x18,%rsp
  81b161:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b165:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b169:	48 8b 00             	mov    (%rax),%rax
  81b16c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b170:	3c fc                	cmp    $0xfc,%al
  81b172:	0f 8c 50 01 00 00    	jl     81b2c8 <do_send+0x170>
    if (msg->conn->pcb.tcp != NULL) {
  81b178:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b17c:	48 8b 00             	mov    (%rax),%rax
  81b17f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b183:	48 85 c0             	test   %rax,%rax
  81b186:	0f 84 3c 01 00 00    	je     81b2c8 <do_send+0x170>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b18c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b190:	48 8b 00             	mov    (%rax),%rax
  81b193:	8b 00                	mov    (%rax),%eax
  81b195:	25 f0 00 00 00       	and    $0xf0,%eax
  81b19a:	83 f8 20             	cmp    $0x20,%eax
  81b19d:	0f 84 95 00 00 00    	je     81b238 <do_send+0xe0>
  81b1a3:	83 f8 40             	cmp    $0x40,%eax
  81b1a6:	74 05                	je     81b1ad <do_send+0x55>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
  81b1a8:	e9 1b 01 00 00       	jmpq   81b2c8 <do_send+0x170>
        if (msg->msg.b->addr == NULL) {
  81b1ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1b1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1b5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b1b9:	48 85 c0             	test   %rax,%rax
  81b1bc:	75 37                	jne    81b1f5 <do_send+0x9d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81b1be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1c2:	48 8b 18             	mov    (%rax),%rbx
  81b1c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1c9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1cd:	48 8b 10             	mov    (%rax),%rdx
  81b1d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1d4:	48 8b 00             	mov    (%rax),%rax
  81b1d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1db:	48 89 d6             	mov    %rdx,%rsi
  81b1de:	48 89 c7             	mov    %rax,%rdi
  81b1e1:	48 b8 1b f5 81 00 00 	movabs $0x81f51b,%rax
  81b1e8:	00 00 00 
  81b1eb:	ff d0                	callq  *%rax
  81b1ed:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b1f0:	e9 d3 00 00 00       	jmpq   81b2c8 <do_send+0x170>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81b1f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1f9:	48 8b 18             	mov    (%rax),%rbx
  81b1fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b200:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b204:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81b208:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b20c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b210:	48 8b 08             	mov    (%rax),%rcx
  81b213:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b217:	48 8b 00             	mov    (%rax),%rax
  81b21a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b21e:	48 89 ce             	mov    %rcx,%rsi
  81b221:	48 89 c7             	mov    %rax,%rdi
  81b224:	48 b8 6f f3 81 00 00 	movabs $0x81f36f,%rax
  81b22b:	00 00 00 
  81b22e:	ff d0                	callq  *%rax
  81b230:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b233:	e9 90 00 00 00       	jmpq   81b2c8 <do_send+0x170>
        if (msg->msg.b->addr == NULL) {
  81b238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b23c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b240:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b244:	48 85 c0             	test   %rax,%rax
  81b247:	75 34                	jne    81b27d <do_send+0x125>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81b249:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b24d:	48 8b 18             	mov    (%rax),%rbx
  81b250:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b254:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b258:	48 8b 10             	mov    (%rax),%rdx
  81b25b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b25f:	48 8b 00             	mov    (%rax),%rax
  81b262:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b266:	48 89 d6             	mov    %rdx,%rsi
  81b269:	48 89 c7             	mov    %rax,%rdi
  81b26c:	48 b8 21 47 81 00 00 	movabs $0x814721,%rax
  81b273:	00 00 00 
  81b276:	ff d0                	callq  *%rax
  81b278:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b27b:	eb 4a                	jmp    81b2c7 <do_send+0x16f>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81b27d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b281:	48 8b 18             	mov    (%rax),%rbx
  81b284:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b288:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b28c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81b290:	0f b7 c8             	movzwl %ax,%ecx
  81b293:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b297:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b29b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81b29f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2a3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2a7:	48 8b 30             	mov    (%rax),%rsi
  81b2aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2ae:	48 8b 00             	mov    (%rax),%rax
  81b2b1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2b5:	48 89 c7             	mov    %rax,%rdi
  81b2b8:	48 b8 62 47 81 00 00 	movabs $0x814762,%rax
  81b2bf:	00 00 00 
  81b2c2:	ff d0                	callq  *%rax
  81b2c4:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b2c7:	90                   	nop
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b2c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2cc:	48 8b 00             	mov    (%rax),%rax
  81b2cf:	8b 40 14             	mov    0x14(%rax),%eax
  81b2d2:	89 c7                	mov    %eax,%edi
  81b2d4:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b2db:	00 00 00 
  81b2de:	ff d0                	callq  *%rax
}
  81b2e0:	48 83 c4 18          	add    $0x18,%rsp
  81b2e4:	5b                   	pop    %rbx
  81b2e5:	5d                   	pop    %rbp
  81b2e6:	c3                   	retq   

000000000081b2e7 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81b2e7:	55                   	push   %rbp
  81b2e8:	48 89 e5             	mov    %rsp,%rbp
  81b2eb:	48 83 ec 10          	sub    $0x10,%rsp
  81b2ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b2f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2f7:	48 8b 00             	mov    (%rax),%rax
  81b2fa:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b2fe:	3c fc                	cmp    $0xfc,%al
  81b300:	7c 45                	jl     81b347 <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81b302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b306:	48 8b 00             	mov    (%rax),%rax
  81b309:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b30d:	48 85 c0             	test   %rax,%rax
  81b310:	74 35                	je     81b347 <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81b312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b316:	48 8b 00             	mov    (%rax),%rax
  81b319:	8b 00                	mov    (%rax),%eax
  81b31b:	83 f8 10             	cmp    $0x10,%eax
  81b31e:	75 27                	jne    81b347 <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81b320:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b324:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81b328:	0f b7 d0             	movzwl %ax,%edx
  81b32b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b32f:	48 8b 00             	mov    (%rax),%rax
  81b332:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b336:	89 d6                	mov    %edx,%esi
  81b338:	48 89 c7             	mov    %rax,%rdi
  81b33b:	48 b8 9f e9 80 00 00 	movabs $0x80e99f,%rax
  81b342:	00 00 00 
  81b345:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81b347:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b34b:	48 8b 00             	mov    (%rax),%rax
  81b34e:	8b 40 14             	mov    0x14(%rax),%eax
  81b351:	89 c7                	mov    %eax,%edi
  81b353:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b35a:	00 00 00 
  81b35d:	ff d0                	callq  *%rax
}
  81b35f:	c9                   	leaveq 
  81b360:	c3                   	retq   

000000000081b361 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81b361:	55                   	push   %rbp
  81b362:	48 89 e5             	mov    %rsp,%rbp
  81b365:	48 83 ec 30          	sub    $0x30,%rsp
  81b369:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81b36d:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81b371:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b375:	8b 40 04             	mov    0x4(%rax),%eax
  81b378:	83 f8 01             	cmp    $0x1,%eax
  81b37b:	74 2a                	je     81b3a7 <do_writemore+0x46>
  81b37d:	48 ba 03 2d 82 00 00 	movabs $0x822d03,%rdx
  81b384:	00 00 00 
  81b387:	be b8 03 00 00       	mov    $0x3b8,%esi
  81b38c:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81b393:	00 00 00 
  81b396:	b8 00 00 00 00       	mov    $0x0,%eax
  81b39b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81b3a2:	00 00 00 
  81b3a5:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81b3a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b3ab:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b3af:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b3b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b3b7:	8b 40 30             	mov    0x30(%rax),%eax
  81b3ba:	48 98                	cltq   
  81b3bc:	48 01 d0             	add    %rdx,%rax
  81b3bf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81b3c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b3c7:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b3cb:	8b 50 10             	mov    0x10(%rax),%edx
  81b3ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b3d2:	8b 40 30             	mov    0x30(%rax),%eax
  81b3d5:	29 c2                	sub    %eax,%edx
  81b3d7:	89 d0                	mov    %edx,%eax
  81b3d9:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81b3de:	7e 08                	jle    81b3e8 <do_writemore+0x87>
    len = 0xffff;
  81b3e0:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81b3e6:	eb 1c                	jmp    81b404 <do_writemore+0xa3>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81b3e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b3ec:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b3f0:	8b 40 10             	mov    0x10(%rax),%eax
  81b3f3:	89 c2                	mov    %eax,%edx
  81b3f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b3f9:	8b 40 30             	mov    0x30(%rax),%eax
  81b3fc:	29 c2                	sub    %eax,%edx
  81b3fe:	89 d0                	mov    %edx,%eax
  81b400:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81b404:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b408:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b40c:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81b410:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81b414:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81b418:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81b41c:	73 08                	jae    81b426 <do_writemore+0xc5>
    /* don't try to write more than sendbuf */
    len = available;
  81b41e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81b422:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81b426:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b42a:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b42e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81b432:	0f b6 c8             	movzbl %al,%ecx
  81b435:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81b439:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b43d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b441:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81b445:	48 89 c7             	mov    %rax,%rdi
  81b448:	48 b8 32 25 81 00 00 	movabs $0x812532,%rax
  81b44f:	00 00 00 
  81b452:	ff d0                	callq  *%rax
  81b454:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81b457:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b45b:	8b 50 30             	mov    0x30(%rax),%edx
  81b45e:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81b462:	01 c2                	add    %eax,%edx
  81b464:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b468:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b46c:	8b 40 10             	mov    0x10(%rax),%eax
  81b46f:	39 c2                	cmp    %eax,%edx
  81b471:	7e 2a                	jle    81b49d <do_writemore+0x13c>
  81b473:	48 ba 20 2d 82 00 00 	movabs $0x822d20,%rdx
  81b47a:	00 00 00 
  81b47d:	be cd 03 00 00       	mov    $0x3cd,%esi
  81b482:	48 bf 12 2b 82 00 00 	movabs $0x822b12,%rdi
  81b489:	00 00 00 
  81b48c:	b8 00 00 00 00       	mov    $0x0,%eax
  81b491:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81b498:	00 00 00 
  81b49b:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81b49d:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81b4a1:	0f 85 07 01 00 00    	jne    81b5ae <do_writemore+0x24d>
    conn->write_offset += len;
  81b4a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4ab:	8b 50 30             	mov    0x30(%rax),%edx
  81b4ae:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81b4b2:	01 c2                	add    %eax,%edx
  81b4b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4b8:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81b4bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4bf:	8b 50 30             	mov    0x30(%rax),%edx
  81b4c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4c6:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b4ca:	8b 40 10             	mov    0x10(%rax),%eax
  81b4cd:	39 c2                	cmp    %eax,%edx
  81b4cf:	75 1b                	jne    81b4ec <do_writemore+0x18b>
      /* everything was written */
      write_finished = 1;
  81b4d1:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81b4d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4d9:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b4e0:	00 
      conn->write_offset = 0;
  81b4e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4e5:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81b4ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b4f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4f4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81b4fb:	48 85 c0             	test   %rax,%rax
  81b4fe:	74 41                	je     81b541 <do_writemore+0x1e0>
  81b500:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b504:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b508:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81b50c:	0f b6 c0             	movzbl %al,%eax
  81b50f:	83 e0 40             	and    $0x40,%eax
  81b512:	85 c0                	test   %eax,%eax
  81b514:	75 2b                	jne    81b541 <do_writemore+0x1e0>
  81b516:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b51a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b51e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81b525:	48 85 c0             	test   %rax,%rax
  81b528:	74 30                	je     81b55a <do_writemore+0x1f9>
  81b52a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b52e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b532:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81b539:	48 8b 00             	mov    (%rax),%rax
  81b53c:	48 85 c0             	test   %rax,%rax
  81b53f:	74 19                	je     81b55a <do_writemore+0x1f9>
  81b541:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b545:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b549:	48 89 c7             	mov    %rax,%rdi
  81b54c:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81b553:	00 00 00 
  81b556:	ff d0                	callq  *%rax
  81b558:	eb 05                	jmp    81b55f <do_writemore+0x1fe>
  81b55a:	b8 00 00 00 00       	mov    $0x0,%eax
  81b55f:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81b562:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b566:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81b56a:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81b56d:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81b571:	75 6c                	jne    81b5df <do_writemore+0x27e>
  81b573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b577:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b57b:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81b57f:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81b583:	77 5a                	ja     81b5df <do_writemore+0x27e>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81b585:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b589:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b58d:	48 85 c0             	test   %rax,%rax
  81b590:	74 4d                	je     81b5df <do_writemore+0x27e>
  81b592:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b596:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b59a:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81b59e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81b5a2:	be 03 00 00 00       	mov    $0x3,%esi
  81b5a7:	48 89 cf             	mov    %rcx,%rdi
  81b5aa:	ff d0                	callq  *%rax
  81b5ac:	eb 31                	jmp    81b5df <do_writemore+0x27e>
    }
  } else if (err == ERR_MEM) {
  81b5ae:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81b5b2:	75 1c                	jne    81b5d0 <do_writemore+0x26f>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81b5b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5bc:	48 89 c7             	mov    %rax,%rdi
  81b5bf:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81b5c6:	00 00 00 
  81b5c9:	ff d0                	callq  *%rax
  81b5cb:	88 45 ed             	mov    %al,-0x13(%rbp)
  81b5ce:	eb 0f                	jmp    81b5df <do_writemore+0x27e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81b5d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5d4:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81b5d8:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81b5db:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81b5df:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81b5e3:	74 20                	je     81b605 <do_writemore+0x2a4>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81b5e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5e9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81b5f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5f4:	8b 40 14             	mov    0x14(%rax),%eax
  81b5f7:	89 c7                	mov    %eax,%edi
  81b5f9:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b600:	00 00 00 
  81b603:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81b605:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b60a:	c9                   	leaveq 
  81b60b:	c3                   	retq   

000000000081b60c <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81b60c:	55                   	push   %rbp
  81b60d:	48 89 e5             	mov    %rsp,%rbp
  81b610:	48 83 ec 10          	sub    $0x10,%rsp
  81b614:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b618:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b61c:	48 8b 00             	mov    (%rax),%rax
  81b61f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b623:	3c fc                	cmp    $0xfc,%al
  81b625:	7c 6c                	jl     81b693 <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81b627:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b62b:	48 8b 00             	mov    (%rax),%rax
  81b62e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b632:	48 85 c0             	test   %rax,%rax
  81b635:	74 51                	je     81b688 <do_write+0x7c>
  81b637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b63b:	48 8b 00             	mov    (%rax),%rax
  81b63e:	8b 00                	mov    (%rax),%eax
  81b640:	83 f8 10             	cmp    $0x10,%eax
  81b643:	75 43                	jne    81b688 <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81b645:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b649:	48 8b 00             	mov    (%rax),%rax
  81b64c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81b653:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b657:	48 8b 00             	mov    (%rax),%rax
  81b65a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b65e:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81b662:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b666:	48 8b 00             	mov    (%rax),%rax
  81b669:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81b670:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b674:	48 8b 00             	mov    (%rax),%rax
  81b677:	48 89 c7             	mov    %rax,%rdi
  81b67a:	48 b8 61 b3 81 00 00 	movabs $0x81b361,%rax
  81b681:	00 00 00 
  81b684:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81b686:	eb 23                	jmp    81b6ab <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81b688:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b68c:	48 8b 00             	mov    (%rax),%rax
  81b68f:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b693:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b697:	48 8b 00             	mov    (%rax),%rax
  81b69a:	8b 40 14             	mov    0x14(%rax),%eax
  81b69d:	89 c7                	mov    %eax,%edi
  81b69f:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b6a6:	00 00 00 
  81b6a9:	ff d0                	callq  *%rax
}
  81b6ab:	c9                   	leaveq 
  81b6ac:	c3                   	retq   

000000000081b6ad <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81b6ad:	55                   	push   %rbp
  81b6ae:	48 89 e5             	mov    %rsp,%rbp
  81b6b1:	48 83 ec 10          	sub    $0x10,%rsp
  81b6b5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81b6b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b6bd:	48 8b 00             	mov    (%rax),%rax
  81b6c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6c4:	48 85 c0             	test   %rax,%rax
  81b6c7:	0f 84 3f 01 00 00    	je     81b80c <do_getaddr+0x15f>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81b6cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b6d1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6d5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b6d9:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81b6dd:	84 d2                	test   %dl,%dl
  81b6df:	74 11                	je     81b6f2 <do_getaddr+0x45>
  81b6e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b6e5:	48 8b 12             	mov    (%rdx),%rdx
  81b6e8:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81b6ec:	8b 12                	mov    (%rdx),%edx
  81b6ee:	89 10                	mov    %edx,(%rax)
  81b6f0:	eb 10                	jmp    81b702 <do_getaddr+0x55>
  81b6f2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b6f6:	48 8b 12             	mov    (%rdx),%rdx
  81b6f9:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81b6fd:	8b 52 04             	mov    0x4(%rdx),%edx
  81b700:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b706:	48 8b 00             	mov    (%rax),%rax
  81b709:	8b 00                	mov    (%rax),%eax
  81b70b:	25 f0 00 00 00       	and    $0xf0,%eax
  81b710:	83 f8 20             	cmp    $0x20,%eax
  81b713:	74 51                	je     81b766 <do_getaddr+0xb9>
  81b715:	83 f8 40             	cmp    $0x40,%eax
  81b718:	74 0e                	je     81b728 <do_getaddr+0x7b>
  81b71a:	83 f8 10             	cmp    $0x10,%eax
  81b71d:	0f 84 af 00 00 00    	je     81b7d2 <do_getaddr+0x125>
  81b723:	e9 ef 00 00 00       	jmpq   81b817 <do_getaddr+0x16a>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81b728:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b72c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81b730:	84 c0                	test   %al,%al
  81b732:	74 22                	je     81b756 <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81b734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b738:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b73c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b740:	48 8b 12             	mov    (%rdx),%rdx
  81b743:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81b747:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81b74b:	0f b6 d2             	movzbl %dl,%edx
  81b74e:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81b751:	e9 b4 00 00 00       	jmpq   81b80a <do_getaddr+0x15d>
        msg->conn->err = ERR_CONN;
  81b756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b75a:	48 8b 00             	mov    (%rax),%rax
  81b75d:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      break;
  81b761:	e9 a4 00 00 00       	jmpq   81b80a <do_getaddr+0x15d>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81b766:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b76a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81b76e:	84 c0                	test   %al,%al
  81b770:	74 1c                	je     81b78e <do_getaddr+0xe1>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81b772:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b776:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b77a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b77e:	48 8b 12             	mov    (%rdx),%rdx
  81b781:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81b785:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81b789:	66 89 10             	mov    %dx,(%rax)
  81b78c:	eb 42                	jmp    81b7d0 <do_getaddr+0x123>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81b78e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b792:	48 8b 00             	mov    (%rax),%rax
  81b795:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b799:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81b79d:	0f b6 c0             	movzbl %al,%eax
  81b7a0:	83 e0 04             	and    $0x4,%eax
  81b7a3:	85 c0                	test   %eax,%eax
  81b7a5:	75 0d                	jne    81b7b4 <do_getaddr+0x107>
          msg->conn->err = ERR_CONN;
  81b7a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7ab:	48 8b 00             	mov    (%rax),%rax
  81b7ae:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  81b7b2:	eb 1c                	jmp    81b7d0 <do_getaddr+0x123>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81b7b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7b8:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b7bc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b7c0:	48 8b 12             	mov    (%rdx),%rdx
  81b7c3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81b7c7:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81b7cb:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81b7ce:	eb 3a                	jmp    81b80a <do_getaddr+0x15d>
  81b7d0:	eb 38                	jmp    81b80a <do_getaddr+0x15d>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81b7d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7d6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81b7da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7de:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81b7e2:	84 c0                	test   %al,%al
  81b7e4:	74 11                	je     81b7f7 <do_getaddr+0x14a>
  81b7e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7ea:	48 8b 00             	mov    (%rax),%rax
  81b7ed:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7f1:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81b7f5:	eb 0f                	jmp    81b806 <do_getaddr+0x159>
  81b7f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7fb:	48 8b 00             	mov    (%rax),%rax
  81b7fe:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b802:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81b806:	66 89 02             	mov    %ax,(%rdx)
      break;
  81b809:	90                   	nop
  81b80a:	eb 0b                	jmp    81b817 <do_getaddr+0x16a>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81b80c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b810:	48 8b 00             	mov    (%rax),%rax
  81b813:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81b817:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b81b:	48 8b 00             	mov    (%rax),%rax
  81b81e:	8b 40 14             	mov    0x14(%rax),%eax
  81b821:	89 c7                	mov    %eax,%edi
  81b823:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b82a:	00 00 00 
  81b82d:	ff d0                	callq  *%rax
}
  81b82f:	c9                   	leaveq 
  81b830:	c3                   	retq   

000000000081b831 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81b831:	55                   	push   %rbp
  81b832:	48 89 e5             	mov    %rsp,%rbp
  81b835:	48 83 ec 10          	sub    $0x10,%rsp
  81b839:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81b83d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b841:	48 8b 00             	mov    (%rax),%rax
  81b844:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b848:	48 85 c0             	test   %rax,%rax
  81b84b:	74 34                	je     81b881 <do_close+0x50>
  81b84d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b851:	48 8b 00             	mov    (%rax),%rax
  81b854:	8b 00                	mov    (%rax),%eax
  81b856:	83 f8 10             	cmp    $0x10,%eax
  81b859:	75 26                	jne    81b881 <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81b85b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b85f:	48 8b 00             	mov    (%rax),%rax
  81b862:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b869:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b86d:	48 8b 00             	mov    (%rax),%rax
  81b870:	48 89 c7             	mov    %rax,%rdi
  81b873:	48 b8 d9 a7 81 00 00 	movabs $0x81a7d9,%rax
  81b87a:	00 00 00 
  81b87d:	ff d0                	callq  *%rax
  81b87f:	eb 23                	jmp    81b8a4 <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81b881:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b885:	48 8b 00             	mov    (%rax),%rax
  81b888:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81b88c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b890:	48 8b 00             	mov    (%rax),%rax
  81b893:	8b 40 14             	mov    0x14(%rax),%eax
  81b896:	89 c7                	mov    %eax,%edi
  81b898:	48 b8 e5 74 81 00 00 	movabs $0x8174e5,%rax
  81b89f:	00 00 00 
  81b8a2:	ff d0                	callq  *%rax
  }
}
  81b8a4:	c9                   	leaveq 
  81b8a5:	c3                   	retq   

000000000081b8a6 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81b8a6:	55                   	push   %rbp
  81b8a7:	48 89 e5             	mov    %rsp,%rbp
  81b8aa:	53                   	push   %rbx
  81b8ab:	48 83 ec 38          	sub    $0x38,%rsp
  81b8af:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81b8b3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81b8b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81b8bb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b8bf:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81b8c6:	00 00 00 
  81b8c9:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81b8cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81b8d0:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81b8d4:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81b8db:	00 00 00 
  81b8de:	48 8b 00             	mov    (%rax),%rax
  81b8e1:	0f b7 00             	movzwl (%rax),%eax
  81b8e4:	0f b7 c0             	movzwl %ax,%eax
  81b8e7:	89 c7                	mov    %eax,%edi
  81b8e9:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81b8f0:	00 00 00 
  81b8f3:	ff d0                	callq  *%rax
  81b8f5:	66 c1 e8 08          	shr    $0x8,%ax
  81b8f9:	0f b7 c0             	movzwl %ax,%eax
  81b8fc:	83 e0 0f             	and    $0xf,%eax
  81b8ff:	c1 e0 02             	shl    $0x2,%eax
  81b902:	48 98                	cltq   
  81b904:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81b908:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81b90f:	00 00 00 
  81b912:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81b915:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81b91c:	00 00 00 
  81b91f:	48 8b 00             	mov    (%rax),%rax
  81b922:	0f b7 00             	movzwl (%rax),%eax
  81b925:	0f b7 c0             	movzwl %ax,%eax
  81b928:	89 c7                	mov    %eax,%edi
  81b92a:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81b931:	00 00 00 
  81b934:	ff d0                	callq  *%rax
  81b936:	66 c1 e8 08          	shr    $0x8,%ax
  81b93a:	83 e0 0f             	and    $0xf,%eax
  81b93d:	c1 e0 02             	shl    $0x2,%eax
  81b940:	f7 d8                	neg    %eax
  81b942:	0f bf d0             	movswl %ax,%edx
  81b945:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81b949:	89 d6                	mov    %edx,%esi
  81b94b:	48 89 c7             	mov    %rax,%rdi
  81b94e:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81b955:	00 00 00 
  81b958:	ff d0                	callq  *%rax
  81b95a:	84 c0                	test   %al,%al
  81b95c:	75 0e                	jne    81b96c <tcp_input+0xc6>
  81b95e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81b962:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b966:	66 83 f8 13          	cmp    $0x13,%ax
  81b96a:	77 18                	ja     81b984 <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81b96c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81b970:	48 89 c7             	mov    %rax,%rdi
  81b973:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81b97a:	00 00 00 
  81b97d:	ff d0                	callq  *%rax
    return;
  81b97f:	e9 eb 0b 00 00       	jmpq   81c56f <tcp_input+0xcc9>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81b984:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81b98b:	00 00 00 
  81b98e:	48 8b 00             	mov    (%rax),%rax
  81b991:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81b995:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81b999:	48 89 c6             	mov    %rax,%rsi
  81b99c:	48 89 d7             	mov    %rdx,%rdi
  81b99f:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  81b9a6:	00 00 00 
  81b9a9:	ff d0                	callq  *%rax
  81b9ab:	84 c0                	test   %al,%al
  81b9ad:	75 38                	jne    81b9e7 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81b9af:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81b9b6:	00 00 00 
  81b9b9:	48 8b 00             	mov    (%rax),%rax
  81b9bc:	8b 58 10             	mov    0x10(%rax),%ebx
  81b9bf:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81b9c4:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81b9cb:	00 00 00 
  81b9ce:	ff d0                	callq  *%rax
  81b9d0:	21 c3                	and    %eax,%ebx
  81b9d2:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81b9d7:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81b9de:	00 00 00 
  81b9e1:	ff d0                	callq  *%rax
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81b9e3:	39 c3                	cmp    %eax,%ebx
  81b9e5:	75 18                	jne    81b9ff <tcp_input+0x159>
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81b9e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81b9eb:	48 89 c7             	mov    %rax,%rdi
  81b9ee:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81b9f5:	00 00 00 
  81b9f8:	ff d0                	callq  *%rax
    return;
  81b9fa:	e9 70 0b 00 00       	jmpq   81c56f <tcp_input+0xcc9>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81b9ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ba03:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81ba07:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81ba0a:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81ba11:	00 00 00 
  81ba14:	48 8b 00             	mov    (%rax),%rax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81ba17:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81ba1b:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81ba22:	00 00 00 
  81ba25:	48 8b 00             	mov    (%rax),%rax
  81ba28:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81ba2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ba30:	41 89 c8             	mov    %ecx,%r8d
  81ba33:	b9 06 00 00 00       	mov    $0x6,%ecx
  81ba38:	48 89 c7             	mov    %rax,%rdi
  81ba3b:	48 b8 01 1c 81 00 00 	movabs $0x811c01,%rax
  81ba42:	00 00 00 
  81ba45:	ff d0                	callq  *%rax
  81ba47:	66 85 c0             	test   %ax,%ax
  81ba4a:	74 18                	je     81ba64 <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81ba4c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ba50:	48 89 c7             	mov    %rax,%rdi
  81ba53:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81ba5a:	00 00 00 
  81ba5d:	ff d0                	callq  *%rax
    return;
  81ba5f:	e9 0b 0b 00 00       	jmpq   81c56f <tcp_input+0xcc9>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81ba64:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81ba6b:	00 00 00 
  81ba6e:	48 8b 00             	mov    (%rax),%rax
  81ba71:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ba75:	0f b7 c0             	movzwl %ax,%eax
  81ba78:	89 c7                	mov    %eax,%edi
  81ba7a:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81ba81:	00 00 00 
  81ba84:	ff d0                	callq  *%rax
  81ba86:	66 c1 e8 0c          	shr    $0xc,%ax
  81ba8a:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81ba8d:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81ba91:	b8 00 00 00 00       	mov    $0x0,%eax
  81ba96:	29 d0                	sub    %edx,%eax
  81ba98:	c1 e0 02             	shl    $0x2,%eax
  81ba9b:	0f bf d0             	movswl %ax,%edx
  81ba9e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81baa2:	89 d6                	mov    %edx,%esi
  81baa4:	48 89 c7             	mov    %rax,%rdi
  81baa7:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81baae:	00 00 00 
  81bab1:	ff d0                	callq  *%rax
  81bab3:	84 c0                	test   %al,%al
  81bab5:	74 18                	je     81bacf <tcp_input+0x229>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81bab7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81babb:	48 89 c7             	mov    %rax,%rdi
  81babe:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81bac5:	00 00 00 
  81bac8:	ff d0                	callq  *%rax
    return;
  81baca:	e9 a0 0a 00 00       	jmpq   81c56f <tcp_input+0xcc9>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81bacf:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bad6:	00 00 00 
  81bad9:	48 8b 18             	mov    (%rax),%rbx
  81badc:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bae3:	00 00 00 
  81bae6:	48 8b 00             	mov    (%rax),%rax
  81bae9:	0f b7 00             	movzwl (%rax),%eax
  81baec:	0f b7 c0             	movzwl %ax,%eax
  81baef:	89 c7                	mov    %eax,%edi
  81baf1:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81baf8:	00 00 00 
  81bafb:	ff d0                	callq  *%rax
  81bafd:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81bb00:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bb07:	00 00 00 
  81bb0a:	48 8b 18             	mov    (%rax),%rbx
  81bb0d:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bb14:	00 00 00 
  81bb17:	48 8b 00             	mov    (%rax),%rax
  81bb1a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81bb1e:	0f b7 c0             	movzwl %ax,%eax
  81bb21:	89 c7                	mov    %eax,%edi
  81bb23:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81bb2a:	00 00 00 
  81bb2d:	ff d0                	callq  *%rax
  81bb2f:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81bb33:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bb3a:	00 00 00 
  81bb3d:	48 8b 18             	mov    (%rax),%rbx
  81bb40:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bb47:	00 00 00 
  81bb4a:	48 8b 00             	mov    (%rax),%rax
  81bb4d:	8b 40 04             	mov    0x4(%rax),%eax
  81bb50:	89 c7                	mov    %eax,%edi
  81bb52:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81bb59:	00 00 00 
  81bb5c:	ff d0                	callq  *%rax
  81bb5e:	89 43 04             	mov    %eax,0x4(%rbx)
  81bb61:	8b 53 04             	mov    0x4(%rbx),%edx
  81bb64:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81bb6b:	00 00 00 
  81bb6e:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81bb70:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bb77:	00 00 00 
  81bb7a:	48 8b 18             	mov    (%rax),%rbx
  81bb7d:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bb84:	00 00 00 
  81bb87:	48 8b 00             	mov    (%rax),%rax
  81bb8a:	8b 40 08             	mov    0x8(%rax),%eax
  81bb8d:	89 c7                	mov    %eax,%edi
  81bb8f:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81bb96:	00 00 00 
  81bb99:	ff d0                	callq  *%rax
  81bb9b:	89 43 08             	mov    %eax,0x8(%rbx)
  81bb9e:	8b 53 08             	mov    0x8(%rbx),%edx
  81bba1:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81bba8:	00 00 00 
  81bbab:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81bbad:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bbb4:	00 00 00 
  81bbb7:	48 8b 18             	mov    (%rax),%rbx
  81bbba:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bbc1:	00 00 00 
  81bbc4:	48 8b 00             	mov    (%rax),%rax
  81bbc7:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81bbcb:	0f b7 c0             	movzwl %ax,%eax
  81bbce:	89 c7                	mov    %eax,%edi
  81bbd0:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81bbd7:	00 00 00 
  81bbda:	ff d0                	callq  *%rax
  81bbdc:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81bbe0:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bbe7:	00 00 00 
  81bbea:	48 8b 00             	mov    (%rax),%rax
  81bbed:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81bbf1:	0f b7 c0             	movzwl %ax,%eax
  81bbf4:	89 c7                	mov    %eax,%edi
  81bbf6:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81bbfd:	00 00 00 
  81bc00:	ff d0                	callq  *%rax
  81bc02:	83 e0 3f             	and    $0x3f,%eax
  81bc05:	89 c2                	mov    %eax,%edx
  81bc07:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81bc0e:	00 00 00 
  81bc11:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81bc13:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bc17:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81bc1b:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81bc22:	00 00 00 
  81bc25:	0f b6 00             	movzbl (%rax),%eax
  81bc28:	0f b6 c0             	movzbl %al,%eax
  81bc2b:	83 e0 01             	and    $0x1,%eax
  81bc2e:	85 c0                	test   %eax,%eax
  81bc30:	75 17                	jne    81bc49 <tcp_input+0x3a3>
  81bc32:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81bc39:	00 00 00 
  81bc3c:	0f b6 00             	movzbl (%rax),%eax
  81bc3f:	0f b6 c0             	movzbl %al,%eax
  81bc42:	83 e0 02             	and    $0x2,%eax
  81bc45:	85 c0                	test   %eax,%eax
  81bc47:	74 07                	je     81bc50 <tcp_input+0x3aa>
  81bc49:	b8 01 00 00 00       	mov    $0x1,%eax
  81bc4e:	eb 05                	jmp    81bc55 <tcp_input+0x3af>
  81bc50:	b8 00 00 00 00       	mov    $0x0,%eax
  81bc55:	01 c2                	add    %eax,%edx
  81bc57:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81bc5e:	00 00 00 
  81bc61:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81bc64:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81bc6b:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81bc6c:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81bc73:	00 00 00 
  81bc76:	48 8b 00             	mov    (%rax),%rax
  81bc79:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81bc7d:	e9 e4 01 00 00       	jmpq   81be66 <tcp_input+0x5c0>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81bc82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc86:	8b 40 18             	mov    0x18(%rax),%eax
  81bc89:	85 c0                	test   %eax,%eax
  81bc8b:	75 2a                	jne    81bcb7 <tcp_input+0x411>
  81bc8d:	48 ba 40 2d 82 00 00 	movabs $0x822d40,%rdx
  81bc94:	00 00 00 
  81bc97:	be b5 00 00 00       	mov    $0xb5,%esi
  81bc9c:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81bca3:	00 00 00 
  81bca6:	b8 00 00 00 00       	mov    $0x0,%eax
  81bcab:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81bcb2:	00 00 00 
  81bcb5:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81bcb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcbb:	8b 40 18             	mov    0x18(%rax),%eax
  81bcbe:	83 f8 0a             	cmp    $0xa,%eax
  81bcc1:	75 2a                	jne    81bced <tcp_input+0x447>
  81bcc3:	48 ba 80 2d 82 00 00 	movabs $0x822d80,%rdx
  81bcca:	00 00 00 
  81bccd:	be b6 00 00 00       	mov    $0xb6,%esi
  81bcd2:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81bcd9:	00 00 00 
  81bcdc:	b8 00 00 00 00       	mov    $0x0,%eax
  81bce1:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81bce8:	00 00 00 
  81bceb:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81bced:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcf1:	8b 40 18             	mov    0x18(%rax),%eax
  81bcf4:	83 f8 01             	cmp    $0x1,%eax
  81bcf7:	75 2a                	jne    81bd23 <tcp_input+0x47d>
  81bcf9:	48 ba b0 2d 82 00 00 	movabs $0x822db0,%rdx
  81bd00:	00 00 00 
  81bd03:	be b7 00 00 00       	mov    $0xb7,%esi
  81bd08:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81bd0f:	00 00 00 
  81bd12:	b8 00 00 00 00       	mov    $0x0,%eax
  81bd17:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81bd1e:	00 00 00 
  81bd21:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81bd23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd27:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81bd2b:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bd32:	00 00 00 
  81bd35:	48 8b 00             	mov    (%rax),%rax
  81bd38:	0f b7 00             	movzwl (%rax),%eax
  81bd3b:	66 39 c2             	cmp    %ax,%dx
  81bd3e:	0f 85 0e 01 00 00    	jne    81be52 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
  81bd44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd48:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81bd4c:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bd53:	00 00 00 
  81bd56:	48 8b 00             	mov    (%rax),%rax
  81bd59:	0f b7 40 02          	movzwl 0x2(%rax),%eax
    if (pcb->remote_port == tcphdr->src &&
  81bd5d:	66 39 c2             	cmp    %ax,%dx
  81bd60:	0f 85 ec 00 00 00    	jne    81be52 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81bd66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd6a:	8b 50 04             	mov    0x4(%rax),%edx
  81bd6d:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81bd74:	00 00 00 
  81bd77:	48 8b 00             	mov    (%rax),%rax
  81bd7a:	8b 40 0c             	mov    0xc(%rax),%eax
       pcb->local_port == tcphdr->dest &&
  81bd7d:	39 c2                	cmp    %eax,%edx
  81bd7f:	0f 85 cd 00 00 00    	jne    81be52 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81bd85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd89:	8b 10                	mov    (%rax),%edx
  81bd8b:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81bd92:	00 00 00 
  81bd95:	48 8b 00             	mov    (%rax),%rax
  81bd98:	8b 40 10             	mov    0x10(%rax),%eax
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81bd9b:	39 c2                	cmp    %eax,%edx
  81bd9d:	0f 85 af 00 00 00    	jne    81be52 <tcp_input+0x5ac>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81bda3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bda7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bdab:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81bdaf:	75 2a                	jne    81bddb <tcp_input+0x535>
  81bdb1:	48 ba d8 2d 82 00 00 	movabs $0x822dd8,%rdx
  81bdb8:	00 00 00 
  81bdbb:	be c0 00 00 00       	mov    $0xc0,%esi
  81bdc0:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81bdc7:	00 00 00 
  81bdca:	b8 00 00 00 00       	mov    $0x0,%eax
  81bdcf:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81bdd6:	00 00 00 
  81bdd9:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81bddb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81bde0:	74 36                	je     81be18 <tcp_input+0x572>
        prev->next = pcb->next;
  81bde2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bde6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bdea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81bdee:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81bdf2:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81bdf9:	00 00 00 
  81bdfc:	48 8b 10             	mov    (%rax),%rdx
  81bdff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be03:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81be07:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81be0e:	00 00 00 
  81be11:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81be15:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81be18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be1c:	48 8b 40 10          	mov    0x10(%rax),%rax
  81be20:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81be24:	75 2a                	jne    81be50 <tcp_input+0x5aa>
  81be26:	48 ba 08 2e 82 00 00 	movabs $0x822e08,%rdx
  81be2d:	00 00 00 
  81be30:	be c6 00 00 00       	mov    $0xc6,%esi
  81be35:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81be3c:	00 00 00 
  81be3f:	b8 00 00 00 00       	mov    $0x0,%eax
  81be44:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81be4b:	00 00 00 
  81be4e:	ff d1                	callq  *%rcx
      break;
  81be50:	eb 1f                	jmp    81be71 <tcp_input+0x5cb>
    }
    prev = pcb;
  81be52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be56:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81be5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be5e:	48 8b 40 10          	mov    0x10(%rax),%rax
  81be62:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81be66:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81be6b:	0f 85 11 fe ff ff    	jne    81bc82 <tcp_input+0x3dc>
  }

  if (pcb == NULL) {
  81be71:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81be76:	0f 85 f2 01 00 00    	jne    81c06e <tcp_input+0x7c8>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81be7c:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81be83:	00 00 00 
  81be86:	48 8b 00             	mov    (%rax),%rax
  81be89:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81be8d:	e9 dd 00 00 00       	jmpq   81bf6f <tcp_input+0x6c9>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81be92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be96:	8b 40 18             	mov    0x18(%rax),%eax
  81be99:	83 f8 0a             	cmp    $0xa,%eax
  81be9c:	74 2a                	je     81bec8 <tcp_input+0x622>
  81be9e:	48 ba 38 2e 82 00 00 	movabs $0x822e38,%rdx
  81bea5:	00 00 00 
  81bea8:	be d0 00 00 00       	mov    $0xd0,%esi
  81bead:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81beb4:	00 00 00 
  81beb7:	b8 00 00 00 00       	mov    $0x0,%eax
  81bebc:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81bec3:	00 00 00 
  81bec6:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81bec8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81becc:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81bed0:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bed7:	00 00 00 
  81beda:	48 8b 00             	mov    (%rax),%rax
  81bedd:	0f b7 00             	movzwl (%rax),%eax
  81bee0:	66 39 c2             	cmp    %ax,%dx
  81bee3:	75 7e                	jne    81bf63 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
  81bee5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bee9:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81beed:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bef4:	00 00 00 
  81bef7:	48 8b 00             	mov    (%rax),%rax
  81befa:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      if (pcb->remote_port == tcphdr->src &&
  81befe:	66 39 c2             	cmp    %ax,%dx
  81bf01:	75 60                	jne    81bf63 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81bf03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf07:	8b 50 04             	mov    0x4(%rax),%edx
  81bf0a:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81bf11:	00 00 00 
  81bf14:	48 8b 00             	mov    (%rax),%rax
  81bf17:	8b 40 0c             	mov    0xc(%rax),%eax
         pcb->local_port == tcphdr->dest &&
  81bf1a:	39 c2                	cmp    %eax,%edx
  81bf1c:	75 45                	jne    81bf63 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81bf1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf22:	8b 10                	mov    (%rax),%edx
  81bf24:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81bf2b:	00 00 00 
  81bf2e:	48 8b 00             	mov    (%rax),%rax
  81bf31:	8b 40 10             	mov    0x10(%rax),%eax
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81bf34:	39 c2                	cmp    %eax,%edx
  81bf36:	75 2b                	jne    81bf63 <tcp_input+0x6bd>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81bf38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf3c:	48 89 c7             	mov    %rax,%rdi
  81bf3f:	48 b8 7a c8 81 00 00 	movabs $0x81c87a,%rax
  81bf46:	00 00 00 
  81bf49:	ff d0                	callq  *%rax
        pbuf_free(p);
  81bf4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bf4f:	48 89 c7             	mov    %rax,%rdi
  81bf52:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81bf59:	00 00 00 
  81bf5c:	ff d0                	callq  *%rax
        return;
  81bf5e:	e9 0c 06 00 00       	jmpq   81c56f <tcp_input+0xcc9>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81bf63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf67:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bf6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81bf6f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81bf74:	0f 85 18 ff ff ff    	jne    81be92 <tcp_input+0x5ec>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81bf7a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81bf81:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81bf82:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  81bf89:	00 00 00 
  81bf8c:	48 8b 00             	mov    (%rax),%rax
  81bf8f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81bf93:	e9 cb 00 00 00       	jmpq   81c063 <tcp_input+0x7bd>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81bf98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf9c:	48 85 c0             	test   %rax,%rax
  81bf9f:	74 28                	je     81bfc9 <tcp_input+0x723>
  81bfa1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfa5:	8b 00                	mov    (%rax),%eax
  81bfa7:	85 c0                	test   %eax,%eax
  81bfa9:	74 1e                	je     81bfc9 <tcp_input+0x723>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81bfab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfaf:	8b 10                	mov    (%rax),%edx
  81bfb1:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81bfb8:	00 00 00 
  81bfbb:	48 8b 00             	mov    (%rax),%rax
  81bfbe:	8b 40 10             	mov    0x10(%rax),%eax
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81bfc1:	39 c2                	cmp    %eax,%edx
  81bfc3:	0f 85 86 00 00 00    	jne    81c04f <tcp_input+0x7a9>
        lpcb->local_port == tcphdr->dest) {
  81bfc9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfcd:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81bfd1:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81bfd8:	00 00 00 
  81bfdb:	48 8b 00             	mov    (%rax),%rax
  81bfde:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81bfe2:	66 39 c2             	cmp    %ax,%dx
  81bfe5:	75 68                	jne    81c04f <tcp_input+0x7a9>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81bfe7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81bfec:	74 36                	je     81c024 <tcp_input+0x77e>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81bfee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bff2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bff6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81bffa:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81bffe:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  81c005:	00 00 00 
  81c008:	48 8b 10             	mov    (%rax),%rdx
  81c00b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c00f:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81c013:	48 b8 20 a0 b5 00 00 	movabs $0xb5a020,%rax
  81c01a:	00 00 00 
  81c01d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81c021:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81c024:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c028:	48 89 c7             	mov    %rax,%rdi
  81c02b:	48 b8 76 c5 81 00 00 	movabs $0x81c576,%rax
  81c032:	00 00 00 
  81c035:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c037:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c03b:	48 89 c7             	mov    %rax,%rdi
  81c03e:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81c045:	00 00 00 
  81c048:	ff d0                	callq  *%rax
        return;
  81c04a:	e9 20 05 00 00       	jmpq   81c56f <tcp_input+0xcc9>
      }
      prev = (struct tcp_pcb *)lpcb;
  81c04f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c053:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c057:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c05b:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c05f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c063:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81c068:	0f 85 2a ff ff ff    	jne    81bf98 <tcp_input+0x6f2>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81c06e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c073:	0f 84 2b 04 00 00    	je     81c4a4 <tcp_input+0xbfe>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81c079:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c080:	00 00 00 
  81c083:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81c08a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c08e:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c092:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c099:	00 00 00 
  81c09c:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81c0a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c0a4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c0a8:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c0af:	00 00 00 
  81c0b2:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81c0b6:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c0bd:	00 00 00 
  81c0c0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81c0c4:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81c0c8:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c0cf:	00 00 00 
  81c0d2:	48 8b 10             	mov    (%rax),%rdx
  81c0d5:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c0dc:	00 00 00 
  81c0df:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81c0e3:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81c0ea:	00 00 00 
  81c0ed:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81c0f4:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81c0fb:	00 00 00 
  81c0fe:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81c101:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c105:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c10c:	48 85 c0             	test   %rax,%rax
  81c10f:	0f 84 9b 00 00 00    	je     81c1b0 <tcp_input+0x90a>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81c115:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c119:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c120:	48 85 c0             	test   %rax,%rax
  81c123:	74 2e                	je     81c153 <tcp_input+0x8ad>
  81c125:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c129:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c130:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c134:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  81c13b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81c13f:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81c143:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c147:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c14c:	ff d0                	callq  *%rax
  81c14e:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c151:	eb 2e                	jmp    81c181 <tcp_input+0x8db>
  81c153:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81c157:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c15b:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c162:	48 85 c0             	test   %rax,%rax
  81c165:	74 1a                	je     81c181 <tcp_input+0x8db>
  81c167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c16b:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c172:	48 89 c7             	mov    %rax,%rdi
  81c175:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81c17c:	00 00 00 
  81c17f:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81c181:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c185:	75 11                	jne    81c198 <tcp_input+0x8f2>
        pcb->refused_data = NULL;
  81c187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c18b:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81c192:	00 00 00 00 
  81c196:	eb 18                	jmp    81c1b0 <tcp_input+0x90a>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81c198:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c19c:	48 89 c7             	mov    %rax,%rdi
  81c19f:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81c1a6:	00 00 00 
  81c1a9:	ff d0                	callq  *%rax
        return;
  81c1ab:	e9 bf 03 00 00       	jmpq   81c56f <tcp_input+0xcc9>
      }
    }

    tcp_input_pcb = pcb;
  81c1b0:	48 b8 48 a0 b5 00 00 	movabs $0xb5a048,%rax
  81c1b7:	00 00 00 
  81c1ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c1be:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81c1c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c1c5:	48 89 c7             	mov    %rax,%rdi
  81c1c8:	48 b8 26 c9 81 00 00 	movabs $0x81c926,%rax
  81c1cf:	00 00 00 
  81c1d2:	ff d0                	callq  *%rax
  81c1d4:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81c1d7:	48 b8 48 a0 b5 00 00 	movabs $0xb5a048,%rax
  81c1de:	00 00 00 
  81c1e1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81c1e8:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81c1ec:	0f 84 67 02 00 00    	je     81c459 <tcp_input+0xbb3>
      if (recv_flags & TF_RESET) {
  81c1f2:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81c1f9:	00 00 00 
  81c1fc:	0f b6 00             	movzbl (%rax),%eax
  81c1ff:	0f b6 c0             	movzbl %al,%eax
  81c202:	83 e0 08             	and    $0x8,%eax
  81c205:	85 c0                	test   %eax,%eax
  81c207:	74 67                	je     81c270 <tcp_input+0x9ca>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81c209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c20d:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81c214:	48 85 c0             	test   %rax,%rax
  81c217:	74 1d                	je     81c236 <tcp_input+0x990>
  81c219:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c21d:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81c224:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c228:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81c22c:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81c231:	48 89 d7             	mov    %rdx,%rdi
  81c234:	ff d0                	callq  *%rax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81c236:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c23a:	48 89 c6             	mov    %rax,%rsi
  81c23d:	48 bf 10 a0 b5 00 00 	movabs $0xb5a010,%rdi
  81c244:	00 00 00 
  81c247:	48 b8 bf fe 80 00 00 	movabs $0x80febf,%rax
  81c24e:	00 00 00 
  81c251:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81c253:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c257:	48 89 c6             	mov    %rax,%rsi
  81c25a:	bf 02 00 00 00       	mov    $0x2,%edi
  81c25f:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81c266:	00 00 00 
  81c269:	ff d0                	callq  *%rax
  81c26b:	e9 e9 01 00 00       	jmpq   81c459 <tcp_input+0xbb3>
      } else if (recv_flags & TF_CLOSED) {
  81c270:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81c277:	00 00 00 
  81c27a:	0f b6 00             	movzbl (%rax),%eax
  81c27d:	0f b6 c0             	movzbl %al,%eax
  81c280:	83 e0 10             	and    $0x10,%eax
  81c283:	85 c0                	test   %eax,%eax
  81c285:	74 3a                	je     81c2c1 <tcp_input+0xa1b>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81c287:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c28b:	48 89 c6             	mov    %rax,%rsi
  81c28e:	48 bf 10 a0 b5 00 00 	movabs $0xb5a010,%rdi
  81c295:	00 00 00 
  81c298:	48 b8 bf fe 80 00 00 	movabs $0x80febf,%rax
  81c29f:	00 00 00 
  81c2a2:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81c2a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c2a8:	48 89 c6             	mov    %rax,%rsi
  81c2ab:	bf 02 00 00 00       	mov    $0x2,%edi
  81c2b0:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81c2b7:	00 00 00 
  81c2ba:	ff d0                	callq  *%rax
  81c2bc:	e9 98 01 00 00       	jmpq   81c459 <tcp_input+0xbb3>
      } else {
        err = ERR_OK;
  81c2c1:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81c2c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c2c9:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81c2cd:	66 85 c0             	test   %ax,%ax
  81c2d0:	74 3a                	je     81c30c <tcp_input+0xa66>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81c2d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c2d6:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81c2dd:	48 85 c0             	test   %rax,%rax
  81c2e0:	74 2a                	je     81c30c <tcp_input+0xa66>
  81c2e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c2e6:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81c2ed:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c2f1:	0f b7 52 78          	movzwl 0x78(%rdx),%edx
  81c2f5:	0f b7 d2             	movzwl %dx,%edx
  81c2f8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81c2fc:	48 8b 49 20          	mov    0x20(%rcx),%rcx
  81c300:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c304:	48 89 cf             	mov    %rcx,%rdi
  81c307:	ff d0                	callq  *%rax
  81c309:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81c30c:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81c313:	00 00 00 
  81c316:	48 8b 00             	mov    (%rax),%rax
  81c319:	48 85 c0             	test   %rax,%rax
  81c31c:	0f 84 cb 00 00 00    	je     81c3ed <tcp_input+0xb47>
          if(flags & TCP_PSH) {
  81c322:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81c329:	00 00 00 
  81c32c:	0f b6 00             	movzbl (%rax),%eax
  81c32f:	0f b6 c0             	movzbl %al,%eax
  81c332:	83 e0 08             	and    $0x8,%eax
  81c335:	85 c0                	test   %eax,%eax
  81c337:	74 24                	je     81c35d <tcp_input+0xab7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81c339:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81c340:	00 00 00 
  81c343:	48 8b 00             	mov    (%rax),%rax
  81c346:	48 ba 88 65 b5 00 00 	movabs $0xb56588,%rdx
  81c34d:	00 00 00 
  81c350:	48 8b 12             	mov    (%rdx),%rdx
  81c353:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81c357:	83 ca 01             	or     $0x1,%edx
  81c35a:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81c35d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c361:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c368:	48 85 c0             	test   %rax,%rax
  81c36b:	74 30                	je     81c39d <tcp_input+0xaf7>
  81c36d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c371:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c378:	48 ba 88 65 b5 00 00 	movabs $0xb56588,%rdx
  81c37f:	00 00 00 
  81c382:	48 8b 12             	mov    (%rdx),%rdx
  81c385:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81c389:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81c38d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c391:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c396:	ff d0                	callq  *%rax
  81c398:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c39b:	eb 32                	jmp    81c3cf <tcp_input+0xb29>
  81c39d:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81c3a1:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81c3a8:	00 00 00 
  81c3ab:	48 8b 00             	mov    (%rax),%rax
  81c3ae:	48 85 c0             	test   %rax,%rax
  81c3b1:	74 1c                	je     81c3cf <tcp_input+0xb29>
  81c3b3:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81c3ba:	00 00 00 
  81c3bd:	48 8b 00             	mov    (%rax),%rax
  81c3c0:	48 89 c7             	mov    %rax,%rdi
  81c3c3:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81c3ca:	00 00 00 
  81c3cd:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81c3cf:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c3d3:	74 18                	je     81c3ed <tcp_input+0xb47>
            pcb->refused_data = recv_data;
  81c3d5:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81c3dc:	00 00 00 
  81c3df:	48 8b 10             	mov    (%rax),%rdx
  81c3e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c3e6:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81c3ed:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81c3f4:	00 00 00 
  81c3f7:	0f b6 00             	movzbl (%rax),%eax
  81c3fa:	0f b6 c0             	movzbl %al,%eax
  81c3fd:	83 e0 20             	and    $0x20,%eax
  81c400:	85 c0                	test   %eax,%eax
  81c402:	74 3c                	je     81c440 <tcp_input+0xb9a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81c404:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c408:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c40f:	48 85 c0             	test   %rax,%rax
  81c412:	74 28                	je     81c43c <tcp_input+0xb96>
  81c414:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c418:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c41f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c423:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
  81c427:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c42b:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c430:	ba 00 00 00 00       	mov    $0x0,%edx
  81c435:	ff d0                	callq  *%rax
  81c437:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c43a:	eb 04                	jmp    81c440 <tcp_input+0xb9a>
  81c43c:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81c440:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c444:	75 13                	jne    81c459 <tcp_input+0xbb3>
          tcp_output(pcb);
  81c446:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c44a:	48 89 c7             	mov    %rax,%rdi
  81c44d:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81c454:	00 00 00 
  81c457:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81c459:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c460:	00 00 00 
  81c463:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c467:	48 85 c0             	test   %rax,%rax
  81c46a:	0f 84 ff 00 00 00    	je     81c56f <tcp_input+0xcc9>
    {
      pbuf_free(inseg.p);
  81c470:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c477:	00 00 00 
  81c47a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c47e:	48 89 c7             	mov    %rax,%rdi
  81c481:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81c488:	00 00 00 
  81c48b:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81c48d:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81c494:	00 00 00 
  81c497:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81c49e:	00 
  81c49f:	e9 cb 00 00 00       	jmpq   81c56f <tcp_input+0xcc9>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81c4a4:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c4ab:	00 00 00 
  81c4ae:	48 8b 00             	mov    (%rax),%rax
  81c4b1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c4b5:	0f b7 c0             	movzwl %ax,%eax
  81c4b8:	89 c7                	mov    %eax,%edi
  81c4ba:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81c4c1:	00 00 00 
  81c4c4:	ff d0                	callq  *%rax
  81c4c6:	0f b7 c0             	movzwl %ax,%eax
  81c4c9:	83 e0 04             	and    $0x4,%eax
  81c4cc:	85 c0                	test   %eax,%eax
  81c4ce:	0f 85 88 00 00 00    	jne    81c55c <tcp_input+0xcb6>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81c4d4:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c4db:	00 00 00 
  81c4de:	48 8b 00             	mov    (%rax),%rax
  81c4e1:	0f b7 00             	movzwl (%rax),%eax
      tcp_rst(ackno, seqno + tcplen,
  81c4e4:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81c4e8:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c4ef:	00 00 00 
  81c4f2:	48 8b 00             	mov    (%rax),%rax
  81c4f5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_rst(ackno, seqno + tcplen,
  81c4f9:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81c4fc:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c503:	00 00 00 
  81c506:	48 8b 00             	mov    (%rax),%rax
      tcp_rst(ackno, seqno + tcplen,
  81c509:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81c50d:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c514:	00 00 00 
  81c517:	48 8b 00             	mov    (%rax),%rax
      tcp_rst(ackno, seqno + tcplen,
  81c51a:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c51e:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81c525:	00 00 00 
  81c528:	0f b7 00             	movzwl (%rax),%eax
  81c52b:	0f b7 f0             	movzwl %ax,%esi
  81c52e:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c535:	00 00 00 
  81c538:	8b 00                	mov    (%rax),%eax
  81c53a:	01 c6                	add    %eax,%esi
  81c53c:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81c543:	00 00 00 
  81c546:	8b 00                	mov    (%rax),%eax
  81c548:	45 89 c1             	mov    %r8d,%r9d
  81c54b:	41 89 f8             	mov    %edi,%r8d
  81c54e:	89 c7                	mov    %eax,%edi
  81c550:	48 b8 a6 39 81 00 00 	movabs $0x8139a6,%rax
  81c557:	00 00 00 
  81c55a:	ff d0                	callq  *%rax
    }
    pbuf_free(p);
  81c55c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c560:	48 89 c7             	mov    %rax,%rdi
  81c563:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81c56a:	00 00 00 
  81c56d:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81c56f:	48 83 c4 38          	add    $0x38,%rsp
  81c573:	5b                   	pop    %rbx
  81c574:	5d                   	pop    %rbp
  81c575:	c3                   	retq   

000000000081c576 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81c576:	55                   	push   %rbp
  81c577:	48 89 e5             	mov    %rsp,%rbp
  81c57a:	48 83 ec 20          	sub    $0x20,%rsp
  81c57e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81c582:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81c589:	00 00 00 
  81c58c:	0f b6 00             	movzbl (%rax),%eax
  81c58f:	0f b6 c0             	movzbl %al,%eax
  81c592:	83 e0 10             	and    $0x10,%eax
  81c595:	85 c0                	test   %eax,%eax
  81c597:	0f 84 90 00 00 00    	je     81c62d <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81c59d:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c5a4:	00 00 00 
  81c5a7:	48 8b 00             	mov    (%rax),%rax
  81c5aa:	0f b7 00             	movzwl (%rax),%eax
    tcp_rst(ackno + 1, seqno + tcplen,
  81c5ad:	44 0f b7 c0          	movzwl %ax,%r8d
      tcphdr->dest, tcphdr->src);
  81c5b1:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c5b8:	00 00 00 
  81c5bb:	48 8b 00             	mov    (%rax),%rax
  81c5be:	0f b7 40 02          	movzwl 0x2(%rax),%eax
    tcp_rst(ackno + 1, seqno + tcplen,
  81c5c2:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81c5c5:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c5cc:	00 00 00 
  81c5cf:	48 8b 00             	mov    (%rax),%rax
    tcp_rst(ackno + 1, seqno + tcplen,
  81c5d2:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81c5d6:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c5dd:	00 00 00 
  81c5e0:	48 8b 00             	mov    (%rax),%rax
    tcp_rst(ackno + 1, seqno + tcplen,
  81c5e3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c5e7:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81c5ee:	00 00 00 
  81c5f1:	0f b7 00             	movzwl (%rax),%eax
  81c5f4:	0f b7 f0             	movzwl %ax,%esi
  81c5f7:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c5fe:	00 00 00 
  81c601:	8b 00                	mov    (%rax),%eax
  81c603:	01 c6                	add    %eax,%esi
  81c605:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81c60c:	00 00 00 
  81c60f:	8b 00                	mov    (%rax),%eax
  81c611:	83 c0 01             	add    $0x1,%eax
  81c614:	45 89 c1             	mov    %r8d,%r9d
  81c617:	41 89 f8             	mov    %edi,%r8d
  81c61a:	89 c7                	mov    %eax,%edi
  81c61c:	48 b8 a6 39 81 00 00 	movabs $0x8139a6,%rax
  81c623:	00 00 00 
  81c626:	ff d0                	callq  *%rax
  81c628:	e9 46 02 00 00       	jmpq   81c873 <tcp_listen_input+0x2fd>
  } else if (flags & TCP_SYN) {
  81c62d:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81c634:	00 00 00 
  81c637:	0f b6 00             	movzbl (%rax),%eax
  81c63a:	0f b6 c0             	movzbl %al,%eax
  81c63d:	83 e0 02             	and    $0x2,%eax
  81c640:	85 c0                	test   %eax,%eax
  81c642:	0f 84 2b 02 00 00    	je     81c873 <tcp_listen_input+0x2fd>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81c648:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c64c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81c650:	0f b6 c0             	movzbl %al,%eax
  81c653:	89 c7                	mov    %eax,%edi
  81c655:	48 b8 2a fb 80 00 00 	movabs $0x80fb2a,%rax
  81c65c:	00 00 00 
  81c65f:	ff d0                	callq  *%rax
  81c661:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81c665:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81c66a:	75 0a                	jne    81c676 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81c66c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81c671:	e9 02 02 00 00       	jmpq   81c878 <tcp_listen_input+0x302>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81c676:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c67d:	00 00 00 
  81c680:	48 8b 00             	mov    (%rax),%rax
  81c683:	48 83 c0 10          	add    $0x10,%rax
  81c687:	48 85 c0             	test   %rax,%rax
  81c68a:	74 12                	je     81c69e <tcp_listen_input+0x128>
  81c68c:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c693:	00 00 00 
  81c696:	48 8b 00             	mov    (%rax),%rax
  81c699:	8b 40 10             	mov    0x10(%rax),%eax
  81c69c:	eb 05                	jmp    81c6a3 <tcp_listen_input+0x12d>
  81c69e:	b8 00 00 00 00       	mov    $0x0,%eax
  81c6a3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c6a7:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81c6a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6ad:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c6b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c6b5:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81c6b9:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c6c0:	00 00 00 
  81c6c3:	48 8b 00             	mov    (%rax),%rax
  81c6c6:	48 83 c0 0c          	add    $0xc,%rax
  81c6ca:	48 85 c0             	test   %rax,%rax
  81c6cd:	74 12                	je     81c6e1 <tcp_listen_input+0x16b>
  81c6cf:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81c6d6:	00 00 00 
  81c6d9:	48 8b 00             	mov    (%rax),%rax
  81c6dc:	8b 40 0c             	mov    0xc(%rax),%eax
  81c6df:	eb 05                	jmp    81c6e6 <tcp_listen_input+0x170>
  81c6e1:	b8 00 00 00 00       	mov    $0x0,%eax
  81c6e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c6ea:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81c6ed:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c6f4:	00 00 00 
  81c6f7:	48 8b 00             	mov    (%rax),%rax
  81c6fa:	0f b7 10             	movzwl (%rax),%edx
  81c6fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c701:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81c705:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c709:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81c710:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c717:	00 00 00 
  81c71a:	8b 00                	mov    (%rax),%eax
  81c71c:	8d 50 01             	lea    0x1(%rax),%edx
  81c71f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c723:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81c726:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81c72d:	00 00 00 
  81c730:	48 8b 00             	mov    (%rax),%rax
  81c733:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81c737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c73b:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81c73f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c743:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81c747:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c74b:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81c74f:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c756:	00 00 00 
  81c759:	8b 00                	mov    (%rax),%eax
  81c75b:	8d 50 ff             	lea    -0x1(%rax),%edx
  81c75e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c762:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81c765:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c769:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81c76d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c771:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81c775:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c779:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81c77d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c781:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81c788:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c78c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81c790:	66 25 99 01          	and    $0x199,%ax
  81c794:	89 c2                	mov    %eax,%edx
  81c796:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c79a:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81c79e:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81c7a5:	00 00 00 
  81c7a8:	48 8b 10             	mov    (%rax),%rdx
  81c7ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c7af:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81c7b3:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81c7ba:	00 00 00 
  81c7bd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c7c1:	48 89 10             	mov    %rdx,(%rax)
  81c7c4:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  81c7cb:	00 00 00 
  81c7ce:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81c7d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c7d4:	48 89 c7             	mov    %rax,%rdi
  81c7d7:	48 b8 5b f0 81 00 00 	movabs $0x81f05b,%rax
  81c7de:	00 00 00 
  81c7e1:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81c7e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c7e7:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81c7eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c7ef:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81c7f3:	0f b7 c0             	movzwl %ax,%eax
  81c7f6:	48 89 d6             	mov    %rdx,%rsi
  81c7f9:	89 c7                	mov    %eax,%edi
  81c7fb:	48 b8 f4 00 81 00 00 	movabs $0x8100f4,%rax
  81c802:	00 00 00 
  81c805:	ff d0                	callq  *%rax
  81c807:	89 c2                	mov    %eax,%edx
  81c809:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c80d:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81c811:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81c816:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  81c81d:	00 00 00 
  81c820:	ff d0                	callq  *%rax
  81c822:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81c825:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81c829:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c82d:	48 83 ec 08          	sub    $0x8,%rsp
  81c831:	6a 04                	pushq  $0x4
  81c833:	49 89 d1             	mov    %rdx,%r9
  81c836:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81c83c:	b9 12 00 00 00       	mov    $0x12,%ecx
  81c841:	ba 00 00 00 00       	mov    $0x0,%edx
  81c846:	be 00 00 00 00       	mov    $0x0,%esi
  81c84b:	48 89 c7             	mov    %rax,%rdi
  81c84e:	48 b8 c9 25 81 00 00 	movabs $0x8125c9,%rax
  81c855:	00 00 00 
  81c858:	ff d0                	callq  *%rax
  81c85a:	48 83 c4 10          	add    $0x10,%rsp
    return tcp_output(npcb);
  81c85e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c862:	48 89 c7             	mov    %rax,%rdi
  81c865:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81c86c:	00 00 00 
  81c86f:	ff d0                	callq  *%rax
  81c871:	eb 05                	jmp    81c878 <tcp_listen_input+0x302>
  }
  return ERR_OK;
  81c873:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81c878:	c9                   	leaveq 
  81c879:	c3                   	retq   

000000000081c87a <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81c87a:	55                   	push   %rbp
  81c87b:	48 89 e5             	mov    %rsp,%rbp
  81c87e:	48 83 ec 10          	sub    $0x10,%rsp
  81c882:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81c886:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81c88d:	00 00 00 
  81c890:	0f b7 00             	movzwl (%rax),%eax
  81c893:	0f b7 d0             	movzwl %ax,%edx
  81c896:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c89d:	00 00 00 
  81c8a0:	8b 00                	mov    (%rax),%eax
  81c8a2:	01 c2                	add    %eax,%edx
  81c8a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c8a8:	8b 40 30             	mov    0x30(%rax),%eax
  81c8ab:	29 c2                	sub    %eax,%edx
  81c8ad:	89 d0                	mov    %edx,%eax
  81c8af:	85 c0                	test   %eax,%eax
  81c8b1:	7e 25                	jle    81c8d8 <tcp_timewait_input+0x5e>
    pcb->rcv_nxt = seqno + tcplen;
  81c8b3:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81c8ba:	00 00 00 
  81c8bd:	0f b7 00             	movzwl (%rax),%eax
  81c8c0:	0f b7 d0             	movzwl %ax,%edx
  81c8c3:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c8ca:	00 00 00 
  81c8cd:	8b 00                	mov    (%rax),%eax
  81c8cf:	01 c2                	add    %eax,%edx
  81c8d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c8d5:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81c8d8:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81c8df:	00 00 00 
  81c8e2:	0f b7 00             	movzwl (%rax),%eax
  81c8e5:	66 85 c0             	test   %ax,%ax
  81c8e8:	74 27                	je     81c911 <tcp_timewait_input+0x97>
    tcp_ack_now(pcb);
  81c8ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c8ee:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81c8f2:	83 c8 02             	or     $0x2,%eax
  81c8f5:	89 c2                	mov    %eax,%edx
  81c8f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c8fb:	88 50 2c             	mov    %dl,0x2c(%rax)
  81c8fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c902:	48 89 c7             	mov    %rax,%rdi
  81c905:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81c90c:	00 00 00 
  81c90f:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81c911:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c915:	48 89 c7             	mov    %rax,%rdi
  81c918:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81c91f:	00 00 00 
  81c922:	ff d0                	callq  *%rax
}
  81c924:	c9                   	leaveq 
  81c925:	c3                   	retq   

000000000081c926 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81c926:	55                   	push   %rbp
  81c927:	48 89 e5             	mov    %rsp,%rbp
  81c92a:	48 83 ec 20          	sub    $0x20,%rsp
  81c92e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81c932:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81c936:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81c93a:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81c941:	00 00 00 
  81c944:	0f b6 00             	movzbl (%rax),%eax
  81c947:	0f b6 c0             	movzbl %al,%eax
  81c94a:	83 e0 04             	and    $0x4,%eax
  81c94d:	85 c0                	test   %eax,%eax
  81c94f:	0f 84 e0 00 00 00    	je     81ca35 <tcp_process+0x10f>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81c955:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c959:	8b 40 18             	mov    0x18(%rax),%eax
  81c95c:	83 f8 02             	cmp    $0x2,%eax
  81c95f:	75 1d                	jne    81c97e <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81c961:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c965:	8b 50 60             	mov    0x60(%rax),%edx
  81c968:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81c96f:	00 00 00 
  81c972:	8b 00                	mov    (%rax),%eax
  81c974:	39 c2                	cmp    %eax,%edx
  81c976:	75 4d                	jne    81c9c5 <tcp_process+0x9f>
        acceptable = 1;
  81c978:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81c97c:	eb 47                	jmp    81c9c5 <tcp_process+0x9f>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81c97e:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c985:	00 00 00 
  81c988:	8b 10                	mov    (%rax),%edx
  81c98a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c98e:	8b 40 30             	mov    0x30(%rax),%eax
  81c991:	29 c2                	sub    %eax,%edx
  81c993:	89 d0                	mov    %edx,%eax
  81c995:	85 c0                	test   %eax,%eax
  81c997:	78 2c                	js     81c9c5 <tcp_process+0x9f>
  81c999:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81c9a0:	00 00 00 
  81c9a3:	8b 10                	mov    (%rax),%edx
  81c9a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9a9:	8b 48 30             	mov    0x30(%rax),%ecx
  81c9ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9b0:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81c9b4:	0f b7 c0             	movzwl %ax,%eax
  81c9b7:	01 c8                	add    %ecx,%eax
  81c9b9:	29 c2                	sub    %eax,%edx
  81c9bb:	89 d0                	mov    %edx,%eax
  81c9bd:	85 c0                	test   %eax,%eax
  81c9bf:	7f 04                	jg     81c9c5 <tcp_process+0x9f>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81c9c1:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81c9c5:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81c9c9:	74 60                	je     81ca2b <tcp_process+0x105>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81c9cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9cf:	8b 40 18             	mov    0x18(%rax),%eax
  81c9d2:	85 c0                	test   %eax,%eax
  81c9d4:	75 2a                	jne    81ca00 <tcp_process+0xda>
  81c9d6:	48 ba 68 2e 82 00 00 	movabs $0x822e68,%rdx
  81c9dd:	00 00 00 
  81c9e0:	be 09 02 00 00       	mov    $0x209,%esi
  81c9e5:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81c9ec:	00 00 00 
  81c9ef:	b8 00 00 00 00       	mov    $0x0,%eax
  81c9f4:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81c9fb:	00 00 00 
  81c9fe:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81ca00:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81ca07:	00 00 00 
  81ca0a:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81ca0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca11:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ca15:	83 e0 fe             	and    $0xfffffffe,%eax
  81ca18:	89 c2                	mov    %eax,%edx
  81ca1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca1e:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81ca21:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81ca26:	e9 c9 0b 00 00       	jmpq   81d5f4 <tcp_process+0xcce>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81ca2b:	b8 00 00 00 00       	mov    $0x0,%eax
  81ca30:	e9 bf 0b 00 00       	jmpq   81d5f4 <tcp_process+0xcce>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81ca35:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  81ca3c:	00 00 00 
  81ca3f:	8b 10                	mov    (%rax),%edx
  81ca41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca45:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81ca48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca4c:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81ca53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca57:	8b 40 18             	mov    0x18(%rax),%eax
  81ca5a:	83 f8 09             	cmp    $0x9,%eax
  81ca5d:	0f 87 8b 0b 00 00    	ja     81d5ee <tcp_process+0xcc8>
  81ca63:	89 c0                	mov    %eax,%eax
  81ca65:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81ca6c:	00 
  81ca6d:	48 b8 b8 2e 82 00 00 	movabs $0x822eb8,%rax
  81ca74:	00 00 00 
  81ca77:	48 01 d0             	add    %rdx,%rax
  81ca7a:	48 8b 00             	mov    (%rax),%rax
  81ca7d:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81ca7f:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81ca86:	00 00 00 
  81ca89:	0f b6 00             	movzbl (%rax),%eax
  81ca8c:	0f b6 c0             	movzbl %al,%eax
  81ca8f:	83 e0 10             	and    $0x10,%eax
  81ca92:	85 c0                	test   %eax,%eax
  81ca94:	0f 84 5a 02 00 00    	je     81ccf4 <tcp_process+0x3ce>
  81ca9a:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81caa1:	00 00 00 
  81caa4:	0f b6 00             	movzbl (%rax),%eax
  81caa7:	0f b6 c0             	movzbl %al,%eax
  81caaa:	83 e0 02             	and    $0x2,%eax
  81caad:	85 c0                	test   %eax,%eax
  81caaf:	0f 84 3f 02 00 00    	je     81ccf4 <tcp_process+0x3ce>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81cab5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cab9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81cac0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81cac4:	8b 40 04             	mov    0x4(%rax),%eax
  81cac7:	89 c7                	mov    %eax,%edi
  81cac9:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81cad0:	00 00 00 
  81cad3:	ff d0                	callq  *%rax
  81cad5:	8d 50 01             	lea    0x1(%rax),%edx
  81cad8:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81cadf:	00 00 00 
  81cae2:	8b 00                	mov    (%rax),%eax
  81cae4:	39 c2                	cmp    %eax,%edx
  81cae6:	0f 85 08 02 00 00    	jne    81ccf4 <tcp_process+0x3ce>
      pcb->snd_buf++;
  81caec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81caf0:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81caf4:	8d 50 01             	lea    0x1(%rax),%edx
  81caf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cafb:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81caff:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81cb06:	00 00 00 
  81cb09:	8b 00                	mov    (%rax),%eax
  81cb0b:	8d 50 01             	lea    0x1(%rax),%edx
  81cb0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb12:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81cb15:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81cb1c:	00 00 00 
  81cb1f:	8b 10                	mov    (%rax),%edx
  81cb21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb25:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81cb28:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81cb2f:	00 00 00 
  81cb32:	48 8b 00             	mov    (%rax),%rax
  81cb35:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81cb39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb3d:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81cb41:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81cb48:	00 00 00 
  81cb4b:	8b 00                	mov    (%rax),%eax
  81cb4d:	8d 50 ff             	lea    -0x1(%rax),%edx
  81cb50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb54:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81cb57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb5b:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81cb62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb66:	48 89 c7             	mov    %rax,%rdi
  81cb69:	48 b8 5b f0 81 00 00 	movabs $0x81f05b,%rax
  81cb70:	00 00 00 
  81cb73:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81cb75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb79:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81cb7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb81:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cb85:	0f b7 c0             	movzwl %ax,%eax
  81cb88:	48 89 d6             	mov    %rdx,%rsi
  81cb8b:	89 c7                	mov    %eax,%edi
  81cb8d:	48 b8 f4 00 81 00 00 	movabs $0x8100f4,%rax
  81cb94:	00 00 00 
  81cb97:	ff d0                	callq  *%rax
  81cb99:	89 c2                	mov    %eax,%edx
  81cb9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb9f:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81cba3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cba7:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81cbab:	89 d0                	mov    %edx,%eax
  81cbad:	c1 e0 02             	shl    $0x2,%eax
  81cbb0:	01 d0                	add    %edx,%eax
  81cbb2:	01 c0                	add    %eax,%eax
  81cbb4:	89 c2                	mov    %eax,%edx
  81cbb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbba:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81cbbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbc2:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81cbc6:	66 83 f8 01          	cmp    $0x1,%ax
  81cbca:	75 0c                	jne    81cbd8 <tcp_process+0x2b2>
  81cbcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbd0:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cbd4:	01 c0                	add    %eax,%eax
  81cbd6:	eb 08                	jmp    81cbe0 <tcp_process+0x2ba>
  81cbd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbdc:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cbe0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cbe4:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81cbe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbec:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81cbf0:	66 85 c0             	test   %ax,%ax
  81cbf3:	75 2a                	jne    81cc1f <tcp_process+0x2f9>
  81cbf5:	48 ba 88 2e 82 00 00 	movabs $0x822e88,%rdx
  81cbfc:	00 00 00 
  81cbff:	be 35 02 00 00       	mov    $0x235,%esi
  81cc04:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81cc0b:	00 00 00 
  81cc0e:	b8 00 00 00 00       	mov    $0x0,%eax
  81cc13:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81cc1a:	00 00 00 
  81cc1d:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81cc1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc23:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81cc27:	8d 50 ff             	lea    -0x1(%rax),%edx
  81cc2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc2e:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81cc32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc36:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81cc3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81cc41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81cc45:	48 8b 10             	mov    (%rax),%rdx
  81cc48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc4c:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81cc53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc57:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81cc5e:	48 85 c0             	test   %rax,%rax
  81cc61:	75 0c                	jne    81cc6f <tcp_process+0x349>
        pcb->rtime = -1;
  81cc63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc67:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81cc6d:	eb 12                	jmp    81cc81 <tcp_process+0x35b>
      else {
        pcb->rtime = 0;
  81cc6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc73:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81cc79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc7d:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81cc81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81cc85:	48 89 c7             	mov    %rax,%rdi
  81cc88:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  81cc8f:	00 00 00 
  81cc92:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81cc94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc98:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81cc9f:	48 85 c0             	test   %rax,%rax
  81cca2:	74 24                	je     81ccc8 <tcp_process+0x3a2>
  81cca4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cca8:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81ccaf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ccb3:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81ccb7:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81ccbb:	ba 00 00 00 00       	mov    $0x0,%edx
  81ccc0:	48 89 cf             	mov    %rcx,%rdi
  81ccc3:	ff d0                	callq  *%rax
  81ccc5:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81ccc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cccc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ccd0:	83 c8 02             	or     $0x2,%eax
  81ccd3:	89 c2                	mov    %eax,%edx
  81ccd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ccd9:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ccdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cce0:	48 89 c7             	mov    %rax,%rdi
  81cce3:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81ccea:	00 00 00 
  81cced:	ff d0                	callq  *%rax
  81ccef:	e9 a8 00 00 00       	jmpq   81cd9c <tcp_process+0x476>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81ccf4:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81ccfb:	00 00 00 
  81ccfe:	0f b6 00             	movzbl (%rax),%eax
  81cd01:	0f b6 c0             	movzbl %al,%eax
  81cd04:	83 e0 10             	and    $0x10,%eax
  81cd07:	85 c0                	test   %eax,%eax
  81cd09:	0f 84 8d 00 00 00    	je     81cd9c <tcp_process+0x476>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cd0f:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81cd16:	00 00 00 
  81cd19:	48 8b 00             	mov    (%rax),%rax
  81cd1c:	0f b7 00             	movzwl (%rax),%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81cd1f:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81cd23:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81cd2a:	00 00 00 
  81cd2d:	48 8b 00             	mov    (%rax),%rax
  81cd30:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81cd34:	0f b7 f8             	movzwl %ax,%edi
  81cd37:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81cd3e:	00 00 00 
  81cd41:	48 8b 00             	mov    (%rax),%rax
  81cd44:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81cd48:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81cd4f:	00 00 00 
  81cd52:	48 8b 00             	mov    (%rax),%rax
  81cd55:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cd59:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81cd60:	00 00 00 
  81cd63:	0f b7 00             	movzwl (%rax),%eax
  81cd66:	0f b7 f0             	movzwl %ax,%esi
  81cd69:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81cd70:	00 00 00 
  81cd73:	8b 00                	mov    (%rax),%eax
  81cd75:	01 c6                	add    %eax,%esi
  81cd77:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81cd7e:	00 00 00 
  81cd81:	8b 00                	mov    (%rax),%eax
  81cd83:	45 89 c1             	mov    %r8d,%r9d
  81cd86:	41 89 f8             	mov    %edi,%r8d
  81cd89:	89 c7                	mov    %eax,%edi
  81cd8b:	48 b8 a6 39 81 00 00 	movabs $0x8139a6,%rax
  81cd92:	00 00 00 
  81cd95:	ff d0                	callq  *%rax
    }
    break;
  81cd97:	e9 53 08 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  81cd9c:	e9 4e 08 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81cda1:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81cda8:	00 00 00 
  81cdab:	0f b6 00             	movzbl (%rax),%eax
  81cdae:	0f b6 c0             	movzbl %al,%eax
  81cdb1:	83 e0 10             	and    $0x10,%eax
  81cdb4:	85 c0                	test   %eax,%eax
  81cdb6:	0f 84 23 02 00 00    	je     81cfdf <tcp_process+0x6b9>
       !(flags & TCP_RST)) {
  81cdbc:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81cdc3:	00 00 00 
  81cdc6:	0f b6 00             	movzbl (%rax),%eax
  81cdc9:	0f b6 c0             	movzbl %al,%eax
  81cdcc:	83 e0 04             	and    $0x4,%eax
    if (flags & TCP_ACK &&
  81cdcf:	85 c0                	test   %eax,%eax
  81cdd1:	0f 85 08 02 00 00    	jne    81cfdf <tcp_process+0x6b9>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81cdd7:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81cdde:	00 00 00 
  81cde1:	8b 10                	mov    (%rax),%edx
  81cde3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cde7:	8b 40 54             	mov    0x54(%rax),%eax
  81cdea:	29 c2                	sub    %eax,%edx
  81cdec:	89 d0                	mov    %edx,%eax
  81cdee:	83 e8 01             	sub    $0x1,%eax
  81cdf1:	85 c0                	test   %eax,%eax
  81cdf3:	0f 88 59 01 00 00    	js     81cf52 <tcp_process+0x62c>
  81cdf9:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81ce00:	00 00 00 
  81ce03:	8b 10                	mov    (%rax),%edx
  81ce05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce09:	8b 40 60             	mov    0x60(%rax),%eax
  81ce0c:	29 c2                	sub    %eax,%edx
  81ce0e:	89 d0                	mov    %edx,%eax
  81ce10:	85 c0                	test   %eax,%eax
  81ce12:	0f 8f 3a 01 00 00    	jg     81cf52 <tcp_process+0x62c>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81ce18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce1c:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81ce23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce27:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81ce2e:	48 85 c0             	test   %rax,%rax
  81ce31:	75 2a                	jne    81ce5d <tcp_process+0x537>
  81ce33:	48 ba 9e 2e 82 00 00 	movabs $0x822e9e,%rdx
  81ce3a:	00 00 00 
  81ce3d:	be 5b 02 00 00       	mov    $0x25b,%esi
  81ce42:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81ce49:	00 00 00 
  81ce4c:	b8 00 00 00 00       	mov    $0x0,%eax
  81ce51:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81ce58:	00 00 00 
  81ce5b:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81ce5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce61:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81ce68:	48 85 c0             	test   %rax,%rax
  81ce6b:	74 24                	je     81ce91 <tcp_process+0x56b>
  81ce6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce71:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81ce78:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ce7c:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81ce80:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81ce84:	ba 00 00 00 00       	mov    $0x0,%edx
  81ce89:	48 89 cf             	mov    %rcx,%rdi
  81ce8c:	ff d0                	callq  *%rax
  81ce8e:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81ce91:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81ce95:	74 1d                	je     81ceb4 <tcp_process+0x58e>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81ce97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce9b:	48 89 c7             	mov    %rax,%rdi
  81ce9e:	48 b8 12 e3 80 00 00 	movabs $0x80e312,%rax
  81cea5:	00 00 00 
  81cea8:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81ceaa:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81ceaf:	e9 40 07 00 00       	jmpq   81d5f4 <tcp_process+0xcce>
        }
        old_cwnd = pcb->cwnd;
  81ceb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ceb8:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81cebc:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81cec0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cec4:	48 89 c7             	mov    %rax,%rdi
  81cec7:	48 b8 f6 d5 81 00 00 	movabs $0x81d5f6,%rax
  81cece:	00 00 00 
  81ced1:	ff d0                	callq  *%rax
  81ced3:	88 45 fb             	mov    %al,-0x5(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81ced6:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  81cedb:	75 0c                	jne    81cee9 <tcp_process+0x5c3>
  81cedd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cee1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cee5:	01 c0                	add    %eax,%eax
  81cee7:	eb 08                	jmp    81cef1 <tcp_process+0x5cb>
  81cee9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ceed:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cef1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cef5:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81cef9:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81cf00:	00 00 00 
  81cf03:	0f b6 00             	movzbl (%rax),%eax
  81cf06:	0f b6 c0             	movzbl %al,%eax
  81cf09:	83 e0 01             	and    $0x1,%eax
  81cf0c:	85 c0                	test   %eax,%eax
  81cf0e:	74 3d                	je     81cf4d <tcp_process+0x627>
  81cf10:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  81cf14:	74 37                	je     81cf4d <tcp_process+0x627>
          tcp_ack_now(pcb);
  81cf16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf1a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81cf1e:	83 c8 02             	or     $0x2,%eax
  81cf21:	89 c2                	mov    %eax,%edx
  81cf23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf27:	88 50 2c             	mov    %dl,0x2c(%rax)
  81cf2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf2e:	48 89 c7             	mov    %rax,%rdi
  81cf31:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81cf38:	00 00 00 
  81cf3b:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81cf3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf41:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81cf48:	e9 92 00 00 00       	jmpq   81cfdf <tcp_process+0x6b9>
  81cf4d:	e9 8d 00 00 00       	jmpq   81cfdf <tcp_process+0x6b9>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81cf52:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81cf59:	00 00 00 
  81cf5c:	48 8b 00             	mov    (%rax),%rax
  81cf5f:	0f b7 00             	movzwl (%rax),%eax
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81cf62:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81cf66:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81cf6d:	00 00 00 
  81cf70:	48 8b 00             	mov    (%rax),%rax
  81cf73:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81cf77:	0f b7 f8             	movzwl %ax,%edi
  81cf7a:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81cf81:	00 00 00 
  81cf84:	48 8b 00             	mov    (%rax),%rax
  81cf87:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81cf8b:	48 b8 70 65 b5 00 00 	movabs $0xb56570,%rax
  81cf92:	00 00 00 
  81cf95:	48 8b 00             	mov    (%rax),%rax
  81cf98:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cf9c:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81cfa3:	00 00 00 
  81cfa6:	0f b7 00             	movzwl (%rax),%eax
  81cfa9:	0f b7 f0             	movzwl %ax,%esi
  81cfac:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81cfb3:	00 00 00 
  81cfb6:	8b 00                	mov    (%rax),%eax
  81cfb8:	01 c6                	add    %eax,%esi
  81cfba:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81cfc1:	00 00 00 
  81cfc4:	8b 00                	mov    (%rax),%eax
  81cfc6:	45 89 c1             	mov    %r8d,%r9d
  81cfc9:	41 89 f8             	mov    %edi,%r8d
  81cfcc:	89 c7                	mov    %eax,%edi
  81cfce:	48 b8 a6 39 81 00 00 	movabs $0x8139a6,%rax
  81cfd5:	00 00 00 
  81cfd8:	ff d0                	callq  *%rax
      }
    }
    break;
  81cfda:	e9 10 06 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  81cfdf:	e9 0b 06 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81cfe4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfe8:	48 89 c7             	mov    %rax,%rdi
  81cfeb:	48 b8 f6 d5 81 00 00 	movabs $0x81d5f6,%rax
  81cff2:	00 00 00 
  81cff5:	ff d0                	callq  *%rax
  81cff7:	88 45 fb             	mov    %al,-0x5(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81cffa:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d001:	00 00 00 
  81d004:	0f b6 00             	movzbl (%rax),%eax
  81d007:	0f b6 c0             	movzbl %al,%eax
  81d00a:	83 e0 01             	and    $0x1,%eax
  81d00d:	85 c0                	test   %eax,%eax
  81d00f:	74 3d                	je     81d04e <tcp_process+0x728>
  81d011:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  81d015:	74 37                	je     81d04e <tcp_process+0x728>
      tcp_ack_now(pcb);
  81d017:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d01b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d01f:	83 c8 02             	or     $0x2,%eax
  81d022:	89 c2                	mov    %eax,%edx
  81d024:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d028:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d02b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d02f:	48 89 c7             	mov    %rax,%rdi
  81d032:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81d039:	00 00 00 
  81d03c:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81d03e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d042:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81d049:	e9 a1 05 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  81d04e:	e9 9c 05 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81d053:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d057:	48 89 c7             	mov    %rax,%rdi
  81d05a:	48 b8 f6 d5 81 00 00 	movabs $0x81d5f6,%rax
  81d061:	00 00 00 
  81d064:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81d066:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d06d:	00 00 00 
  81d070:	0f b6 00             	movzbl (%rax),%eax
  81d073:	0f b6 c0             	movzbl %al,%eax
  81d076:	83 e0 01             	and    $0x1,%eax
  81d079:	85 c0                	test   %eax,%eax
  81d07b:	0f 84 b9 01 00 00    	je     81d23a <tcp_process+0x914>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d081:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d088:	00 00 00 
  81d08b:	0f b6 00             	movzbl (%rax),%eax
  81d08e:	0f b6 c0             	movzbl %al,%eax
  81d091:	83 e0 10             	and    $0x10,%eax
  81d094:	85 c0                	test   %eax,%eax
  81d096:	0f 84 6a 01 00 00    	je     81d206 <tcp_process+0x8e0>
  81d09c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0a0:	8b 50 60             	mov    0x60(%rax),%edx
  81d0a3:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d0aa:	00 00 00 
  81d0ad:	8b 00                	mov    (%rax),%eax
  81d0af:	39 c2                	cmp    %eax,%edx
  81d0b1:	0f 85 4f 01 00 00    	jne    81d206 <tcp_process+0x8e0>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81d0b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0bb:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d0bf:	83 c8 02             	or     $0x2,%eax
  81d0c2:	89 c2                	mov    %eax,%edx
  81d0c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0c8:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d0cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0cf:	48 89 c7             	mov    %rax,%rdi
  81d0d2:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81d0d9:	00 00 00 
  81d0dc:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81d0de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0e2:	48 89 c7             	mov    %rax,%rdi
  81d0e5:	48 b8 bd fd 80 00 00 	movabs $0x80fdbd,%rax
  81d0ec:	00 00 00 
  81d0ef:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81d0f1:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d0f8:	00 00 00 
  81d0fb:	48 8b 00             	mov    (%rax),%rax
  81d0fe:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81d102:	75 23                	jne    81d127 <tcp_process+0x801>
  81d104:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d10b:	00 00 00 
  81d10e:	48 8b 00             	mov    (%rax),%rax
  81d111:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d115:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d11c:	00 00 00 
  81d11f:	48 89 10             	mov    %rdx,(%rax)
  81d122:	e9 94 00 00 00       	jmpq   81d1bb <tcp_process+0x895>
  81d127:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d12e:	00 00 00 
  81d131:	48 8b 10             	mov    (%rax),%rdx
  81d134:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d13b:	00 00 00 
  81d13e:	48 89 10             	mov    %rdx,(%rax)
  81d141:	eb 66                	jmp    81d1a9 <tcp_process+0x883>
  81d143:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d14a:	00 00 00 
  81d14d:	48 8b 00             	mov    (%rax),%rax
  81d150:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d154:	48 85 c0             	test   %rax,%rax
  81d157:	74 32                	je     81d18b <tcp_process+0x865>
  81d159:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d160:	00 00 00 
  81d163:	48 8b 00             	mov    (%rax),%rax
  81d166:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d16a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81d16e:	75 1b                	jne    81d18b <tcp_process+0x865>
  81d170:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d177:	00 00 00 
  81d17a:	48 8b 00             	mov    (%rax),%rax
  81d17d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d181:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d185:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d189:	eb 30                	jmp    81d1bb <tcp_process+0x895>
  81d18b:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d192:	00 00 00 
  81d195:	48 8b 00             	mov    (%rax),%rax
  81d198:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d19c:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d1a3:	00 00 00 
  81d1a6:	48 89 10             	mov    %rdx,(%rax)
  81d1a9:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d1b0:	00 00 00 
  81d1b3:	48 8b 00             	mov    (%rax),%rax
  81d1b6:	48 85 c0             	test   %rax,%rax
  81d1b9:	75 88                	jne    81d143 <tcp_process+0x81d>
  81d1bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1bf:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81d1c6:	00 
        pcb->state = TIME_WAIT;
  81d1c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1cb:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81d1d2:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81d1d9:	00 00 00 
  81d1dc:	48 8b 10             	mov    (%rax),%rdx
  81d1df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1e3:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d1e7:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81d1ee:	00 00 00 
  81d1f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d1f5:	48 89 10             	mov    %rdx,(%rax)
  81d1f8:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  81d1ff:	00 00 00 
  81d202:	ff d0                	callq  *%rax
  81d204:	eb 72                	jmp    81d278 <tcp_process+0x952>
      } else {
        tcp_ack_now(pcb);
  81d206:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d20a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d20e:	83 c8 02             	or     $0x2,%eax
  81d211:	89 c2                	mov    %eax,%edx
  81d213:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d217:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d21a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d21e:	48 89 c7             	mov    %rax,%rdi
  81d221:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81d228:	00 00 00 
  81d22b:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81d22d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d231:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
  81d238:	eb 3e                	jmp    81d278 <tcp_process+0x952>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d23a:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d241:	00 00 00 
  81d244:	0f b6 00             	movzbl (%rax),%eax
  81d247:	0f b6 c0             	movzbl %al,%eax
  81d24a:	83 e0 10             	and    $0x10,%eax
  81d24d:	85 c0                	test   %eax,%eax
  81d24f:	74 27                	je     81d278 <tcp_process+0x952>
  81d251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d255:	8b 50 60             	mov    0x60(%rax),%edx
  81d258:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d25f:	00 00 00 
  81d262:	8b 00                	mov    (%rax),%eax
  81d264:	39 c2                	cmp    %eax,%edx
  81d266:	75 10                	jne    81d278 <tcp_process+0x952>
      pcb->state = FIN_WAIT_2;
  81d268:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d26c:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81d273:	e9 77 03 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  81d278:	e9 72 03 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81d27d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d281:	48 89 c7             	mov    %rax,%rdi
  81d284:	48 b8 f6 d5 81 00 00 	movabs $0x81d5f6,%rax
  81d28b:	00 00 00 
  81d28e:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81d290:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d297:	00 00 00 
  81d29a:	0f b6 00             	movzbl (%rax),%eax
  81d29d:	0f b6 c0             	movzbl %al,%eax
  81d2a0:	83 e0 01             	and    $0x1,%eax
  81d2a3:	85 c0                	test   %eax,%eax
  81d2a5:	0f 84 52 01 00 00    	je     81d3fd <tcp_process+0xad7>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81d2ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2af:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d2b3:	83 c8 02             	or     $0x2,%eax
  81d2b6:	89 c2                	mov    %eax,%edx
  81d2b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2bc:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d2bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2c3:	48 89 c7             	mov    %rax,%rdi
  81d2c6:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81d2cd:	00 00 00 
  81d2d0:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81d2d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2d6:	48 89 c7             	mov    %rax,%rdi
  81d2d9:	48 b8 bd fd 80 00 00 	movabs $0x80fdbd,%rax
  81d2e0:	00 00 00 
  81d2e3:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81d2e5:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d2ec:	00 00 00 
  81d2ef:	48 8b 00             	mov    (%rax),%rax
  81d2f2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81d2f6:	75 23                	jne    81d31b <tcp_process+0x9f5>
  81d2f8:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d2ff:	00 00 00 
  81d302:	48 8b 00             	mov    (%rax),%rax
  81d305:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d309:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d310:	00 00 00 
  81d313:	48 89 10             	mov    %rdx,(%rax)
  81d316:	e9 94 00 00 00       	jmpq   81d3af <tcp_process+0xa89>
  81d31b:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d322:	00 00 00 
  81d325:	48 8b 10             	mov    (%rax),%rdx
  81d328:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d32f:	00 00 00 
  81d332:	48 89 10             	mov    %rdx,(%rax)
  81d335:	eb 66                	jmp    81d39d <tcp_process+0xa77>
  81d337:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d33e:	00 00 00 
  81d341:	48 8b 00             	mov    (%rax),%rax
  81d344:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d348:	48 85 c0             	test   %rax,%rax
  81d34b:	74 32                	je     81d37f <tcp_process+0xa59>
  81d34d:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d354:	00 00 00 
  81d357:	48 8b 00             	mov    (%rax),%rax
  81d35a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d35e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81d362:	75 1b                	jne    81d37f <tcp_process+0xa59>
  81d364:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d36b:	00 00 00 
  81d36e:	48 8b 00             	mov    (%rax),%rax
  81d371:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d375:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d379:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d37d:	eb 30                	jmp    81d3af <tcp_process+0xa89>
  81d37f:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d386:	00 00 00 
  81d389:	48 8b 00             	mov    (%rax),%rax
  81d38c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d390:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d397:	00 00 00 
  81d39a:	48 89 10             	mov    %rdx,(%rax)
  81d39d:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d3a4:	00 00 00 
  81d3a7:	48 8b 00             	mov    (%rax),%rax
  81d3aa:	48 85 c0             	test   %rax,%rax
  81d3ad:	75 88                	jne    81d337 <tcp_process+0xa11>
  81d3af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d3b3:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81d3ba:	00 
      pcb->state = TIME_WAIT;
  81d3bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d3bf:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81d3c6:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81d3cd:	00 00 00 
  81d3d0:	48 8b 10             	mov    (%rax),%rdx
  81d3d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d3d7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d3db:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81d3e2:	00 00 00 
  81d3e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d3e9:	48 89 10             	mov    %rdx,(%rax)
  81d3ec:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  81d3f3:	00 00 00 
  81d3f6:	ff d0                	callq  *%rax
    }
    break;
  81d3f8:	e9 f2 01 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  81d3fd:	e9 ed 01 00 00       	jmpq   81d5ef <tcp_process+0xcc9>
  case CLOSING:
    tcp_receive(pcb);
  81d402:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d406:	48 89 c7             	mov    %rax,%rdi
  81d409:	48 b8 f6 d5 81 00 00 	movabs $0x81d5f6,%rax
  81d410:	00 00 00 
  81d413:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d415:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d41c:	00 00 00 
  81d41f:	0f b6 00             	movzbl (%rax),%eax
  81d422:	0f b6 c0             	movzbl %al,%eax
  81d425:	83 e0 10             	and    $0x10,%eax
  81d428:	85 c0                	test   %eax,%eax
  81d42a:	0f 84 6a 01 00 00    	je     81d59a <tcp_process+0xc74>
  81d430:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d434:	8b 50 60             	mov    0x60(%rax),%edx
  81d437:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d43e:	00 00 00 
  81d441:	8b 00                	mov    (%rax),%eax
  81d443:	39 c2                	cmp    %eax,%edx
  81d445:	0f 85 4f 01 00 00    	jne    81d59a <tcp_process+0xc74>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81d44b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d44f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d453:	83 c8 02             	or     $0x2,%eax
  81d456:	89 c2                	mov    %eax,%edx
  81d458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d45c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d45f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d463:	48 89 c7             	mov    %rax,%rdi
  81d466:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81d46d:	00 00 00 
  81d470:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81d472:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d476:	48 89 c7             	mov    %rax,%rdi
  81d479:	48 b8 bd fd 80 00 00 	movabs $0x80fdbd,%rax
  81d480:	00 00 00 
  81d483:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81d485:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d48c:	00 00 00 
  81d48f:	48 8b 00             	mov    (%rax),%rax
  81d492:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81d496:	75 23                	jne    81d4bb <tcp_process+0xb95>
  81d498:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d49f:	00 00 00 
  81d4a2:	48 8b 00             	mov    (%rax),%rax
  81d4a5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d4a9:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d4b0:	00 00 00 
  81d4b3:	48 89 10             	mov    %rdx,(%rax)
  81d4b6:	e9 94 00 00 00       	jmpq   81d54f <tcp_process+0xc29>
  81d4bb:	48 b8 10 a0 b5 00 00 	movabs $0xb5a010,%rax
  81d4c2:	00 00 00 
  81d4c5:	48 8b 10             	mov    (%rax),%rdx
  81d4c8:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d4cf:	00 00 00 
  81d4d2:	48 89 10             	mov    %rdx,(%rax)
  81d4d5:	eb 66                	jmp    81d53d <tcp_process+0xc17>
  81d4d7:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d4de:	00 00 00 
  81d4e1:	48 8b 00             	mov    (%rax),%rax
  81d4e4:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d4e8:	48 85 c0             	test   %rax,%rax
  81d4eb:	74 32                	je     81d51f <tcp_process+0xbf9>
  81d4ed:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d4f4:	00 00 00 
  81d4f7:	48 8b 00             	mov    (%rax),%rax
  81d4fa:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d4fe:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81d502:	75 1b                	jne    81d51f <tcp_process+0xbf9>
  81d504:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d50b:	00 00 00 
  81d50e:	48 8b 00             	mov    (%rax),%rax
  81d511:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d515:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d519:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d51d:	eb 30                	jmp    81d54f <tcp_process+0xc29>
  81d51f:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d526:	00 00 00 
  81d529:	48 8b 00             	mov    (%rax),%rax
  81d52c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d530:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d537:	00 00 00 
  81d53a:	48 89 10             	mov    %rdx,(%rax)
  81d53d:	48 b8 28 a0 b5 00 00 	movabs $0xb5a028,%rax
  81d544:	00 00 00 
  81d547:	48 8b 00             	mov    (%rax),%rax
  81d54a:	48 85 c0             	test   %rax,%rax
  81d54d:	75 88                	jne    81d4d7 <tcp_process+0xbb1>
  81d54f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d553:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81d55a:	00 
      pcb->state = TIME_WAIT;
  81d55b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d55f:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81d566:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81d56d:	00 00 00 
  81d570:	48 8b 10             	mov    (%rax),%rdx
  81d573:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d577:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d57b:	48 b8 38 a0 b5 00 00 	movabs $0xb5a038,%rax
  81d582:	00 00 00 
  81d585:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d589:	48 89 10             	mov    %rdx,(%rax)
  81d58c:	48 b8 ef 7a 80 00 00 	movabs $0x807aef,%rax
  81d593:	00 00 00 
  81d596:	ff d0                	callq  *%rax
    }
    break;
  81d598:	eb 55                	jmp    81d5ef <tcp_process+0xcc9>
  81d59a:	eb 53                	jmp    81d5ef <tcp_process+0xcc9>
  case LAST_ACK:
    tcp_receive(pcb);
  81d59c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d5a0:	48 89 c7             	mov    %rax,%rdi
  81d5a3:	48 b8 f6 d5 81 00 00 	movabs $0x81d5f6,%rax
  81d5aa:	00 00 00 
  81d5ad:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d5af:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d5b6:	00 00 00 
  81d5b9:	0f b6 00             	movzbl (%rax),%eax
  81d5bc:	0f b6 c0             	movzbl %al,%eax
  81d5bf:	83 e0 10             	and    $0x10,%eax
  81d5c2:	85 c0                	test   %eax,%eax
  81d5c4:	74 26                	je     81d5ec <tcp_process+0xcc6>
  81d5c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d5ca:	8b 50 60             	mov    0x60(%rax),%edx
  81d5cd:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d5d4:	00 00 00 
  81d5d7:	8b 00                	mov    (%rax),%eax
  81d5d9:	39 c2                	cmp    %eax,%edx
  81d5db:	75 0f                	jne    81d5ec <tcp_process+0xcc6>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81d5dd:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81d5e4:	00 00 00 
  81d5e7:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81d5ea:	eb 03                	jmp    81d5ef <tcp_process+0xcc9>
  81d5ec:	eb 01                	jmp    81d5ef <tcp_process+0xcc9>
  default:
    break;
  81d5ee:	90                   	nop
  }
  return ERR_OK;
  81d5ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d5f4:	c9                   	leaveq 
  81d5f5:	c3                   	retq   

000000000081d5f6 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81d5f6:	55                   	push   %rbp
  81d5f7:	48 89 e5             	mov    %rsp,%rbp
  81d5fa:	41 55                	push   %r13
  81d5fc:	41 54                	push   %r12
  81d5fe:	53                   	push   %rbx
  81d5ff:	48 83 ec 58          	sub    $0x58,%rsp
  81d603:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81d607:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81d60b:	48 b8 80 65 b5 00 00 	movabs $0xb56580,%rax
  81d612:	00 00 00 
  81d615:	0f b6 00             	movzbl (%rax),%eax
  81d618:	0f b6 c0             	movzbl %al,%eax
  81d61b:	83 e0 10             	and    $0x10,%eax
  81d61e:	85 c0                	test   %eax,%eax
  81d620:	0f 84 7c 09 00 00    	je     81dfa2 <tcp_receive+0x9ac>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81d626:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d62a:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81d62e:	0f b7 d0             	movzwl %ax,%edx
  81d631:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d635:	8b 40 6c             	mov    0x6c(%rax),%eax
  81d638:	01 d0                	add    %edx,%eax
  81d63a:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81d63d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d641:	8b 50 6c             	mov    0x6c(%rax),%edx
  81d644:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81d64b:	00 00 00 
  81d64e:	8b 00                	mov    (%rax),%eax
  81d650:	29 c2                	sub    %eax,%edx
  81d652:	89 d0                	mov    %edx,%eax
  81d654:	85 c0                	test   %eax,%eax
  81d656:	78 6b                	js     81d6c3 <tcp_receive+0xcd>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81d658:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d65c:	8b 50 6c             	mov    0x6c(%rax),%edx
  81d65f:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81d666:	00 00 00 
  81d669:	8b 00                	mov    (%rax),%eax
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81d66b:	39 c2                	cmp    %eax,%edx
  81d66d:	75 1b                	jne    81d68a <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81d66f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d673:	8b 50 70             	mov    0x70(%rax),%edx
  81d676:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d67d:	00 00 00 
  81d680:	8b 00                	mov    (%rax),%eax
  81d682:	29 c2                	sub    %eax,%edx
  81d684:	89 d0                	mov    %edx,%eax
  81d686:	85 c0                	test   %eax,%eax
  81d688:	78 39                	js     81d6c3 <tcp_receive+0xcd>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81d68a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d68e:	8b 50 70             	mov    0x70(%rax),%edx
  81d691:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d698:	00 00 00 
  81d69b:	8b 00                	mov    (%rax),%eax
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81d69d:	39 c2                	cmp    %eax,%edx
  81d69f:	0f 85 84 00 00 00    	jne    81d729 <tcp_receive+0x133>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81d6a5:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81d6ac:	00 00 00 
  81d6af:	48 8b 00             	mov    (%rax),%rax
  81d6b2:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d6b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d6ba:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81d6be:	66 39 c2             	cmp    %ax,%dx
  81d6c1:	76 66                	jbe    81d729 <tcp_receive+0x133>
      pcb->snd_wnd = tcphdr->wnd;
  81d6c3:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81d6ca:	00 00 00 
  81d6cd:	48 8b 00             	mov    (%rax),%rax
  81d6d0:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d6d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d6d8:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81d6dc:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81d6e3:	00 00 00 
  81d6e6:	8b 10                	mov    (%rax),%edx
  81d6e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d6ec:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81d6ef:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d6f6:	00 00 00 
  81d6f9:	8b 10                	mov    (%rax),%edx
  81d6fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d6ff:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81d702:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d706:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81d70a:	66 85 c0             	test   %ax,%ax
  81d70d:	74 1a                	je     81d729 <tcp_receive+0x133>
  81d70f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d713:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81d71a:	84 c0                	test   %al,%al
  81d71c:	74 0b                	je     81d729 <tcp_receive+0x133>
          pcb->persist_backoff = 0;
  81d71e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d722:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81d729:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d72d:	8b 50 54             	mov    0x54(%rax),%edx
  81d730:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d737:	00 00 00 
  81d73a:	8b 00                	mov    (%rax),%eax
  81d73c:	39 c2                	cmp    %eax,%edx
  81d73e:	0f 85 72 01 00 00    	jne    81d8b6 <tcp_receive+0x2c0>
      pcb->acked = 0;
  81d744:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d748:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81d74e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d752:	8b 50 6c             	mov    0x6c(%rax),%edx
  81d755:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d759:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81d75d:	0f b7 c0             	movzwl %ax,%eax
  81d760:	01 d0                	add    %edx,%eax
  81d762:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81d765:	0f 85 10 05 00 00    	jne    81dc7b <tcp_receive+0x685>
        ++pcb->dupacks;
  81d76b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d76f:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81d773:	8d 50 01             	lea    0x1(%rax),%edx
  81d776:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d77a:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81d77d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d781:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81d785:	3c 02                	cmp    $0x2,%al
  81d787:	0f 86 ee 04 00 00    	jbe    81dc7b <tcp_receive+0x685>
  81d78d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d791:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d798:	48 85 c0             	test   %rax,%rax
  81d79b:	0f 84 da 04 00 00    	je     81dc7b <tcp_receive+0x685>
          if (!(pcb->flags & TF_INFR)) {
  81d7a1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7a5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d7a9:	0f b6 c0             	movzbl %al,%eax
  81d7ac:	83 e0 04             	and    $0x4,%eax
  81d7af:	85 c0                	test   %eax,%eax
  81d7b1:	0f 85 bd 00 00 00    	jne    81d874 <tcp_receive+0x27e>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81d7b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7bb:	48 89 c7             	mov    %rax,%rdi
  81d7be:	48 b8 9b 3c 81 00 00 	movabs $0x813c9b,%rax
  81d7c5:	00 00 00 
  81d7c8:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81d7ca:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7ce:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81d7d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7d6:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81d7da:	66 39 c2             	cmp    %ax,%dx
  81d7dd:	76 17                	jbe    81d7f6 <tcp_receive+0x200>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81d7df:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7e3:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81d7e7:	66 d1 e8             	shr    %ax
  81d7ea:	89 c2                	mov    %eax,%edx
  81d7ec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7f0:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81d7f4:	eb 15                	jmp    81d80b <tcp_receive+0x215>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81d7f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d7fa:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d7fe:	66 d1 e8             	shr    %ax
  81d801:	89 c2                	mov    %eax,%edx
  81d803:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d807:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81d80b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d80f:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81d813:	0f b7 d0             	movzwl %ax,%edx
  81d816:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d81a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d81e:	0f b7 c0             	movzwl %ax,%eax
  81d821:	01 c0                	add    %eax,%eax
  81d823:	39 c2                	cmp    %eax,%edx
  81d825:	7d 13                	jge    81d83a <tcp_receive+0x244>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81d827:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d82b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d82f:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81d832:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d836:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81d83a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d83e:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81d842:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d846:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d84a:	89 d0                	mov    %edx,%eax
  81d84c:	01 c0                	add    %eax,%eax
  81d84e:	01 d0                	add    %edx,%eax
  81d850:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81d853:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d857:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81d85b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d85f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d863:	83 c8 04             	or     $0x4,%eax
  81d866:	89 c2                	mov    %eax,%edx
  81d868:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d86c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d86f:	e9 07 04 00 00       	jmpq   81dc7b <tcp_receive+0x685>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81d874:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d878:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81d87c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d880:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d884:	01 c2                	add    %eax,%edx
  81d886:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d88a:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d88e:	66 39 c2             	cmp    %ax,%dx
  81d891:	0f 86 e4 03 00 00    	jbe    81dc7b <tcp_receive+0x685>
              pcb->cwnd += pcb->mss;
  81d897:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d89b:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81d89f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d8a3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d8a7:	01 c2                	add    %eax,%edx
  81d8a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d8ad:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81d8b1:	e9 14 05 00 00       	jmpq   81ddca <tcp_receive+0x7d4>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81d8b6:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d8bd:	00 00 00 
  81d8c0:	8b 10                	mov    (%rax),%edx
  81d8c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d8c6:	8b 40 54             	mov    0x54(%rax),%eax
  81d8c9:	29 c2                	sub    %eax,%edx
  81d8cb:	89 d0                	mov    %edx,%eax
  81d8cd:	83 e8 01             	sub    $0x1,%eax
  81d8d0:	85 c0                	test   %eax,%eax
  81d8d2:	0f 88 99 03 00 00    	js     81dc71 <tcp_receive+0x67b>
  81d8d8:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d8df:	00 00 00 
  81d8e2:	8b 10                	mov    (%rax),%edx
  81d8e4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d8e8:	8b 40 64             	mov    0x64(%rax),%eax
  81d8eb:	29 c2                	sub    %eax,%edx
  81d8ed:	89 d0                	mov    %edx,%eax
  81d8ef:	85 c0                	test   %eax,%eax
  81d8f1:	0f 8f 7a 03 00 00    	jg     81dc71 <tcp_receive+0x67b>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81d8f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d8fb:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d8ff:	0f b6 c0             	movzbl %al,%eax
  81d902:	83 e0 04             	and    $0x4,%eax
  81d905:	85 c0                	test   %eax,%eax
  81d907:	74 24                	je     81d92d <tcp_receive+0x337>
        pcb->flags &= ~TF_INFR;
  81d909:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d90d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d911:	83 e0 fb             	and    $0xfffffffb,%eax
  81d914:	89 c2                	mov    %eax,%edx
  81d916:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d91a:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81d91d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d921:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81d925:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d929:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81d92d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d931:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81d935:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d939:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81d93d:	66 c1 f8 03          	sar    $0x3,%ax
  81d941:	89 c2                	mov    %eax,%edx
  81d943:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d947:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81d94b:	01 d0                	add    %edx,%eax
  81d94d:	89 c2                	mov    %eax,%edx
  81d94f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d953:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81d957:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d95e:	00 00 00 
  81d961:	8b 00                	mov    (%rax),%eax
  81d963:	89 c2                	mov    %eax,%edx
  81d965:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d969:	8b 40 54             	mov    0x54(%rax),%eax
  81d96c:	29 c2                	sub    %eax,%edx
  81d96e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d972:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81d976:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d97a:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81d97e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d982:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81d986:	01 c2                	add    %eax,%edx
  81d988:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d98c:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81d990:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d994:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81d998:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81d99f:	00 00 00 
  81d9a2:	8b 10                	mov    (%rax),%edx
  81d9a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9a8:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81d9ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9af:	8b 40 18             	mov    0x18(%rax),%eax
  81d9b2:	83 f8 03             	cmp    $0x3,%eax
  81d9b5:	0f 86 a1 00 00 00    	jbe    81da5c <tcp_receive+0x466>
        if (pcb->cwnd < pcb->ssthresh) {
  81d9bb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9bf:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81d9c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9c7:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81d9cb:	66 39 c2             	cmp    %ax,%dx
  81d9ce:	73 3b                	jae    81da0b <tcp_receive+0x415>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81d9d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9d4:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81d9d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9dc:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d9e0:	01 c2                	add    %eax,%edx
  81d9e2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9e6:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d9ea:	66 39 c2             	cmp    %ax,%dx
  81d9ed:	76 6d                	jbe    81da5c <tcp_receive+0x466>
            pcb->cwnd += pcb->mss;
  81d9ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9f3:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81d9f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81d9fb:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d9ff:	01 c2                	add    %eax,%edx
  81da01:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da05:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81da09:	eb 51                	jmp    81da5c <tcp_receive+0x466>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81da0b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da0f:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81da13:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da17:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81da1b:	0f b7 d0             	movzwl %ax,%edx
  81da1e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da22:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81da26:	0f b7 c0             	movzwl %ax,%eax
  81da29:	0f af c2             	imul   %edx,%eax
  81da2c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81da30:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81da34:	0f b7 f2             	movzwl %dx,%esi
  81da37:	99                   	cltd   
  81da38:	f7 fe                	idiv   %esi
  81da3a:	01 c8                	add    %ecx,%eax
  81da3c:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81da40:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da44:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81da48:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81da4c:	73 0e                	jae    81da5c <tcp_receive+0x466>
            pcb->cwnd = new_cwnd;
  81da4e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da52:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81da56:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81da5a:	eb 00                	jmp    81da5c <tcp_receive+0x466>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81da5c:	e9 11 01 00 00       	jmpq   81db72 <tcp_receive+0x57c>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81da61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da65:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81da6c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81da70:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da74:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81da7b:	48 8b 10             	mov    (%rax),%rdx
  81da7e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da82:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81da89:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81da8d:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81da91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da95:	48 8b 40 08          	mov    0x8(%rax),%rax
  81da99:	48 89 c7             	mov    %rax,%rdi
  81da9c:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  81daa3:	00 00 00 
  81daa6:	ff d0                	callq  *%rax
  81daa8:	0f b6 c0             	movzbl %al,%eax
  81daab:	66 39 c3             	cmp    %ax,%bx
  81daae:	73 2a                	jae    81dada <tcp_receive+0x4e4>
  81dab0:	48 ba 08 2f 82 00 00 	movabs $0x822f08,%rdx
  81dab7:	00 00 00 
  81daba:	be 55 03 00 00       	mov    $0x355,%esi
  81dabf:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81dac6:	00 00 00 
  81dac9:	b8 00 00 00 00       	mov    $0x0,%eax
  81dace:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81dad5:	00 00 00 
  81dad8:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81dada:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dade:	48 8b 40 08          	mov    0x8(%rax),%rax
  81dae2:	48 89 c7             	mov    %rax,%rdi
  81dae5:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  81daec:	00 00 00 
  81daef:	ff d0                	callq  *%rax
  81daf1:	89 c1                	mov    %eax,%ecx
  81daf3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81daf7:	0f b7 50 7c          	movzwl 0x7c(%rax),%edx
  81dafb:	0f b6 c1             	movzbl %cl,%eax
  81dafe:	29 c2                	sub    %eax,%edx
  81db00:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81db04:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81db08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db0c:	48 89 c7             	mov    %rax,%rdi
  81db0f:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  81db16:	00 00 00 
  81db19:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81db1b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81db1f:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81db23:	66 85 c0             	test   %ax,%ax
  81db26:	74 4a                	je     81db72 <tcp_receive+0x57c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81db28:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81db2c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81db33:	48 85 c0             	test   %rax,%rax
  81db36:	75 3a                	jne    81db72 <tcp_receive+0x57c>
  81db38:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81db3c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81db43:	48 85 c0             	test   %rax,%rax
  81db46:	75 2a                	jne    81db72 <tcp_receive+0x57c>
  81db48:	48 ba 30 2f 82 00 00 	movabs $0x822f30,%rdx
  81db4f:	00 00 00 
  81db52:	be 5c 03 00 00       	mov    $0x35c,%esi
  81db57:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81db5e:	00 00 00 
  81db61:	b8 00 00 00 00       	mov    $0x0,%eax
  81db66:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81db6d:	00 00 00 
  81db70:	ff d1                	callq  *%rcx
      while (pcb->unacked != NULL &&
  81db72:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81db76:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81db7d:	48 85 c0             	test   %rax,%rax
  81db80:	0f 84 bb 00 00 00    	je     81dc41 <tcp_receive+0x64b>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81db86:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81db8a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81db91:	48 8b 40 20          	mov    0x20(%rax),%rax
  81db95:	8b 40 04             	mov    0x4(%rax),%eax
  81db98:	89 c7                	mov    %eax,%edi
  81db9a:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81dba1:	00 00 00 
  81dba4:	ff d0                	callq  *%rax
  81dba6:	41 89 c4             	mov    %eax,%r12d
  81dba9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dbad:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dbb4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81dbb8:	0f b7 d8             	movzwl %ax,%ebx
  81dbbb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dbbf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dbc6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81dbca:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81dbce:	0f b7 c0             	movzwl %ax,%eax
  81dbd1:	89 c7                	mov    %eax,%edi
  81dbd3:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81dbda:	00 00 00 
  81dbdd:	ff d0                	callq  *%rax
  81dbdf:	0f b7 c0             	movzwl %ax,%eax
  81dbe2:	83 e0 01             	and    $0x1,%eax
  81dbe5:	85 c0                	test   %eax,%eax
  81dbe7:	75 2e                	jne    81dc17 <tcp_receive+0x621>
  81dbe9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dbed:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dbf4:	48 8b 40 20          	mov    0x20(%rax),%rax
  81dbf8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81dbfc:	0f b7 c0             	movzwl %ax,%eax
  81dbff:	89 c7                	mov    %eax,%edi
  81dc01:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81dc08:	00 00 00 
  81dc0b:	ff d0                	callq  *%rax
  81dc0d:	0f b7 c0             	movzwl %ax,%eax
  81dc10:	83 e0 02             	and    $0x2,%eax
  81dc13:	85 c0                	test   %eax,%eax
  81dc15:	74 07                	je     81dc1e <tcp_receive+0x628>
  81dc17:	b8 01 00 00 00       	mov    $0x1,%eax
  81dc1c:	eb 05                	jmp    81dc23 <tcp_receive+0x62d>
  81dc1e:	b8 00 00 00 00       	mov    $0x0,%eax
  81dc23:	01 d8                	add    %ebx,%eax
  81dc25:	41 8d 14 04          	lea    (%r12,%rax,1),%edx
  81dc29:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81dc30:	00 00 00 
  81dc33:	8b 00                	mov    (%rax),%eax
  81dc35:	29 c2                	sub    %eax,%edx
  81dc37:	89 d0                	mov    %edx,%eax
      while (pcb->unacked != NULL &&
  81dc39:	85 c0                	test   %eax,%eax
  81dc3b:	0f 8e 20 fe ff ff    	jle    81da61 <tcp_receive+0x46b>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81dc41:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc45:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dc4c:	48 85 c0             	test   %rax,%rax
  81dc4f:	75 0c                	jne    81dc5d <tcp_receive+0x667>
        pcb->rtime = -1;
  81dc51:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc55:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81dc5b:	eb 0a                	jmp    81dc67 <tcp_receive+0x671>
      else
        pcb->rtime = 0;
  81dc5d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc61:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81dc67:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc6b:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
  81dc6f:	eb 0a                	jmp    81dc7b <tcp_receive+0x685>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81dc71:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc75:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81dc7b:	e9 4a 01 00 00       	jmpq   81ddca <tcp_receive+0x7d4>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81dc80:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc84:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81dc8b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81dc8f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc93:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81dc9a:	48 8b 10             	mov    (%rax),%rdx
  81dc9d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dca1:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81dca8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dcac:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81dcb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dcb4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81dcb8:	48 89 c7             	mov    %rax,%rdi
  81dcbb:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  81dcc2:	00 00 00 
  81dcc5:	ff d0                	callq  *%rax
  81dcc7:	0f b6 c0             	movzbl %al,%eax
  81dcca:	66 39 c3             	cmp    %ax,%bx
  81dccd:	73 2a                	jae    81dcf9 <tcp_receive+0x703>
  81dccf:	48 ba 08 2f 82 00 00 	movabs $0x822f08,%rdx
  81dcd6:	00 00 00 
  81dcd9:	be 7f 03 00 00       	mov    $0x37f,%esi
  81dcde:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81dce5:	00 00 00 
  81dce8:	b8 00 00 00 00       	mov    $0x0,%eax
  81dced:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81dcf4:	00 00 00 
  81dcf7:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81dcf9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dcfd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81dd01:	48 89 c7             	mov    %rax,%rdi
  81dd04:	48 b8 12 d3 80 00 00 	movabs $0x80d312,%rax
  81dd0b:	00 00 00 
  81dd0e:	ff d0                	callq  *%rax
  81dd10:	89 c1                	mov    %eax,%ecx
  81dd12:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd16:	0f b7 50 7c          	movzwl 0x7c(%rax),%edx
  81dd1a:	0f b6 c1             	movzbl %cl,%eax
  81dd1d:	29 c2                	sub    %eax,%edx
  81dd1f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd23:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81dd27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd2b:	48 89 c7             	mov    %rax,%rdi
  81dd2e:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  81dd35:	00 00 00 
  81dd38:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81dd3a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd3e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81dd42:	66 85 c0             	test   %ax,%ax
  81dd45:	74 4a                	je     81dd91 <tcp_receive+0x79b>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81dd47:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd4b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dd52:	48 85 c0             	test   %rax,%rax
  81dd55:	75 3a                	jne    81dd91 <tcp_receive+0x79b>
  81dd57:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd5b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81dd62:	48 85 c0             	test   %rax,%rax
  81dd65:	75 2a                	jne    81dd91 <tcp_receive+0x79b>
  81dd67:	48 ba 30 2f 82 00 00 	movabs $0x822f30,%rdx
  81dd6e:	00 00 00 
  81dd71:	be 85 03 00 00       	mov    $0x385,%esi
  81dd76:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81dd7d:	00 00 00 
  81dd80:	b8 00 00 00 00       	mov    $0x0,%eax
  81dd85:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81dd8c:	00 00 00 
  81dd8f:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81dd91:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd95:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81dd9c:	48 85 c0             	test   %rax,%rax
  81dd9f:	74 29                	je     81ddca <tcp_receive+0x7d4>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81dda1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dda5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ddac:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ddb0:	8b 40 04             	mov    0x4(%rax),%eax
  81ddb3:	89 c7                	mov    %eax,%edi
  81ddb5:	48 b8 90 24 81 00 00 	movabs $0x812490,%rax
  81ddbc:	00 00 00 
  81ddbf:	ff d0                	callq  *%rax
  81ddc1:	89 c2                	mov    %eax,%edx
  81ddc3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddc7:	89 50 60             	mov    %edx,0x60(%rax)
    while (pcb->unsent != NULL &&
  81ddca:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddce:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ddd5:	48 85 c0             	test   %rax,%rax
  81ddd8:	0f 84 d7 00 00 00    	je     81deb5 <tcp_receive+0x8bf>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81ddde:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81dde5:	00 00 00 
  81dde8:	8b 18                	mov    (%rax),%ebx
  81ddea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddee:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ddf5:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ddf9:	8b 40 04             	mov    0x4(%rax),%eax
  81ddfc:	89 c7                	mov    %eax,%edi
  81ddfe:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81de05:	00 00 00 
  81de08:	ff d0                	callq  *%rax
  81de0a:	41 89 c5             	mov    %eax,%r13d
  81de0d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de11:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81de18:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81de1c:	44 0f b7 e0          	movzwl %ax,%r12d
  81de20:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de24:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81de2b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81de2f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81de33:	0f b7 c0             	movzwl %ax,%eax
  81de36:	89 c7                	mov    %eax,%edi
  81de38:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81de3f:	00 00 00 
  81de42:	ff d0                	callq  *%rax
  81de44:	0f b7 c0             	movzwl %ax,%eax
  81de47:	83 e0 01             	and    $0x1,%eax
  81de4a:	85 c0                	test   %eax,%eax
  81de4c:	75 2e                	jne    81de7c <tcp_receive+0x886>
  81de4e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de52:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81de59:	48 8b 40 20          	mov    0x20(%rax),%rax
  81de5d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81de61:	0f b7 c0             	movzwl %ax,%eax
  81de64:	89 c7                	mov    %eax,%edi
  81de66:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81de6d:	00 00 00 
  81de70:	ff d0                	callq  *%rax
  81de72:	0f b7 c0             	movzwl %ax,%eax
  81de75:	83 e0 02             	and    $0x2,%eax
  81de78:	85 c0                	test   %eax,%eax
  81de7a:	74 07                	je     81de83 <tcp_receive+0x88d>
  81de7c:	b8 01 00 00 00       	mov    $0x1,%eax
  81de81:	eb 05                	jmp    81de88 <tcp_receive+0x892>
  81de83:	b8 00 00 00 00       	mov    $0x0,%eax
  81de88:	44 01 e0             	add    %r12d,%eax
  81de8b:	44 01 e8             	add    %r13d,%eax
  81de8e:	29 c3                	sub    %eax,%ebx
  81de90:	89 d8                	mov    %ebx,%eax
    while (pcb->unsent != NULL &&
  81de92:	85 c0                	test   %eax,%eax
  81de94:	78 1f                	js     81deb5 <tcp_receive+0x8bf>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81de96:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81de9d:	00 00 00 
  81dea0:	8b 10                	mov    (%rax),%edx
  81dea2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dea6:	8b 40 64             	mov    0x64(%rax),%eax
  81dea9:	29 c2                	sub    %eax,%edx
  81deab:	89 d0                	mov    %edx,%eax
  81dead:	85 c0                	test   %eax,%eax
  81deaf:	0f 8e cb fd ff ff    	jle    81dc80 <tcp_receive+0x68a>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81deb5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81deb9:	8b 40 44             	mov    0x44(%rax),%eax
  81debc:	85 c0                	test   %eax,%eax
  81debe:	0f 84 de 00 00 00    	je     81dfa2 <tcp_receive+0x9ac>
  81dec4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dec8:	8b 50 48             	mov    0x48(%rax),%edx
  81decb:	48 b8 7c 65 b5 00 00 	movabs $0xb5657c,%rax
  81ded2:	00 00 00 
  81ded5:	8b 00                	mov    (%rax),%eax
  81ded7:	29 c2                	sub    %eax,%edx
  81ded9:	89 d0                	mov    %edx,%eax
  81dedb:	85 c0                	test   %eax,%eax
  81dedd:	0f 89 bf 00 00 00    	jns    81dfa2 <tcp_receive+0x9ac>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81dee3:	48 b8 18 a0 b5 00 00 	movabs $0xb5a018,%rax
  81deea:	00 00 00 
  81deed:	8b 00                	mov    (%rax),%eax
  81deef:	89 c2                	mov    %eax,%edx
  81def1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81def5:	8b 40 44             	mov    0x44(%rax),%eax
  81def8:	29 c2                	sub    %eax,%edx
  81defa:	89 d0                	mov    %edx,%eax
  81defc:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81df00:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81df04:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df08:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81df0c:	66 c1 f8 03          	sar    $0x3,%ax
  81df10:	29 c2                	sub    %eax,%edx
  81df12:	89 d0                	mov    %edx,%eax
  81df14:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81df18:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df1c:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81df20:	89 c2                	mov    %eax,%edx
  81df22:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81df26:	01 d0                	add    %edx,%eax
  81df28:	89 c2                	mov    %eax,%edx
  81df2a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df2e:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81df32:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81df37:	79 0a                	jns    81df43 <tcp_receive+0x94d>
        m = -m;
  81df39:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81df3d:	f7 d8                	neg    %eax
  81df3f:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81df43:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81df47:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df4b:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81df4f:	66 c1 f8 02          	sar    $0x2,%ax
  81df53:	29 c2                	sub    %eax,%edx
  81df55:	89 d0                	mov    %edx,%eax
  81df57:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81df5b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df5f:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81df63:	89 c2                	mov    %eax,%edx
  81df65:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81df69:	01 d0                	add    %edx,%eax
  81df6b:	89 c2                	mov    %eax,%edx
  81df6d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df71:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81df75:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df79:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81df7d:	66 c1 f8 03          	sar    $0x3,%ax
  81df81:	89 c2                	mov    %eax,%edx
  81df83:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df87:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81df8b:	01 d0                	add    %edx,%eax
  81df8d:	89 c2                	mov    %eax,%edx
  81df8f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df93:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81df97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df9b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81dfa2:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81dfa9:	00 00 00 
  81dfac:	0f b7 00             	movzwl (%rax),%eax
  81dfaf:	66 85 c0             	test   %ax,%ax
  81dfb2:	0f 84 27 10 00 00    	je     81efdf <tcp_receive+0x19e9>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81dfb8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfbc:	8b 50 30             	mov    0x30(%rax),%edx
  81dfbf:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81dfc6:	00 00 00 
  81dfc9:	8b 00                	mov    (%rax),%eax
  81dfcb:	29 c2                	sub    %eax,%edx
  81dfcd:	89 d0                	mov    %edx,%eax
  81dfcf:	83 e8 01             	sub    $0x1,%eax
  81dfd2:	85 c0                	test   %eax,%eax
  81dfd4:	0f 88 ad 02 00 00    	js     81e287 <tcp_receive+0xc91>
  81dfda:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfde:	8b 50 30             	mov    0x30(%rax),%edx
  81dfe1:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81dfe8:	00 00 00 
  81dfeb:	0f b7 00             	movzwl (%rax),%eax
  81dfee:	0f b7 c8             	movzwl %ax,%ecx
  81dff1:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81dff8:	00 00 00 
  81dffb:	8b 00                	mov    (%rax),%eax
  81dffd:	01 c8                	add    %ecx,%eax
  81dfff:	29 c2                	sub    %eax,%edx
  81e001:	89 d0                	mov    %edx,%eax
  81e003:	83 c0 01             	add    $0x1,%eax
  81e006:	85 c0                	test   %eax,%eax
  81e008:	0f 8f 79 02 00 00    	jg     81e287 <tcp_receive+0xc91>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81e00e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e012:	8b 50 30             	mov    0x30(%rax),%edx
  81e015:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e01c:	00 00 00 
  81e01f:	8b 00                	mov    (%rax),%eax
  81e021:	29 c2                	sub    %eax,%edx
  81e023:	89 d0                	mov    %edx,%eax
  81e025:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81e028:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e02f:	00 00 00 
  81e032:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e036:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81e03a:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e041:	00 00 00 
  81e044:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e048:	48 85 c0             	test   %rax,%rax
  81e04b:	75 2a                	jne    81e077 <tcp_receive+0xa81>
  81e04d:	48 ba 50 2f 82 00 00 	movabs $0x822f50,%rdx
  81e054:	00 00 00 
  81e057:	be e5 03 00 00       	mov    $0x3e5,%esi
  81e05c:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81e063:	00 00 00 
  81e066:	b8 00 00 00 00       	mov    $0x0,%eax
  81e06b:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81e072:	00 00 00 
  81e075:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81e077:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81e07e:	7e 2a                	jle    81e0aa <tcp_receive+0xab4>
  81e080:	48 ba 60 2f 82 00 00 	movabs $0x822f60,%rdx
  81e087:	00 00 00 
  81e08a:	be e6 03 00 00       	mov    $0x3e6,%esi
  81e08f:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81e096:	00 00 00 
  81e099:	b8 00 00 00 00       	mov    $0x0,%eax
  81e09e:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81e0a5:	00 00 00 
  81e0a8:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81e0aa:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e0b1:	00 00 00 
  81e0b4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e0b8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e0bc:	0f b7 c0             	movzwl %ax,%eax
  81e0bf:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e0c2:	0f 8d eb 00 00 00    	jge    81e1b3 <tcp_receive+0xbbd>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81e0c8:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e0cf:	00 00 00 
  81e0d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e0d6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e0da:	0f b7 c0             	movzwl %ax,%eax
  81e0dd:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e0e0:	7d 2a                	jge    81e10c <tcp_receive+0xb16>
  81e0e2:	48 ba 6f 2f 82 00 00 	movabs $0x822f6f,%rdx
  81e0e9:	00 00 00 
  81e0ec:	be e8 03 00 00       	mov    $0x3e8,%esi
  81e0f1:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81e0f8:	00 00 00 
  81e0fb:	b8 00 00 00 00       	mov    $0x0,%eax
  81e100:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81e107:	00 00 00 
  81e10a:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81e10c:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e113:	00 00 00 
  81e116:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e11a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e11e:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  81e121:	29 d0                	sub    %edx,%eax
  81e123:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81e127:	eb 2f                	jmp    81e158 <tcp_receive+0xb62>
          off -= p->len;
  81e129:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e12d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e131:	0f b7 c0             	movzwl %ax,%eax
  81e134:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81e137:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e13b:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81e13f:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81e143:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e147:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81e14d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e151:	48 8b 00             	mov    (%rax),%rax
  81e154:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        while (p->len < off) {
  81e158:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e15c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e160:	0f b7 c0             	movzwl %ax,%eax
  81e163:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e166:	7c c1                	jl     81e129 <tcp_receive+0xb33>
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81e168:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e16b:	f7 d8                	neg    %eax
  81e16d:	0f bf d0             	movswl %ax,%edx
  81e170:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e174:	89 d6                	mov    %edx,%esi
  81e176:	48 89 c7             	mov    %rax,%rdi
  81e179:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81e180:	00 00 00 
  81e183:	ff d0                	callq  *%rax
  81e185:	84 c0                	test   %al,%al
  81e187:	74 7f                	je     81e208 <tcp_receive+0xc12>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e189:	48 ba 7f 2f 82 00 00 	movabs $0x822f7f,%rdx
  81e190:	00 00 00 
  81e193:	be f5 03 00 00       	mov    $0x3f5,%esi
  81e198:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81e19f:	00 00 00 
  81e1a2:	b8 00 00 00 00       	mov    $0x0,%eax
  81e1a7:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81e1ae:	00 00 00 
  81e1b1:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81e1b3:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e1b6:	f7 d8                	neg    %eax
  81e1b8:	0f bf d0             	movswl %ax,%edx
  81e1bb:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e1c2:	00 00 00 
  81e1c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e1c9:	89 d6                	mov    %edx,%esi
  81e1cb:	48 89 c7             	mov    %rax,%rdi
  81e1ce:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81e1d5:	00 00 00 
  81e1d8:	ff d0                	callq  *%rax
  81e1da:	84 c0                	test   %al,%al
  81e1dc:	74 2a                	je     81e208 <tcp_receive+0xc12>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e1de:	48 ba 7f 2f 82 00 00 	movabs $0x822f7f,%rdx
  81e1e5:	00 00 00 
  81e1e8:	be fa 03 00 00       	mov    $0x3fa,%esi
  81e1ed:	48 bf 67 2d 82 00 00 	movabs $0x822d67,%rdi
  81e1f4:	00 00 00 
  81e1f7:	b8 00 00 00 00       	mov    $0x0,%eax
  81e1fc:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81e203:	00 00 00 
  81e206:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81e208:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e20c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81e210:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e217:	00 00 00 
  81e21a:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81e21e:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e225:	00 00 00 
  81e228:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81e22c:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e233:	00 00 00 
  81e236:	8b 00                	mov    (%rax),%eax
  81e238:	89 c1                	mov    %eax,%ecx
  81e23a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e23e:	8b 40 30             	mov    0x30(%rax),%eax
  81e241:	29 c1                	sub    %eax,%ecx
  81e243:	89 c8                	mov    %ecx,%eax
  81e245:	01 c2                	add    %eax,%edx
  81e247:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e24e:	00 00 00 
  81e251:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81e255:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e25c:	00 00 00 
  81e25f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e263:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e267:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81e26a:	48 ba 78 65 b5 00 00 	movabs $0xb56578,%rdx
  81e271:	00 00 00 
  81e274:	89 0a                	mov    %ecx,(%rdx)
  81e276:	48 ba 78 65 b5 00 00 	movabs $0xb56578,%rdx
  81e27d:	00 00 00 
  81e280:	8b 12                	mov    (%rdx),%edx
  81e282:	89 50 04             	mov    %edx,0x4(%rax)
  81e285:	eb 42                	jmp    81e2c9 <tcp_receive+0xcd3>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81e287:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e28e:	00 00 00 
  81e291:	8b 10                	mov    (%rax),%edx
  81e293:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e297:	8b 40 30             	mov    0x30(%rax),%eax
  81e29a:	29 c2                	sub    %eax,%edx
  81e29c:	89 d0                	mov    %edx,%eax
  81e29e:	85 c0                	test   %eax,%eax
  81e2a0:	79 27                	jns    81e2c9 <tcp_receive+0xcd3>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81e2a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2a6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e2aa:	83 c8 02             	or     $0x2,%eax
  81e2ad:	89 c2                	mov    %eax,%edx
  81e2af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2b3:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e2b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2ba:	48 89 c7             	mov    %rax,%rdi
  81e2bd:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81e2c4:	00 00 00 
  81e2c7:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81e2c9:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e2d0:	00 00 00 
  81e2d3:	8b 10                	mov    (%rax),%edx
  81e2d5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2d9:	8b 40 30             	mov    0x30(%rax),%eax
  81e2dc:	29 c2                	sub    %eax,%edx
  81e2de:	89 d0                	mov    %edx,%eax
  81e2e0:	85 c0                	test   %eax,%eax
  81e2e2:	0f 88 cc 0c 00 00    	js     81efb4 <tcp_receive+0x19be>
  81e2e8:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e2ef:	00 00 00 
  81e2f2:	8b 10                	mov    (%rax),%edx
  81e2f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2f8:	8b 48 30             	mov    0x30(%rax),%ecx
  81e2fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2ff:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81e303:	0f b7 c0             	movzwl %ax,%eax
  81e306:	01 c8                	add    %ecx,%eax
  81e308:	29 c2                	sub    %eax,%edx
  81e30a:	89 d0                	mov    %edx,%eax
  81e30c:	83 c0 01             	add    $0x1,%eax
  81e30f:	85 c0                	test   %eax,%eax
  81e311:	0f 8f 9d 0c 00 00    	jg     81efb4 <tcp_receive+0x19be>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81e317:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e31b:	8b 50 30             	mov    0x30(%rax),%edx
  81e31e:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e325:	00 00 00 
  81e328:	8b 00                	mov    (%rax),%eax
  81e32a:	39 c2                	cmp    %eax,%edx
  81e32c:	0f 85 3f 07 00 00    	jne    81ea71 <tcp_receive+0x147b>
        accepted_inseq = 1; 
  81e332:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81e336:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e33a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e341:	48 85 c0             	test   %rax,%rax
  81e344:	0f 84 4c 01 00 00    	je     81e496 <tcp_receive+0xea0>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81e34a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e34e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e355:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e359:	8b 50 04             	mov    0x4(%rax),%edx
  81e35c:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e363:	00 00 00 
  81e366:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e36a:	0f b7 c8             	movzwl %ax,%ecx
  81e36d:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e374:	00 00 00 
  81e377:	8b 00                	mov    (%rax),%eax
  81e379:	01 c8                	add    %ecx,%eax
  81e37b:	29 c2                	sub    %eax,%edx
  81e37d:	89 d0                	mov    %edx,%eax
        if (pcb->ooseq != NULL &&
  81e37f:	85 c0                	test   %eax,%eax
  81e381:	0f 8f 0f 01 00 00    	jg     81e496 <tcp_receive+0xea0>
          if (pcb->ooseq->len > 0) {
  81e387:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e38b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e392:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e396:	66 85 c0             	test   %ax,%ax
  81e399:	74 65                	je     81e400 <tcp_receive+0xe0a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81e39b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e39f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e3a6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e3aa:	8b 40 04             	mov    0x4(%rax),%eax
  81e3ad:	89 c2                	mov    %eax,%edx
  81e3af:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e3b6:	00 00 00 
  81e3b9:	8b 00                	mov    (%rax),%eax
  81e3bb:	29 c2                	sub    %eax,%edx
  81e3bd:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e3c4:	00 00 00 
  81e3c7:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81e3cb:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e3d2:	00 00 00 
  81e3d5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e3d9:	0f b7 d0             	movzwl %ax,%edx
  81e3dc:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e3e3:	00 00 00 
  81e3e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e3ea:	89 d6                	mov    %edx,%esi
  81e3ec:	48 89 c7             	mov    %rax,%rdi
  81e3ef:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  81e3f6:	00 00 00 
  81e3f9:	ff d0                	callq  *%rax
  81e3fb:	e9 96 00 00 00       	jmpq   81e496 <tcp_receive+0xea0>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81e400:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e407:	00 00 00 
  81e40a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e40e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e412:	0f b7 c0             	movzwl %ax,%eax
  81e415:	89 c7                	mov    %eax,%edi
  81e417:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e41e:	00 00 00 
  81e421:	ff d0                	callq  *%rax
  81e423:	0f b7 d8             	movzwl %ax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81e426:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e42a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e431:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e435:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e439:	0f b7 c0             	movzwl %ax,%eax
  81e43c:	89 c7                	mov    %eax,%edi
  81e43e:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e445:	00 00 00 
  81e448:	ff d0                	callq  *%rax
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81e44a:	0f b7 c0             	movzwl %ax,%eax
  81e44d:	31 d8                	xor    %ebx,%eax
  81e44f:	83 e0 03             	and    $0x3,%eax
  81e452:	85 c0                	test   %eax,%eax
  81e454:	75 40                	jne    81e496 <tcp_receive+0xea0>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81e456:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e45a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e461:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81e465:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e469:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e470:	48 8b 10             	mov    (%rax),%rdx
  81e473:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e477:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81e47e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81e482:	48 89 c6             	mov    %rax,%rsi
  81e485:	bf 04 00 00 00       	mov    $0x4,%edi
  81e48a:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81e491:	00 00 00 
  81e494:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81e496:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e49d:	00 00 00 
  81e4a0:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81e4a4:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e4ab:	00 00 00 
  81e4ae:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e4b2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e4b6:	0f b7 c0             	movzwl %ax,%eax
  81e4b9:	89 c7                	mov    %eax,%edi
  81e4bb:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e4c2:	00 00 00 
  81e4c5:	ff d0                	callq  *%rax
  81e4c7:	0f b7 c0             	movzwl %ax,%eax
  81e4ca:	83 e0 01             	and    $0x1,%eax
  81e4cd:	85 c0                	test   %eax,%eax
  81e4cf:	75 2d                	jne    81e4fe <tcp_receive+0xf08>
  81e4d1:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e4d8:	00 00 00 
  81e4db:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e4df:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e4e3:	0f b7 c0             	movzwl %ax,%eax
  81e4e6:	89 c7                	mov    %eax,%edi
  81e4e8:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e4ef:	00 00 00 
  81e4f2:	ff d0                	callq  *%rax
  81e4f4:	0f b7 c0             	movzwl %ax,%eax
  81e4f7:	83 e0 02             	and    $0x2,%eax
  81e4fa:	85 c0                	test   %eax,%eax
  81e4fc:	74 07                	je     81e505 <tcp_receive+0xf0f>
  81e4fe:	b8 01 00 00 00       	mov    $0x1,%eax
  81e503:	eb 05                	jmp    81e50a <tcp_receive+0xf14>
  81e505:	b8 00 00 00 00       	mov    $0x0,%eax
  81e50a:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e50d:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81e514:	00 00 00 
  81e517:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81e51a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e51e:	8b 40 18             	mov    0x18(%rax),%eax
  81e521:	83 f8 07             	cmp    $0x7,%eax
  81e524:	74 20                	je     81e546 <tcp_receive+0xf50>
          pcb->rcv_nxt += tcplen;
  81e526:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e52a:	8b 50 30             	mov    0x30(%rax),%edx
  81e52d:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81e534:	00 00 00 
  81e537:	0f b7 00             	movzwl (%rax),%eax
  81e53a:	0f b7 c0             	movzwl %ax,%eax
  81e53d:	01 c2                	add    %eax,%edx
  81e53f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e543:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81e546:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e54a:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81e54e:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81e555:	00 00 00 
  81e558:	0f b7 00             	movzwl (%rax),%eax
  81e55b:	66 39 c2             	cmp    %ax,%dx
  81e55e:	73 0c                	jae    81e56c <tcp_receive+0xf76>
          pcb->rcv_wnd = 0;
  81e560:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e564:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81e56a:	eb 1f                	jmp    81e58b <tcp_receive+0xf95>
        } else {
          pcb->rcv_wnd -= tcplen;
  81e56c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e570:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81e574:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81e57b:	00 00 00 
  81e57e:	0f b7 00             	movzwl (%rax),%eax
  81e581:	29 c2                	sub    %eax,%edx
  81e583:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e587:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81e58b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e58f:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81e593:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81e59a:	00 00 00 
  81e59d:	0f b7 00             	movzwl (%rax),%eax
  81e5a0:	66 39 c2             	cmp    %ax,%dx
  81e5a3:	73 0c                	jae    81e5b1 <tcp_receive+0xfbb>
          pcb->rcv_ann_wnd = 0;
  81e5a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5a9:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81e5af:	eb 1f                	jmp    81e5d0 <tcp_receive+0xfda>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81e5b1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5b5:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81e5b9:	48 b8 82 65 b5 00 00 	movabs $0xb56582,%rax
  81e5c0:	00 00 00 
  81e5c3:	0f b7 00             	movzwl (%rax),%eax
  81e5c6:	29 c2                	sub    %eax,%edx
  81e5c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5cc:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81e5d0:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e5d7:	00 00 00 
  81e5da:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e5de:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e5e2:	66 85 c0             	test   %ax,%ax
  81e5e5:	74 2d                	je     81e614 <tcp_receive+0x101e>
          recv_data = inseg.p;
  81e5e7:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e5ee:	00 00 00 
  81e5f1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81e5f5:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81e5fc:	00 00 00 
  81e5ff:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81e602:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e609:	00 00 00 
  81e60c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81e613:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81e614:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81e61b:	00 00 00 
  81e61e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e622:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e626:	0f b7 c0             	movzwl %ax,%eax
  81e629:	89 c7                	mov    %eax,%edi
  81e62b:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e632:	00 00 00 
  81e635:	ff d0                	callq  *%rax
  81e637:	0f b7 c0             	movzwl %ax,%eax
  81e63a:	83 e0 01             	and    $0x1,%eax
  81e63d:	85 c0                	test   %eax,%eax
  81e63f:	74 0d                	je     81e64e <tcp_receive+0x1058>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81e641:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81e648:	00 00 00 
  81e64b:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81e64e:	e9 82 03 00 00       	jmpq   81e9d5 <tcp_receive+0x13df>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81e653:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e657:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e65e:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81e662:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e666:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e66d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e671:	8b 50 04             	mov    0x4(%rax),%edx
  81e674:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81e67b:	00 00 00 
  81e67e:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81e680:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e684:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e688:	0f b7 d8             	movzwl %ax,%ebx
  81e68b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e68f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e693:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e697:	0f b7 c0             	movzwl %ax,%eax
  81e69a:	89 c7                	mov    %eax,%edi
  81e69c:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e6a3:	00 00 00 
  81e6a6:	ff d0                	callq  *%rax
  81e6a8:	0f b7 c0             	movzwl %ax,%eax
  81e6ab:	83 e0 01             	and    $0x1,%eax
  81e6ae:	85 c0                	test   %eax,%eax
  81e6b0:	75 27                	jne    81e6d9 <tcp_receive+0x10e3>
  81e6b2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e6b6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e6ba:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e6be:	0f b7 c0             	movzwl %ax,%eax
  81e6c1:	89 c7                	mov    %eax,%edi
  81e6c3:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e6ca:	00 00 00 
  81e6cd:	ff d0                	callq  *%rax
  81e6cf:	0f b7 c0             	movzwl %ax,%eax
  81e6d2:	83 e0 02             	and    $0x2,%eax
  81e6d5:	85 c0                	test   %eax,%eax
  81e6d7:	74 07                	je     81e6e0 <tcp_receive+0x10ea>
  81e6d9:	b8 01 00 00 00       	mov    $0x1,%eax
  81e6de:	eb 05                	jmp    81e6e5 <tcp_receive+0x10ef>
  81e6e0:	b8 00 00 00 00       	mov    $0x0,%eax
  81e6e5:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e6e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6ec:	8b 40 30             	mov    0x30(%rax),%eax
  81e6ef:	01 c2                	add    %eax,%edx
  81e6f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f5:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81e6f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6fc:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81e700:	0f b7 d8             	movzwl %ax,%ebx
  81e703:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e707:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e70b:	44 0f b7 e0          	movzwl %ax,%r12d
  81e70f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e713:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e717:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e71b:	0f b7 c0             	movzwl %ax,%eax
  81e71e:	89 c7                	mov    %eax,%edi
  81e720:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e727:	00 00 00 
  81e72a:	ff d0                	callq  *%rax
  81e72c:	0f b7 c0             	movzwl %ax,%eax
  81e72f:	83 e0 01             	and    $0x1,%eax
  81e732:	85 c0                	test   %eax,%eax
  81e734:	75 27                	jne    81e75d <tcp_receive+0x1167>
  81e736:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e73a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e73e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e742:	0f b7 c0             	movzwl %ax,%eax
  81e745:	89 c7                	mov    %eax,%edi
  81e747:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e74e:	00 00 00 
  81e751:	ff d0                	callq  *%rax
  81e753:	0f b7 c0             	movzwl %ax,%eax
  81e756:	83 e0 02             	and    $0x2,%eax
  81e759:	85 c0                	test   %eax,%eax
  81e75b:	74 07                	je     81e764 <tcp_receive+0x116e>
  81e75d:	b8 01 00 00 00       	mov    $0x1,%eax
  81e762:	eb 05                	jmp    81e769 <tcp_receive+0x1173>
  81e764:	b8 00 00 00 00       	mov    $0x0,%eax
  81e769:	44 01 e0             	add    %r12d,%eax
  81e76c:	39 c3                	cmp    %eax,%ebx
  81e76e:	7d 0c                	jge    81e77c <tcp_receive+0x1186>
            pcb->rcv_wnd = 0;
  81e770:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e774:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81e77a:	eb 7c                	jmp    81e7f8 <tcp_receive+0x1202>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81e77c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e780:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e784:	0f b7 d8             	movzwl %ax,%ebx
  81e787:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e78b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e78f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e793:	0f b7 c0             	movzwl %ax,%eax
  81e796:	89 c7                	mov    %eax,%edi
  81e798:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e79f:	00 00 00 
  81e7a2:	ff d0                	callq  *%rax
  81e7a4:	0f b7 c0             	movzwl %ax,%eax
  81e7a7:	83 e0 01             	and    $0x1,%eax
  81e7aa:	85 c0                	test   %eax,%eax
  81e7ac:	75 27                	jne    81e7d5 <tcp_receive+0x11df>
  81e7ae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e7b2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e7b6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e7ba:	0f b7 c0             	movzwl %ax,%eax
  81e7bd:	89 c7                	mov    %eax,%edi
  81e7bf:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e7c6:	00 00 00 
  81e7c9:	ff d0                	callq  *%rax
  81e7cb:	0f b7 c0             	movzwl %ax,%eax
  81e7ce:	83 e0 02             	and    $0x2,%eax
  81e7d1:	85 c0                	test   %eax,%eax
  81e7d3:	74 07                	je     81e7dc <tcp_receive+0x11e6>
  81e7d5:	b8 01 00 00 00       	mov    $0x1,%eax
  81e7da:	eb 05                	jmp    81e7e1 <tcp_receive+0x11eb>
  81e7dc:	b8 00 00 00 00       	mov    $0x0,%eax
  81e7e1:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e7e4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7e8:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81e7ec:	29 d0                	sub    %edx,%eax
  81e7ee:	89 c2                	mov    %eax,%edx
  81e7f0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7f4:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81e7f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7fc:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81e800:	0f b7 d8             	movzwl %ax,%ebx
  81e803:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e807:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e80b:	44 0f b7 e0          	movzwl %ax,%r12d
  81e80f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e813:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e817:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e81b:	0f b7 c0             	movzwl %ax,%eax
  81e81e:	89 c7                	mov    %eax,%edi
  81e820:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e827:	00 00 00 
  81e82a:	ff d0                	callq  *%rax
  81e82c:	0f b7 c0             	movzwl %ax,%eax
  81e82f:	83 e0 01             	and    $0x1,%eax
  81e832:	85 c0                	test   %eax,%eax
  81e834:	75 27                	jne    81e85d <tcp_receive+0x1267>
  81e836:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e83a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e83e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e842:	0f b7 c0             	movzwl %ax,%eax
  81e845:	89 c7                	mov    %eax,%edi
  81e847:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e84e:	00 00 00 
  81e851:	ff d0                	callq  *%rax
  81e853:	0f b7 c0             	movzwl %ax,%eax
  81e856:	83 e0 02             	and    $0x2,%eax
  81e859:	85 c0                	test   %eax,%eax
  81e85b:	74 07                	je     81e864 <tcp_receive+0x126e>
  81e85d:	b8 01 00 00 00       	mov    $0x1,%eax
  81e862:	eb 05                	jmp    81e869 <tcp_receive+0x1273>
  81e864:	b8 00 00 00 00       	mov    $0x0,%eax
  81e869:	44 01 e0             	add    %r12d,%eax
  81e86c:	39 c3                	cmp    %eax,%ebx
  81e86e:	7d 0c                	jge    81e87c <tcp_receive+0x1286>
            pcb->rcv_ann_wnd = 0;
  81e870:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e874:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81e87a:	eb 7c                	jmp    81e8f8 <tcp_receive+0x1302>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81e87c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e880:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e884:	0f b7 d8             	movzwl %ax,%ebx
  81e887:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e88b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e88f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e893:	0f b7 c0             	movzwl %ax,%eax
  81e896:	89 c7                	mov    %eax,%edi
  81e898:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e89f:	00 00 00 
  81e8a2:	ff d0                	callq  *%rax
  81e8a4:	0f b7 c0             	movzwl %ax,%eax
  81e8a7:	83 e0 01             	and    $0x1,%eax
  81e8aa:	85 c0                	test   %eax,%eax
  81e8ac:	75 27                	jne    81e8d5 <tcp_receive+0x12df>
  81e8ae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e8b2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e8b6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e8ba:	0f b7 c0             	movzwl %ax,%eax
  81e8bd:	89 c7                	mov    %eax,%edi
  81e8bf:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e8c6:	00 00 00 
  81e8c9:	ff d0                	callq  *%rax
  81e8cb:	0f b7 c0             	movzwl %ax,%eax
  81e8ce:	83 e0 02             	and    $0x2,%eax
  81e8d1:	85 c0                	test   %eax,%eax
  81e8d3:	74 07                	je     81e8dc <tcp_receive+0x12e6>
  81e8d5:	b8 01 00 00 00       	mov    $0x1,%eax
  81e8da:	eb 05                	jmp    81e8e1 <tcp_receive+0x12eb>
  81e8dc:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8e1:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e8e4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8e8:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81e8ec:	29 d0                	sub    %edx,%eax
  81e8ee:	89 c2                	mov    %eax,%edx
  81e8f0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8f4:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81e8f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e8fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e900:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e904:	66 85 c0             	test   %ax,%ax
  81e907:	74 5c                	je     81e965 <tcp_receive+0x136f>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81e909:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81e910:	00 00 00 
  81e913:	48 8b 00             	mov    (%rax),%rax
  81e916:	48 85 c0             	test   %rax,%rax
  81e919:	74 29                	je     81e944 <tcp_receive+0x134e>
              pbuf_cat(recv_data, cseg->p);
  81e91b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e91f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81e923:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81e92a:	00 00 00 
  81e92d:	48 8b 00             	mov    (%rax),%rax
  81e930:	48 89 d6             	mov    %rdx,%rsi
  81e933:	48 89 c7             	mov    %rax,%rdi
  81e936:	48 b8 68 d3 80 00 00 	movabs $0x80d368,%rax
  81e93d:	00 00 00 
  81e940:	ff d0                	callq  *%rax
  81e942:	eb 15                	jmp    81e959 <tcp_receive+0x1363>
            } else {
              recv_data = cseg->p;
  81e944:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e948:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81e94c:	48 b8 88 65 b5 00 00 	movabs $0xb56588,%rax
  81e953:	00 00 00 
  81e956:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81e959:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e95d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81e964:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81e965:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e969:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e96d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e971:	0f b7 c0             	movzwl %ax,%eax
  81e974:	89 c7                	mov    %eax,%edi
  81e976:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81e97d:	00 00 00 
  81e980:	ff d0                	callq  *%rax
  81e982:	0f b7 c0             	movzwl %ax,%eax
  81e985:	83 e0 01             	and    $0x1,%eax
  81e988:	85 c0                	test   %eax,%eax
  81e98a:	74 24                	je     81e9b0 <tcp_receive+0x13ba>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81e98c:	48 b8 84 65 b5 00 00 	movabs $0xb56584,%rax
  81e993:	00 00 00 
  81e996:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81e999:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e99d:	8b 40 18             	mov    0x18(%rax),%eax
  81e9a0:	83 f8 04             	cmp    $0x4,%eax
  81e9a3:	75 0b                	jne    81e9b0 <tcp_receive+0x13ba>
              pcb->state = CLOSE_WAIT;
  81e9a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9a9:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81e9b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e9b4:	48 8b 10             	mov    (%rax),%rdx
  81e9b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9bb:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81e9c2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81e9c6:	48 89 c7             	mov    %rax,%rdi
  81e9c9:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  81e9d0:	00 00 00 
  81e9d3:	ff d0                	callq  *%rax
        while (pcb->ooseq != NULL &&
  81e9d5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9d9:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e9e0:	48 85 c0             	test   %rax,%rax
  81e9e3:	74 21                	je     81ea06 <tcp_receive+0x1410>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81e9e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9e9:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e9f0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e9f4:	8b 50 04             	mov    0x4(%rax),%edx
  81e9f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9fb:	8b 40 30             	mov    0x30(%rax),%eax
        while (pcb->ooseq != NULL &&
  81e9fe:	39 c2                	cmp    %eax,%edx
  81ea00:	0f 84 4d fc ff ff    	je     81e653 <tcp_receive+0x105d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81ea06:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea0a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ea0e:	0f b6 c0             	movzbl %al,%eax
  81ea11:	83 e0 01             	and    $0x1,%eax
  81ea14:	85 c0                	test   %eax,%eax
  81ea16:	74 40                	je     81ea58 <tcp_receive+0x1462>
  81ea18:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea1c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ea20:	83 e0 fe             	and    $0xfffffffe,%eax
  81ea23:	89 c2                	mov    %eax,%edx
  81ea25:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea29:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ea2c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea30:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ea34:	83 c8 02             	or     $0x2,%eax
  81ea37:	89 c2                	mov    %eax,%edx
  81ea39:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea3d:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ea40:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea44:	48 89 c7             	mov    %rax,%rdi
  81ea47:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81ea4e:	00 00 00 
  81ea51:	ff d0                	callq  *%rax
  81ea53:	e9 5a 05 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
  81ea58:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea5c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ea60:	83 c8 01             	or     $0x1,%eax
  81ea63:	89 c2                	mov    %eax,%edx
  81ea65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea69:	88 50 2c             	mov    %dl,0x2c(%rax)
      if (pcb->rcv_nxt == seqno) {
  81ea6c:	e9 6c 05 00 00       	jmpq   81efdd <tcp_receive+0x19e7>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81ea71:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea75:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ea79:	83 c8 02             	or     $0x2,%eax
  81ea7c:	89 c2                	mov    %eax,%edx
  81ea7e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea82:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ea85:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea89:	48 89 c7             	mov    %rax,%rdi
  81ea8c:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81ea93:	00 00 00 
  81ea96:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81ea98:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea9c:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eaa3:	48 85 c0             	test   %rax,%rax
  81eaa6:	75 29                	jne    81ead1 <tcp_receive+0x14db>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81eaa8:	48 bf 40 65 b5 00 00 	movabs $0xb56540,%rdi
  81eaaf:	00 00 00 
  81eab2:	48 b8 0c f9 80 00 00 	movabs $0x80f90c,%rax
  81eab9:	00 00 00 
  81eabc:	ff d0                	callq  *%rax
  81eabe:	48 89 c2             	mov    %rax,%rdx
  81eac1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eac5:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
  81eacc:	e9 e1 04 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81ead1:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81ead8:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81ead9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eadd:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eae4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81eae8:	e9 ba 04 00 00       	jmpq   81efa7 <tcp_receive+0x19b1>
            if (seqno == next->tcphdr->seqno) {
  81eaed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eaf1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eaf5:	8b 50 04             	mov    0x4(%rax),%edx
  81eaf8:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81eaff:	00 00 00 
  81eb02:	8b 00                	mov    (%rax),%eax
  81eb04:	39 c2                	cmp    %eax,%edx
  81eb06:	0f 85 25 01 00 00    	jne    81ec31 <tcp_receive+0x163b>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81eb0c:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81eb13:	00 00 00 
  81eb16:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81eb1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eb1e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eb22:	66 39 c2             	cmp    %ax,%dx
  81eb25:	0f 86 01 01 00 00    	jbe    81ec2c <tcp_receive+0x1636>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81eb2b:	48 bf 40 65 b5 00 00 	movabs $0xb56540,%rdi
  81eb32:	00 00 00 
  81eb35:	48 b8 0c f9 80 00 00 	movabs $0x80f90c,%rax
  81eb3c:	00 00 00 
  81eb3f:	ff d0                	callq  *%rax
  81eb41:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81eb45:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81eb4a:	0f 84 d7 00 00 00    	je     81ec27 <tcp_receive+0x1631>
                  cseg->next = next->next;
  81eb50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eb54:	48 8b 10             	mov    (%rax),%rdx
  81eb57:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eb5b:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81eb5e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81eb63:	74 0d                	je     81eb72 <tcp_receive+0x157c>
                    prev->next = cseg;
  81eb65:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81eb69:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81eb6d:	48 89 10             	mov    %rdx,(%rax)
  81eb70:	eb 0f                	jmp    81eb81 <tcp_receive+0x158b>
                  } else {
                    pcb->ooseq = cseg;
  81eb72:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb76:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81eb7a:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81eb81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eb85:	48 89 c7             	mov    %rax,%rdi
  81eb88:	48 b8 92 f8 80 00 00 	movabs $0x80f892,%rax
  81eb8f:	00 00 00 
  81eb92:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81eb94:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eb98:	48 8b 00             	mov    (%rax),%rax
  81eb9b:	48 85 c0             	test   %rax,%rax
  81eb9e:	0f 84 83 00 00 00    	je     81ec27 <tcp_receive+0x1631>
                    next = cseg->next;
  81eba4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eba8:	48 8b 00             	mov    (%rax),%rax
  81ebab:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81ebaf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ebb3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ebb7:	0f b7 d0             	movzwl %ax,%edx
  81ebba:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ebc1:	00 00 00 
  81ebc4:	8b 00                	mov    (%rax),%eax
  81ebc6:	01 c2                	add    %eax,%edx
  81ebc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ebcc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ebd0:	8b 40 04             	mov    0x4(%rax),%eax
  81ebd3:	29 c2                	sub    %eax,%edx
  81ebd5:	89 d0                	mov    %edx,%eax
  81ebd7:	85 c0                	test   %eax,%eax
  81ebd9:	7e 4c                	jle    81ec27 <tcp_receive+0x1631>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81ebdb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ebdf:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ebe3:	8b 40 04             	mov    0x4(%rax),%eax
  81ebe6:	89 c2                	mov    %eax,%edx
  81ebe8:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ebef:	00 00 00 
  81ebf2:	8b 00                	mov    (%rax),%eax
  81ebf4:	29 c2                	sub    %eax,%edx
  81ebf6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ebfa:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81ebfe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ec02:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ec06:	0f b7 d0             	movzwl %ax,%edx
  81ec09:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ec0d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ec11:	89 d6                	mov    %edx,%esi
  81ec13:	48 89 c7             	mov    %rax,%rdi
  81ec16:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  81ec1d:	00 00 00 
  81ec20:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81ec22:	e9 8b 03 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
  81ec27:	e9 86 03 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81ec2c:	e9 81 03 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
              }
            } else {
              if (prev == NULL) {
  81ec31:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81ec36:	0f 85 f3 00 00 00    	jne    81ed2f <tcp_receive+0x1739>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81ec3c:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ec43:	00 00 00 
  81ec46:	8b 10                	mov    (%rax),%edx
  81ec48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ec4c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec50:	8b 40 04             	mov    0x4(%rax),%eax
  81ec53:	29 c2                	sub    %eax,%edx
  81ec55:	89 d0                	mov    %edx,%eax
  81ec57:	85 c0                	test   %eax,%eax
  81ec59:	0f 89 5f 02 00 00    	jns    81eebe <tcp_receive+0x18c8>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81ec5f:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81ec66:	00 00 00 
  81ec69:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ec6d:	0f b7 d0             	movzwl %ax,%edx
  81ec70:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ec77:	00 00 00 
  81ec7a:	8b 00                	mov    (%rax),%eax
  81ec7c:	01 c2                	add    %eax,%edx
  81ec7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ec82:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec86:	8b 40 04             	mov    0x4(%rax),%eax
  81ec89:	29 c2                	sub    %eax,%edx
  81ec8b:	89 d0                	mov    %edx,%eax
  81ec8d:	85 c0                	test   %eax,%eax
  81ec8f:	7e 59                	jle    81ecea <tcp_receive+0x16f4>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81ec91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ec95:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec99:	8b 40 04             	mov    0x4(%rax),%eax
  81ec9c:	89 c2                	mov    %eax,%edx
  81ec9e:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81eca5:	00 00 00 
  81eca8:	8b 00                	mov    (%rax),%eax
  81ecaa:	29 c2                	sub    %eax,%edx
  81ecac:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81ecb3:	00 00 00 
  81ecb6:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81ecba:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81ecc1:	00 00 00 
  81ecc4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ecc8:	0f b7 d0             	movzwl %ax,%edx
  81eccb:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81ecd2:	00 00 00 
  81ecd5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ecd9:	89 d6                	mov    %edx,%esi
  81ecdb:	48 89 c7             	mov    %rax,%rdi
  81ecde:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  81ece5:	00 00 00 
  81ece8:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81ecea:	48 bf 40 65 b5 00 00 	movabs $0xb56540,%rdi
  81ecf1:	00 00 00 
  81ecf4:	48 b8 0c f9 80 00 00 	movabs $0x80f90c,%rax
  81ecfb:	00 00 00 
  81ecfe:	ff d0                	callq  *%rax
  81ed00:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81ed04:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81ed09:	74 1f                	je     81ed2a <tcp_receive+0x1734>
                    cseg->next = next;
  81ed0b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ed0f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81ed13:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81ed16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed1a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81ed1e:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81ed25:	e9 88 02 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
  81ed2a:	e9 83 02 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81ed2f:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ed36:	00 00 00 
  81ed39:	8b 10                	mov    (%rax),%edx
  81ed3b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ed3f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ed43:	8b 40 04             	mov    0x4(%rax),%eax
  81ed46:	29 c2                	sub    %eax,%edx
  81ed48:	89 d0                	mov    %edx,%eax
  81ed4a:	83 e8 01             	sub    $0x1,%eax
  81ed4d:	85 c0                	test   %eax,%eax
  81ed4f:	0f 88 69 01 00 00    	js     81eebe <tcp_receive+0x18c8>
  81ed55:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ed5c:	00 00 00 
  81ed5f:	8b 10                	mov    (%rax),%edx
  81ed61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ed65:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ed69:	8b 40 04             	mov    0x4(%rax),%eax
  81ed6c:	29 c2                	sub    %eax,%edx
  81ed6e:	89 d0                	mov    %edx,%eax
  81ed70:	83 c0 01             	add    $0x1,%eax
  81ed73:	85 c0                	test   %eax,%eax
  81ed75:	0f 8f 43 01 00 00    	jg     81eebe <tcp_receive+0x18c8>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81ed7b:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81ed82:	00 00 00 
  81ed85:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ed89:	0f b7 d0             	movzwl %ax,%edx
  81ed8c:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ed93:	00 00 00 
  81ed96:	8b 00                	mov    (%rax),%eax
  81ed98:	01 c2                	add    %eax,%edx
  81ed9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ed9e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eda2:	8b 40 04             	mov    0x4(%rax),%eax
  81eda5:	29 c2                	sub    %eax,%edx
  81eda7:	89 d0                	mov    %edx,%eax
  81eda9:	85 c0                	test   %eax,%eax
  81edab:	7e 59                	jle    81ee06 <tcp_receive+0x1810>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81edad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81edb1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81edb5:	8b 40 04             	mov    0x4(%rax),%eax
  81edb8:	89 c2                	mov    %eax,%edx
  81edba:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81edc1:	00 00 00 
  81edc4:	8b 00                	mov    (%rax),%eax
  81edc6:	29 c2                	sub    %eax,%edx
  81edc8:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81edcf:	00 00 00 
  81edd2:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81edd6:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81eddd:	00 00 00 
  81ede0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ede4:	0f b7 d0             	movzwl %ax,%edx
  81ede7:	48 b8 40 65 b5 00 00 	movabs $0xb56540,%rax
  81edee:	00 00 00 
  81edf1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81edf5:	89 d6                	mov    %edx,%esi
  81edf7:	48 89 c7             	mov    %rax,%rdi
  81edfa:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  81ee01:	00 00 00 
  81ee04:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81ee06:	48 bf 40 65 b5 00 00 	movabs $0xb56540,%rdi
  81ee0d:	00 00 00 
  81ee10:	48 b8 0c f9 80 00 00 	movabs $0x80f90c,%rax
  81ee17:	00 00 00 
  81ee1a:	ff d0                	callq  *%rax
  81ee1c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81ee20:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81ee25:	0f 84 8e 00 00 00    	je     81eeb9 <tcp_receive+0x18c3>
                  cseg->next = next;
  81ee2b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ee2f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81ee33:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81ee36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee3a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81ee3e:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81ee41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee45:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee49:	8b 50 04             	mov    0x4(%rax),%edx
  81ee4c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee50:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ee54:	0f b7 c0             	movzwl %ax,%eax
  81ee57:	01 c2                	add    %eax,%edx
  81ee59:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ee60:	00 00 00 
  81ee63:	8b 00                	mov    (%rax),%eax
  81ee65:	29 c2                	sub    %eax,%edx
  81ee67:	89 d0                	mov    %edx,%eax
  81ee69:	85 c0                	test   %eax,%eax
  81ee6b:	7e 4c                	jle    81eeb9 <tcp_receive+0x18c3>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81ee6d:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ee74:	00 00 00 
  81ee77:	8b 00                	mov    (%rax),%eax
  81ee79:	89 c2                	mov    %eax,%edx
  81ee7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee7f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee83:	8b 40 04             	mov    0x4(%rax),%eax
  81ee86:	29 c2                	sub    %eax,%edx
  81ee88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee8c:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81ee90:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee94:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ee98:	0f b7 d0             	movzwl %ax,%edx
  81ee9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ee9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eea3:	89 d6                	mov    %edx,%esi
  81eea5:	48 89 c7             	mov    %rax,%rdi
  81eea8:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  81eeaf:	00 00 00 
  81eeb2:	ff d0                	callq  *%rax
                  }
                }
                break;
  81eeb4:	e9 f9 00 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
  81eeb9:	e9 f4 00 00 00       	jmpq   81efb2 <tcp_receive+0x19bc>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81eebe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eec2:	48 8b 00             	mov    (%rax),%rax
  81eec5:	48 85 c0             	test   %rax,%rax
  81eec8:	0f 85 c6 00 00 00    	jne    81ef94 <tcp_receive+0x199e>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81eece:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81eed5:	00 00 00 
  81eed8:	8b 10                	mov    (%rax),%edx
  81eeda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eede:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eee2:	8b 40 04             	mov    0x4(%rax),%eax
  81eee5:	29 c2                	sub    %eax,%edx
  81eee7:	89 d0                	mov    %edx,%eax
              if (next->next == NULL &&
  81eee9:	85 c0                	test   %eax,%eax
  81eeeb:	0f 8e a3 00 00 00    	jle    81ef94 <tcp_receive+0x199e>
                next->next = tcp_seg_copy(&inseg);
  81eef1:	48 bf 40 65 b5 00 00 	movabs $0xb56540,%rdi
  81eef8:	00 00 00 
  81eefb:	48 b8 0c f9 80 00 00 	movabs $0x80f90c,%rax
  81ef02:	00 00 00 
  81ef05:	ff d0                	callq  *%rax
  81ef07:	48 89 c2             	mov    %rax,%rdx
  81ef0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef0e:	48 89 10             	mov    %rdx,(%rax)
                if (next->next != NULL) {
  81ef11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef15:	48 8b 00             	mov    (%rax),%rax
  81ef18:	48 85 c0             	test   %rax,%rax
  81ef1b:	74 75                	je     81ef92 <tcp_receive+0x199c>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81ef1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef21:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef25:	8b 50 04             	mov    0x4(%rax),%edx
  81ef28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef2c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ef30:	0f b7 c0             	movzwl %ax,%eax
  81ef33:	01 c2                	add    %eax,%edx
  81ef35:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ef3c:	00 00 00 
  81ef3f:	8b 00                	mov    (%rax),%eax
  81ef41:	29 c2                	sub    %eax,%edx
  81ef43:	89 d0                	mov    %edx,%eax
  81ef45:	85 c0                	test   %eax,%eax
  81ef47:	7e 49                	jle    81ef92 <tcp_receive+0x199c>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81ef49:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81ef50:	00 00 00 
  81ef53:	8b 00                	mov    (%rax),%eax
  81ef55:	89 c2                	mov    %eax,%edx
  81ef57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef5b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef5f:	8b 40 04             	mov    0x4(%rax),%eax
  81ef62:	29 c2                	sub    %eax,%edx
  81ef64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef68:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81ef6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef70:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ef74:	0f b7 d0             	movzwl %ax,%edx
  81ef77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef7b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ef7f:	89 d6                	mov    %edx,%esi
  81ef81:	48 89 c7             	mov    %rax,%rdi
  81ef84:	48 b8 53 cd 80 00 00 	movabs $0x80cd53,%rax
  81ef8b:	00 00 00 
  81ef8e:	ff d0                	callq  *%rax
                  }
                }
                break;
  81ef90:	eb 20                	jmp    81efb2 <tcp_receive+0x19bc>
  81ef92:	eb 1e                	jmp    81efb2 <tcp_receive+0x19bc>
              }
            }
            prev = next;
  81ef94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ef98:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81ef9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81efa0:	48 8b 00             	mov    (%rax),%rax
  81efa3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81efa7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81efac:	0f 85 3b fb ff ff    	jne    81eaed <tcp_receive+0x14f7>
      if (pcb->rcv_nxt == seqno) {
  81efb2:	eb 29                	jmp    81efdd <tcp_receive+0x19e7>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81efb4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efb8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81efbc:	83 c8 02             	or     $0x2,%eax
  81efbf:	89 c2                	mov    %eax,%edx
  81efc1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efc5:	88 50 2c             	mov    %dl,0x2c(%rax)
  81efc8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efcc:	48 89 c7             	mov    %rax,%rdi
  81efcf:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81efd6:	00 00 00 
  81efd9:	ff d0                	callq  *%rax
  81efdb:	eb 6f                	jmp    81f04c <tcp_receive+0x1a56>
  81efdd:	eb 6d                	jmp    81f04c <tcp_receive+0x1a56>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81efdf:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81efe6:	00 00 00 
  81efe9:	8b 10                	mov    (%rax),%edx
  81efeb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efef:	8b 40 30             	mov    0x30(%rax),%eax
  81eff2:	29 c2                	sub    %eax,%edx
  81eff4:	89 d0                	mov    %edx,%eax
  81eff6:	85 c0                	test   %eax,%eax
  81eff8:	78 2b                	js     81f025 <tcp_receive+0x1a2f>
  81effa:	48 b8 78 65 b5 00 00 	movabs $0xb56578,%rax
  81f001:	00 00 00 
  81f004:	8b 10                	mov    (%rax),%edx
  81f006:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f00a:	8b 48 30             	mov    0x30(%rax),%ecx
  81f00d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f011:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f015:	0f b7 c0             	movzwl %ax,%eax
  81f018:	01 c8                	add    %ecx,%eax
  81f01a:	29 c2                	sub    %eax,%edx
  81f01c:	89 d0                	mov    %edx,%eax
  81f01e:	83 c0 01             	add    $0x1,%eax
  81f021:	85 c0                	test   %eax,%eax
  81f023:	7e 27                	jle    81f04c <tcp_receive+0x1a56>
      tcp_ack_now(pcb);
  81f025:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f029:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f02d:	83 c8 02             	or     $0x2,%eax
  81f030:	89 c2                	mov    %eax,%edx
  81f032:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f036:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f039:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f03d:	48 89 c7             	mov    %rax,%rdi
  81f040:	48 b8 89 30 81 00 00 	movabs $0x813089,%rax
  81f047:	00 00 00 
  81f04a:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81f04c:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81f050:	48 83 c4 58          	add    $0x58,%rsp
  81f054:	5b                   	pop    %rbx
  81f055:	41 5c                	pop    %r12
  81f057:	41 5d                	pop    %r13
  81f059:	5d                   	pop    %rbp
  81f05a:	c3                   	retq   

000000000081f05b <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81f05b:	55                   	push   %rbp
  81f05c:	48 89 e5             	mov    %rsp,%rbp
  81f05f:	53                   	push   %rbx
  81f060:	48 83 ec 38          	sub    $0x38,%rsp
  81f064:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81f068:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81f06f:	00 00 00 
  81f072:	48 8b 00             	mov    (%rax),%rax
  81f075:	48 83 c0 14          	add    $0x14,%rax
  81f079:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81f07d:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81f084:	00 00 00 
  81f087:	48 8b 00             	mov    (%rax),%rax
  81f08a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f08e:	0f b7 c0             	movzwl %ax,%eax
  81f091:	89 c7                	mov    %eax,%edi
  81f093:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81f09a:	00 00 00 
  81f09d:	ff d0                	callq  *%rax
  81f09f:	66 c1 e8 0c          	shr    $0xc,%ax
  81f0a3:	66 83 f8 05          	cmp    $0x5,%ax
  81f0a7:	0f 86 11 01 00 00    	jbe    81f1be <tcp_parseopt+0x163>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f0ad:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81f0b1:	e9 cd 00 00 00       	jmpq   81f183 <tcp_parseopt+0x128>
      opt = opts[c];
  81f0b6:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  81f0ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f0be:	48 01 d0             	add    %rdx,%rax
  81f0c1:	0f b6 00             	movzbl (%rax),%eax
  81f0c4:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81f0c7:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81f0cb:	75 05                	jne    81f0d2 <tcp_parseopt+0x77>
        /* End of options. */
        break;
  81f0cd:	e9 ec 00 00 00       	jmpq   81f1be <tcp_parseopt+0x163>
      } else if (opt == 0x01) {
  81f0d2:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81f0d6:	75 09                	jne    81f0e1 <tcp_parseopt+0x86>
        ++c;
  81f0d8:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81f0dc:	e9 a2 00 00 00       	jmpq   81f183 <tcp_parseopt+0x128>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f0e1:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81f0e5:	75 6f                	jne    81f156 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
  81f0e7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f0eb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81f0ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f0f3:	48 01 d0             	add    %rdx,%rax
  81f0f6:	0f b6 00             	movzbl (%rax),%eax
      } else if (opt == 0x02 &&
  81f0f9:	3c 04                	cmp    $0x4,%al
  81f0fb:	75 59                	jne    81f156 <tcp_parseopt+0xfb>
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81f0fd:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f101:	48 8d 50 02          	lea    0x2(%rax),%rdx
  81f105:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f109:	48 01 d0             	add    %rdx,%rax
  81f10c:	0f b6 00             	movzbl (%rax),%eax
  81f10f:	0f b6 c0             	movzbl %al,%eax
  81f112:	c1 e0 08             	shl    $0x8,%eax
  81f115:	89 c1                	mov    %eax,%ecx
  81f117:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f11b:	48 8d 50 03          	lea    0x3(%rax),%rdx
  81f11f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f123:	48 01 d0             	add    %rdx,%rax
  81f126:	0f b6 00             	movzbl (%rax),%eax
  81f129:	0f b6 c0             	movzbl %al,%eax
  81f12c:	09 c8                	or     %ecx,%eax
  81f12e:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81f132:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81f138:	77 0d                	ja     81f147 <tcp_parseopt+0xec>
  81f13a:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81f13f:	74 06                	je     81f147 <tcp_parseopt+0xec>
  81f141:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81f145:	eb 05                	jmp    81f14c <tcp_parseopt+0xf1>
  81f147:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81f14c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f150:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81f154:	eb 68                	jmp    81f1be <tcp_parseopt+0x163>
      } else {
        if (opts[c + 1] == 0) {
  81f156:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f15a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81f15e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f162:	48 01 d0             	add    %rdx,%rax
  81f165:	0f b6 00             	movzbl (%rax),%eax
  81f168:	84 c0                	test   %al,%al
  81f16a:	75 02                	jne    81f16e <tcp_parseopt+0x113>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81f16c:	eb 50                	jmp    81f1be <tcp_parseopt+0x163>
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81f16e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f172:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81f176:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f17a:	48 01 d0             	add    %rdx,%rax
  81f17d:	0f b6 00             	movzbl (%rax),%eax
  81f180:	00 45 ef             	add    %al,-0x11(%rbp)
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f183:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81f187:	48 b8 68 65 b5 00 00 	movabs $0xb56568,%rax
  81f18e:	00 00 00 
  81f191:	48 8b 00             	mov    (%rax),%rax
  81f194:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f198:	0f b7 c0             	movzwl %ax,%eax
  81f19b:	89 c7                	mov    %eax,%edi
  81f19d:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81f1a4:	00 00 00 
  81f1a7:	ff d0                	callq  *%rax
  81f1a9:	66 c1 e8 0c          	shr    $0xc,%ax
  81f1ad:	0f b7 c0             	movzwl %ax,%eax
  81f1b0:	83 e8 05             	sub    $0x5,%eax
  81f1b3:	c1 e0 02             	shl    $0x2,%eax
  81f1b6:	39 c3                	cmp    %eax,%ebx
  81f1b8:	0f 8c f8 fe ff ff    	jl     81f0b6 <tcp_parseopt+0x5b>
      }
    }
  }
}
  81f1be:	48 83 c4 38          	add    $0x38,%rsp
  81f1c2:	5b                   	pop    %rbx
  81f1c3:	5d                   	pop    %rbp
  81f1c4:	c3                   	retq   

000000000081f1c5 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81f1c5:	55                   	push   %rbp
  81f1c6:	48 89 e5             	mov    %rsp,%rbp
  81f1c9:	48 83 ec 40          	sub    $0x40,%rsp
  81f1cd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81f1d1:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81f1d5:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81f1d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81f1dd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f1e1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81f1e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f1e9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81f1ed:	0f b7 c0             	movzwl %ax,%eax
  81f1f0:	89 c7                	mov    %eax,%edi
  81f1f2:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81f1f9:	00 00 00 
  81f1fc:	ff d0                	callq  *%rax
  81f1fe:	66 25 ff 00          	and    $0xff,%ax
  81f202:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81f206:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81f20d:	00 
  pcb = raw_pcbs;
  81f20e:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f215:	00 00 00 
  81f218:	48 8b 00             	mov    (%rax),%rax
  81f21b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81f21f:	e9 a3 00 00 00       	jmpq   81f2c7 <raw_input+0x102>
    if (pcb->protocol == proto) {
  81f224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f228:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81f22c:	0f b6 d0             	movzbl %al,%edx
  81f22f:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81f233:	39 c2                	cmp    %eax,%edx
  81f235:	75 7c                	jne    81f2b3 <raw_input+0xee>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81f237:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f23b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f23f:	48 85 c0             	test   %rax,%rax
  81f242:	74 6f                	je     81f2b3 <raw_input+0xee>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81f244:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f248:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f24c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81f250:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81f254:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f258:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  81f25c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f260:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81f264:	ff d0                	callq  *%rax
  81f266:	84 c0                	test   %al,%al
  81f268:	74 49                	je     81f2b3 <raw_input+0xee>
        {
          /* receive function ate the packet */
          p = NULL;
  81f26a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81f271:	00 
          eaten = 1;
  81f272:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81f276:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f27b:	74 36                	je     81f2b3 <raw_input+0xee>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81f27d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f281:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81f285:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f289:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81f28d:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f294:	00 00 00 
  81f297:	48 8b 10             	mov    (%rax),%rdx
  81f29a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f29e:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81f2a2:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f2a9:	00 00 00 
  81f2ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f2b0:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81f2b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f2b7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81f2bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f2bf:	48 8b 40 10          	mov    0x10(%rax),%rax
  81f2c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while ((eaten == 0) && (pcb != NULL)) {
  81f2c7:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81f2cb:	75 0b                	jne    81f2d8 <raw_input+0x113>
  81f2cd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81f2d2:	0f 85 4c ff ff ff    	jne    81f224 <raw_input+0x5f>
  }
  return eaten;
  81f2d8:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81f2dc:	c9                   	leaveq 
  81f2dd:	c3                   	retq   

000000000081f2de <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81f2de:	55                   	push   %rbp
  81f2df:	48 89 e5             	mov    %rsp,%rbp
  81f2e2:	48 83 ec 10          	sub    $0x10,%rsp
  81f2e6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f2ea:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  81f2ee:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f2f3:	74 08                	je     81f2fd <raw_bind+0x1f>
  81f2f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f2f9:	8b 00                	mov    (%rax),%eax
  81f2fb:	eb 05                	jmp    81f302 <raw_bind+0x24>
  81f2fd:	b8 00 00 00 00       	mov    $0x0,%eax
  81f302:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f306:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  81f308:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81f30d:	c9                   	leaveq 
  81f30e:	c3                   	retq   

000000000081f30f <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81f30f:	55                   	push   %rbp
  81f310:	48 89 e5             	mov    %rsp,%rbp
  81f313:	48 83 ec 10          	sub    $0x10,%rsp
  81f317:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f31b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81f31f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f324:	74 08                	je     81f32e <raw_connect+0x1f>
  81f326:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f32a:	8b 00                	mov    (%rax),%eax
  81f32c:	eb 05                	jmp    81f333 <raw_connect+0x24>
  81f32e:	b8 00 00 00 00       	mov    $0x0,%eax
  81f333:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f337:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  81f33a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81f33f:	c9                   	leaveq 
  81f340:	c3                   	retq   

000000000081f341 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81f341:	55                   	push   %rbp
  81f342:	48 89 e5             	mov    %rsp,%rbp
  81f345:	48 83 ec 18          	sub    $0x18,%rsp
  81f349:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f34d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81f351:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81f355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f359:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81f35d:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81f361:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f365:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81f369:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81f36d:	c9                   	leaveq 
  81f36e:	c3                   	retq   

000000000081f36f <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  81f36f:	55                   	push   %rbp
  81f370:	48 89 e5             	mov    %rsp,%rbp
  81f373:	48 83 ec 40          	sub    $0x40,%rsp
  81f377:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81f37b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81f37f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81f383:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f387:	be 14 00 00 00       	mov    $0x14,%esi
  81f38c:	48 89 c7             	mov    %rax,%rdi
  81f38f:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f396:	00 00 00 
  81f399:	ff d0                	callq  *%rax
  81f39b:	84 c0                	test   %al,%al
  81f39d:	74 4c                	je     81f3eb <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81f39f:	ba 00 00 00 00       	mov    $0x0,%edx
  81f3a4:	be 00 00 00 00       	mov    $0x0,%esi
  81f3a9:	bf 01 00 00 00       	mov    $0x1,%edi
  81f3ae:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81f3b5:	00 00 00 
  81f3b8:	ff d0                	callq  *%rax
  81f3ba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81f3be:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f3c3:	75 0a                	jne    81f3cf <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  81f3c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81f3ca:	e9 4a 01 00 00       	jmpq   81f519 <raw_sendto+0x1aa>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81f3cf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81f3d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f3d7:	48 89 d6             	mov    %rdx,%rsi
  81f3da:	48 89 c7             	mov    %rax,%rdi
  81f3dd:	48 b8 87 d4 80 00 00 	movabs $0x80d487,%rax
  81f3e4:	00 00 00 
  81f3e7:	ff d0                	callq  *%rax
  81f3e9:	eb 4e                	jmp    81f439 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81f3eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f3ef:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  81f3f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f3f7:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81f3fc:	48 89 c7             	mov    %rax,%rdi
  81f3ff:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f406:	00 00 00 
  81f409:	ff d0                	callq  *%rax
  81f40b:	84 c0                	test   %al,%al
  81f40d:	74 2a                	je     81f439 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  81f40f:	48 ba 98 2f 82 00 00 	movabs $0x822f98,%rdx
  81f416:	00 00 00 
  81f419:	be e3 00 00 00       	mov    $0xe3,%esi
  81f41e:	48 bf be 2f 82 00 00 	movabs $0x822fbe,%rdi
  81f425:	00 00 00 
  81f428:	b8 00 00 00 00       	mov    $0x0,%eax
  81f42d:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81f434:	00 00 00 
  81f437:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  81f439:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81f43d:	48 89 c7             	mov    %rax,%rdi
  81f440:	48 b8 f4 01 81 00 00 	movabs $0x8101f4,%rax
  81f447:	00 00 00 
  81f44a:	ff d0                	callq  *%rax
  81f44c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81f450:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81f455:	75 27                	jne    81f47e <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81f457:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f45b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81f45f:	74 13                	je     81f474 <raw_sendto+0x105>
      pbuf_free(q);
  81f461:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f465:	48 89 c7             	mov    %rax,%rdi
  81f468:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81f46f:	00 00 00 
  81f472:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  81f474:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81f479:	e9 9b 00 00 00       	jmpq   81f519 <raw_sendto+0x1aa>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81f47e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f482:	48 85 c0             	test   %rax,%rax
  81f485:	74 0a                	je     81f491 <raw_sendto+0x122>
  81f487:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f48b:	8b 00                	mov    (%rax),%eax
  81f48d:	85 c0                	test   %eax,%eax
  81f48f:	75 0e                	jne    81f49f <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81f491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f495:	48 83 c0 08          	add    $0x8,%rax
  81f499:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81f49d:	eb 08                	jmp    81f4a7 <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  81f49f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  81f4a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4ab:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81f4af:	44 0f b6 c0          	movzbl %al,%r8d
  81f4b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4b7:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81f4bb:	0f b6 f8             	movzbl %al,%edi
  81f4be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4c2:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81f4c6:	0f b6 c8             	movzbl %al,%ecx
  81f4c9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f4cd:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81f4d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f4d5:	48 83 ec 08          	sub    $0x8,%rsp
  81f4d9:	ff 75 e8             	pushq  -0x18(%rbp)
  81f4dc:	45 89 c1             	mov    %r8d,%r9d
  81f4df:	41 89 f8             	mov    %edi,%r8d
  81f4e2:	48 89 c7             	mov    %rax,%rdi
  81f4e5:	48 b8 29 07 81 00 00 	movabs $0x810729,%rax
  81f4ec:	00 00 00 
  81f4ef:	ff d0                	callq  *%rax
  81f4f1:	48 83 c4 10          	add    $0x10,%rsp
  81f4f5:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81f4f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f4fc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81f500:	74 13                	je     81f515 <raw_sendto+0x1a6>
    /* free the header */
    pbuf_free(q);
  81f502:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f506:	48 89 c7             	mov    %rax,%rdi
  81f509:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81f510:	00 00 00 
  81f513:	ff d0                	callq  *%rax
  }
  return err;
  81f515:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  81f519:	c9                   	leaveq 
  81f51a:	c3                   	retq   

000000000081f51b <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  81f51b:	55                   	push   %rbp
  81f51c:	48 89 e5             	mov    %rsp,%rbp
  81f51f:	48 83 ec 10          	sub    $0x10,%rsp
  81f523:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f527:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81f52b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f52f:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81f533:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81f537:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f53b:	48 89 ce             	mov    %rcx,%rsi
  81f53e:	48 89 c7             	mov    %rax,%rdi
  81f541:	48 b8 6f f3 81 00 00 	movabs $0x81f36f,%rax
  81f548:	00 00 00 
  81f54b:	ff d0                	callq  *%rax
}
  81f54d:	c9                   	leaveq 
  81f54e:	c3                   	retq   

000000000081f54f <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81f54f:	55                   	push   %rbp
  81f550:	48 89 e5             	mov    %rsp,%rbp
  81f553:	48 83 ec 20          	sub    $0x20,%rsp
  81f557:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  81f55b:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f562:	00 00 00 
  81f565:	48 8b 00             	mov    (%rax),%rax
  81f568:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81f56c:	75 20                	jne    81f58e <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  81f56e:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f575:	00 00 00 
  81f578:	48 8b 00             	mov    (%rax),%rax
  81f57b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81f57f:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f586:	00 00 00 
  81f589:	48 89 10             	mov    %rdx,(%rax)
  81f58c:	eb 51                	jmp    81f5df <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81f58e:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f595:	00 00 00 
  81f598:	48 8b 00             	mov    (%rax),%rax
  81f59b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81f59f:	eb 37                	jmp    81f5d8 <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  81f5a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f5a5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81f5a9:	48 85 c0             	test   %rax,%rax
  81f5ac:	74 1e                	je     81f5cc <raw_remove+0x7d>
  81f5ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f5b2:	48 8b 40 10          	mov    0x10(%rax),%rax
  81f5b6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81f5ba:	75 10                	jne    81f5cc <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81f5bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f5c0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81f5c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f5c8:	48 89 50 10          	mov    %rdx,0x10(%rax)
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81f5cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f5d0:	48 8b 40 10          	mov    0x10(%rax),%rax
  81f5d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81f5d8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81f5dd:	75 c2                	jne    81f5a1 <raw_remove+0x52>
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  81f5df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f5e3:	48 89 c6             	mov    %rax,%rsi
  81f5e6:	bf 00 00 00 00       	mov    $0x0,%edi
  81f5eb:	48 b8 24 c3 80 00 00 	movabs $0x80c324,%rax
  81f5f2:	00 00 00 
  81f5f5:	ff d0                	callq  *%rax
}
  81f5f7:	c9                   	leaveq 
  81f5f8:	c3                   	retq   

000000000081f5f9 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  81f5f9:	55                   	push   %rbp
  81f5fa:	48 89 e5             	mov    %rsp,%rbp
  81f5fd:	48 83 ec 20          	sub    $0x20,%rsp
  81f601:	89 f8                	mov    %edi,%eax
  81f603:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  81f606:	bf 00 00 00 00       	mov    $0x0,%edi
  81f60b:	48 b8 79 c2 80 00 00 	movabs $0x80c279,%rax
  81f612:	00 00 00 
  81f615:	ff d0                	callq  *%rax
  81f617:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  81f61b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81f620:	74 56                	je     81f678 <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  81f622:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f626:	ba 30 00 00 00       	mov    $0x30,%edx
  81f62b:	be 00 00 00 00       	mov    $0x0,%esi
  81f630:	48 89 c7             	mov    %rax,%rdi
  81f633:	48 b8 4c 1f 80 00 00 	movabs $0x801f4c,%rax
  81f63a:	00 00 00 
  81f63d:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  81f63f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f643:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  81f647:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  81f64a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f64e:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  81f652:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f659:	00 00 00 
  81f65c:	48 8b 10             	mov    (%rax),%rdx
  81f65f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f663:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  81f667:	48 b8 90 65 b5 00 00 	movabs $0xb56590,%rax
  81f66e:	00 00 00 
  81f671:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f675:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  81f678:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81f67c:	c9                   	leaveq 
  81f67d:	c3                   	retq   

000000000081f67e <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  81f67e:	55                   	push   %rbp
  81f67f:	48 89 e5             	mov    %rsp,%rbp
  81f682:	53                   	push   %rbx
  81f683:	48 83 ec 48          	sub    $0x48,%rsp
  81f687:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  81f68b:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  81f68f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f693:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f697:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  81f69b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f69f:	0f b7 00             	movzwl (%rax),%eax
  81f6a2:	0f b7 c0             	movzwl %ax,%eax
  81f6a5:	89 c7                	mov    %eax,%edi
  81f6a7:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81f6ae:	00 00 00 
  81f6b1:	ff d0                	callq  *%rax
  81f6b3:	66 c1 e8 08          	shr    $0x8,%ax
  81f6b7:	83 e0 0f             	and    $0xf,%eax
  81f6ba:	c1 e0 02             	shl    $0x2,%eax
  81f6bd:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  81f6c1:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  81f6c5:	f7 d8                	neg    %eax
  81f6c7:	0f bf d0             	movswl %ax,%edx
  81f6ca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f6ce:	89 d6                	mov    %edx,%esi
  81f6d0:	48 89 c7             	mov    %rax,%rdi
  81f6d3:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f6da:	00 00 00 
  81f6dd:	ff d0                	callq  *%rax
  81f6df:	84 c0                	test   %al,%al
  81f6e1:	75 0e                	jne    81f6f1 <icmp_input+0x73>
  81f6e3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f6e7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f6eb:	66 83 f8 03          	cmp    $0x3,%ax
  81f6ef:	77 05                	ja     81f6f6 <icmp_input+0x78>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  81f6f1:	e9 9d 04 00 00       	jmpq   81fb93 <icmp_input+0x515>
  }

  type = *((u8_t *)p->payload);
  81f6f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f6fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f6fe:	0f b6 00             	movzbl (%rax),%eax
  81f701:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  81f704:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f708:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f70c:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  81f710:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  81f713:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  81f717:	83 f8 08             	cmp    $0x8,%eax
  81f71a:	74 05                	je     81f721 <icmp_input+0xa3>
  81f71c:	e9 5d 04 00 00       	jmpq   81fb7e <icmp_input+0x500>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  81f721:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f725:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81f729:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81f72d:	48 89 c6             	mov    %rax,%rsi
  81f730:	48 89 d7             	mov    %rdx,%rdi
  81f733:	48 b8 57 01 81 00 00 	movabs $0x810157,%rax
  81f73a:	00 00 00 
  81f73d:	ff d0                	callq  *%rax
  81f73f:	84 c0                	test   %al,%al
  81f741:	75 2f                	jne    81f772 <icmp_input+0xf4>
  81f743:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f747:	8b 58 10             	mov    0x10(%rax),%ebx
  81f74a:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81f74f:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81f756:	00 00 00 
  81f759:	ff d0                	callq  *%rax
  81f75b:	21 c3                	and    %eax,%ebx
  81f75d:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81f762:	48 b8 c8 24 81 00 00 	movabs $0x8124c8,%rax
  81f769:	00 00 00 
  81f76c:	ff d0                	callq  *%rax
  81f76e:	39 c3                	cmp    %eax,%ebx
  81f770:	75 18                	jne    81f78a <icmp_input+0x10c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  81f772:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f776:	48 89 c7             	mov    %rax,%rdi
  81f779:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81f780:	00 00 00 
  81f783:	ff d0                	callq  *%rax
      return;
  81f785:	e9 1d 04 00 00       	jmpq   81fba7 <icmp_input+0x529>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  81f78a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f78e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f792:	66 83 f8 07          	cmp    $0x7,%ax
  81f796:	77 05                	ja     81f79d <icmp_input+0x11f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  81f798:	e9 f6 03 00 00       	jmpq   81fb93 <icmp_input+0x515>
    }
    if (inet_chksum_pbuf(p) != 0) {
  81f79d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f7a1:	48 89 c7             	mov    %rax,%rdi
  81f7a4:	48 b8 66 1f 81 00 00 	movabs $0x811f66,%rax
  81f7ab:	00 00 00 
  81f7ae:	ff d0                	callq  *%rax
  81f7b0:	66 85 c0             	test   %ax,%ax
  81f7b3:	74 18                	je     81f7cd <icmp_input+0x14f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  81f7b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f7b9:	48 89 c7             	mov    %rax,%rdi
  81f7bc:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81f7c3:	00 00 00 
  81f7c6:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  81f7c8:	e9 da 03 00 00       	jmpq   81fba7 <icmp_input+0x529>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  81f7cd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f7d1:	be 22 00 00 00       	mov    $0x22,%esi
  81f7d6:	48 89 c7             	mov    %rax,%rdi
  81f7d9:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f7e0:	00 00 00 
  81f7e3:	ff d0                	callq  *%rax
  81f7e5:	84 c0                	test   %al,%al
  81f7e7:	0f 84 8f 01 00 00    	je     81f97c <icmp_input+0x2fe>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  81f7ed:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  81f7f1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f7f5:	89 d6                	mov    %edx,%esi
  81f7f7:	48 89 c7             	mov    %rax,%rdi
  81f7fa:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f801:	00 00 00 
  81f804:	ff d0                	callq  *%rax
  81f806:	84 c0                	test   %al,%al
  81f808:	74 2a                	je     81f834 <icmp_input+0x1b6>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  81f80a:	48 ba d8 2f 82 00 00 	movabs $0x822fd8,%rdx
  81f811:	00 00 00 
  81f814:	be 7b 00 00 00       	mov    $0x7b,%esi
  81f819:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81f820:	00 00 00 
  81f823:	b8 00 00 00 00       	mov    $0x0,%eax
  81f828:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81f82f:	00 00 00 
  81f832:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  81f834:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f838:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f83c:	0f b7 c0             	movzwl %ax,%eax
  81f83f:	ba 00 00 00 00       	mov    $0x0,%edx
  81f844:	89 c6                	mov    %eax,%esi
  81f846:	bf 02 00 00 00       	mov    $0x2,%edi
  81f84b:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81f852:	00 00 00 
  81f855:	ff d0                	callq  *%rax
  81f857:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  81f85b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81f860:	75 1a                	jne    81f87c <icmp_input+0x1fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  81f862:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  81f863:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f867:	48 89 c7             	mov    %rax,%rdi
  81f86a:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81f871:	00 00 00 
  81f874:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  81f876:	90                   	nop
  81f877:	e9 2b 03 00 00       	jmpq   81fba7 <icmp_input+0x529>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  81f87c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f880:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81f884:	0f b7 c0             	movzwl %ax,%eax
  81f887:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  81f88c:	48 83 c2 08          	add    $0x8,%rdx
  81f890:	48 39 d0             	cmp    %rdx,%rax
  81f893:	73 2a                	jae    81f8bf <icmp_input+0x241>
  81f895:	48 ba 28 30 82 00 00 	movabs $0x823028,%rdx
  81f89c:	00 00 00 
  81f89f:	be 85 00 00 00       	mov    $0x85,%esi
  81f8a4:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81f8ab:	00 00 00 
  81f8ae:	b8 00 00 00 00       	mov    $0x0,%eax
  81f8b3:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81f8ba:	00 00 00 
  81f8bd:	ff d1                	callq  *%rcx
      if (pbuf_copy(r, p) != ERR_OK) {
  81f8bf:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81f8c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f8c7:	48 89 d6             	mov    %rdx,%rsi
  81f8ca:	48 89 c7             	mov    %rax,%rdi
  81f8cd:	48 b8 dc d5 80 00 00 	movabs $0x80d5dc,%rax
  81f8d4:	00 00 00 
  81f8d7:	ff d0                	callq  *%rax
  81f8d9:	84 c0                	test   %al,%al
  81f8db:	74 2a                	je     81f907 <icmp_input+0x289>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  81f8dd:	48 ba 60 30 82 00 00 	movabs $0x823060,%rdx
  81f8e4:	00 00 00 
  81f8e7:	be 88 00 00 00       	mov    $0x88,%esi
  81f8ec:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81f8f3:	00 00 00 
  81f8f6:	b8 00 00 00 00       	mov    $0x0,%eax
  81f8fb:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81f902:	00 00 00 
  81f905:	ff d1                	callq  *%rcx
      iphdr = r->payload;
  81f907:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f90b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f90f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (pbuf_header(r, -hlen)) {
  81f913:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  81f917:	f7 d8                	neg    %eax
  81f919:	0f bf d0             	movswl %ax,%edx
  81f91c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f920:	89 d6                	mov    %edx,%esi
  81f922:	48 89 c7             	mov    %rax,%rdi
  81f925:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f92c:	00 00 00 
  81f92f:	ff d0                	callq  *%rax
  81f931:	84 c0                	test   %al,%al
  81f933:	74 2a                	je     81f95f <icmp_input+0x2e1>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  81f935:	48 ba 88 30 82 00 00 	movabs $0x823088,%rdx
  81f93c:	00 00 00 
  81f93f:	be 8e 00 00 00       	mov    $0x8e,%esi
  81f944:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81f94b:	00 00 00 
  81f94e:	b8 00 00 00 00       	mov    $0x0,%eax
  81f953:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81f95a:	00 00 00 
  81f95d:	ff d1                	callq  *%rcx
      pbuf_free(p);
  81f95f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f963:	48 89 c7             	mov    %rax,%rdi
  81f966:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81f96d:	00 00 00 
  81f970:	ff d0                	callq  *%rax
      p = r;
  81f972:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f976:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  81f97a:	eb 46                	jmp    81f9c2 <icmp_input+0x344>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  81f97c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f980:	be de ff ff ff       	mov    $0xffffffde,%esi
  81f985:	48 89 c7             	mov    %rax,%rdi
  81f988:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81f98f:	00 00 00 
  81f992:	ff d0                	callq  *%rax
  81f994:	84 c0                	test   %al,%al
  81f996:	74 2a                	je     81f9c2 <icmp_input+0x344>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  81f998:	48 ba 88 30 82 00 00 	movabs $0x823088,%rdx
  81f99f:	00 00 00 
  81f9a2:	be 98 00 00 00       	mov    $0x98,%esi
  81f9a7:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81f9ae:	00 00 00 
  81f9b1:	b8 00 00 00 00       	mov    $0x0,%eax
  81f9b6:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81f9bd:	00 00 00 
  81f9c0:	ff d1                	callq  *%rcx
    iecho = p->payload;
  81f9c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81f9c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f9ca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  81f9ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f9d2:	8b 40 0c             	mov    0xc(%rax),%eax
  81f9d5:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  81f9d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f9dc:	8b 50 10             	mov    0x10(%rax),%edx
  81f9df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f9e3:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  81f9e6:	8b 55 c0             	mov    -0x40(%rbp),%edx
  81f9e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81f9ed:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  81f9f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9f4:	0f b7 00             	movzwl (%rax),%eax
  81f9f7:	0f b7 c0             	movzwl %ax,%eax
  81f9fa:	89 c7                	mov    %eax,%edi
  81f9fc:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81fa03:	00 00 00 
  81fa06:	ff d0                	callq  *%rax
  81fa08:	0f b7 c0             	movzwl %ax,%eax
  81fa0b:	0f b6 c0             	movzbl %al,%eax
  81fa0e:	89 c7                	mov    %eax,%edi
  81fa10:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fa17:	00 00 00 
  81fa1a:	ff d0                	callq  *%rax
  81fa1c:	89 c2                	mov    %eax,%edx
  81fa1e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa22:	66 89 10             	mov    %dx,(%rax)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  81fa25:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa29:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  81fa2d:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  81fa32:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fa39:	00 00 00 
  81fa3c:	ff d0                	callq  *%rax
  81fa3e:	66 39 c3             	cmp    %ax,%bx
  81fa41:	72 2b                	jb     81fa6e <icmp_input+0x3f0>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  81fa43:	bf 00 08 00 00       	mov    $0x800,%edi
  81fa48:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fa4f:	00 00 00 
  81fa52:	ff d0                	callq  *%rax
  81fa54:	0f b7 c0             	movzwl %ax,%eax
  81fa57:	8d 50 01             	lea    0x1(%rax),%edx
  81fa5a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa5e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81fa62:	01 c2                	add    %eax,%edx
  81fa64:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa68:	66 89 50 02          	mov    %dx,0x2(%rax)
  81fa6c:	eb 25                	jmp    81fa93 <icmp_input+0x415>
      iecho->chksum += htons(ICMP_ECHO << 8);
  81fa6e:	bf 00 08 00 00       	mov    $0x800,%edi
  81fa73:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fa7a:	00 00 00 
  81fa7d:	ff d0                	callq  *%rax
  81fa7f:	89 c2                	mov    %eax,%edx
  81fa81:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa85:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81fa89:	01 c2                	add    %eax,%edx
  81fa8b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa8f:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_TTL_SET(iphdr, ICMP_TTL);
  81fa93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fa97:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81fa9b:	0f b7 c0             	movzwl %ax,%eax
  81fa9e:	89 c7                	mov    %eax,%edi
  81faa0:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81faa7:	00 00 00 
  81faaa:	ff d0                	callq  *%rax
  81faac:	66 0d 00 ff          	or     $0xff00,%ax
  81fab0:	0f b7 c0             	movzwl %ax,%eax
  81fab3:	89 c7                	mov    %eax,%edi
  81fab5:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fabc:	00 00 00 
  81fabf:	ff d0                	callq  *%rax
  81fac1:	89 c2                	mov    %eax,%edx
  81fac3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fac7:	66 89 50 08          	mov    %dx,0x8(%rax)
    IPH_CHKSUM_SET(iphdr, 0);
  81facb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81facf:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  81fad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fad9:	be 14 00 00 00       	mov    $0x14,%esi
  81fade:	48 89 c7             	mov    %rax,%rdi
  81fae1:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  81fae8:	00 00 00 
  81faeb:	ff d0                	callq  *%rax
  81faed:	89 c2                	mov    %eax,%edx
  81faef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81faf3:	66 89 50 0a          	mov    %dx,0xa(%rax)
    if(pbuf_header(p, hlen)) {
  81faf7:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  81fafb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81faff:	89 d6                	mov    %edx,%esi
  81fb01:	48 89 c7             	mov    %rax,%rdi
  81fb04:	48 b8 9c cf 80 00 00 	movabs $0x80cf9c,%rax
  81fb0b:	00 00 00 
  81fb0e:	ff d0                	callq  *%rax
  81fb10:	84 c0                	test   %al,%al
  81fb12:	74 2a                	je     81fb3e <icmp_input+0x4c0>
      LWIP_ASSERT("Can't move over header in packet", 0);
  81fb14:	48 ba c0 30 82 00 00 	movabs $0x8230c0,%rdx
  81fb1b:	00 00 00 
  81fb1e:	be b9 00 00 00       	mov    $0xb9,%esi
  81fb23:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81fb2a:	00 00 00 
  81fb2d:	b8 00 00 00 00       	mov    $0x0,%eax
  81fb32:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81fb39:	00 00 00 
  81fb3c:	ff d1                	callq  *%rcx
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  81fb3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fb42:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81fb46:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fb4a:	48 83 ec 08          	sub    $0x8,%rsp
  81fb4e:	ff 75 b0             	pushq  -0x50(%rbp)
  81fb51:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  81fb57:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81fb5d:	b9 ff 00 00 00       	mov    $0xff,%ecx
  81fb62:	ba 00 00 00 00       	mov    $0x0,%edx
  81fb67:	48 89 c7             	mov    %rax,%rdi
  81fb6a:	48 b8 29 07 81 00 00 	movabs $0x810729,%rax
  81fb71:	00 00 00 
  81fb74:	ff d0                	callq  *%rax
  81fb76:	48 83 c4 10          	add    $0x10,%rsp
  81fb7a:	88 45 cf             	mov    %al,-0x31(%rbp)
    break;
  81fb7d:	90                   	nop
  pbuf_free(p);
  81fb7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fb82:	48 89 c7             	mov    %rax,%rdi
  81fb85:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81fb8c:	00 00 00 
  81fb8f:	ff d0                	callq  *%rax
  return;
  81fb91:	eb 14                	jmp    81fba7 <icmp_input+0x529>
  pbuf_free(p);
  81fb93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fb97:	48 89 c7             	mov    %rax,%rdi
  81fb9a:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81fba1:	00 00 00 
  81fba4:	ff d0                	callq  *%rax
  return;
  81fba6:	90                   	nop
}
  81fba7:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  81fbab:	c9                   	leaveq 
  81fbac:	c3                   	retq   

000000000081fbad <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  81fbad:	55                   	push   %rbp
  81fbae:	48 89 e5             	mov    %rsp,%rbp
  81fbb1:	48 83 ec 30          	sub    $0x30,%rsp
  81fbb5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81fbb9:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81fbbc:	ba 00 00 00 00       	mov    $0x0,%edx
  81fbc1:	be 24 00 00 00       	mov    $0x24,%esi
  81fbc6:	bf 01 00 00 00       	mov    $0x1,%edi
  81fbcb:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81fbd2:	00 00 00 
  81fbd5:	ff d0                	callq  *%rax
  81fbd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  81fbdb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fbe0:	75 05                	jne    81fbe7 <icmp_dest_unreach+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  81fbe2:	e9 66 01 00 00       	jmpq   81fd4d <icmp_dest_unreach+0x1a0>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  81fbe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fbeb:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81fbef:	66 83 f8 23          	cmp    $0x23,%ax
  81fbf3:	77 2a                	ja     81fc1f <icmp_dest_unreach+0x72>
  81fbf5:	48 ba e8 30 82 00 00 	movabs $0x8230e8,%rdx
  81fbfc:	00 00 00 
  81fbff:	be ef 00 00 00       	mov    $0xef,%esi
  81fc04:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81fc0b:	00 00 00 
  81fc0e:	b8 00 00 00 00       	mov    $0x0,%eax
  81fc13:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81fc1a:	00 00 00 
  81fc1d:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  81fc1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc23:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fc27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  81fc2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc2f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fc33:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  81fc37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fc3b:	0f b7 00             	movzwl (%rax),%eax
  81fc3e:	0f b7 c0             	movzwl %ax,%eax
  81fc41:	89 c7                	mov    %eax,%edi
  81fc43:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81fc4a:	00 00 00 
  81fc4d:	ff d0                	callq  *%rax
  81fc4f:	0f b6 c0             	movzbl %al,%eax
  81fc52:	80 cc 03             	or     $0x3,%ah
  81fc55:	0f b7 c0             	movzwl %ax,%eax
  81fc58:	89 c7                	mov    %eax,%edi
  81fc5a:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fc61:	00 00 00 
  81fc64:	ff d0                	callq  *%rax
  81fc66:	89 c2                	mov    %eax,%edx
  81fc68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fc6c:	66 89 10             	mov    %dx,(%rax)
  ICMPH_CODE_SET(idur, t);
  81fc6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fc73:	0f b7 00             	movzwl (%rax),%eax
  81fc76:	0f b7 c0             	movzwl %ax,%eax
  81fc79:	89 c7                	mov    %eax,%edi
  81fc7b:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81fc82:	00 00 00 
  81fc85:	ff d0                	callq  *%rax
  81fc87:	b0 00                	mov    $0x0,%al
  81fc89:	89 c2                	mov    %eax,%edx
  81fc8b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  81fc8e:	09 d0                	or     %edx,%eax
  81fc90:	0f b7 c0             	movzwl %ax,%eax
  81fc93:	89 c7                	mov    %eax,%edi
  81fc95:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fc9c:	00 00 00 
  81fc9f:	ff d0                	callq  *%rax
  81fca1:	89 c2                	mov    %eax,%edx
  81fca3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fca7:	66 89 10             	mov    %dx,(%rax)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  81fcaa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcae:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fcb2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fcb6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81fcba:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  81fcbe:	ba 1c 00 00 00       	mov    $0x1c,%edx
  81fcc3:	48 89 c6             	mov    %rax,%rsi
  81fcc6:	48 89 cf             	mov    %rcx,%rdi
  81fcc9:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  81fcd0:	00 00 00 
  81fcd3:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  81fcd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fcd9:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  81fcdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fce3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81fce7:	0f b7 d0             	movzwl %ax,%edx
  81fcea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fcee:	89 d6                	mov    %edx,%esi
  81fcf0:	48 89 c7             	mov    %rax,%rdi
  81fcf3:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  81fcfa:	00 00 00 
  81fcfd:	ff d0                	callq  *%rax
  81fcff:	89 c2                	mov    %eax,%edx
  81fd01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fd05:	66 89 50 02          	mov    %dx,0x2(%rax)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  81fd09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd0d:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81fd11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd15:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  81fd1b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81fd21:	b9 ff 00 00 00       	mov    $0xff,%ecx
  81fd26:	be 00 00 00 00       	mov    $0x0,%esi
  81fd2b:	48 89 c7             	mov    %rax,%rdi
  81fd2e:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  81fd35:	00 00 00 
  81fd38:	ff d0                	callq  *%rax
  pbuf_free(q);
  81fd3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd3e:	48 89 c7             	mov    %rax,%rdi
  81fd41:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81fd48:	00 00 00 
  81fd4b:	ff d0                	callq  *%rax
}
  81fd4d:	c9                   	leaveq 
  81fd4e:	c3                   	retq   

000000000081fd4f <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  81fd4f:	55                   	push   %rbp
  81fd50:	48 89 e5             	mov    %rsp,%rbp
  81fd53:	48 83 ec 30          	sub    $0x30,%rsp
  81fd57:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81fd5b:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81fd5e:	ba 00 00 00 00       	mov    $0x0,%edx
  81fd63:	be 24 00 00 00       	mov    $0x24,%esi
  81fd68:	bf 01 00 00 00       	mov    $0x1,%edi
  81fd6d:	48 b8 86 c8 80 00 00 	movabs $0x80c886,%rax
  81fd74:	00 00 00 
  81fd77:	ff d0                	callq  *%rax
  81fd79:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  81fd7d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fd82:	75 05                	jne    81fd89 <icmp_time_exceeded+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  81fd84:	e9 66 01 00 00       	jmpq   81feef <icmp_time_exceeded+0x1a0>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  81fd89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd8d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81fd91:	66 83 f8 23          	cmp    $0x23,%ax
  81fd95:	77 2a                	ja     81fdc1 <icmp_time_exceeded+0x72>
  81fd97:	48 ba e8 30 82 00 00 	movabs $0x8230e8,%rdx
  81fd9e:	00 00 00 
  81fda1:	be 1e 01 00 00       	mov    $0x11e,%esi
  81fda6:	48 bf 0b 30 82 00 00 	movabs $0x82300b,%rdi
  81fdad:	00 00 00 
  81fdb0:	b8 00 00 00 00       	mov    $0x0,%eax
  81fdb5:	48 b9 e0 0e 80 00 00 	movabs $0x800ee0,%rcx
  81fdbc:	00 00 00 
  81fdbf:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  81fdc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fdc5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fdc9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  81fdcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdd1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fdd5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  81fdd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fddd:	0f b7 00             	movzwl (%rax),%eax
  81fde0:	0f b7 c0             	movzwl %ax,%eax
  81fde3:	89 c7                	mov    %eax,%edi
  81fde5:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81fdec:	00 00 00 
  81fdef:	ff d0                	callq  *%rax
  81fdf1:	0f b6 c0             	movzbl %al,%eax
  81fdf4:	80 cc 0b             	or     $0xb,%ah
  81fdf7:	0f b7 c0             	movzwl %ax,%eax
  81fdfa:	89 c7                	mov    %eax,%edi
  81fdfc:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fe03:	00 00 00 
  81fe06:	ff d0                	callq  *%rax
  81fe08:	89 c2                	mov    %eax,%edx
  81fe0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fe0e:	66 89 10             	mov    %dx,(%rax)
  ICMPH_CODE_SET(tehdr, t);
  81fe11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fe15:	0f b7 00             	movzwl (%rax),%eax
  81fe18:	0f b7 c0             	movzwl %ax,%eax
  81fe1b:	89 c7                	mov    %eax,%edi
  81fe1d:	48 b8 6e 24 81 00 00 	movabs $0x81246e,%rax
  81fe24:	00 00 00 
  81fe27:	ff d0                	callq  *%rax
  81fe29:	b0 00                	mov    $0x0,%al
  81fe2b:	89 c2                	mov    %eax,%edx
  81fe2d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  81fe30:	09 d0                	or     %edx,%eax
  81fe32:	0f b7 c0             	movzwl %ax,%eax
  81fe35:	89 c7                	mov    %eax,%edi
  81fe37:	48 b8 4b 24 81 00 00 	movabs $0x81244b,%rax
  81fe3e:	00 00 00 
  81fe41:	ff d0                	callq  *%rax
  81fe43:	89 c2                	mov    %eax,%edx
  81fe45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fe49:	66 89 10             	mov    %dx,(%rax)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  81fe4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fe50:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fe54:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fe58:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81fe5c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  81fe60:	ba 1c 00 00 00       	mov    $0x1c,%edx
  81fe65:	48 89 c6             	mov    %rax,%rsi
  81fe68:	48 89 cf             	mov    %rcx,%rdi
  81fe6b:	48 b8 ee 20 80 00 00 	movabs $0x8020ee,%rax
  81fe72:	00 00 00 
  81fe75:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  81fe77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fe7b:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  81fe81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe85:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81fe89:	0f b7 d0             	movzwl %ax,%edx
  81fe8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fe90:	89 d6                	mov    %edx,%esi
  81fe92:	48 89 c7             	mov    %rax,%rdi
  81fe95:	48 b8 37 1f 81 00 00 	movabs $0x811f37,%rax
  81fe9c:	00 00 00 
  81fe9f:	ff d0                	callq  *%rax
  81fea1:	89 c2                	mov    %eax,%edx
  81fea3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fea7:	66 89 50 02          	mov    %dx,0x2(%rax)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  81feab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81feaf:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81feb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81feb7:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  81febd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81fec3:	b9 ff 00 00 00       	mov    $0xff,%ecx
  81fec8:	be 00 00 00 00       	mov    $0x0,%esi
  81fecd:	48 89 c7             	mov    %rax,%rdi
  81fed0:	48 b8 eb 09 81 00 00 	movabs $0x8109eb,%rax
  81fed7:	00 00 00 
  81feda:	ff d0                	callq  *%rax
  pbuf_free(q);
  81fedc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fee0:	48 89 c7             	mov    %rax,%rdi
  81fee3:	48 b8 5d d1 80 00 00 	movabs $0x80d15d,%rax
  81feea:	00 00 00 
  81feed:	ff d0                	callq  *%rax
}
  81feef:	c9                   	leaveq 
  81fef0:	c3                   	retq   
