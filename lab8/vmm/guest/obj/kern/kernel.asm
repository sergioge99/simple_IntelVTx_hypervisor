
vmm/guest/obj/kern/kernel:     formato del fichero elf64-x86-64


Desensamblado de la secci√≥n .bootstrap:

0000000000100000 <_head64>:
_head64:

# Save multiboot_info addr passed by bootloader
#ifdef VMM_GUEST
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
  100000:	b8 01 00 00 00       	mov    $0x1,%eax
    vmcall
  100005:	0f 01 c1             	vmcall 
#endif
	
    movl $multiboot_info, %eax
  100008:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  10000d:	89 18                	mov    %ebx,(%rax)
#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
#endif
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  10000f:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100014:	e8 cc 00 00 00       	callq  1000e5 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  100019:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif
    movl %eax,%cr4
  10001e:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100021:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100026:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100028:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002d:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  10002f:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100034:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  100039:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  10003f:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100041:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100046:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  100049:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004c:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  10004f:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100054:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  100059:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  10005f:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100061:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100066:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006b:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006e:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100071:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100073:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100078:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007d:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100082:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100088:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008d:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  10008f:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100091:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100094:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100097:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009c:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  10009f:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a2:	75 e9                	jne    10008d <_head64+0x8d>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a4:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000a9:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b1:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b3:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b7:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000b9:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bc:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000bf:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c4:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000c9:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000ce:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d1:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d4:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000d9:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dc:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000de:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e3:	50                   	push   %rax

00000000001000e4 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e4:	cb                   	lret   

00000000001000e5 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e5:	9c                   	pushfq 
    popl %eax
  1000e6:	58                   	pop    %rax
    movl %eax,%ecx
  1000e7:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000e9:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ee:	50                   	push   %rax
    popfl
  1000ef:	9d                   	popfq  
    pushfl
  1000f0:	9c                   	pushfq 
    popl %eax
  1000f1:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f2:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f4:	74 1c                	je     100112 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f6:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fb:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fd:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100100:	72 10                	jb     100112 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100102:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100107:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  100109:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  10010f:	74 01                	je     100112 <verify_cpu_no_longmode>

    ret
  100111:	c3                   	retq   

0000000000100112 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100112:	eb fe                	jmp    100112 <verify_cpu_no_longmode>
  100114:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011b:	00 00 00 
  10011e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100125:	00 00 00 
  100128:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10012f:	00 00 00 
  100132:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100139:	00 00 00 
  10013c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100143:	00 00 00 
  100146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014d:	00 00 00 
  100150:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100157:	00 00 00 
  10015a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100161:	00 00 00 
  100164:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016b:	00 00 00 
  10016e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100175:	00 00 00 
  100178:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10017f:	00 00 00 
  100182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100189:	00 00 00 
  10018c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100193:	00 00 00 
  100196:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019d:	00 00 00 
  1001a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a7:	00 00 00 
  1001aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b1:	00 00 00 
  1001b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bb:	00 00 00 
  1001be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c5:	00 00 00 
  1001c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001cf:	00 00 00 
  1001d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d9:	00 00 00 
  1001dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e3:	00 00 00 
  1001e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ed:	00 00 00 
  1001f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f7:	00 00 00 
  1001fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100201:	00 00 00 
  100204:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020b:	00 00 00 
  10020e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100215:	00 00 00 
  100218:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10021f:	00 00 00 
  100222:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100229:	00 00 00 
  10022c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100233:	00 00 00 
  100236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023d:	00 00 00 
  100240:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100247:	00 00 00 
  10024a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100251:	00 00 00 
  100254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025b:	00 00 00 
  10025e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100265:	00 00 00 
  100268:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10026f:	00 00 00 
  100272:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100279:	00 00 00 
  10027c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100283:	00 00 00 
  100286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028d:	00 00 00 
  100290:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100297:	00 00 00 
  10029a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a1:	00 00 00 
  1002a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ab:	00 00 00 
  1002ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b5:	00 00 00 
  1002b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002bf:	00 00 00 
  1002c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c9:	00 00 00 
  1002cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d3:	00 00 00 
  1002d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002dd:	00 00 00 
  1002e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e7:	00 00 00 
  1002ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f1:	00 00 00 
  1002f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fb:	00 00 00 
  1002fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100305:	00 00 00 
  100308:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10030f:	00 00 00 
  100312:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100319:	00 00 00 
  10031c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100323:	00 00 00 
  100326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032d:	00 00 00 
  100330:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100337:	00 00 00 
  10033a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100341:	00 00 00 
  100344:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034b:	00 00 00 
  10034e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100355:	00 00 00 
  100358:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10035f:	00 00 00 
  100362:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100369:	00 00 00 
  10036c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100373:	00 00 00 
  100376:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037d:	00 00 00 
  100380:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100387:	00 00 00 
  10038a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100391:	00 00 00 
  100394:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039b:	00 00 00 
  10039e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a5:	00 00 00 
  1003a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003af:	00 00 00 
  1003b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b9:	00 00 00 
  1003bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c3:	00 00 00 
  1003c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003cd:	00 00 00 
  1003d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d7:	00 00 00 
  1003da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e1:	00 00 00 
  1003e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003eb:	00 00 00 
  1003ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f5:	00 00 00 
  1003f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ff:	00 00 00 
  100402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100409:	00 00 00 
  10040c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100413:	00 00 00 
  100416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041d:	00 00 00 
  100420:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100427:	00 00 00 
  10042a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100431:	00 00 00 
  100434:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043b:	00 00 00 
  10043e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100445:	00 00 00 
  100448:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10044f:	00 00 00 
  100452:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100459:	00 00 00 
  10045c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100463:	00 00 00 
  100466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046d:	00 00 00 
  100470:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100477:	00 00 00 
  10047a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100481:	00 00 00 
  100484:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048b:	00 00 00 
  10048e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100495:	00 00 00 
  100498:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10049f:	00 00 00 
  1004a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a9:	00 00 00 
  1004ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b3:	00 00 00 
  1004b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004bd:	00 00 00 
  1004c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c7:	00 00 00 
  1004ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d1:	00 00 00 
  1004d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004db:	00 00 00 
  1004de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e5:	00 00 00 
  1004e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004ef:	00 00 00 
  1004f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f9:	00 00 00 
  1004fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100503:	00 00 00 
  100506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050d:	00 00 00 
  100510:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100517:	00 00 00 
  10051a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100521:	00 00 00 
  100524:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052b:	00 00 00 
  10052e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100535:	00 00 00 
  100538:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10053f:	00 00 00 
  100542:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100549:	00 00 00 
  10054c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100553:	00 00 00 
  100556:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055d:	00 00 00 
  100560:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100567:	00 00 00 
  10056a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100571:	00 00 00 
  100574:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057b:	00 00 00 
  10057e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100585:	00 00 00 
  100588:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10058f:	00 00 00 
  100592:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100599:	00 00 00 
  10059c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a3:	00 00 00 
  1005a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ad:	00 00 00 
  1005b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b7:	00 00 00 
  1005ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c1:	00 00 00 
  1005c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cb:	00 00 00 
  1005ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d5:	00 00 00 
  1005d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005df:	00 00 00 
  1005e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e9:	00 00 00 
  1005ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f3:	00 00 00 
  1005f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fd:	00 00 00 
  100600:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100607:	00 00 00 
  10060a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100611:	00 00 00 
  100614:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061b:	00 00 00 
  10061e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100625:	00 00 00 
  100628:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10062f:	00 00 00 
  100632:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100639:	00 00 00 
  10063c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100643:	00 00 00 
  100646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064d:	00 00 00 
  100650:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100657:	00 00 00 
  10065a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100661:	00 00 00 
  100664:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066b:	00 00 00 
  10066e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100675:	00 00 00 
  100678:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10067f:	00 00 00 
  100682:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100689:	00 00 00 
  10068c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100693:	00 00 00 
  100696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069d:	00 00 00 
  1006a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a7:	00 00 00 
  1006aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b1:	00 00 00 
  1006b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bb:	00 00 00 
  1006be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c5:	00 00 00 
  1006c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006cf:	00 00 00 
  1006d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d9:	00 00 00 
  1006dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e3:	00 00 00 
  1006e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ed:	00 00 00 
  1006f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f7:	00 00 00 
  1006fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100701:	00 00 00 
  100704:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070b:	00 00 00 
  10070e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100715:	00 00 00 
  100718:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10071f:	00 00 00 
  100722:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100729:	00 00 00 
  10072c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100733:	00 00 00 
  100736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073d:	00 00 00 
  100740:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100747:	00 00 00 
  10074a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100751:	00 00 00 
  100754:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075b:	00 00 00 
  10075e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100765:	00 00 00 
  100768:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10076f:	00 00 00 
  100772:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100779:	00 00 00 
  10077c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100783:	00 00 00 
  100786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078d:	00 00 00 
  100790:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100797:	00 00 00 
  10079a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a1:	00 00 00 
  1007a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ab:	00 00 00 
  1007ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b5:	00 00 00 
  1007b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007bf:	00 00 00 
  1007c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c9:	00 00 00 
  1007cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d3:	00 00 00 
  1007d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007dd:	00 00 00 
  1007e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e7:	00 00 00 
  1007ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f1:	00 00 00 
  1007f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fb:	00 00 00 
  1007fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100805:	00 00 00 
  100808:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10080f:	00 00 00 
  100812:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100819:	00 00 00 
  10081c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100823:	00 00 00 
  100826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082d:	00 00 00 
  100830:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100837:	00 00 00 
  10083a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100841:	00 00 00 
  100844:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084b:	00 00 00 
  10084e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100855:	00 00 00 
  100858:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10085f:	00 00 00 
  100862:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100869:	00 00 00 
  10086c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100873:	00 00 00 
  100876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087d:	00 00 00 
  100880:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100887:	00 00 00 
  10088a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100891:	00 00 00 
  100894:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089b:	00 00 00 
  10089e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a5:	00 00 00 
  1008a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008af:	00 00 00 
  1008b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b9:	00 00 00 
  1008bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c3:	00 00 00 
  1008c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008cd:	00 00 00 
  1008d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d7:	00 00 00 
  1008da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e1:	00 00 00 
  1008e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008eb:	00 00 00 
  1008ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f5:	00 00 00 
  1008f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ff:	00 00 00 
  100902:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100909:	00 00 00 
  10090c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100913:	00 00 00 
  100916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091d:	00 00 00 
  100920:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100927:	00 00 00 
  10092a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100931:	00 00 00 
  100934:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093b:	00 00 00 
  10093e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100945:	00 00 00 
  100948:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10094f:	00 00 00 
  100952:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100959:	00 00 00 
  10095c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100963:	00 00 00 
  100966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096d:	00 00 00 
  100970:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100977:	00 00 00 
  10097a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100981:	00 00 00 
  100984:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098b:	00 00 00 
  10098e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100995:	00 00 00 
  100998:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10099f:	00 00 00 
  1009a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a9:	00 00 00 
  1009ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b3:	00 00 00 
  1009b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009bd:	00 00 00 
  1009c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c7:	00 00 00 
  1009ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d1:	00 00 00 
  1009d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009db:	00 00 00 
  1009de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e5:	00 00 00 
  1009e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009ef:	00 00 00 
  1009f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f9:	00 00 00 
  1009fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a03:	00 00 00 
  100a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0d:	00 00 00 
  100a10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a17:	00 00 00 
  100a1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a21:	00 00 00 
  100a24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2b:	00 00 00 
  100a2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a35:	00 00 00 
  100a38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a3f:	00 00 00 
  100a42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a49:	00 00 00 
  100a4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a53:	00 00 00 
  100a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5d:	00 00 00 
  100a60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a67:	00 00 00 
  100a6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a71:	00 00 00 
  100a74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7b:	00 00 00 
  100a7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a85:	00 00 00 
  100a88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a8f:	00 00 00 
  100a92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a99:	00 00 00 
  100a9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa3:	00 00 00 
  100aa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aad:	00 00 00 
  100ab0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab7:	00 00 00 
  100aba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac1:	00 00 00 
  100ac4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acb:	00 00 00 
  100ace:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad5:	00 00 00 
  100ad8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100adf:	00 00 00 
  100ae2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae9:	00 00 00 
  100aec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af3:	00 00 00 
  100af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afd:	00 00 00 
  100b00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b07:	00 00 00 
  100b0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b11:	00 00 00 
  100b14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1b:	00 00 00 
  100b1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b25:	00 00 00 
  100b28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b2f:	00 00 00 
  100b32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b39:	00 00 00 
  100b3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b43:	00 00 00 
  100b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4d:	00 00 00 
  100b50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b57:	00 00 00 
  100b5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b61:	00 00 00 
  100b64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6b:	00 00 00 
  100b6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b75:	00 00 00 
  100b78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b7f:	00 00 00 
  100b82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b89:	00 00 00 
  100b8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b93:	00 00 00 
  100b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9d:	00 00 00 
  100ba0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba7:	00 00 00 
  100baa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb1:	00 00 00 
  100bb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbb:	00 00 00 
  100bbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc5:	00 00 00 
  100bc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bcf:	00 00 00 
  100bd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd9:	00 00 00 
  100bdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be3:	00 00 00 
  100be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bed:	00 00 00 
  100bf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf7:	00 00 00 
  100bfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c01:	00 00 00 
  100c04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0b:	00 00 00 
  100c0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c15:	00 00 00 
  100c18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c1f:	00 00 00 
  100c22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c29:	00 00 00 
  100c2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c33:	00 00 00 
  100c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3d:	00 00 00 
  100c40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c47:	00 00 00 
  100c4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c51:	00 00 00 
  100c54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5b:	00 00 00 
  100c5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c65:	00 00 00 
  100c68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c6f:	00 00 00 
  100c72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c79:	00 00 00 
  100c7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c83:	00 00 00 
  100c86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8d:	00 00 00 
  100c90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c97:	00 00 00 
  100c9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca1:	00 00 00 
  100ca4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cab:	00 00 00 
  100cae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb5:	00 00 00 
  100cb8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cbf:	00 00 00 
  100cc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc9:	00 00 00 
  100ccc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd3:	00 00 00 
  100cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cdd:	00 00 00 
  100ce0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce7:	00 00 00 
  100cea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf1:	00 00 00 
  100cf4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfb:	00 00 00 
  100cfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d05:	00 00 00 
  100d08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d0f:	00 00 00 
  100d12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d19:	00 00 00 
  100d1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d23:	00 00 00 
  100d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2d:	00 00 00 
  100d30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d37:	00 00 00 
  100d3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d41:	00 00 00 
  100d44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4b:	00 00 00 
  100d4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d55:	00 00 00 
  100d58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d5f:	00 00 00 
  100d62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d69:	00 00 00 
  100d6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d73:	00 00 00 
  100d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7d:	00 00 00 
  100d80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d87:	00 00 00 
  100d8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d91:	00 00 00 
  100d94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9b:	00 00 00 
  100d9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da5:	00 00 00 
  100da8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100daf:	00 00 00 
  100db2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db9:	00 00 00 
  100dbc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc3:	00 00 00 
  100dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dcd:	00 00 00 
  100dd0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd7:	00 00 00 
  100dda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de1:	00 00 00 
  100de4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100deb:	00 00 00 
  100dee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df5:	00 00 00 
  100df8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dff:	00 00 00 
  100e02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e09:	00 00 00 
  100e0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e13:	00 00 00 
  100e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1d:	00 00 00 
  100e20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e27:	00 00 00 
  100e2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e31:	00 00 00 
  100e34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3b:	00 00 00 
  100e3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e45:	00 00 00 
  100e48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e4f:	00 00 00 
  100e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e59:	00 00 00 
  100e5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e63:	00 00 00 
  100e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6d:	00 00 00 
  100e70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e77:	00 00 00 
  100e7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e81:	00 00 00 
  100e84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8b:	00 00 00 
  100e8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e95:	00 00 00 
  100e98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e9f:	00 00 00 
  100ea2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea9:	00 00 00 
  100eac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb3:	00 00 00 
  100eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebd:	00 00 00 
  100ec0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec7:	00 00 00 
  100eca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed1:	00 00 00 
  100ed4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edb:	00 00 00 
  100ede:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee5:	00 00 00 
  100ee8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eef:	00 00 00 
  100ef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef9:	00 00 00 
  100efc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f03:	00 00 00 
  100f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0d:	00 00 00 
  100f10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f17:	00 00 00 
  100f1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f21:	00 00 00 
  100f24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2b:	00 00 00 
  100f2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f35:	00 00 00 
  100f38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f3f:	00 00 00 
  100f42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f49:	00 00 00 
  100f4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f53:	00 00 00 
  100f56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5d:	00 00 00 
  100f60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f67:	00 00 00 
  100f6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f71:	00 00 00 
  100f74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7b:	00 00 00 
  100f7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f85:	00 00 00 
  100f88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f8f:	00 00 00 
  100f92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f99:	00 00 00 
  100f9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa3:	00 00 00 
  100fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fad:	00 00 00 
  100fb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb7:	00 00 00 
  100fba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc1:	00 00 00 
  100fc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcb:	00 00 00 
  100fce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd5:	00 00 00 
  100fd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fdf:	00 00 00 
  100fe2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe9:	00 00 00 
  100fec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff3:	00 00 00 
  100ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ffd:	00 00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Desensamblado de la secci√≥n .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4                   	.byte 0xe4

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 80 22 04 80 	movabs $0x8004228038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 80 22 04 80 	movabs $0x8004228000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 82 01 20 04 80 	movabs $0x8004200182,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	53                   	push   %rbx
  800420005d:	48 83 ec 38          	sub    $0x38,%rsp
  8004200061:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  8004200064:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  8004200068:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420006c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200070:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  8004200074:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200077:	0f a2                	cpuid  
  8004200079:	89 de                	mov    %ebx,%esi
  800420007b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420007e:	89 75 f0             	mov    %esi,-0x10(%rbp)
  8004200081:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  8004200084:	89 55 e8             	mov    %edx,-0x18(%rbp)
			 : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
			 : "a" (info));
	if (eaxp)
  8004200087:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420008c:	74 09                	je     8004200097 <cpuid+0x3f>
		*eaxp = eax;
  800420008e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200092:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200095:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  8004200097:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420009c:	74 09                	je     80042000a7 <cpuid+0x4f>
		*ebxp = ebx;
  800420009e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042000a2:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042000a5:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  80042000a7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042000ac:	74 09                	je     80042000b7 <cpuid+0x5f>
		*ecxp = ecx;
  80042000ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042000b2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042000b5:	89 10                	mov    %edx,(%rax)
	if (edxp)
  80042000b7:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042000bc:	74 09                	je     80042000c7 <cpuid+0x6f>
		*edxp = edx;
  80042000be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042000c2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042000c5:	89 10                	mov    %edx,(%rax)
}
  80042000c7:	48 83 c4 38          	add    $0x38,%rsp
  80042000cb:	5b                   	pop    %rbx
  80042000cc:	5d                   	pop    %rbp
  80042000cd:	c3                   	retq   

00000080042000ce <xchg>:

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042000ce:	55                   	push   %rbp
  80042000cf:	48 89 e5             	mov    %rsp,%rbp
  80042000d2:	48 83 ec 20          	sub    $0x20,%rsp
  80042000d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042000da:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042000dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042000e1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042000e4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042000e8:	f0 87 02             	lock xchg %eax,(%rdx)
  80042000eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042000ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042000f1:	c9                   	leaveq 
  80042000f2:	c3                   	retq   

00000080042000f3 <vmcall>:
#ifdef VMM_GUEST

static void boot_virtual_aps(void);

int64_t vmcall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  80042000f3:	55                   	push   %rbp
  80042000f4:	48 89 e5             	mov    %rsp,%rbp
  80042000f7:	53                   	push   %rbx
  80042000f8:	48 83 ec 48          	sub    $0x48,%rsp
  80042000fc:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042000ff:	89 75 d8             	mov    %esi,-0x28(%rbp)
  8004200102:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004200106:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800420010a:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  800420010e:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    int64_t ret;
    asm volatile("vmcall\n" : "=a" (ret) : "a" (num), "d" (a1), "c" (a2), "b" (a3), "D" (a4), "S" (a5) : "cc", "memory");
  8004200112:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200115:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004200119:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420011d:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8004200121:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004200125:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004200129:	4c 89 c3             	mov    %r8,%rbx
  800420012c:	0f 01 c1             	vmcall 
  800420012f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(check && ret > 0) panic("vmcall %d returned %d (> 0)", num, ret);
  8004200133:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8004200137:	74 3e                	je     8004200177 <vmcall+0x84>
  8004200139:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420013e:	7e 37                	jle    8004200177 <vmcall+0x84>
  8004200140:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004200144:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200147:	49 89 d0             	mov    %rdx,%r8
  800420014a:	89 c1                	mov    %eax,%ecx
  800420014c:	48 ba 40 46 21 04 80 	movabs $0x8004214640,%rdx
  8004200153:	00 00 00 
  8004200156:	be 28 00 00 00       	mov    $0x28,%esi
  800420015b:	48 bf 5c 46 21 04 80 	movabs $0x800421465c,%rdi
  8004200162:	00 00 00 
  8004200165:	b8 00 00 00 00       	mov    $0x0,%eax
  800420016a:	49 b9 a6 05 20 04 80 	movabs $0x80042005a6,%r9
  8004200171:	00 00 00 
  8004200174:	41 ff d1             	callq  *%r9
    return ret;
  8004200177:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420017b:	48 83 c4 48          	add    $0x48,%rsp
  800420017f:	5b                   	pop    %rbx
  8004200180:	5d                   	pop    %rbp
  8004200181:	c3                   	retq   

0000008004200182 <i386_init>:
#endif


void
i386_init(void)
{
  8004200182:	55                   	push   %rbp
  8004200183:	48 89 e5             	mov    %rsp,%rbp
  8004200186:	48 83 ec 10          	sub    $0x10,%rsp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420018a:	48 ba 10 f0 5b 04 80 	movabs $0x80045bf010,%rdx
  8004200191:	00 00 00 
  8004200194:	48 b8 18 a2 57 04 80 	movabs $0x800457a218,%rax
  800420019b:	00 00 00 
  800420019e:	48 29 c2             	sub    %rax,%rdx
  80042001a1:	48 89 d0             	mov    %rdx,%rax
  80042001a4:	48 89 c2             	mov    %rax,%rdx
  80042001a7:	be 00 00 00 00       	mov    $0x0,%esi
  80042001ac:	48 bf 18 a2 57 04 80 	movabs $0x800457a218,%rdi
  80042001b3:	00 00 00 
  80042001b6:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  80042001bd:	00 00 00 
  80042001c0:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042001c2:	48 b8 a7 12 20 04 80 	movabs $0x80042012a7,%rax
  80042001c9:	00 00 00 
  80042001cc:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042001ce:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042001d3:	48 bf 68 46 21 04 80 	movabs $0x8004214668,%rdi
  80042001da:	00 00 00 
  80042001dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001e2:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042001e9:	00 00 00 
  80042001ec:	ff d2                	callq  *%rdx

#ifdef VMM_GUEST
	/* Guest VMX extension exposure check */
	{
		uint32_t ecx = 0;
  80042001ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		cpuid(0x1, NULL, NULL, &ecx, NULL);
  80042001f5:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042001f9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042001ff:	48 89 c1             	mov    %rax,%rcx
  8004200202:	ba 00 00 00 00       	mov    $0x0,%edx
  8004200207:	be 00 00 00 00       	mov    $0x0,%esi
  800420020c:	bf 01 00 00 00       	mov    $0x1,%edi
  8004200211:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200218:	00 00 00 
  800420021b:	ff d0                	callq  *%rax
		if (ecx & 0x20)
  800420021d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200220:	83 e0 20             	and    $0x20,%eax
  8004200223:	85 c0                	test   %eax,%eax
  8004200225:	74 2a                	je     8004200251 <i386_init+0xcf>
			panic("[ERR] VMX extension exposed to guest.\n");
  8004200227:	48 ba 88 46 21 04 80 	movabs $0x8004214688,%rdx
  800420022e:	00 00 00 
  8004200231:	be 46 00 00 00       	mov    $0x46,%esi
  8004200236:	48 bf 5c 46 21 04 80 	movabs $0x800421465c,%rdi
  800420023d:	00 00 00 
  8004200240:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200245:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420024c:	00 00 00 
  800420024f:	ff d1                	callq  *%rcx
		else
			cprintf("VMX extension hidden from guest.\n");
  8004200251:	48 bf b0 46 21 04 80 	movabs $0x80042146b0,%rdi
  8004200258:	00 00 00 
  800420025b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200260:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004200267:	00 00 00 
  800420026a:	ff d2                	callq  *%rdx
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  800420026c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200271:	48 ba 2d 27 20 04 80 	movabs $0x800420272d,%rdx
  8004200278:	00 00 00 
  800420027b:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  800420027d:	48 b8 5e 80 20 04 80 	movabs $0x800420805e,%rax
  8004200284:	00 00 00 
  8004200287:	ff d0                	callq  *%rax
	trap_init();
  8004200289:	48 b8 c2 96 20 04 80 	movabs $0x80042096c2,%rax
  8004200290:	00 00 00 
  8004200293:	ff d0                	callq  *%rax
	mp_init();
	lapic_init();
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200295:	48 b8 4a 92 20 04 80 	movabs $0x800420924a,%rax
  800420029c:	00 00 00 
  800420029f:	ff d0                	callq  *%rax




	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042002a1:	be 01 00 00 00       	mov    $0x1,%esi
  80042002a6:	48 bf c0 8e 2e 04 80 	movabs $0x80042e8ec0,%rdi
  80042002ad:	00 00 00 
  80042002b0:	48 b8 ff 88 20 04 80 	movabs $0x80042088ff,%rax
  80042002b7:	00 00 00 
  80042002ba:	ff d0                	callq  *%rax
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
#else
	// Touch all you want.

	ENV_CREATE(user_icode, ENV_TYPE_USER);
  80042002bc:	be 00 00 00 00       	mov    $0x0,%esi
  80042002c1:	48 bf d0 70 2c 04 80 	movabs $0x80042c70d0,%rdi
  80042002c8:	00 00 00 
  80042002cb:	48 b8 ff 88 20 04 80 	movabs $0x80042088ff,%rax
  80042002d2:	00 00 00 
  80042002d5:	ff d0                	callq  *%rax
#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042002d7:	48 b8 d9 10 20 04 80 	movabs $0x80042010d9,%rax
  80042002de:	00 00 00 
  80042002e1:	ff d0                	callq  *%rax

	// Schedule and run the first user environment!
	sched_yield();
  80042002e3:	48 b8 c5 a3 20 04 80 	movabs $0x800420a3c5,%rax
  80042002ea:	00 00 00 
  80042002ed:	ff d0                	callq  *%rax

00000080042002ef <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042002ef:	55                   	push   %rbp
  80042002f0:	48 89 e5             	mov    %rsp,%rbp
  80042002f3:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042002f7:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  80042002fe:	00 
  80042002ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200303:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200307:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420030a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420030d:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004200314:	00 00 00 
  8004200317:	48 8b 00             	mov    (%rax),%rax
  800420031a:	48 39 c2             	cmp    %rax,%rdx
  800420031d:	72 32                	jb     8004200351 <boot_aps+0x62>
  800420031f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200323:	48 89 c1             	mov    %rax,%rcx
  8004200326:	48 ba d8 46 21 04 80 	movabs $0x80042146d8,%rdx
  800420032d:	00 00 00 
  8004200330:	be 96 00 00 00       	mov    $0x96,%esi
  8004200335:	48 bf 5c 46 21 04 80 	movabs $0x800421465c,%rdi
  800420033c:	00 00 00 
  800420033f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200344:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420034b:	00 00 00 
  800420034e:	41 ff d0             	callq  *%r8
  8004200351:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004200358:	00 00 00 
  800420035b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420035f:	48 01 d0             	add    %rdx,%rax
  8004200362:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200366:	48 ba ce 28 21 04 80 	movabs $0x80042128ce,%rdx
  800420036d:	00 00 00 
  8004200370:	48 b8 e8 27 21 04 80 	movabs $0x80042127e8,%rax
  8004200377:	00 00 00 
  800420037a:	48 29 c2             	sub    %rax,%rdx
  800420037d:	48 89 d0             	mov    %rdx,%rax
  8004200380:	48 89 c2             	mov    %rax,%rdx
  8004200383:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200387:	48 be e8 27 21 04 80 	movabs $0x80042127e8,%rsi
  800420038e:	00 00 00 
  8004200391:	48 89 c7             	mov    %rax,%rdi
  8004200394:	48 b8 73 c5 20 04 80 	movabs $0x800420c573,%rax
  800420039b:	00 00 00 
  800420039e:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003a0:	48 b8 40 e0 57 04 80 	movabs $0x800457e040,%rax
  80042003a7:	00 00 00 
  80042003aa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042003ae:	e9 0e 01 00 00       	jmpq   80042004c1 <boot_aps+0x1d2>
		if (c == cpus + cpunum())  // We've started already.
  80042003b3:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042003ba:	00 00 00 
  80042003bd:	ff d0                	callq  *%rax
  80042003bf:	48 98                	cltq   
  80042003c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042003c5:	48 89 c2             	mov    %rax,%rdx
  80042003c8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003cc:	48 01 c2             	add    %rax,%rdx
  80042003cf:	48 b8 40 e0 57 04 80 	movabs $0x800457e040,%rax
  80042003d6:	00 00 00 
  80042003d9:	48 01 d0             	add    %rdx,%rax
  80042003dc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003e0:	75 05                	jne    80042003e7 <boot_aps+0xf8>
			continue;
  80042003e2:	e9 d2 00 00 00       	jmpq   80042004b9 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042003e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042003eb:	48 b8 40 e0 57 04 80 	movabs $0x800457e040,%rax
  80042003f2:	00 00 00 
  80042003f5:	48 29 c2             	sub    %rax,%rdx
  80042003f8:	48 89 d0             	mov    %rdx,%rax
  80042003fb:	48 c1 f8 03          	sar    $0x3,%rax
  80042003ff:	48 89 c2             	mov    %rax,%rdx
  8004200402:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  8004200409:	f0 f0 f0 
  800420040c:	48 0f af c2          	imul   %rdx,%rax
  8004200410:	48 83 c0 01          	add    $0x1,%rax
  8004200414:	48 c1 e0 10          	shl    $0x10,%rax
  8004200418:	48 89 c2             	mov    %rax,%rdx
  800420041b:	48 b8 00 f0 57 04 80 	movabs $0x800457f000,%rax
  8004200422:	00 00 00 
  8004200425:	48 01 c2             	add    %rax,%rdx
  8004200428:	48 b8 b8 c7 57 04 80 	movabs $0x800457c7b8,%rax
  800420042f:	00 00 00 
  8004200432:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200435:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200439:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420043d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200444:	00 00 00 
  8004200447:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420044b:	77 32                	ja     800420047f <boot_aps+0x190>
  800420044d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200451:	48 89 c1             	mov    %rax,%rcx
  8004200454:	48 ba 00 47 21 04 80 	movabs $0x8004214700,%rdx
  800420045b:	00 00 00 
  800420045e:	be a0 00 00 00       	mov    $0xa0,%esi
  8004200463:	48 bf 5c 46 21 04 80 	movabs $0x800421465c,%rdi
  800420046a:	00 00 00 
  800420046d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200472:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004200479:	00 00 00 
  800420047c:	41 ff d0             	callq  *%r8
  800420047f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004200486:	ff ff ff 
  8004200489:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420048d:	48 01 d0             	add    %rdx,%rax
  8004200490:	89 c2                	mov    %eax,%edx
  8004200492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200496:	0f b6 00             	movzbl (%rax),%eax
  8004200499:	0f b6 c0             	movzbl %al,%eax
  800420049c:	89 d6                	mov    %edx,%esi
  800420049e:	89 c7                	mov    %eax,%edi
  80042004a0:	48 b8 69 34 21 04 80 	movabs $0x8004213469,%rax
  80042004a7:	00 00 00 
  80042004aa:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042004ac:	90                   	nop
  80042004ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042004b1:	8b 40 04             	mov    0x4(%rax),%eax
  80042004b4:	83 f8 01             	cmp    $0x1,%eax
  80042004b7:	75 f4                	jne    80042004ad <boot_aps+0x1be>
	for (c = cpus; c < cpus + ncpu; c++) {
  80042004b9:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  80042004c0:	00 
  80042004c1:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  80042004c8:	00 00 00 
  80042004cb:	8b 00                	mov    (%rax),%eax
  80042004cd:	48 98                	cltq   
  80042004cf:	48 c1 e0 03          	shl    $0x3,%rax
  80042004d3:	48 89 c2             	mov    %rax,%rdx
  80042004d6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004da:	48 01 c2             	add    %rax,%rdx
  80042004dd:	48 b8 40 e0 57 04 80 	movabs $0x800457e040,%rax
  80042004e4:	00 00 00 
  80042004e7:	48 01 d0             	add    %rdx,%rax
  80042004ea:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042004ee:	0f 87 bf fe ff ff    	ja     80042003b3 <boot_aps+0xc4>
			;
	}
}
  80042004f4:	c9                   	leaveq 
  80042004f5:	c3                   	retq   

00000080042004f6 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042004f6:	55                   	push   %rbp
  80042004f7:	48 89 e5             	mov    %rsp,%rbp
  80042004fa:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir
	lcr3(boot_cr3);
  80042004fe:	48 b8 c0 c7 57 04 80 	movabs $0x800457c7c0,%rax
  8004200505:	00 00 00 
  8004200508:	48 8b 00             	mov    (%rax),%rax
  800420050b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420050f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200513:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200516:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420051d:	00 00 00 
  8004200520:	ff d0                	callq  *%rax
  8004200522:	89 c6                	mov    %eax,%esi
  8004200524:	48 bf 24 47 21 04 80 	movabs $0x8004214724,%rdi
  800420052b:	00 00 00 
  800420052e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200533:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420053a:	00 00 00 
  800420053d:	ff d2                	callq  *%rdx

	lapic_init();
  800420053f:	48 b8 ff 31 21 04 80 	movabs $0x80042131ff,%rax
  8004200546:	00 00 00 
  8004200549:	ff d0                	callq  *%rax
	env_init_percpu();
  800420054b:	48 b8 2b 81 20 04 80 	movabs $0x800420812b,%rax
  8004200552:	00 00 00 
  8004200555:	ff d0                	callq  *%rax
	trap_init_percpu();
  8004200557:	48 b8 fb 96 20 04 80 	movabs $0x80042096fb,%rax
  800420055e:	00 00 00 
  8004200561:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200563:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420056a:	00 00 00 
  800420056d:	ff d0                	callq  *%rax
  800420056f:	48 98                	cltq   
  8004200571:	48 c1 e0 03          	shl    $0x3,%rax
  8004200575:	48 89 c2             	mov    %rax,%rdx
  8004200578:	48 c1 e2 04          	shl    $0x4,%rdx
  800420057c:	48 01 d0             	add    %rdx,%rax
  800420057f:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004200586:	00 00 00 
  8004200589:	48 01 d0             	add    %rdx,%rax
  800420058c:	48 83 c0 04          	add    $0x4,%rax
  8004200590:	be 01 00 00 00       	mov    $0x1,%esi
  8004200595:	48 89 c7             	mov    %rax,%rdi
  8004200598:	48 b8 ce 00 20 04 80 	movabs $0x80042000ce,%rax
  800420059f:	00 00 00 
  80042005a2:	ff d0                	callq  *%rax
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:

	// Remove this after you finish Exercise 4
	for (;;);
  80042005a4:	eb fe                	jmp    80042005a4 <mp_main+0xae>

00000080042005a6 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042005a6:	55                   	push   %rbp
  80042005a7:	48 89 e5             	mov    %rsp,%rbp
  80042005aa:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005b1:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005b8:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005be:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042005c5:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042005cc:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042005d3:	84 c0                	test   %al,%al
  80042005d5:	74 20                	je     80042005f7 <_panic+0x51>
  80042005d7:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042005db:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042005df:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042005e3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042005e7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042005eb:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042005ef:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042005f3:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042005f7:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  80042005fe:	48 b8 b0 c7 57 04 80 	movabs $0x800457c7b0,%rax
  8004200605:	00 00 00 
  8004200608:	48 8b 00             	mov    (%rax),%rax
  800420060b:	48 85 c0             	test   %rax,%rax
  800420060e:	74 05                	je     8004200615 <_panic+0x6f>
		goto dead;
  8004200610:	e9 ba 00 00 00       	jmpq   80042006cf <_panic+0x129>
	panicstr = fmt;
  8004200615:	48 b8 b0 c7 57 04 80 	movabs $0x800457c7b0,%rax
  800420061c:	00 00 00 
  800420061f:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200626:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200629:	fa                   	cli    
  800420062a:	fc                   	cld    

	va_start(ap, fmt);
  800420062b:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200632:	00 00 00 
  8004200635:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420063c:	00 00 00 
  800420063f:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200643:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420064a:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200651:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200658:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420065f:	00 00 00 
  8004200662:	ff d0                	callq  *%rax
  8004200664:	89 c6                	mov    %eax,%esi
  8004200666:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800420066c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200673:	89 d1                	mov    %edx,%ecx
  8004200675:	48 89 c2             	mov    %rax,%rdx
  8004200678:	48 bf 40 47 21 04 80 	movabs $0x8004214740,%rdi
  800420067f:	00 00 00 
  8004200682:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200687:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  800420068e:	00 00 00 
  8004200691:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200694:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420069b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006a2:	48 89 d6             	mov    %rdx,%rsi
  80042006a5:	48 89 c7             	mov    %rax,%rdi
  80042006a8:	48 b8 eb 94 20 04 80 	movabs $0x80042094eb,%rax
  80042006af:	00 00 00 
  80042006b2:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006b4:	48 bf 62 47 21 04 80 	movabs $0x8004214762,%rdi
  80042006bb:	00 00 00 
  80042006be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006c3:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042006ca:	00 00 00 
  80042006cd:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042006cf:	bf 00 00 00 00       	mov    $0x0,%edi
  80042006d4:	48 b8 60 1b 20 04 80 	movabs $0x8004201b60,%rax
  80042006db:	00 00 00 
  80042006de:	ff d0                	callq  *%rax
  80042006e0:	eb ed                	jmp    80042006cf <_panic+0x129>

00000080042006e2 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042006e2:	55                   	push   %rbp
  80042006e3:	48 89 e5             	mov    %rsp,%rbp
  80042006e6:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042006ed:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042006f4:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042006fa:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200701:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200708:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420070f:	84 c0                	test   %al,%al
  8004200711:	74 20                	je     8004200733 <_warn+0x51>
  8004200713:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200717:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420071b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420071f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200723:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200727:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420072b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420072f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200733:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420073a:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200741:	00 00 00 
  8004200744:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420074b:	00 00 00 
  800420074e:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200752:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200759:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200760:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  8004200767:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800420076d:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200774:	48 89 c6             	mov    %rax,%rsi
  8004200777:	48 bf 64 47 21 04 80 	movabs $0x8004214764,%rdi
  800420077e:	00 00 00 
  8004200781:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200786:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  800420078d:	00 00 00 
  8004200790:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200792:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200799:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042007a0:	48 89 d6             	mov    %rdx,%rsi
  80042007a3:	48 89 c7             	mov    %rax,%rdi
  80042007a6:	48 b8 eb 94 20 04 80 	movabs $0x80042094eb,%rax
  80042007ad:	00 00 00 
  80042007b0:	ff d0                	callq  *%rax
	cprintf("\n");
  80042007b2:	48 bf 62 47 21 04 80 	movabs $0x8004214762,%rdi
  80042007b9:	00 00 00 
  80042007bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042007c1:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042007c8:	00 00 00 
  80042007cb:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042007cd:	c9                   	leaveq 
  80042007ce:	c3                   	retq   

00000080042007cf <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042007cf:	55                   	push   %rbp
  80042007d0:	48 89 e5             	mov    %rsp,%rbp
  80042007d3:	48 83 ec 20          	sub    $0x20,%rsp
  80042007d7:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042007e1:	89 c2                	mov    %eax,%edx
  80042007e3:	ec                   	in     (%dx),%al
  80042007e4:	88 45 fb             	mov    %al,-0x5(%rbp)
  80042007e7:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  80042007ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007f1:	89 c2                	mov    %eax,%edx
  80042007f3:	ec                   	in     (%dx),%al
  80042007f4:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042007f7:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  80042007fe:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200801:	89 c2                	mov    %eax,%edx
  8004200803:	ec                   	in     (%dx),%al
  8004200804:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200807:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  800420080e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200811:	89 c2                	mov    %eax,%edx
  8004200813:	ec                   	in     (%dx),%al
  8004200814:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200817:	c9                   	leaveq 
  8004200818:	c3                   	retq   

0000008004200819 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200819:	55                   	push   %rbp
  800420081a:	48 89 e5             	mov    %rsp,%rbp
  800420081d:	48 83 ec 10          	sub    $0x10,%rsp
  8004200821:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  8004200828:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420082b:	89 c2                	mov    %eax,%edx
  800420082d:	ec                   	in     (%dx),%al
  800420082e:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004200831:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200835:	0f b6 c0             	movzbl %al,%eax
  8004200838:	83 e0 01             	and    $0x1,%eax
  800420083b:	85 c0                	test   %eax,%eax
  800420083d:	75 07                	jne    8004200846 <serial_proc_data+0x2d>
		return -1;
  800420083f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200844:	eb 17                	jmp    800420085d <serial_proc_data+0x44>
  8004200846:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420084d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200850:	89 c2                	mov    %eax,%edx
  8004200852:	ec                   	in     (%dx),%al
  8004200853:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200856:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  800420085a:	0f b6 c0             	movzbl %al,%eax
}
  800420085d:	c9                   	leaveq 
  800420085e:	c3                   	retq   

000000800420085f <serial_intr>:

void
serial_intr(void)
{
  800420085f:	55                   	push   %rbp
  8004200860:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  8004200863:	48 b8 00 b0 57 04 80 	movabs $0x800457b000,%rax
  800420086a:	00 00 00 
  800420086d:	0f b6 00             	movzbl (%rax),%eax
  8004200870:	84 c0                	test   %al,%al
  8004200872:	74 16                	je     800420088a <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200874:	48 bf 19 08 20 04 80 	movabs $0x8004200819,%rdi
  800420087b:	00 00 00 
  800420087e:	48 b8 2a 11 20 04 80 	movabs $0x800420112a,%rax
  8004200885:	00 00 00 
  8004200888:	ff d0                	callq  *%rax
}
  800420088a:	5d                   	pop    %rbp
  800420088b:	c3                   	retq   

000000800420088c <serial_putc>:

static void
serial_putc(int c)
{
  800420088c:	55                   	push   %rbp
  800420088d:	48 89 e5             	mov    %rsp,%rbp
  8004200890:	48 83 ec 28          	sub    $0x28,%rsp
  8004200894:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  8004200897:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420089e:	eb 10                	jmp    80042008b0 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042008a0:	48 b8 cf 07 20 04 80 	movabs $0x80042007cf,%rax
  80042008a7:	00 00 00 
  80042008aa:	ff d0                	callq  *%rax
	     i++)
  80042008ac:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042008b0:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008b7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042008ba:	89 c2                	mov    %eax,%edx
  80042008bc:	ec                   	in     (%dx),%al
  80042008bd:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042008c0:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042008c4:	0f b6 c0             	movzbl %al,%eax
  80042008c7:	83 e0 20             	and    $0x20,%eax
	for (i = 0;
  80042008ca:	85 c0                	test   %eax,%eax
  80042008cc:	75 09                	jne    80042008d7 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042008ce:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042008d5:	7e c9                	jle    80042008a0 <serial_putc+0x14>

	outb(COM1 + COM_TX, c);
  80042008d7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042008da:	0f b6 c0             	movzbl %al,%eax
  80042008dd:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  80042008e4:	88 45 ef             	mov    %al,-0x11(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042008e7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042008eb:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042008ee:	ee                   	out    %al,(%dx)
}
  80042008ef:	c9                   	leaveq 
  80042008f0:	c3                   	retq   

00000080042008f1 <serial_init>:

static void
serial_init(void)
{
  80042008f1:	55                   	push   %rbp
  80042008f2:	48 89 e5             	mov    %rsp,%rbp
  80042008f5:	48 83 ec 50          	sub    $0x50,%rsp
  80042008f9:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200900:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200904:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200908:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420090b:	ee                   	out    %al,(%dx)
  800420090c:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  8004200913:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  8004200917:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420091b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420091e:	ee                   	out    %al,(%dx)
  800420091f:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200926:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  800420092a:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420092e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200931:	ee                   	out    %al,(%dx)
  8004200932:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  8004200939:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  800420093d:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200941:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200944:	ee                   	out    %al,(%dx)
  8004200945:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  800420094c:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  8004200950:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200954:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200957:	ee                   	out    %al,(%dx)
  8004200958:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  800420095f:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200963:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200967:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420096a:	ee                   	out    %al,(%dx)
  800420096b:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200972:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200976:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800420097a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420097d:	ee                   	out    %al,(%dx)
  800420097e:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200985:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004200988:	89 c2                	mov    %eax,%edx
  800420098a:	ec                   	in     (%dx),%al
  800420098b:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  800420098e:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200992:	3c ff                	cmp    $0xff,%al
  8004200994:	0f 95 c2             	setne  %dl
  8004200997:	48 b8 00 b0 57 04 80 	movabs $0x800457b000,%rax
  800420099e:	00 00 00 
  80042009a1:	88 10                	mov    %dl,(%rax)
  80042009a3:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009aa:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042009ad:	89 c2                	mov    %eax,%edx
  80042009af:	ec                   	in     (%dx),%al
  80042009b0:	88 45 bb             	mov    %al,-0x45(%rbp)
  80042009b3:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  80042009ba:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042009bd:	89 c2                	mov    %eax,%edx
  80042009bf:	ec                   	in     (%dx),%al
  80042009c0:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  80042009c3:	48 b8 00 b0 57 04 80 	movabs $0x800457b000,%rax
  80042009ca:	00 00 00 
  80042009cd:	0f b6 00             	movzbl (%rax),%eax
  80042009d0:	84 c0                	test   %al,%al
  80042009d2:	74 23                	je     80042009f7 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  80042009d4:	48 b8 b2 86 22 04 80 	movabs $0x80042286b2,%rax
  80042009db:	00 00 00 
  80042009de:	0f b7 00             	movzwl (%rax),%eax
  80042009e1:	0f b7 c0             	movzwl %ax,%eax
  80042009e4:	25 ef ff 00 00       	and    $0xffef,%eax
  80042009e9:	89 c7                	mov    %eax,%edi
  80042009eb:	48 b8 9c 93 20 04 80 	movabs $0x800420939c,%rax
  80042009f2:	00 00 00 
  80042009f5:	ff d0                	callq  *%rax
}
  80042009f7:	c9                   	leaveq 
  80042009f8:	c3                   	retq   

00000080042009f9 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  80042009f9:	55                   	push   %rbp
  80042009fa:	48 89 e5             	mov    %rsp,%rbp
  80042009fd:	48 83 ec 38          	sub    $0x38,%rsp
  8004200a01:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200a04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200a0b:	eb 10                	jmp    8004200a1d <lpt_putc+0x24>
		delay();
  8004200a0d:	48 b8 cf 07 20 04 80 	movabs $0x80042007cf,%rax
  8004200a14:	00 00 00 
  8004200a17:	ff d0                	callq  *%rax
	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200a19:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200a1d:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200a24:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200a27:	89 c2                	mov    %eax,%edx
  8004200a29:	ec                   	in     (%dx),%al
  8004200a2a:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200a2d:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200a31:	84 c0                	test   %al,%al
  8004200a33:	78 09                	js     8004200a3e <lpt_putc+0x45>
  8004200a35:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200a3c:	7e cf                	jle    8004200a0d <lpt_putc+0x14>
	outb(0x378+0, c);
  8004200a3e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200a41:	0f b6 c0             	movzbl %al,%eax
  8004200a44:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  8004200a4b:	88 45 ef             	mov    %al,-0x11(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a4e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200a52:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200a55:	ee                   	out    %al,(%dx)
  8004200a56:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200a5d:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200a61:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200a65:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200a68:	ee                   	out    %al,(%dx)
  8004200a69:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200a70:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200a74:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200a78:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200a7b:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200a7c:	c9                   	leaveq 
  8004200a7d:	c3                   	retq   

0000008004200a7e <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200a7e:	55                   	push   %rbp
  8004200a7f:	48 89 e5             	mov    %rsp,%rbp
  8004200a82:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200a86:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200a8d:	00 00 00 
  8004200a90:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200a94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a98:	0f b7 00             	movzwl (%rax),%eax
  8004200a9b:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200aa3:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200aa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200aac:	0f b7 00             	movzwl (%rax),%eax
  8004200aaf:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200ab3:	74 20                	je     8004200ad5 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200ab5:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200abc:	00 00 00 
  8004200abf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200ac3:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200aca:	00 00 00 
  8004200acd:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200ad3:	eb 1b                	jmp    8004200af0 <cga_init+0x72>
	} else {
		*cp = was;
  8004200ad5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200ad9:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200add:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200ae0:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200ae7:	00 00 00 
  8004200aea:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200af0:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200af7:	00 00 00 
  8004200afa:	8b 00                	mov    (%rax),%eax
  8004200afc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200aff:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200b03:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200b07:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200b0a:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200b0b:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200b12:	00 00 00 
  8004200b15:	8b 00                	mov    (%rax),%eax
  8004200b17:	83 c0 01             	add    $0x1,%eax
  8004200b1a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200b1d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200b20:	89 c2                	mov    %eax,%edx
  8004200b22:	ec                   	in     (%dx),%al
  8004200b23:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200b26:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200b2a:	0f b6 c0             	movzbl %al,%eax
  8004200b2d:	c1 e0 08             	shl    $0x8,%eax
  8004200b30:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200b33:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200b3a:	00 00 00 
  8004200b3d:	8b 00                	mov    (%rax),%eax
  8004200b3f:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200b42:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200b46:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200b4a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200b4d:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200b4e:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200b55:	00 00 00 
  8004200b58:	8b 00                	mov    (%rax),%eax
  8004200b5a:	83 c0 01             	add    $0x1,%eax
  8004200b5d:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200b60:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200b63:	89 c2                	mov    %eax,%edx
  8004200b65:	ec                   	in     (%dx),%al
  8004200b66:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200b69:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200b6d:	0f b6 c0             	movzbl %al,%eax
  8004200b70:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200b73:	48 b8 08 b0 57 04 80 	movabs $0x800457b008,%rax
  8004200b7a:	00 00 00 
  8004200b7d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200b81:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200b84:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200b87:	89 c2                	mov    %eax,%edx
  8004200b89:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200b90:	00 00 00 
  8004200b93:	66 89 10             	mov    %dx,(%rax)
}
  8004200b96:	c9                   	leaveq 
  8004200b97:	c3                   	retq   

0000008004200b98 <cga_putc>:



static void
cga_putc(int c)
{
  8004200b98:	55                   	push   %rbp
  8004200b99:	48 89 e5             	mov    %rsp,%rbp
  8004200b9c:	48 83 ec 40          	sub    $0x40,%rsp
  8004200ba0:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200ba3:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ba6:	b0 00                	mov    $0x0,%al
  8004200ba8:	85 c0                	test   %eax,%eax
  8004200baa:	75 07                	jne    8004200bb3 <cga_putc+0x1b>
		c |= 0x0700;
  8004200bac:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200bb3:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bb6:	0f b6 c0             	movzbl %al,%eax
  8004200bb9:	83 f8 09             	cmp    $0x9,%eax
  8004200bbc:	0f 84 f6 00 00 00    	je     8004200cb8 <cga_putc+0x120>
  8004200bc2:	83 f8 09             	cmp    $0x9,%eax
  8004200bc5:	7f 0a                	jg     8004200bd1 <cga_putc+0x39>
  8004200bc7:	83 f8 08             	cmp    $0x8,%eax
  8004200bca:	74 18                	je     8004200be4 <cga_putc+0x4c>
  8004200bcc:	e9 3e 01 00 00       	jmpq   8004200d0f <cga_putc+0x177>
  8004200bd1:	83 f8 0a             	cmp    $0xa,%eax
  8004200bd4:	74 75                	je     8004200c4b <cga_putc+0xb3>
  8004200bd6:	83 f8 0d             	cmp    $0xd,%eax
  8004200bd9:	0f 84 89 00 00 00    	je     8004200c68 <cga_putc+0xd0>
  8004200bdf:	e9 2b 01 00 00       	jmpq   8004200d0f <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200be4:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200beb:	00 00 00 
  8004200bee:	0f b7 00             	movzwl (%rax),%eax
  8004200bf1:	66 85 c0             	test   %ax,%ax
  8004200bf4:	74 50                	je     8004200c46 <cga_putc+0xae>
			crt_pos--;
  8004200bf6:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200bfd:	00 00 00 
  8004200c00:	0f b7 00             	movzwl (%rax),%eax
  8004200c03:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200c06:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200c0d:	00 00 00 
  8004200c10:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200c13:	48 b8 08 b0 57 04 80 	movabs $0x800457b008,%rax
  8004200c1a:	00 00 00 
  8004200c1d:	48 8b 10             	mov    (%rax),%rdx
  8004200c20:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200c27:	00 00 00 
  8004200c2a:	0f b7 00             	movzwl (%rax),%eax
  8004200c2d:	0f b7 c0             	movzwl %ax,%eax
  8004200c30:	48 01 c0             	add    %rax,%rax
  8004200c33:	48 01 d0             	add    %rdx,%rax
  8004200c36:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200c39:	b2 00                	mov    $0x0,%dl
  8004200c3b:	83 ca 20             	or     $0x20,%edx
  8004200c3e:	66 89 10             	mov    %dx,(%rax)
		}
		break;
  8004200c41:	e9 03 01 00 00       	jmpq   8004200d49 <cga_putc+0x1b1>
  8004200c46:	e9 fe 00 00 00       	jmpq   8004200d49 <cga_putc+0x1b1>
	case '\n':
		crt_pos += CRT_COLS;
  8004200c4b:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200c52:	00 00 00 
  8004200c55:	0f b7 00             	movzwl (%rax),%eax
  8004200c58:	8d 50 50             	lea    0x50(%rax),%edx
  8004200c5b:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200c62:	00 00 00 
  8004200c65:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200c68:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200c6f:	00 00 00 
  8004200c72:	0f b7 30             	movzwl (%rax),%esi
  8004200c75:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200c7c:	00 00 00 
  8004200c7f:	0f b7 08             	movzwl (%rax),%ecx
  8004200c82:	0f b7 c1             	movzwl %cx,%eax
  8004200c85:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c8b:	c1 e8 10             	shr    $0x10,%eax
  8004200c8e:	89 c2                	mov    %eax,%edx
  8004200c90:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c94:	89 d0                	mov    %edx,%eax
  8004200c96:	c1 e0 02             	shl    $0x2,%eax
  8004200c99:	01 d0                	add    %edx,%eax
  8004200c9b:	c1 e0 04             	shl    $0x4,%eax
  8004200c9e:	29 c1                	sub    %eax,%ecx
  8004200ca0:	89 ca                	mov    %ecx,%edx
  8004200ca2:	29 d6                	sub    %edx,%esi
  8004200ca4:	89 f2                	mov    %esi,%edx
  8004200ca6:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200cad:	00 00 00 
  8004200cb0:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200cb3:	e9 91 00 00 00       	jmpq   8004200d49 <cga_putc+0x1b1>
	case '\t':
		cons_putc(' ');
  8004200cb8:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cbd:	48 b8 67 12 20 04 80 	movabs $0x8004201267,%rax
  8004200cc4:	00 00 00 
  8004200cc7:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200cc9:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cce:	48 b8 67 12 20 04 80 	movabs $0x8004201267,%rax
  8004200cd5:	00 00 00 
  8004200cd8:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200cda:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cdf:	48 b8 67 12 20 04 80 	movabs $0x8004201267,%rax
  8004200ce6:	00 00 00 
  8004200ce9:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200ceb:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cf0:	48 b8 67 12 20 04 80 	movabs $0x8004201267,%rax
  8004200cf7:	00 00 00 
  8004200cfa:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200cfc:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d01:	48 b8 67 12 20 04 80 	movabs $0x8004201267,%rax
  8004200d08:	00 00 00 
  8004200d0b:	ff d0                	callq  *%rax
		break;
  8004200d0d:	eb 3a                	jmp    8004200d49 <cga_putc+0x1b1>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200d0f:	48 b8 08 b0 57 04 80 	movabs $0x800457b008,%rax
  8004200d16:	00 00 00 
  8004200d19:	48 8b 30             	mov    (%rax),%rsi
  8004200d1c:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200d23:	00 00 00 
  8004200d26:	0f b7 00             	movzwl (%rax),%eax
  8004200d29:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200d2c:	48 ba 10 b0 57 04 80 	movabs $0x800457b010,%rdx
  8004200d33:	00 00 00 
  8004200d36:	66 89 0a             	mov    %cx,(%rdx)
  8004200d39:	0f b7 c0             	movzwl %ax,%eax
  8004200d3c:	48 01 c0             	add    %rax,%rax
  8004200d3f:	48 01 f0             	add    %rsi,%rax
  8004200d42:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200d45:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200d48:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200d49:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200d50:	00 00 00 
  8004200d53:	0f b7 00             	movzwl (%rax),%eax
  8004200d56:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200d5a:	0f 86 89 00 00 00    	jbe    8004200de9 <cga_putc+0x251>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200d60:	48 b8 08 b0 57 04 80 	movabs $0x800457b008,%rax
  8004200d67:	00 00 00 
  8004200d6a:	48 8b 00             	mov    (%rax),%rax
  8004200d6d:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200d74:	48 b8 08 b0 57 04 80 	movabs $0x800457b008,%rax
  8004200d7b:	00 00 00 
  8004200d7e:	48 8b 00             	mov    (%rax),%rax
  8004200d81:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200d86:	48 89 ce             	mov    %rcx,%rsi
  8004200d89:	48 89 c7             	mov    %rax,%rdi
  8004200d8c:	48 b8 73 c5 20 04 80 	movabs $0x800420c573,%rax
  8004200d93:	00 00 00 
  8004200d96:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d98:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d9f:	eb 22                	jmp    8004200dc3 <cga_putc+0x22b>
			crt_buf[i] = 0x0700 | ' ';
  8004200da1:	48 b8 08 b0 57 04 80 	movabs $0x800457b008,%rax
  8004200da8:	00 00 00 
  8004200dab:	48 8b 00             	mov    (%rax),%rax
  8004200dae:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200db1:	48 63 d2             	movslq %edx,%rdx
  8004200db4:	48 01 d2             	add    %rdx,%rdx
  8004200db7:	48 01 d0             	add    %rdx,%rax
  8004200dba:	66 c7 00 20 07       	movw   $0x720,(%rax)
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200dbf:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200dc3:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200dca:	7e d5                	jle    8004200da1 <cga_putc+0x209>
		crt_pos -= CRT_COLS;
  8004200dcc:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200dd3:	00 00 00 
  8004200dd6:	0f b7 00             	movzwl (%rax),%eax
  8004200dd9:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200ddc:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200de3:	00 00 00 
  8004200de6:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200de9:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200df0:	00 00 00 
  8004200df3:	8b 00                	mov    (%rax),%eax
  8004200df5:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200df8:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200dfc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200e00:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200e03:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200e04:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200e0b:	00 00 00 
  8004200e0e:	0f b7 00             	movzwl (%rax),%eax
  8004200e11:	66 c1 e8 08          	shr    $0x8,%ax
  8004200e15:	0f b6 c0             	movzbl %al,%eax
  8004200e18:	48 ba 04 b0 57 04 80 	movabs $0x800457b004,%rdx
  8004200e1f:	00 00 00 
  8004200e22:	8b 12                	mov    (%rdx),%edx
  8004200e24:	83 c2 01             	add    $0x1,%edx
  8004200e27:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200e2a:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200e2d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200e31:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200e34:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200e35:	48 b8 04 b0 57 04 80 	movabs $0x800457b004,%rax
  8004200e3c:	00 00 00 
  8004200e3f:	8b 00                	mov    (%rax),%eax
  8004200e41:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200e44:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200e48:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200e4c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200e4f:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200e50:	48 b8 10 b0 57 04 80 	movabs $0x800457b010,%rax
  8004200e57:	00 00 00 
  8004200e5a:	0f b7 00             	movzwl (%rax),%eax
  8004200e5d:	0f b6 c0             	movzbl %al,%eax
  8004200e60:	48 ba 04 b0 57 04 80 	movabs $0x800457b004,%rdx
  8004200e67:	00 00 00 
  8004200e6a:	8b 12                	mov    (%rdx),%edx
  8004200e6c:	83 c2 01             	add    $0x1,%edx
  8004200e6f:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200e72:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200e75:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200e79:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200e7c:	ee                   	out    %al,(%dx)
}
  8004200e7d:	c9                   	leaveq 
  8004200e7e:	c3                   	retq   

0000008004200e7f <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200e7f:	55                   	push   %rbp
  8004200e80:	48 89 e5             	mov    %rsp,%rbp
  8004200e83:	48 83 ec 30          	sub    $0x30,%rsp
  8004200e87:	c7 45 f0 64 00 00 00 	movl   $0x64,-0x10(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e8e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200e91:	89 c2                	mov    %eax,%edx
  8004200e93:	ec                   	in     (%dx),%al
  8004200e94:	88 45 ef             	mov    %al,-0x11(%rbp)
	return data;
  8004200e97:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e9b:	0f b6 c0             	movzbl %al,%eax
  8004200e9e:	83 e0 01             	and    $0x1,%eax
  8004200ea1:	85 c0                	test   %eax,%eax
  8004200ea3:	75 0a                	jne    8004200eaf <kbd_proc_data+0x30>
		return -1;
  8004200ea5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200eaa:	e9 28 02 00 00       	jmpq   80042010d7 <kbd_proc_data+0x258>
  8004200eaf:	c7 45 e8 60 00 00 00 	movl   $0x60,-0x18(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200eb6:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200eb9:	89 c2                	mov    %eax,%edx
  8004200ebb:	ec                   	in     (%dx),%al
  8004200ebc:	88 45 e7             	mov    %al,-0x19(%rbp)
	return data;
  8004200ebf:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax

	data = inb(KBDATAP);
  8004200ec3:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200ec6:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200eca:	75 27                	jne    8004200ef3 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200ecc:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200ed3:	00 00 00 
  8004200ed6:	8b 00                	mov    (%rax),%eax
  8004200ed8:	83 c8 40             	or     $0x40,%eax
  8004200edb:	89 c2                	mov    %eax,%edx
  8004200edd:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200ee4:	00 00 00 
  8004200ee7:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200ee9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200eee:	e9 e4 01 00 00       	jmpq   80042010d7 <kbd_proc_data+0x258>
	} else if (data & 0x80) {
  8004200ef3:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ef7:	84 c0                	test   %al,%al
  8004200ef9:	79 65                	jns    8004200f60 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200efb:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200f02:	00 00 00 
  8004200f05:	8b 00                	mov    (%rax),%eax
  8004200f07:	83 e0 40             	and    $0x40,%eax
  8004200f0a:	85 c0                	test   %eax,%eax
  8004200f0c:	75 09                	jne    8004200f17 <kbd_proc_data+0x98>
  8004200f0e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f12:	83 e0 7f             	and    $0x7f,%eax
  8004200f15:	eb 04                	jmp    8004200f1b <kbd_proc_data+0x9c>
  8004200f17:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f1b:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200f1e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f22:	48 ba 80 80 22 04 80 	movabs $0x8004228080,%rdx
  8004200f29:	00 00 00 
  8004200f2c:	48 98                	cltq   
  8004200f2e:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f32:	83 c8 40             	or     $0x40,%eax
  8004200f35:	0f b6 c0             	movzbl %al,%eax
  8004200f38:	f7 d0                	not    %eax
  8004200f3a:	89 c2                	mov    %eax,%edx
  8004200f3c:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200f43:	00 00 00 
  8004200f46:	8b 00                	mov    (%rax),%eax
  8004200f48:	21 c2                	and    %eax,%edx
  8004200f4a:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200f51:	00 00 00 
  8004200f54:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200f56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f5b:	e9 77 01 00 00       	jmpq   80042010d7 <kbd_proc_data+0x258>
	} else if (shift & E0ESC) {
  8004200f60:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200f67:	00 00 00 
  8004200f6a:	8b 00                	mov    (%rax),%eax
  8004200f6c:	83 e0 40             	and    $0x40,%eax
  8004200f6f:	85 c0                	test   %eax,%eax
  8004200f71:	74 21                	je     8004200f94 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200f73:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200f77:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200f7e:	00 00 00 
  8004200f81:	8b 00                	mov    (%rax),%eax
  8004200f83:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200f86:	89 c2                	mov    %eax,%edx
  8004200f88:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200f8f:	00 00 00 
  8004200f92:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f94:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f98:	48 ba 80 80 22 04 80 	movabs $0x8004228080,%rdx
  8004200f9f:	00 00 00 
  8004200fa2:	48 98                	cltq   
  8004200fa4:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200fa8:	0f b6 d0             	movzbl %al,%edx
  8004200fab:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200fb2:	00 00 00 
  8004200fb5:	8b 00                	mov    (%rax),%eax
  8004200fb7:	09 c2                	or     %eax,%edx
  8004200fb9:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200fc0:	00 00 00 
  8004200fc3:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200fc5:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fc9:	48 ba 80 81 22 04 80 	movabs $0x8004228180,%rdx
  8004200fd0:	00 00 00 
  8004200fd3:	48 98                	cltq   
  8004200fd5:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200fd9:	0f b6 d0             	movzbl %al,%edx
  8004200fdc:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200fe3:	00 00 00 
  8004200fe6:	8b 00                	mov    (%rax),%eax
  8004200fe8:	31 c2                	xor    %eax,%edx
  8004200fea:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200ff1:	00 00 00 
  8004200ff4:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200ff6:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004200ffd:	00 00 00 
  8004201000:	8b 00                	mov    (%rax),%eax
  8004201002:	83 e0 03             	and    $0x3,%eax
  8004201005:	89 c2                	mov    %eax,%edx
  8004201007:	48 b8 80 85 22 04 80 	movabs $0x8004228580,%rax
  800420100e:	00 00 00 
  8004201011:	89 d2                	mov    %edx,%edx
  8004201013:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004201017:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420101b:	48 01 d0             	add    %rdx,%rax
  800420101e:	0f b6 00             	movzbl (%rax),%eax
  8004201021:	0f b6 c0             	movzbl %al,%eax
  8004201024:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004201027:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  800420102e:	00 00 00 
  8004201031:	8b 00                	mov    (%rax),%eax
  8004201033:	83 e0 08             	and    $0x8,%eax
  8004201036:	85 c0                	test   %eax,%eax
  8004201038:	74 22                	je     800420105c <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  800420103a:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  800420103e:	7e 0c                	jle    800420104c <kbd_proc_data+0x1cd>
  8004201040:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004201044:	7f 06                	jg     800420104c <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004201046:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  800420104a:	eb 10                	jmp    800420105c <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  800420104c:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004201050:	7e 0a                	jle    800420105c <kbd_proc_data+0x1dd>
  8004201052:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004201056:	7f 04                	jg     800420105c <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004201058:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  800420105c:	48 b8 48 b2 57 04 80 	movabs $0x800457b248,%rax
  8004201063:	00 00 00 
  8004201066:	8b 00                	mov    (%rax),%eax
  8004201068:	f7 d0                	not    %eax
  800420106a:	83 e0 06             	and    $0x6,%eax
  800420106d:	85 c0                	test   %eax,%eax
  800420106f:	75 37                	jne    80042010a8 <kbd_proc_data+0x229>
  8004201071:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004201078:	75 2e                	jne    80042010a8 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  800420107a:	48 bf 7e 47 21 04 80 	movabs $0x800421477e,%rdi
  8004201081:	00 00 00 
  8004201084:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201089:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201090:	00 00 00 
  8004201093:	ff d2                	callq  *%rdx
  8004201095:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%rbp)
  800420109c:	c6 45 df 03          	movb   $0x3,-0x21(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042010a0:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042010a4:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042010a7:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
#ifdef VMM_GUEST
	if (c == 0x1b) {
  80042010a8:	83 7d fc 1b          	cmpl   $0x1b,-0x4(%rbp)
  80042010ac:	75 26                	jne    80042010d4 <kbd_proc_data+0x255>
		cprintf("ESC pressed\n");
  80042010ae:	48 bf 8a 47 21 04 80 	movabs $0x800421478a,%rdi
  80042010b5:	00 00 00 
  80042010b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042010bd:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042010c4:	00 00 00 
  80042010c7:	ff d2                	callq  *%rdx
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
  80042010c9:	b8 05 00 00 00       	mov    $0x5,%eax
  80042010ce:	0f 01 c1             	vmcall 
  80042010d1:	89 45 f4             	mov    %eax,-0xc(%rbp)
	}
#endif
	return c;
  80042010d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042010d7:	c9                   	leaveq 
  80042010d8:	c3                   	retq   

00000080042010d9 <kbd_intr>:

void
kbd_intr(void)
{
  80042010d9:	55                   	push   %rbp
  80042010da:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  80042010dd:	48 bf 7f 0e 20 04 80 	movabs $0x8004200e7f,%rdi
  80042010e4:	00 00 00 
  80042010e7:	48 b8 2a 11 20 04 80 	movabs $0x800420112a,%rax
  80042010ee:	00 00 00 
  80042010f1:	ff d0                	callq  *%rax
}
  80042010f3:	5d                   	pop    %rbp
  80042010f4:	c3                   	retq   

00000080042010f5 <kbd_init>:

static void
kbd_init(void)
{
  80042010f5:	55                   	push   %rbp
  80042010f6:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  80042010f9:	48 b8 d9 10 20 04 80 	movabs $0x80042010d9,%rax
  8004201100:	00 00 00 
  8004201103:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201105:	48 b8 b2 86 22 04 80 	movabs $0x80042286b2,%rax
  800420110c:	00 00 00 
  800420110f:	0f b7 00             	movzwl (%rax),%eax
  8004201112:	0f b7 c0             	movzwl %ax,%eax
  8004201115:	25 fd ff 00 00       	and    $0xfffd,%eax
  800420111a:	89 c7                	mov    %eax,%edi
  800420111c:	48 b8 9c 93 20 04 80 	movabs $0x800420939c,%rax
  8004201123:	00 00 00 
  8004201126:	ff d0                	callq  *%rax
}
  8004201128:	5d                   	pop    %rbp
  8004201129:	c3                   	retq   

000000800420112a <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  800420112a:	55                   	push   %rbp
  800420112b:	48 89 e5             	mov    %rsp,%rbp
  800420112e:	48 83 ec 20          	sub    $0x20,%rsp
  8004201132:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201136:	eb 6a                	jmp    80042011a2 <cons_intr+0x78>
		if (c == 0)
  8004201138:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420113c:	75 02                	jne    8004201140 <cons_intr+0x16>
			continue;
  800420113e:	eb 62                	jmp    80042011a2 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004201140:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  8004201147:	00 00 00 
  800420114a:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201150:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201153:	48 ba 40 b0 57 04 80 	movabs $0x800457b040,%rdx
  800420115a:	00 00 00 
  800420115d:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004201163:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004201166:	89 d1                	mov    %edx,%ecx
  8004201168:	48 ba 40 b0 57 04 80 	movabs $0x800457b040,%rdx
  800420116f:	00 00 00 
  8004201172:	89 c0                	mov    %eax,%eax
  8004201174:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004201177:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  800420117e:	00 00 00 
  8004201181:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201187:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420118c:	75 14                	jne    80042011a2 <cons_intr+0x78>
			cons.wpos = 0;
  800420118e:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  8004201195:	00 00 00 
  8004201198:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  800420119f:	00 00 00 
	while ((c = (*proc)()) != -1) {
  80042011a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042011a6:	ff d0                	callq  *%rax
  80042011a8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042011ab:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042011af:	75 87                	jne    8004201138 <cons_intr+0xe>
	}
}
  80042011b1:	c9                   	leaveq 
  80042011b2:	c3                   	retq   

00000080042011b3 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  80042011b3:	55                   	push   %rbp
  80042011b4:	48 89 e5             	mov    %rsp,%rbp
  80042011b7:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  80042011bb:	48 b8 5f 08 20 04 80 	movabs $0x800420085f,%rax
  80042011c2:	00 00 00 
  80042011c5:	ff d0                	callq  *%rax
	kbd_intr();
  80042011c7:	48 b8 d9 10 20 04 80 	movabs $0x80042010d9,%rax
  80042011ce:	00 00 00 
  80042011d1:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  80042011d3:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  80042011da:	00 00 00 
  80042011dd:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  80042011e3:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  80042011ea:	00 00 00 
  80042011ed:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042011f3:	39 c2                	cmp    %eax,%edx
  80042011f5:	74 69                	je     8004201260 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042011f7:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  80042011fe:	00 00 00 
  8004201201:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201207:	8d 48 01             	lea    0x1(%rax),%ecx
  800420120a:	48 ba 40 b0 57 04 80 	movabs $0x800457b040,%rdx
  8004201211:	00 00 00 
  8004201214:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  800420121a:	48 ba 40 b0 57 04 80 	movabs $0x800457b040,%rdx
  8004201221:	00 00 00 
  8004201224:	89 c0                	mov    %eax,%eax
  8004201226:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420122a:	0f b6 c0             	movzbl %al,%eax
  800420122d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201230:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  8004201237:	00 00 00 
  800420123a:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201240:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201245:	75 14                	jne    800420125b <cons_getc+0xa8>
			cons.rpos = 0;
  8004201247:	48 b8 40 b0 57 04 80 	movabs $0x800457b040,%rax
  800420124e:	00 00 00 
  8004201251:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201258:	00 00 00 
		return c;
  800420125b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420125e:	eb 05                	jmp    8004201265 <cons_getc+0xb2>
	}
	return 0;
  8004201260:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201265:	c9                   	leaveq 
  8004201266:	c3                   	retq   

0000008004201267 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201267:	55                   	push   %rbp
  8004201268:	48 89 e5             	mov    %rsp,%rbp
  800420126b:	48 83 ec 10          	sub    $0x10,%rsp
  800420126f:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  8004201272:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201275:	89 c7                	mov    %eax,%edi
  8004201277:	48 b8 8c 08 20 04 80 	movabs $0x800420088c,%rax
  800420127e:	00 00 00 
  8004201281:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201283:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201286:	89 c7                	mov    %eax,%edi
  8004201288:	48 b8 f9 09 20 04 80 	movabs $0x80042009f9,%rax
  800420128f:	00 00 00 
  8004201292:	ff d0                	callq  *%rax
	cga_putc(c);
  8004201294:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201297:	89 c7                	mov    %eax,%edi
  8004201299:	48 b8 98 0b 20 04 80 	movabs $0x8004200b98,%rax
  80042012a0:	00 00 00 
  80042012a3:	ff d0                	callq  *%rax
}
  80042012a5:	c9                   	leaveq 
  80042012a6:	c3                   	retq   

00000080042012a7 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042012a7:	55                   	push   %rbp
  80042012a8:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042012ab:	48 b8 7e 0a 20 04 80 	movabs $0x8004200a7e,%rax
  80042012b2:	00 00 00 
  80042012b5:	ff d0                	callq  *%rax
	kbd_init();
  80042012b7:	48 b8 f5 10 20 04 80 	movabs $0x80042010f5,%rax
  80042012be:	00 00 00 
  80042012c1:	ff d0                	callq  *%rax
	serial_init();
  80042012c3:	48 b8 f1 08 20 04 80 	movabs $0x80042008f1,%rax
  80042012ca:	00 00 00 
  80042012cd:	ff d0                	callq  *%rax

	if (!serial_exists)
  80042012cf:	48 b8 00 b0 57 04 80 	movabs $0x800457b000,%rax
  80042012d6:	00 00 00 
  80042012d9:	0f b6 00             	movzbl (%rax),%eax
  80042012dc:	83 f0 01             	xor    $0x1,%eax
  80042012df:	84 c0                	test   %al,%al
  80042012e1:	74 1b                	je     80042012fe <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  80042012e3:	48 bf 97 47 21 04 80 	movabs $0x8004214797,%rdi
  80042012ea:	00 00 00 
  80042012ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012f2:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042012f9:	00 00 00 
  80042012fc:	ff d2                	callq  *%rdx
}
  80042012fe:	5d                   	pop    %rbp
  80042012ff:	c3                   	retq   

0000008004201300 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  8004201300:	55                   	push   %rbp
  8004201301:	48 89 e5             	mov    %rsp,%rbp
  8004201304:	48 83 ec 10          	sub    $0x10,%rsp
  8004201308:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  800420130b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420130e:	89 c7                	mov    %eax,%edi
  8004201310:	48 b8 67 12 20 04 80 	movabs $0x8004201267,%rax
  8004201317:	00 00 00 
  800420131a:	ff d0                	callq  *%rax
}
  800420131c:	c9                   	leaveq 
  800420131d:	c3                   	retq   

000000800420131e <getchar>:

int
getchar(void)
{
  800420131e:	55                   	push   %rbp
  800420131f:	48 89 e5             	mov    %rsp,%rbp
  8004201322:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201326:	48 b8 b3 11 20 04 80 	movabs $0x80042011b3,%rax
  800420132d:	00 00 00 
  8004201330:	ff d0                	callq  *%rax
  8004201332:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201335:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201339:	74 eb                	je     8004201326 <getchar+0x8>
		/* do nothing */;
	return c;
  800420133b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420133e:	c9                   	leaveq 
  800420133f:	c3                   	retq   

0000008004201340 <iscons>:

int
iscons(int fdnum)
{
  8004201340:	55                   	push   %rbp
  8004201341:	48 89 e5             	mov    %rsp,%rbp
  8004201344:	48 83 ec 08          	sub    $0x8,%rsp
  8004201348:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  800420134b:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201350:	c9                   	leaveq 
  8004201351:	c3                   	retq   

0000008004201352 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  8004201352:	55                   	push   %rbp
  8004201353:	48 89 e5             	mov    %rsp,%rbp
  8004201356:	48 83 ec 30          	sub    $0x30,%rsp
  800420135a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420135d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201361:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201365:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420136c:	eb 6c                	jmp    80042013da <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  800420136e:	48 b9 c0 85 22 04 80 	movabs $0x80042285c0,%rcx
  8004201375:	00 00 00 
  8004201378:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420137b:	48 63 d0             	movslq %eax,%rdx
  800420137e:	48 89 d0             	mov    %rdx,%rax
  8004201381:	48 01 c0             	add    %rax,%rax
  8004201384:	48 01 d0             	add    %rdx,%rax
  8004201387:	48 c1 e0 03          	shl    $0x3,%rax
  800420138b:	48 01 c8             	add    %rcx,%rax
  800420138e:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004201392:	48 be c0 85 22 04 80 	movabs $0x80042285c0,%rsi
  8004201399:	00 00 00 
  800420139c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420139f:	48 63 d0             	movslq %eax,%rdx
  80042013a2:	48 89 d0             	mov    %rdx,%rax
  80042013a5:	48 01 c0             	add    %rax,%rax
  80042013a8:	48 01 d0             	add    %rdx,%rax
  80042013ab:	48 c1 e0 03          	shl    $0x3,%rax
  80042013af:	48 01 f0             	add    %rsi,%rax
  80042013b2:	48 8b 00             	mov    (%rax),%rax
  80042013b5:	48 89 ca             	mov    %rcx,%rdx
  80042013b8:	48 89 c6             	mov    %rax,%rsi
  80042013bb:	48 bf 45 48 21 04 80 	movabs $0x8004214845,%rdi
  80042013c2:	00 00 00 
  80042013c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013ca:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  80042013d1:	00 00 00 
  80042013d4:	ff d1                	callq  *%rcx
	for (i = 0; i < NCOMMANDS; i++)
  80042013d6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042013da:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042013dd:	83 f8 03             	cmp    $0x3,%eax
  80042013e0:	76 8c                	jbe    800420136e <mon_help+0x1c>
	return 0;
  80042013e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042013e7:	c9                   	leaveq 
  80042013e8:	c3                   	retq   

00000080042013e9 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  80042013e9:	55                   	push   %rbp
  80042013ea:	48 89 e5             	mov    %rsp,%rbp
  80042013ed:	48 83 ec 30          	sub    $0x30,%rsp
  80042013f1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042013f4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042013f8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042013fc:	48 bf 4e 48 21 04 80 	movabs $0x800421484e,%rdi
  8004201403:	00 00 00 
  8004201406:	b8 00 00 00 00       	mov    $0x0,%eax
  800420140b:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201412:	00 00 00 
  8004201415:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201417:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420141e:	00 00 00 
  8004201421:	48 bf 68 48 21 04 80 	movabs $0x8004214868,%rdi
  8004201428:	00 00 00 
  800420142b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201430:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201437:	00 00 00 
  800420143a:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420143c:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  8004201443:	00 00 00 
  8004201446:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  800420144d:	00 00 00 
  8004201450:	48 bf 90 48 21 04 80 	movabs $0x8004214890,%rdi
  8004201457:	00 00 00 
  800420145a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420145f:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  8004201466:	00 00 00 
  8004201469:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  800420146b:	48 ba 3d 46 21 00 00 	movabs $0x21463d,%rdx
  8004201472:	00 00 00 
  8004201475:	48 be 3d 46 21 04 80 	movabs $0x800421463d,%rsi
  800420147c:	00 00 00 
  800420147f:	48 bf b8 48 21 04 80 	movabs $0x80042148b8,%rdi
  8004201486:	00 00 00 
  8004201489:	b8 00 00 00 00       	mov    $0x0,%eax
  800420148e:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  8004201495:	00 00 00 
  8004201498:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  800420149a:	48 ba 18 a2 57 00 00 	movabs $0x57a218,%rdx
  80042014a1:	00 00 00 
  80042014a4:	48 be 18 a2 57 04 80 	movabs $0x800457a218,%rsi
  80042014ab:	00 00 00 
  80042014ae:	48 bf e0 48 21 04 80 	movabs $0x80042148e0,%rdi
  80042014b5:	00 00 00 
  80042014b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014bd:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  80042014c4:	00 00 00 
  80042014c7:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  80042014c9:	48 ba 10 f0 5b 00 00 	movabs $0x5bf010,%rdx
  80042014d0:	00 00 00 
  80042014d3:	48 be 10 f0 5b 04 80 	movabs $0x80045bf010,%rsi
  80042014da:	00 00 00 
  80042014dd:	48 bf 08 49 21 04 80 	movabs $0x8004214908,%rdi
  80042014e4:	00 00 00 
  80042014e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014ec:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  80042014f3:	00 00 00 
  80042014f6:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042014f8:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042014ff:	00 
  8004201500:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201507:	00 00 00 
  800420150a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420150e:	48 29 c2             	sub    %rax,%rdx
  8004201511:	48 b8 10 f0 5b 04 80 	movabs $0x80045bf010,%rax
  8004201518:	00 00 00 
  800420151b:	48 83 e8 01          	sub    $0x1,%rax
  800420151f:	48 01 d0             	add    %rdx,%rax
  8004201522:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201526:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420152a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420152f:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201533:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201537:	48 29 d0             	sub    %rdx,%rax
	cprintf("Kernel executable memory footprint: %dKB\n",
  800420153a:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201541:	48 85 c0             	test   %rax,%rax
  8004201544:	48 0f 48 c2          	cmovs  %rdx,%rax
  8004201548:	48 c1 f8 0a          	sar    $0xa,%rax
  800420154c:	48 89 c6             	mov    %rax,%rsi
  800420154f:	48 bf 30 49 21 04 80 	movabs $0x8004214930,%rdi
  8004201556:	00 00 00 
  8004201559:	b8 00 00 00 00       	mov    $0x0,%eax
  800420155e:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201565:	00 00 00 
  8004201568:	ff d2                	callq  *%rdx
	return 0;
  800420156a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420156f:	c9                   	leaveq 
  8004201570:	c3                   	retq   

0000008004201571 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201571:	55                   	push   %rbp
  8004201572:	48 89 e5             	mov    %rsp,%rbp
  8004201575:	48 81 ec 50 05 00 00 	sub    $0x550,%rsp
  800420157c:	89 bd cc fa ff ff    	mov    %edi,-0x534(%rbp)
  8004201582:	48 89 b5 c0 fa ff ff 	mov    %rsi,-0x540(%rbp)
  8004201589:	48 89 95 b8 fa ff ff 	mov    %rdx,-0x548(%rbp)
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004201590:	48 89 e8             	mov    %rbp,%rax
  8004201593:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	return rbp;
  8004201597:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
	uint64_t rip;
	uint64_t rsp;
	uint64_t offset;
	struct Ripdebuginfo info;

	rbp = (const uint64_t*)read_rbp();
  800420159b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	__asm __volatile("movq %%rsp,%0" : "=r" (esp));
  800420159f:	48 89 e0             	mov    %rsp,%rax
  80042015a2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	return esp;
  80042015a6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	rsp = read_rsp();
  80042015aa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if (tf) {
  80042015ae:	48 83 bd b8 fa ff ff 	cmpq   $0x0,-0x548(%rbp)
  80042015b5:	00 
  80042015b6:	74 21                	je     80042015d9 <mon_backtrace+0x68>
		rbp = (const uint64_t*)tf->tf_regs.reg_rbp;
  80042015b8:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  80042015bf:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042015c3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		rsp = tf->tf_rsp;
  80042015c7:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  80042015ce:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  80042015d5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	read_rip(rip);
  80042015d9:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042015e0 <mon_backtrace+0x6f>
  80042015e0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cprintf("Stack backtrace:\n");
  80042015e4:	48 bf 5a 49 21 04 80 	movabs $0x800421495a,%rdi
  80042015eb:	00 00 00 
  80042015ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015f3:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042015fa:	00 00 00 
  80042015fd:	ff d2                	callq  *%rdx
	while (rbp) {
  80042015ff:	e9 1f 03 00 00       	jmpq   8004201923 <mon_backtrace+0x3b2>
		// print this stack frame
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
  8004201604:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201608:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420160c:	48 89 c6             	mov    %rax,%rsi
  800420160f:	48 bf 6c 49 21 04 80 	movabs $0x800421496c,%rdi
  8004201616:	00 00 00 
  8004201619:	b8 00 00 00 00       	mov    $0x0,%eax
  800420161e:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  8004201625:	00 00 00 
  8004201628:	ff d1                	callq  *%rcx
		if (debuginfo_rip(rip, &info) >= 0){
  800420162a:	48 8d 95 d0 fa ff ff 	lea    -0x530(%rbp),%rdx
  8004201631:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201635:	48 89 d6             	mov    %rdx,%rsi
  8004201638:	48 89 c7             	mov    %rax,%rdi
  800420163b:	48 b8 88 b1 20 04 80 	movabs $0x800420b188,%rax
  8004201642:	00 00 00 
  8004201645:	ff d0                	callq  *%rax
  8004201647:	85 c0                	test   %eax,%eax
  8004201649:	0f 88 a2 02 00 00    	js     80042018f1 <mon_backtrace+0x380>
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
  800420164f:	48 8d 85 d0 fa ff ff 	lea    -0x530(%rbp),%rax
  8004201656:	48 05 a8 00 00 00    	add    $0xa8,%rax
  800420165c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line,
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);
  8004201660:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line,
  8004201667:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420166b:	48 89 d7             	mov    %rdx,%rdi
  800420166e:	48 29 c7             	sub    %rax,%rdi
  8004201671:	48 8b b5 e0 fa ff ff 	mov    -0x520(%rbp),%rsi
  8004201678:	8b 8d e8 fa ff ff    	mov    -0x518(%rbp),%ecx
  800420167e:	8b 95 d8 fa ff ff    	mov    -0x528(%rbp),%edx
  8004201684:	48 8b 85 d0 fa ff ff 	mov    -0x530(%rbp),%rax
  800420168b:	49 89 f9             	mov    %rdi,%r9
  800420168e:	49 89 f0             	mov    %rsi,%r8
  8004201691:	48 89 c6             	mov    %rax,%rsi
  8004201694:	48 bf 88 49 21 04 80 	movabs $0x8004214988,%rdi
  800420169b:	00 00 00 
  800420169e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016a3:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  80042016aa:	00 00 00 
  80042016ad:	41 ff d2             	callq  *%r10

			if (cfa_rule->dw_regnum == 6) { /* 6: rbp */
  80042016b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042016b4:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042016b8:	66 83 f8 06          	cmp    $0x6,%ax
  80042016bc:	75 15                	jne    80042016d3 <mon_backtrace+0x162>
				cfa = (uint64_t)rbp + cfa_rule->dw_offset;
  80042016be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042016c2:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042016c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042016ca:	48 01 d0             	add    %rdx,%rax
  80042016cd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042016d1:	eb 28                	jmp    80042016fb <mon_backtrace+0x18a>
			} else if (cfa_rule->dw_regnum == 7) { /* 7: rsp */
  80042016d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042016d7:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042016db:	66 83 f8 07          	cmp    $0x7,%ax
  80042016df:	75 15                	jne    80042016f6 <mon_backtrace+0x185>
				cfa = rsp + cfa_rule->dw_offset;
  80042016e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042016e5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042016e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042016ed:	48 01 d0             	add    %rdx,%rax
  80042016f0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042016f4:	eb 05                	jmp    80042016fb <mon_backtrace+0x18a>
			} else {
				goto unknown_cfa;
  80042016f6:	e9 f6 01 00 00       	jmpq   80042018f1 <mon_backtrace+0x380>
			}

			cprintf("  args:%d ", info.rip_fn_narg);
  80042016fb:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  8004201701:	89 c6                	mov    %eax,%esi
  8004201703:	48 bf a3 49 21 04 80 	movabs $0x80042149a3,%rdi
  800420170a:	00 00 00 
  800420170d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201712:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201719:	00 00 00 
  800420171c:	ff d2                	callq  *%rdx
			for (i = 0; i < info.rip_fn_narg ; i++)
  800420171e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201725:	e9 fa 00 00 00       	jmpq   8004201824 <mon_backtrace+0x2b3>
			{
				uint64_t val = 0;
  800420172a:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004201731:	00 
				assert(info.offset_fn_arg[i]);
  8004201732:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201735:	48 98                	cltq   
  8004201737:	48 83 c0 0a          	add    $0xa,%rax
  800420173b:	48 8b 84 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rax
  8004201742:	ff 
  8004201743:	48 85 c0             	test   %rax,%rax
  8004201746:	75 35                	jne    800420177d <mon_backtrace+0x20c>
  8004201748:	48 b9 ae 49 21 04 80 	movabs $0x80042149ae,%rcx
  800420174f:	00 00 00 
  8004201752:	48 ba c4 49 21 04 80 	movabs $0x80042149c4,%rdx
  8004201759:	00 00 00 
  800420175c:	be 6f 00 00 00       	mov    $0x6f,%esi
  8004201761:	48 bf d9 49 21 04 80 	movabs $0x80042149d9,%rdi
  8004201768:	00 00 00 
  800420176b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201770:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004201777:	00 00 00 
  800420177a:	41 ff d0             	callq  *%r8
				offset = cfa + info.offset_fn_arg[i];
  800420177d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201780:	48 98                	cltq   
  8004201782:	48 83 c0 0a          	add    $0xa,%rax
  8004201786:	48 8b 94 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rdx
  800420178d:	ff 
  800420178e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201792:	48 01 d0             	add    %rdx,%rax
  8004201795:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				switch(info.size_fn_arg[i]) {
  8004201799:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420179c:	48 98                	cltq   
  800420179e:	48 83 c0 08          	add    $0x8,%rax
  80042017a2:	8b 84 85 dc fa ff ff 	mov    -0x524(%rbp,%rax,4),%eax
  80042017a9:	83 f8 02             	cmp    $0x2,%eax
  80042017ac:	74 31                	je     80042017df <mon_backtrace+0x26e>
  80042017ae:	83 f8 02             	cmp    $0x2,%eax
  80042017b1:	7f 07                	jg     80042017ba <mon_backtrace+0x249>
  80042017b3:	83 f8 01             	cmp    $0x1,%eax
  80042017b6:	74 37                	je     80042017ef <mon_backtrace+0x27e>
  80042017b8:	eb 44                	jmp    80042017fe <mon_backtrace+0x28d>
  80042017ba:	83 f8 04             	cmp    $0x4,%eax
  80042017bd:	74 12                	je     80042017d1 <mon_backtrace+0x260>
  80042017bf:	83 f8 08             	cmp    $0x8,%eax
  80042017c2:	75 3a                	jne    80042017fe <mon_backtrace+0x28d>
					case 8:
						val = *(uint64_t *) offset;
  80042017c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042017c8:	48 8b 00             	mov    (%rax),%rax
  80042017cb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  80042017cf:	eb 2d                	jmp    80042017fe <mon_backtrace+0x28d>
					case 4:
						val = *(uint32_t *) offset;
  80042017d1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042017d5:	8b 00                	mov    (%rax),%eax
  80042017d7:	89 c0                	mov    %eax,%eax
  80042017d9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  80042017dd:	eb 1f                	jmp    80042017fe <mon_backtrace+0x28d>
					case 2:
						val = *(uint16_t *) offset;
  80042017df:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042017e3:	0f b7 00             	movzwl (%rax),%eax
  80042017e6:	0f b7 c0             	movzwl %ax,%eax
  80042017e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  80042017ed:	eb 0f                	jmp    80042017fe <mon_backtrace+0x28d>
					case 1:
						val = *(uint8_t *) offset;
  80042017ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042017f3:	0f b6 00             	movzbl (%rax),%eax
  80042017f6:	0f b6 c0             	movzbl %al,%eax
  80042017f9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  80042017fd:	90                   	nop
				}
				cprintf(" %016x", val);
  80042017fe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201802:	48 89 c6             	mov    %rax,%rsi
  8004201805:	48 bf e8 49 21 04 80 	movabs $0x80042149e8,%rdi
  800420180c:	00 00 00 
  800420180f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201814:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420181b:	00 00 00 
  800420181e:	ff d2                	callq  *%rdx
			for (i = 0; i < info.rip_fn_narg ; i++)
  8004201820:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201824:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  800420182a:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420182d:	0f 8f f7 fe ff ff    	jg     800420172a <mon_backtrace+0x1b9>
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
  8004201833:	0f b7 85 ea fb ff ff 	movzwl -0x416(%rbp),%eax
  800420183a:	0f b7 c0             	movzwl %ax,%eax
  800420183d:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  8004201842:	74 48                	je     800420188c <mon_backtrace+0x31b>
  8004201844:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  8004201849:	75 17                	jne    8004201862 <mon_backtrace+0x2f1>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rbp = (const uint64_t *)*(uint64_t *)(cfa + info.reg_table.rules[6].dw_offset);
  800420184b:	48 8b 95 f0 fb ff ff 	mov    -0x410(%rbp),%rdx
  8004201852:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201856:	48 01 d0             	add    %rdx,%rax
  8004201859:	48 8b 00             	mov    (%rax),%rax
  800420185c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					break;
  8004201860:	eb 2b                	jmp    800420188d <mon_backtrace+0x31c>
				default:
					panic("unknown reg rule");
  8004201862:	48 ba ef 49 21 04 80 	movabs $0x80042149ef,%rdx
  8004201869:	00 00 00 
  800420186c:	be 89 00 00 00       	mov    $0x89,%esi
  8004201871:	48 bf d9 49 21 04 80 	movabs $0x80042149d9,%rdi
  8004201878:	00 00 00 
  800420187b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201880:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004201887:	00 00 00 
  800420188a:	ff d1                	callq  *%rcx
					break;
  800420188c:	90                   	nop
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
  800420188d:	0f b7 85 8a fc ff ff 	movzwl -0x376(%rbp),%eax
  8004201894:	0f b7 c0             	movzwl %ax,%eax
  8004201897:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  800420189c:	74 48                	je     80042018e6 <mon_backtrace+0x375>
  800420189e:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  80042018a3:	75 17                	jne    80042018bc <mon_backtrace+0x34b>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rip = *(uint64_t *)(cfa + info.reg_table.rules[16].dw_offset);
  80042018a5:	48 8b 95 90 fc ff ff 	mov    -0x370(%rbp),%rdx
  80042018ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042018b0:	48 01 d0             	add    %rdx,%rax
  80042018b3:	48 8b 00             	mov    (%rax),%rax
  80042018b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					break;
  80042018ba:	eb 2b                	jmp    80042018e7 <mon_backtrace+0x376>
				default:
					panic("unknown reg rule");
  80042018bc:	48 ba ef 49 21 04 80 	movabs $0x80042149ef,%rdx
  80042018c3:	00 00 00 
  80042018c6:	be 94 00 00 00       	mov    $0x94,%esi
  80042018cb:	48 bf d9 49 21 04 80 	movabs $0x80042149d9,%rdi
  80042018d2:	00 00 00 
  80042018d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018da:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  80042018e1:	00 00 00 
  80042018e4:	ff d1                	callq  *%rcx
					break;
  80042018e6:	90                   	nop
					break;
			}

			rsp = cfa;
  80042018e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042018eb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042018ef:	eb 17                	jmp    8004201908 <mon_backtrace+0x397>
		} else {
unknown_cfa:
			// move to next lower stack frame
			rip = rbp[1];
  80042018f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042018f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042018f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			rbp = (const uint64_t*) rbp[0];
  80042018fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201901:	48 8b 00             	mov    (%rax),%rax
  8004201904:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		}
		cprintf("\n");
  8004201908:	48 bf 00 4a 21 04 80 	movabs $0x8004214a00,%rdi
  800420190f:	00 00 00 
  8004201912:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201917:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420191e:	00 00 00 
  8004201921:	ff d2                	callq  *%rdx
	while (rbp) {
  8004201923:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004201928:	0f 85 d6 fc ff ff    	jne    8004201604 <mon_backtrace+0x93>
	}
  return 0;
  800420192e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201933:	c9                   	leaveq 
  8004201934:	c3                   	retq   

0000008004201935 <mon_exit>:

int
mon_exit(int argc, char** argv, struct Trapframe* tf)
{
  8004201935:	55                   	push   %rbp
  8004201936:	48 89 e5             	mov    %rsp,%rbp
  8004201939:	48 83 ec 18          	sub    $0x18,%rsp
  800420193d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201940:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201944:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
#ifdef VMM_GUEST
	asm("hlt");
  8004201948:	f4                   	hlt    
#endif
	return -1;
  8004201949:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800420194e:	c9                   	leaveq 
  800420194f:	c3                   	retq   

0000008004201950 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201950:	55                   	push   %rbp
  8004201951:	48 89 e5             	mov    %rsp,%rbp
  8004201954:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  800420195b:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201962:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201969:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201970:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201973:	48 98                	cltq   
  8004201975:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  800420197c:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201981:	eb 15                	jmp    8004201998 <runcmd+0x48>
			*buf++ = 0;
  8004201983:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420198a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420198e:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201995:	c6 00 00             	movb   $0x0,(%rax)
		while (*buf && strchr(WHITESPACE, *buf))
  8004201998:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420199f:	0f b6 00             	movzbl (%rax),%eax
  80042019a2:	84 c0                	test   %al,%al
  80042019a4:	74 2a                	je     80042019d0 <runcmd+0x80>
  80042019a6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019ad:	0f b6 00             	movzbl (%rax),%eax
  80042019b0:	0f be c0             	movsbl %al,%eax
  80042019b3:	89 c6                	mov    %eax,%esi
  80042019b5:	48 bf 02 4a 21 04 80 	movabs $0x8004214a02,%rdi
  80042019bc:	00 00 00 
  80042019bf:	48 b8 75 c4 20 04 80 	movabs $0x800420c475,%rax
  80042019c6:	00 00 00 
  80042019c9:	ff d0                	callq  *%rax
  80042019cb:	48 85 c0             	test   %rax,%rax
  80042019ce:	75 b3                	jne    8004201983 <runcmd+0x33>
		if (*buf == 0)
  80042019d0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019d7:	0f b6 00             	movzbl (%rax),%eax
  80042019da:	84 c0                	test   %al,%al
  80042019dc:	75 21                	jne    80042019ff <runcmd+0xaf>
			break;
  80042019de:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042019df:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019e2:	48 98                	cltq   
  80042019e4:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019eb:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042019f0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019f4:	0f 85 a0 00 00 00    	jne    8004201a9a <runcmd+0x14a>
  80042019fa:	e9 91 00 00 00       	jmpq   8004201a90 <runcmd+0x140>
		if (argc == MAXARGS-1) {
  80042019ff:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004201a03:	75 2a                	jne    8004201a2f <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004201a05:	be 10 00 00 00       	mov    $0x10,%esi
  8004201a0a:	48 bf 07 4a 21 04 80 	movabs $0x8004214a07,%rdi
  8004201a11:	00 00 00 
  8004201a14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a19:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201a20:	00 00 00 
  8004201a23:	ff d2                	callq  *%rdx
			return 0;
  8004201a25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a2a:	e9 2f 01 00 00       	jmpq   8004201b5e <runcmd+0x20e>
		argv[argc++] = buf;
  8004201a2f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201a32:	8d 50 01             	lea    0x1(%rax),%edx
  8004201a35:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201a38:	48 98                	cltq   
  8004201a3a:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201a41:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201a48:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a49:	eb 08                	jmp    8004201a53 <runcmd+0x103>
			buf++;
  8004201a4b:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201a52:	01 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a53:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a5a:	0f b6 00             	movzbl (%rax),%eax
  8004201a5d:	84 c0                	test   %al,%al
  8004201a5f:	74 2a                	je     8004201a8b <runcmd+0x13b>
  8004201a61:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a68:	0f b6 00             	movzbl (%rax),%eax
  8004201a6b:	0f be c0             	movsbl %al,%eax
  8004201a6e:	89 c6                	mov    %eax,%esi
  8004201a70:	48 bf 02 4a 21 04 80 	movabs $0x8004214a02,%rdi
  8004201a77:	00 00 00 
  8004201a7a:	48 b8 75 c4 20 04 80 	movabs $0x800420c475,%rax
  8004201a81:	00 00 00 
  8004201a84:	ff d0                	callq  *%rax
  8004201a86:	48 85 c0             	test   %rax,%rax
  8004201a89:	74 c0                	je     8004201a4b <runcmd+0xfb>
	}
  8004201a8b:	e9 f1 fe ff ff       	jmpq   8004201981 <runcmd+0x31>
		return 0;
  8004201a90:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a95:	e9 c4 00 00 00       	jmpq   8004201b5e <runcmd+0x20e>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a9a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201aa1:	e9 82 00 00 00       	jmpq   8004201b28 <runcmd+0x1d8>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201aa6:	48 b9 c0 85 22 04 80 	movabs $0x80042285c0,%rcx
  8004201aad:	00 00 00 
  8004201ab0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201ab3:	48 63 d0             	movslq %eax,%rdx
  8004201ab6:	48 89 d0             	mov    %rdx,%rax
  8004201ab9:	48 01 c0             	add    %rax,%rax
  8004201abc:	48 01 d0             	add    %rdx,%rax
  8004201abf:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ac3:	48 01 c8             	add    %rcx,%rax
  8004201ac6:	48 8b 10             	mov    (%rax),%rdx
  8004201ac9:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201ad0:	48 89 d6             	mov    %rdx,%rsi
  8004201ad3:	48 89 c7             	mov    %rax,%rdi
  8004201ad6:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004201add:	00 00 00 
  8004201ae0:	ff d0                	callq  *%rax
  8004201ae2:	85 c0                	test   %eax,%eax
  8004201ae4:	75 3e                	jne    8004201b24 <runcmd+0x1d4>
			return commands[i].func(argc, argv, tf);
  8004201ae6:	48 b9 c0 85 22 04 80 	movabs $0x80042285c0,%rcx
  8004201aed:	00 00 00 
  8004201af0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201af3:	48 63 d0             	movslq %eax,%rdx
  8004201af6:	48 89 d0             	mov    %rdx,%rax
  8004201af9:	48 01 c0             	add    %rax,%rax
  8004201afc:	48 01 d0             	add    %rdx,%rax
  8004201aff:	48 c1 e0 03          	shl    $0x3,%rax
  8004201b03:	48 01 c8             	add    %rcx,%rax
  8004201b06:	48 83 c0 10          	add    $0x10,%rax
  8004201b0a:	48 8b 00             	mov    (%rax),%rax
  8004201b0d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201b14:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201b1b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201b1e:	89 cf                	mov    %ecx,%edi
  8004201b20:	ff d0                	callq  *%rax
  8004201b22:	eb 3a                	jmp    8004201b5e <runcmd+0x20e>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201b24:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201b28:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201b2b:	83 f8 03             	cmp    $0x3,%eax
  8004201b2e:	0f 86 72 ff ff ff    	jbe    8004201aa6 <runcmd+0x156>
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201b34:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b3b:	48 89 c6             	mov    %rax,%rsi
  8004201b3e:	48 bf 24 4a 21 04 80 	movabs $0x8004214a24,%rdi
  8004201b45:	00 00 00 
  8004201b48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b4d:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201b54:	00 00 00 
  8004201b57:	ff d2                	callq  *%rdx
	return 0;
  8004201b59:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201b5e:	c9                   	leaveq 
  8004201b5f:	c3                   	retq   

0000008004201b60 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201b60:	55                   	push   %rbp
  8004201b61:	48 89 e5             	mov    %rsp,%rbp
  8004201b64:	48 83 ec 20          	sub    $0x20,%rsp
  8004201b68:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201b6c:	48 bf 40 4a 21 04 80 	movabs $0x8004214a40,%rdi
  8004201b73:	00 00 00 
  8004201b76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b7b:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201b82:	00 00 00 
  8004201b85:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201b87:	48 bf 68 4a 21 04 80 	movabs $0x8004214a68,%rdi
  8004201b8e:	00 00 00 
  8004201b91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b96:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201b9d:	00 00 00 
  8004201ba0:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201ba2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201ba7:	74 13                	je     8004201bbc <monitor+0x5c>
		print_trapframe(tf);
  8004201ba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201bad:	48 89 c7             	mov    %rax,%rdi
  8004201bb0:	48 b8 42 99 20 04 80 	movabs $0x8004209942,%rax
  8004201bb7:	00 00 00 
  8004201bba:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201bbc:	48 bf 8d 4a 21 04 80 	movabs $0x8004214a8d,%rdi
  8004201bc3:	00 00 00 
  8004201bc6:	48 b8 8e c0 20 04 80 	movabs $0x800420c08e,%rax
  8004201bcd:	00 00 00 
  8004201bd0:	ff d0                	callq  *%rax
  8004201bd2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201bd6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201bdb:	74 20                	je     8004201bfd <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201bdd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201be1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201be5:	48 89 d6             	mov    %rdx,%rsi
  8004201be8:	48 89 c7             	mov    %rax,%rdi
  8004201beb:	48 b8 50 19 20 04 80 	movabs $0x8004201950,%rax
  8004201bf2:	00 00 00 
  8004201bf5:	ff d0                	callq  *%rax
  8004201bf7:	85 c0                	test   %eax,%eax
  8004201bf9:	79 02                	jns    8004201bfd <monitor+0x9d>
				break;
  8004201bfb:	eb 02                	jmp    8004201bff <monitor+0x9f>
	}
  8004201bfd:	eb bd                	jmp    8004201bbc <monitor+0x5c>
}
  8004201bff:	c9                   	leaveq 
  8004201c00:	c3                   	retq   

0000008004201c01 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201c01:	55                   	push   %rbp
  8004201c02:	48 89 e5             	mov    %rsp,%rbp
  8004201c05:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c09:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201c0d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c11:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004201c18:	00 00 00 
  8004201c1b:	48 8b 00             	mov    (%rax),%rax
  8004201c1e:	48 29 c2             	sub    %rax,%rdx
  8004201c21:	48 89 d0             	mov    %rdx,%rax
  8004201c24:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201c28:	c9                   	leaveq 
  8004201c29:	c3                   	retq   

0000008004201c2a <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201c2a:	55                   	push   %rbp
  8004201c2b:	48 89 e5             	mov    %rsp,%rbp
  8004201c2e:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c32:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201c36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c3a:	48 89 c7             	mov    %rax,%rdi
  8004201c3d:	48 b8 01 1c 20 04 80 	movabs $0x8004201c01,%rax
  8004201c44:	00 00 00 
  8004201c47:	ff d0                	callq  *%rax
  8004201c49:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201c4d:	c9                   	leaveq 
  8004201c4e:	c3                   	retq   

0000008004201c4f <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201c4f:	55                   	push   %rbp
  8004201c50:	48 89 e5             	mov    %rsp,%rbp
  8004201c53:	48 83 ec 10          	sub    $0x10,%rsp
  8004201c57:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201c5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c5f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c63:	48 89 c2             	mov    %rax,%rdx
  8004201c66:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004201c6d:	00 00 00 
  8004201c70:	48 8b 00             	mov    (%rax),%rax
  8004201c73:	48 39 c2             	cmp    %rax,%rdx
  8004201c76:	72 2a                	jb     8004201ca2 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201c78:	48 ba 98 4a 21 04 80 	movabs $0x8004214a98,%rdx
  8004201c7f:	00 00 00 
  8004201c82:	be 54 00 00 00       	mov    $0x54,%esi
  8004201c87:	48 bf b7 4a 21 04 80 	movabs $0x8004214ab7,%rdi
  8004201c8e:	00 00 00 
  8004201c91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c96:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004201c9d:	00 00 00 
  8004201ca0:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201ca2:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004201ca9:	00 00 00 
  8004201cac:	48 8b 00             	mov    (%rax),%rax
  8004201caf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201cb3:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201cb7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201cbb:	48 01 d0             	add    %rdx,%rax
}
  8004201cbe:	c9                   	leaveq 
  8004201cbf:	c3                   	retq   

0000008004201cc0 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201cc0:	55                   	push   %rbp
  8004201cc1:	48 89 e5             	mov    %rsp,%rbp
  8004201cc4:	48 83 ec 20          	sub    $0x20,%rsp
  8004201cc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201ccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201cd0:	48 89 c7             	mov    %rax,%rdi
  8004201cd3:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004201cda:	00 00 00 
  8004201cdd:	ff d0                	callq  *%rax
  8004201cdf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201ce3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201ce7:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201ceb:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201cee:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201cf1:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004201cf8:	00 00 00 
  8004201cfb:	48 8b 00             	mov    (%rax),%rax
  8004201cfe:	48 39 c2             	cmp    %rax,%rdx
  8004201d01:	72 32                	jb     8004201d35 <page2kva+0x75>
  8004201d03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d07:	48 89 c1             	mov    %rax,%rcx
  8004201d0a:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004201d11:	00 00 00 
  8004201d14:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201d19:	48 bf b7 4a 21 04 80 	movabs $0x8004214ab7,%rdi
  8004201d20:	00 00 00 
  8004201d23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d28:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004201d2f:	00 00 00 
  8004201d32:	41 ff d0             	callq  *%r8
  8004201d35:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201d3c:	00 00 00 
  8004201d3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d43:	48 01 d0             	add    %rdx,%rax
}
  8004201d46:	c9                   	leaveq 
  8004201d47:	c3                   	retq   

0000008004201d48 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201d48:	55                   	push   %rbp
  8004201d49:	48 89 e5             	mov    %rsp,%rbp
  8004201d4c:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d50:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201d53:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201d56:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201d5a:	74 06                	je     8004201d62 <restrictive_type+0x1a>
  8004201d5c:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201d60:	75 07                	jne    8004201d69 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201d62:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201d67:	eb 3e                	jmp    8004201da7 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201d69:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201d6d:	74 06                	je     8004201d75 <restrictive_type+0x2d>
  8004201d6f:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201d73:	75 07                	jne    8004201d7c <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201d75:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201d7a:	eb 2b                	jmp    8004201da7 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201d7c:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201d80:	74 06                	je     8004201d88 <restrictive_type+0x40>
  8004201d82:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201d86:	75 07                	jne    8004201d8f <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201d88:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201d8d:	eb 18                	jmp    8004201da7 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201d8f:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201d93:	74 06                	je     8004201d9b <restrictive_type+0x53>
  8004201d95:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201d99:	75 07                	jne    8004201da2 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201d9b:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201da0:	eb 05                	jmp    8004201da7 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201da2:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201da7:	c9                   	leaveq 
  8004201da8:	c3                   	retq   

0000008004201da9 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201da9:	55                   	push   %rbp
  8004201daa:	48 89 e5             	mov    %rsp,%rbp
  8004201dad:	53                   	push   %rbx
  8004201dae:	48 83 ec 18          	sub    $0x18,%rsp
  8004201db2:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201db5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201db8:	89 c7                	mov    %eax,%edi
  8004201dba:	48 b8 ce 91 20 04 80 	movabs $0x80042091ce,%rax
  8004201dc1:	00 00 00 
  8004201dc4:	ff d0                	callq  *%rax
  8004201dc6:	89 c3                	mov    %eax,%ebx
  8004201dc8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201dcb:	83 c0 01             	add    $0x1,%eax
  8004201dce:	89 c7                	mov    %eax,%edi
  8004201dd0:	48 b8 ce 91 20 04 80 	movabs $0x80042091ce,%rax
  8004201dd7:	00 00 00 
  8004201dda:	ff d0                	callq  *%rax
  8004201ddc:	c1 e0 08             	shl    $0x8,%eax
  8004201ddf:	09 d8                	or     %ebx,%eax
}
  8004201de1:	48 83 c4 18          	add    $0x18,%rsp
  8004201de5:	5b                   	pop    %rbx
  8004201de6:	5d                   	pop    %rbp
  8004201de7:	c3                   	retq   

0000008004201de8 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201de8:	55                   	push   %rbp
  8004201de9:	48 89 e5             	mov    %rsp,%rbp
  8004201dec:	53                   	push   %rbx
  8004201ded:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
  8004201df4:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201dfb:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201e02:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201e09:	48 89 e0             	mov    %rsp,%rax
  8004201e0c:	48 89 c3             	mov    %rax,%rbx
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201e0f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e16:	8b 40 30             	mov    0x30(%rax),%eax
  8004201e19:	89 c0                	mov    %eax,%eax
  8004201e1b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201e1f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e26:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201e29:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201e2e:	f7 e2                	mul    %edx
  8004201e30:	89 d0                	mov    %edx,%eax
  8004201e32:	c1 e8 04             	shr    $0x4,%eax
  8004201e35:	89 c0                	mov    %eax,%eax
  8004201e37:	48 89 c2             	mov    %rax,%rdx
  8004201e3a:	48 83 ea 01          	sub    $0x1,%rdx
  8004201e3e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201e42:	49 89 c2             	mov    %rax,%r10
  8004201e45:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  8004201e4b:	49 89 c0             	mov    %rax,%r8
  8004201e4e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201e54:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e58:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201e5c:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201e61:	48 83 e8 01          	sub    $0x1,%rax
  8004201e65:	48 01 d0             	add    %rdx,%rax
  8004201e68:	be 10 00 00 00       	mov    $0x10,%esi
  8004201e6d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e72:	48 f7 f6             	div    %rsi
  8004201e75:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201e79:	48 29 c4             	sub    %rax,%rsp
  8004201e7c:	48 89 e0             	mov    %rsp,%rax
  8004201e7f:	48 83 c0 07          	add    $0x7,%rax
  8004201e83:	48 c1 e8 03          	shr    $0x3,%rax
  8004201e87:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e8b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201e8f:	48 bf eb 4a 21 04 80 	movabs $0x8004214aeb,%rdi
  8004201e96:	00 00 00 
  8004201e99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e9e:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004201ea5:	00 00 00 
  8004201ea8:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201eaa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201eb1:	e9 6c 01 00 00       	jmpq   8004202022 <multiboot_read+0x23a>
		memory_map_t* mmap = &mmap_base[i];
  8004201eb6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201eb9:	48 63 d0             	movslq %eax,%rdx
  8004201ebc:	48 89 d0             	mov    %rdx,%rax
  8004201ebf:	48 01 c0             	add    %rax,%rax
  8004201ec2:	48 01 d0             	add    %rdx,%rax
  8004201ec5:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ec9:	48 89 c2             	mov    %rax,%rdx
  8004201ecc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201ed0:	48 01 d0             	add    %rdx,%rax
  8004201ed3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201ed7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201edb:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ede:	89 c0                	mov    %eax,%eax
  8004201ee0:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ee4:	48 89 c2             	mov    %rax,%rdx
  8004201ee7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eeb:	8b 40 04             	mov    0x4(%rax),%eax
  8004201eee:	89 c0                	mov    %eax,%eax
  8004201ef0:	48 01 d0             	add    %rdx,%rax
  8004201ef3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201ef7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201efb:	8b 40 10             	mov    0x10(%rax),%eax
  8004201efe:	89 c0                	mov    %eax,%eax
  8004201f00:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f04:	48 89 c2             	mov    %rax,%rdx
  8004201f07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f0b:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201f0e:	89 c0                	mov    %eax,%eax
  8004201f10:	48 01 d0             	add    %rdx,%rax
  8004201f13:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size,
  8004201f17:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f1b:	8b 70 14             	mov    0x14(%rax),%esi
  8004201f1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f22:	8b 00                	mov    (%rax),%eax
  8004201f24:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201f28:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201f2c:	41 89 f0             	mov    %esi,%r8d
  8004201f2f:	89 c6                	mov    %eax,%esi
  8004201f31:	48 bf 00 4b 21 04 80 	movabs $0x8004214b00,%rdi
  8004201f38:	00 00 00 
  8004201f3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f40:	49 b9 4a 95 20 04 80 	movabs $0x800420954a,%r9
  8004201f47:	00 00 00 
  8004201f4a:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201f4d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f51:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f54:	83 f8 05             	cmp    $0x5,%eax
  8004201f57:	77 0b                	ja     8004201f64 <multiboot_read+0x17c>
  8004201f59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f5d:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f60:	85 c0                	test   %eax,%eax
  8004201f62:	75 0b                	jne    8004201f6f <multiboot_read+0x187>
			mmap->type = MB_TYPE_RESERVED;
  8004201f64:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f68:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		//Insert into the sorted list
		int j = 0;
  8004201f6f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201f76:	e9 85 00 00 00       	jmpq   8004202000 <multiboot_read+0x218>
			memory_map_t* this = mmap_list[j];
  8004201f7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f7f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f82:	48 63 d2             	movslq %edx,%rdx
  8004201f85:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f89:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201f8d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f91:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f94:	89 c0                	mov    %eax,%eax
  8004201f96:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f9a:	48 89 c2             	mov    %rax,%rdx
  8004201f9d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201fa1:	8b 40 04             	mov    0x4(%rax),%eax
  8004201fa4:	89 c0                	mov    %eax,%eax
  8004201fa6:	48 01 d0             	add    %rdx,%rax
  8004201fa9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201fad:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201fb1:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201fb5:	76 45                	jbe    8004201ffc <multiboot_read+0x214>
				int last = i+1;
  8004201fb7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201fba:	83 c0 01             	add    $0x1,%eax
  8004201fbd:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201fc0:	eb 30                	jmp    8004201ff2 <multiboot_read+0x20a>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201fc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fc6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201fc9:	48 63 d2             	movslq %edx,%rdx
  8004201fcc:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201fd0:	48 01 c2             	add    %rax,%rdx
  8004201fd3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fd7:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201fda:	48 63 c9             	movslq %ecx,%rcx
  8004201fdd:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201fe1:	48 83 e9 08          	sub    $0x8,%rcx
  8004201fe5:	48 01 c8             	add    %rcx,%rax
  8004201fe8:	48 8b 00             	mov    (%rax),%rax
  8004201feb:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201fee:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
				while(last != j) {
  8004201ff2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201ff5:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201ff8:	75 c8                	jne    8004201fc2 <multiboot_read+0x1da>
				}
				break;
  8004201ffa:	eb 10                	jmp    800420200c <multiboot_read+0x224>
		for(;j<i;j++) {
  8004201ffc:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004202000:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004202003:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004202006:	0f 8c 6f ff ff ff    	jl     8004201f7b <multiboot_read+0x193>
			}
		}
		mmap_list[j] = mmap;
  800420200c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202010:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004202013:	48 63 d2             	movslq %edx,%rdx
  8004202016:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420201a:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420201e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202022:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202025:	48 63 c8             	movslq %eax,%rcx
  8004202028:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420202f:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202032:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202037:	f7 e2                	mul    %edx
  8004202039:	89 d0                	mov    %edx,%eax
  800420203b:	c1 e8 04             	shr    $0x4,%eax
  800420203e:	89 c0                	mov    %eax,%eax
  8004202040:	48 39 c1             	cmp    %rax,%rcx
  8004202043:	0f 82 6d fe ff ff    	jb     8004201eb6 <multiboot_read+0xce>
	}
	cprintf("\n");
  8004202049:	48 bf 37 4b 21 04 80 	movabs $0x8004214b37,%rdi
  8004202050:	00 00 00 
  8004202053:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202058:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420205f:	00 00 00 
  8004202062:	ff d2                	callq  *%rdx

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202064:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  800420206b:	e9 93 01 00 00       	jmpq   8004202203 <multiboot_read+0x41b>
		memory_map_t* prev = mmap_list[i-1];
  8004202070:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202073:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202076:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420207a:	48 63 d2             	movslq %edx,%rdx
  800420207d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202081:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202085:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202089:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420208c:	48 63 d2             	movslq %edx,%rdx
  800420208f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202093:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202097:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420209b:	8b 40 08             	mov    0x8(%rax),%eax
  800420209e:	89 c0                	mov    %eax,%eax
  80042020a0:	48 c1 e0 20          	shl    $0x20,%rax
  80042020a4:	48 89 c2             	mov    %rax,%rdx
  80042020a7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020ab:	8b 40 04             	mov    0x4(%rax),%eax
  80042020ae:	89 c0                	mov    %eax,%eax
  80042020b0:	48 01 d0             	add    %rdx,%rax
  80042020b3:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  80042020b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020bb:	8b 40 08             	mov    0x8(%rax),%eax
  80042020be:	89 c0                	mov    %eax,%eax
  80042020c0:	48 c1 e0 20          	shl    $0x20,%rax
  80042020c4:	48 89 c2             	mov    %rax,%rdx
  80042020c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020cb:	8b 40 04             	mov    0x4(%rax),%eax
  80042020ce:	89 c0                	mov    %eax,%eax
  80042020d0:	48 01 d0             	add    %rdx,%rax
  80042020d3:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042020d7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020db:	8b 40 10             	mov    0x10(%rax),%eax
  80042020de:	89 c0                	mov    %eax,%eax
  80042020e0:	48 c1 e0 20          	shl    $0x20,%rax
  80042020e4:	48 89 c2             	mov    %rax,%rdx
  80042020e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020eb:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020ee:	89 c0                	mov    %eax,%eax
  80042020f0:	48 01 d0             	add    %rdx,%rax
  80042020f3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042020fa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020fe:	8b 40 10             	mov    0x10(%rax),%eax
  8004202101:	89 c0                	mov    %eax,%eax
  8004202103:	48 c1 e0 20          	shl    $0x20,%rax
  8004202107:	48 89 c2             	mov    %rax,%rdx
  800420210a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420210e:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202111:	89 c0                	mov    %eax,%eax
  8004202113:	48 01 d0             	add    %rdx,%rax
  8004202116:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  800420211d:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202121:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202128:	48 01 d0             	add    %rdx,%rax
  800420212b:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420212f:	75 7c                	jne    80042021ad <multiboot_read+0x3c5>
  8004202131:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202135:	8b 50 14             	mov    0x14(%rax),%edx
  8004202138:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420213c:	8b 40 14             	mov    0x14(%rax),%eax
  800420213f:	39 c2                	cmp    %eax,%edx
  8004202141:	75 6a                	jne    80042021ad <multiboot_read+0x3c5>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202143:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420214a:	89 c2                	mov    %eax,%edx
  800420214c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202153:	01 c2                	add    %eax,%edx
  8004202155:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202159:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  800420215c:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202163:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420216a:	48 01 d0             	add    %rdx,%rax
  800420216d:	48 c1 e8 20          	shr    $0x20,%rax
  8004202171:	89 c2                	mov    %eax,%edx
  8004202173:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202177:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  800420217a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420217e:	8b 50 04             	mov    0x4(%rax),%edx
  8004202181:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202185:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004202188:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420218c:	8b 50 08             	mov    0x8(%rax),%edx
  800420218f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202193:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202196:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202199:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420219c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042021a0:	48 63 d2             	movslq %edx,%rdx
  80042021a3:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80042021aa:	00 
  80042021ab:	eb 52                	jmp    80042021ff <multiboot_read+0x417>
		} else if(prev_addr + prev_length > this_addr) {
  80042021ad:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042021b1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042021b8:	48 01 d0             	add    %rdx,%rax
  80042021bb:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042021bf:	76 3e                	jbe    80042021ff <multiboot_read+0x417>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  80042021c1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021c5:	8b 50 14             	mov    0x14(%rax),%edx
  80042021c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021cc:	8b 40 14             	mov    0x14(%rax),%eax
  80042021cf:	89 d6                	mov    %edx,%esi
  80042021d1:	89 c7                	mov    %eax,%edi
  80042021d3:	48 b8 48 1d 20 04 80 	movabs $0x8004201d48,%rax
  80042021da:	00 00 00 
  80042021dd:	ff d0                	callq  *%rax
  80042021df:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042021e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021e9:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021ef:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042021f2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021f6:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021fc:	89 50 14             	mov    %edx,0x14(%rax)
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021ff:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202203:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202206:	48 63 c8             	movslq %eax,%rcx
  8004202209:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202210:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202213:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202218:	f7 e2                	mul    %edx
  800420221a:	89 d0                	mov    %edx,%eax
  800420221c:	c1 e8 04             	shr    $0x4,%eax
  800420221f:	89 c0                	mov    %eax,%eax
  8004202221:	48 39 c1             	cmp    %rax,%rcx
  8004202224:	0f 82 46 fe ff ff    	jb     8004202070 <multiboot_read+0x288>
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420222a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202231:	e9 dc 00 00 00       	jmpq   8004202312 <multiboot_read+0x52a>
		memory_map_t* mmap = mmap_list[i];
  8004202236:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420223a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420223d:	48 63 d2             	movslq %edx,%rdx
  8004202240:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202244:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  800420224b:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202252:	00 
  8004202253:	0f 84 b5 00 00 00    	je     800420230e <multiboot_read+0x526>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202259:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202260:	8b 40 14             	mov    0x14(%rax),%eax
  8004202263:	83 f8 01             	cmp    $0x1,%eax
  8004202266:	74 13                	je     800420227b <multiboot_read+0x493>
  8004202268:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420226f:	8b 40 14             	mov    0x14(%rax),%eax
  8004202272:	83 f8 03             	cmp    $0x3,%eax
  8004202275:	0f 85 93 00 00 00    	jne    800420230e <multiboot_read+0x526>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  800420227b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202282:	8b 40 04             	mov    0x4(%rax),%eax
  8004202285:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  800420228a:	77 49                	ja     80042022d5 <multiboot_read+0x4ed>
  800420228c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202293:	8b 40 08             	mov    0x8(%rax),%eax
  8004202296:	85 c0                	test   %eax,%eax
  8004202298:	75 3b                	jne    80042022d5 <multiboot_read+0x4ed>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  800420229a:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042022a1:	48 8b 10             	mov    (%rax),%rdx
  80042022a4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022ab:	8b 40 10             	mov    0x10(%rax),%eax
  80042022ae:	89 c0                	mov    %eax,%eax
  80042022b0:	48 c1 e0 20          	shl    $0x20,%rax
  80042022b4:	48 89 c1             	mov    %rax,%rcx
  80042022b7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022be:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022c1:	89 c0                	mov    %eax,%eax
  80042022c3:	48 01 c8             	add    %rcx,%rax
  80042022c6:	48 01 c2             	add    %rax,%rdx
  80042022c9:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042022d0:	48 89 10             	mov    %rdx,(%rax)
  80042022d3:	eb 39                	jmp    800420230e <multiboot_read+0x526>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042022d5:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022dc:	48 8b 10             	mov    (%rax),%rdx
  80042022df:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022e6:	8b 40 10             	mov    0x10(%rax),%eax
  80042022e9:	89 c0                	mov    %eax,%eax
  80042022eb:	48 c1 e0 20          	shl    $0x20,%rax
  80042022ef:	48 89 c1             	mov    %rax,%rcx
  80042022f2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022f9:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022fc:	89 c0                	mov    %eax,%eax
  80042022fe:	48 01 c8             	add    %rcx,%rax
  8004202301:	48 01 c2             	add    %rax,%rdx
  8004202304:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420230b:	48 89 10             	mov    %rdx,(%rax)
	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420230e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202312:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202315:	48 63 c8             	movslq %eax,%rcx
  8004202318:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420231f:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202322:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202327:	f7 e2                	mul    %edx
  8004202329:	89 d0                	mov    %edx,%eax
  800420232b:	c1 e8 04             	shr    $0x4,%eax
  800420232e:	89 c0                	mov    %eax,%eax
  8004202330:	48 39 c1             	cmp    %rax,%rcx
  8004202333:	0f 82 fd fe ff ff    	jb     8004202236 <multiboot_read+0x44e>
  8004202339:	48 89 dc             	mov    %rbx,%rsp
			}
		}
	}
}
  800420233c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8004202340:	c9                   	leaveq 
  8004202341:	c3                   	retq   

0000008004202342 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202342:	55                   	push   %rbp
  8004202343:	48 89 e5             	mov    %rsp,%rbp
  8004202346:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  800420234a:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202351:	00 
	size_t extmem = 0;
  8004202352:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202359:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  800420235a:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202361:	00 00 00 
  8004202364:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202368:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420236c:	48 8b 00             	mov    (%rax),%rax
  800420236f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202373:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202378:	74 2d                	je     80042023a7 <i386_detect_memory+0x65>
  800420237a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420237e:	8b 00                	mov    (%rax),%eax
  8004202380:	83 e0 40             	and    $0x40,%eax
  8004202383:	85 c0                	test   %eax,%eax
  8004202385:	74 20                	je     80042023a7 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202387:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800420238b:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  800420238f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202393:	48 89 ce             	mov    %rcx,%rsi
  8004202396:	48 89 c7             	mov    %rax,%rdi
  8004202399:	48 b8 e8 1d 20 04 80 	movabs $0x8004201de8,%rax
  80042023a0:	00 00 00 
  80042023a3:	ff d0                	callq  *%rax
  80042023a5:	eb 34                	jmp    80042023db <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  80042023a7:	bf 15 00 00 00       	mov    $0x15,%edi
  80042023ac:	48 b8 a9 1d 20 04 80 	movabs $0x8004201da9,%rax
  80042023b3:	00 00 00 
  80042023b6:	ff d0                	callq  *%rax
  80042023b8:	c1 e0 0a             	shl    $0xa,%eax
  80042023bb:	48 98                	cltq   
  80042023bd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042023c1:	bf 17 00 00 00       	mov    $0x17,%edi
  80042023c6:	48 b8 a9 1d 20 04 80 	movabs $0x8004201da9,%rax
  80042023cd:	00 00 00 
  80042023d0:	ff d0                	callq  *%rax
  80042023d2:	c1 e0 0a             	shl    $0xa,%eax
  80042023d5:	48 98                	cltq   
  80042023d7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  80042023db:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023df:	48 85 c0             	test   %rax,%rax
  80042023e2:	75 35                	jne    8004202419 <i386_detect_memory+0xd7>
  80042023e4:	48 b9 39 4b 21 04 80 	movabs $0x8004214b39,%rcx
  80042023eb:	00 00 00 
  80042023ee:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042023f5:	00 00 00 
  80042023f8:	be 86 00 00 00       	mov    $0x86,%esi
  80042023fd:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202404:	00 00 00 
  8004202407:	b8 00 00 00 00       	mov    $0x0,%eax
  800420240c:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202413:	00 00 00 
  8004202416:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202419:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420241d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202421:	48 89 c2             	mov    %rax,%rdx
  8004202424:	48 b8 50 b2 57 04 80 	movabs $0x800457b250,%rax
  800420242b:	00 00 00 
  800420242e:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202431:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202435:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202439:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420243d:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202442:	48 b8 a9 1d 20 04 80 	movabs $0x8004201da9,%rax
  8004202449:	00 00 00 
  800420244c:	ff d0                	callq  *%rax
  800420244e:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202453:	75 2c                	jne    8004202481 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202455:	bf 34 00 00 00       	mov    $0x34,%edi
  800420245a:	48 b8 a9 1d 20 04 80 	movabs $0x8004201da9,%rax
  8004202461:	00 00 00 
  8004202464:	ff d0                	callq  *%rax
  8004202466:	c1 e0 10             	shl    $0x10,%eax
  8004202469:	48 98                	cltq   
  800420246b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  800420246f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202473:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202479:	48 c1 e8 0c          	shr    $0xc,%rax
  800420247d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202481:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202486:	74 1a                	je     80042024a2 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202488:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420248c:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202493:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420249a:	00 00 00 
  800420249d:	48 89 10             	mov    %rdx,(%rax)
  80042024a0:	eb 1a                	jmp    80042024bc <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  80042024a2:	48 b8 50 b2 57 04 80 	movabs $0x800457b250,%rax
  80042024a9:	00 00 00 
  80042024ac:	48 8b 10             	mov    (%rax),%rdx
  80042024af:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042024b6:	00 00 00 
  80042024b9:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024bc:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042024c3:	00 00 00 
  80042024c6:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042024c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024cd:	48 c1 e0 0c          	shl    $0xc,%rax
	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024d1:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024d5:	48 89 c1             	mov    %rax,%rcx
		npages_basemem * PGSIZE / 1024,
  80042024d8:	48 b8 50 b2 57 04 80 	movabs $0x800457b250,%rax
  80042024df:	00 00 00 
  80042024e2:	48 8b 00             	mov    (%rax),%rax
  80042024e5:	48 c1 e0 0c          	shl    $0xc,%rax
	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024e9:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024ed:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042024f0:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042024f7:	00 00 00 
  80042024fa:	48 8b 00             	mov    (%rax),%rax
  80042024fd:	48 c1 e0 0c          	shl    $0xc,%rax
	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202501:	48 c1 e8 14          	shr    $0x14,%rax
  8004202505:	49 89 f0             	mov    %rsi,%r8
  8004202508:	48 89 c6             	mov    %rax,%rsi
  800420250b:	48 bf 68 4b 21 04 80 	movabs $0x8004214b68,%rdi
  8004202512:	00 00 00 
  8004202515:	b8 00 00 00 00       	mov    $0x0,%eax
  800420251a:	49 b9 4a 95 20 04 80 	movabs $0x800420954a,%r9
  8004202521:	00 00 00 
  8004202524:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202527:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420252e:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420252f:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202536:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202537:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420253b:	48 c1 e0 0c          	shl    $0xc,%rax
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  800420253f:	48 c1 e8 14          	shr    $0x14,%rax
  8004202543:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202546:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420254a:	48 c1 e0 0c          	shl    $0xc,%rax
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  800420254e:	48 c1 e8 14          	shr    $0x14,%rax
  8004202552:	48 89 c6             	mov    %rax,%rsi
  8004202555:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202559:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420255d:	49 89 c8             	mov    %rcx,%r8
  8004202560:	48 89 d1             	mov    %rdx,%rcx
  8004202563:	48 89 f2             	mov    %rsi,%rdx
  8004202566:	48 89 c6             	mov    %rax,%rsi
  8004202569:	48 bf b8 4b 21 04 80 	movabs $0x8004214bb8,%rdi
  8004202570:	00 00 00 
  8004202573:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202578:	49 b9 4a 95 20 04 80 	movabs $0x800420954a,%r9
  800420257f:	00 00 00 
  8004202582:	41 ff d1             	callq  *%r9
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202585:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202589:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420258d:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202592:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202596:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420259d:	00 00 00 
  80042025a0:	48 8b 00             	mov    (%rax),%rax
  80042025a3:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042025a7:	76 3a                	jbe    80042025e3 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  80042025a9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042025ad:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042025b4:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042025bb:	00 00 00 
  80042025be:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042025c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042025c5:	48 89 c6             	mov    %rax,%rsi
  80042025c8:	48 bf 20 4c 21 04 80 	movabs $0x8004214c20,%rdi
  80042025cf:	00 00 00 
  80042025d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025d7:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042025de:	00 00 00 
  80042025e1:	ff d2                	callq  *%rdx
	}
}
  80042025e3:	c9                   	leaveq 
  80042025e4:	c3                   	retq   

00000080042025e5 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042025e5:	55                   	push   %rbp
  80042025e6:	48 89 e5             	mov    %rsp,%rbp
  80042025e9:	48 83 ec 40          	sub    $0x40,%rsp
  80042025ed:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042025f0:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  80042025f7:	00 00 00 
  80042025fa:	48 8b 00             	mov    (%rax),%rax
  80042025fd:	48 85 c0             	test   %rax,%rax
  8004202600:	75 45                	jne    8004202647 <boot_alloc+0x62>
#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  8004202602:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004202609:	00 
  800420260a:	48 b8 10 f0 5b 04 80 	movabs $0x80045bf010,%rax
  8004202611:	00 00 00 
  8004202614:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004202618:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420261c:	48 01 d0             	add    %rdx,%rax
  800420261f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202623:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202627:	ba 00 00 00 00       	mov    $0x0,%edx
  800420262c:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202630:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202634:	48 29 d0             	sub    %rdx,%rax
  8004202637:	48 89 c2             	mov    %rax,%rdx
  800420263a:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  8004202641:	00 00 00 
  8004202644:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
  if ((uintptr_t)nextfree + n < (uintptr_t)nextfree
  8004202647:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420264a:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  8004202651:	00 00 00 
  8004202654:	48 8b 00             	mov    (%rax),%rax
  8004202657:	48 01 c2             	add    %rax,%rdx
  800420265a:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  8004202661:	00 00 00 
  8004202664:	48 8b 00             	mov    (%rax),%rax
  8004202667:	48 39 c2             	cmp    %rax,%rdx
  800420266a:	72 2f                	jb     800420269b <boot_alloc+0xb6>
      || nextfree + n > (char *) (npages * PGSIZE + KERNBASE)) {
  800420266c:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  8004202673:	00 00 00 
  8004202676:	48 8b 10             	mov    (%rax),%rdx
  8004202679:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420267c:	48 01 c2             	add    %rax,%rdx
  800420267f:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202686:	00 00 00 
  8004202689:	48 8b 00             	mov    (%rax),%rax
  800420268c:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202692:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202696:	48 39 c2             	cmp    %rax,%rdx
  8004202699:	76 2a                	jbe    80042026c5 <boot_alloc+0xe0>
    panic("out of memory during x64_vm_init");
  800420269b:	48 ba 50 4c 21 04 80 	movabs $0x8004214c50,%rdx
  80042026a2:	00 00 00 
  80042026a5:	be e5 00 00 00       	mov    $0xe5,%esi
  80042026aa:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042026b1:	00 00 00 
  80042026b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026b9:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  80042026c0:	00 00 00 
  80042026c3:	ff d1                	callq  *%rcx
  }
  result=nextfree;
  80042026c5:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  80042026cc:	00 00 00 
  80042026cf:	48 8b 00             	mov    (%rax),%rax
  80042026d2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  nextfree = ROUNDUP(nextfree + n, PGSIZE);
  80042026d6:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042026dd:	00 
  80042026de:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  80042026e5:	00 00 00 
  80042026e8:	48 8b 10             	mov    (%rax),%rdx
  80042026eb:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042026ee:	48 01 d0             	add    %rdx,%rax
  80042026f1:	48 89 c2             	mov    %rax,%rdx
  80042026f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042026f8:	48 01 d0             	add    %rdx,%rax
  80042026fb:	48 83 e8 01          	sub    $0x1,%rax
  80042026ff:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202703:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202707:	ba 00 00 00 00       	mov    $0x0,%edx
  800420270c:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202710:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202714:	48 29 d0             	sub    %rdx,%rax
  8004202717:	48 89 c2             	mov    %rax,%rdx
  800420271a:	48 b8 68 b2 57 04 80 	movabs $0x800457b268,%rax
  8004202721:	00 00 00 
  8004202724:	48 89 10             	mov    %rdx,(%rax)
  return result;
  8004202727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

	// return NULL;
}
  800420272b:	c9                   	leaveq 
  800420272c:	c3                   	retq   

000000800420272d <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  800420272d:	55                   	push   %rbp
  800420272e:	48 89 e5             	mov    %rsp,%rbp
  8004202731:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202735:	48 b8 42 23 20 04 80 	movabs $0x8004202342,%rax
  800420273c:	00 00 00 
  800420273f:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	// panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202741:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202746:	48 b8 e5 25 20 04 80 	movabs $0x80042025e5,%rax
  800420274d:	00 00 00 
  8004202750:	ff d0                	callq  *%rax
  8004202752:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420275a:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420275f:	be 00 00 00 00       	mov    $0x0,%esi
  8004202764:	48 89 c7             	mov    %rax,%rdi
  8004202767:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420276e:	00 00 00 
  8004202771:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202773:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420277a:	00 00 00 
  800420277d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202781:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202784:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202788:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420278c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202793:	00 00 00 
  8004202796:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420279a:	77 32                	ja     80042027ce <x64_vm_init+0xa1>
  800420279c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027a0:	48 89 c1             	mov    %rax,%rcx
  80042027a3:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  80042027aa:	00 00 00 
  80042027ad:	be 07 01 00 00       	mov    $0x107,%esi
  80042027b2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042027b9:	00 00 00 
  80042027bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027c1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042027c8:	00 00 00 
  80042027cb:	41 ff d0             	callq  *%r8
  80042027ce:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042027d5:	ff ff ff 
  80042027d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027dc:	48 01 c2             	add    %rax,%rdx
  80042027df:	48 b8 c0 c7 57 04 80 	movabs $0x800457c7c0,%rax
  80042027e6:	00 00 00 
  80042027e9:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	n = npages * sizeof(struct PageInfo);
  80042027ec:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042027f3:	00 00 00 
  80042027f6:	48 8b 00             	mov    (%rax),%rax
  80042027f9:	48 c1 e0 04          	shl    $0x4,%rax
  80042027fd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pages = (struct PageInfo *) boot_alloc(n);
  8004202801:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202805:	89 c7                	mov    %eax,%edi
  8004202807:	48 b8 e5 25 20 04 80 	movabs $0x80042025e5,%rax
  800420280e:	00 00 00 
  8004202811:	ff d0                	callq  *%rax
  8004202813:	48 89 c2             	mov    %rax,%rdx
  8004202816:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  800420281d:	00 00 00 
  8004202820:	48 89 10             	mov    %rdx,(%rax)
	memset(pages, 0, n);
  8004202823:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  800420282a:	00 00 00 
  800420282d:	48 8b 00             	mov    (%rax),%rax
  8004202830:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202834:	be 00 00 00 00       	mov    $0x0,%esi
  8004202839:	48 89 c7             	mov    %rax,%rdi
  800420283c:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004202843:	00 00 00 
  8004202846:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs    = boot_alloc(sizeof(struct Env)*NENV);
  8004202848:	bf 00 a0 05 00       	mov    $0x5a000,%edi
  800420284d:	48 b8 e5 25 20 04 80 	movabs $0x80042025e5,%rax
  8004202854:	00 00 00 
  8004202857:	ff d0                	callq  *%rax
  8004202859:	48 89 c2             	mov    %rax,%rdx
  800420285c:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  8004202863:	00 00 00 
  8004202866:	48 89 10             	mov    %rdx,(%rax)
	memset(envs, 0, sizeof(struct Env)*NENV);
  8004202869:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  8004202870:	00 00 00 
  8004202873:	48 8b 00             	mov    (%rax),%rax
  8004202876:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  800420287b:	be 00 00 00 00       	mov    $0x0,%esi
  8004202880:	48 89 c7             	mov    %rax,%rdi
  8004202883:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420288a:	00 00 00 
  800420288d:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  800420288f:	48 b8 e7 2c 20 04 80 	movabs $0x8004202ce7,%rax
  8004202896:	00 00 00 
  8004202899:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	n = npages*sizeof(struct PageInfo);
  800420289b:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042028a2:	00 00 00 
  80042028a5:	48 8b 00             	mov    (%rax),%rax
  80042028a8:	48 c1 e0 04          	shl    $0x4,%rax
  80042028ac:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UPAGES, n, PADDR(pages), PTE_U);
  80042028b0:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  80042028b7:	00 00 00 
  80042028ba:	48 8b 00             	mov    (%rax),%rax
  80042028bd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042028c1:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028c8:	00 00 00 
  80042028cb:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042028cf:	77 32                	ja     8004202903 <x64_vm_init+0x1d6>
  80042028d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028d5:	48 89 c1             	mov    %rax,%rcx
  80042028d8:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  80042028df:	00 00 00 
  80042028e2:	be 28 01 00 00       	mov    $0x128,%esi
  80042028e7:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042028ee:	00 00 00 
  80042028f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028f6:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042028fd:	00 00 00 
  8004202900:	41 ff d0             	callq  *%r8
  8004202903:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420290a:	ff ff ff 
  800420290d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202911:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202915:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420291c:	00 00 00 
  800420291f:	48 8b 00             	mov    (%rax),%rax
  8004202922:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202926:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  800420292c:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202933:	00 00 00 
  8004202936:	48 89 c7             	mov    %rax,%rdi
  8004202939:	48 b8 32 38 20 04 80 	movabs $0x8004203832,%rax
  8004202940:	00 00 00 
  8004202943:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	n   = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004202945:	48 c7 45 d8 00 10 00 	movq   $0x1000,-0x28(%rbp)
  800420294c:	00 
  800420294d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202951:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  8004202957:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420295b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420295f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202964:	48 f7 75 d8          	divq   -0x28(%rbp)
  8004202968:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420296c:	48 29 d0             	sub    %rdx,%rax
  800420296f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UENVS, n, PADDR(envs), PTE_U|PTE_P);
  8004202973:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420297a:	00 00 00 
  800420297d:	48 8b 00             	mov    (%rax),%rax
  8004202980:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202984:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420298b:	00 00 00 
  800420298e:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  8004202992:	77 32                	ja     80042029c6 <x64_vm_init+0x299>
  8004202994:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202998:	48 89 c1             	mov    %rax,%rcx
  800420299b:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  80042029a2:	00 00 00 
  80042029a5:	be 32 01 00 00       	mov    $0x132,%esi
  80042029aa:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042029b1:	00 00 00 
  80042029b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029b9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042029c0:	00 00 00 
  80042029c3:	41 ff d0             	callq  *%r8
  80042029c6:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042029cd:	ff ff ff 
  80042029d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042029d4:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042029d8:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042029df:	00 00 00 
  80042029e2:	48 8b 00             	mov    (%rax),%rax
  80042029e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042029e9:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  80042029ef:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  80042029f6:	00 00 00 
  80042029f9:	48 89 c7             	mov    %rax,%rdi
  80042029fc:	48 b8 32 38 20 04 80 	movabs $0x8004203832,%rax
  8004202a03:	00 00 00 
  8004202a06:	ff d0                	callq  *%rax
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W|PTE_P);
  8004202a08:	48 b8 00 80 21 04 80 	movabs $0x8004218000,%rax
  8004202a0f:	00 00 00 
  8004202a12:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202a16:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202a1d:	00 00 00 
  8004202a20:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202a24:	77 32                	ja     8004202a58 <x64_vm_init+0x32b>
  8004202a26:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a2a:	48 89 c1             	mov    %rax,%rcx
  8004202a2d:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  8004202a34:	00 00 00 
  8004202a37:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004202a3c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202a43:	00 00 00 
  8004202a46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a4b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202a52:	00 00 00 
  8004202a55:	41 ff d0             	callq  *%r8
  8004202a58:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202a5f:	ff ff ff 
  8004202a62:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a66:	48 01 c2             	add    %rax,%rdx
  8004202a69:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004202a70:	00 00 00 
  8004202a73:	48 8b 00             	mov    (%rax),%rax
  8004202a76:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202a7c:	48 89 d1             	mov    %rdx,%rcx
  8004202a7f:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202a84:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  8004202a8b:	00 00 00 
  8004202a8e:	48 89 c7             	mov    %rax,%rdi
  8004202a91:	48 b8 32 38 20 04 80 	movabs $0x8004203832,%rax
  8004202a98:	00 00 00 
  8004202a9b:	ff d0                	callq  *%rax
	// of physical pages to be npages.
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, KERNBASE, npages*PGSIZE, 0, PTE_W|PTE_P);
  8004202a9d:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202aa4:	00 00 00 
  8004202aa7:	48 8b 00             	mov    (%rax),%rax
  8004202aaa:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202aae:	48 89 c2             	mov    %rax,%rdx
  8004202ab1:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004202ab8:	00 00 00 
  8004202abb:	48 8b 00             	mov    (%rax),%rax
  8004202abe:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202ac4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202ac9:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202ad0:	00 00 00 
  8004202ad3:	48 89 c7             	mov    %rax,%rdi
  8004202ad6:	48 b8 32 38 20 04 80 	movabs $0x8004203832,%rax
  8004202add:	00 00 00 
  8004202ae0:	ff d0                	callq  *%rax
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202ae2:	48 b8 fc 2b 20 04 80 	movabs $0x8004202bfc,%rax
  8004202ae9:	00 00 00 
  8004202aec:	ff d0                	callq  *%rax


	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202aee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202af2:	48 83 c0 08          	add    $0x8,%rax
  8004202af6:	48 8b 00             	mov    (%rax),%rax
  8004202af9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202aff:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202b03:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b07:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b0b:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202b0e:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202b11:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202b18:	00 00 00 
  8004202b1b:	48 8b 00             	mov    (%rax),%rax
  8004202b1e:	48 39 c2             	cmp    %rax,%rdx
  8004202b21:	72 32                	jb     8004202b55 <x64_vm_init+0x428>
  8004202b23:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b27:	48 89 c1             	mov    %rax,%rcx
  8004202b2a:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004202b31:	00 00 00 
  8004202b34:	be 50 01 00 00       	mov    $0x150,%esi
  8004202b39:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202b40:	00 00 00 
  8004202b43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b48:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202b4f:	00 00 00 
  8004202b52:	41 ff d0             	callq  *%r8
  8004202b55:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202b5c:	00 00 00 
  8004202b5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b63:	48 01 d0             	add    %rdx,%rax
  8004202b66:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202b6a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202b6e:	48 8b 00             	mov    (%rax),%rax
  8004202b71:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202b77:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202b7b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202b7f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b83:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004202b86:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202b89:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202b90:	00 00 00 
  8004202b93:	48 8b 00             	mov    (%rax),%rax
  8004202b96:	48 39 c2             	cmp    %rax,%rdx
  8004202b99:	72 32                	jb     8004202bcd <x64_vm_init+0x4a0>
  8004202b9b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202b9f:	48 89 c1             	mov    %rax,%rcx
  8004202ba2:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004202ba9:	00 00 00 
  8004202bac:	be 51 01 00 00       	mov    $0x151,%esi
  8004202bb1:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202bb8:	00 00 00 
  8004202bbb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202bc0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202bc7:	00 00 00 
  8004202bca:	41 ff d0             	callq  *%r8
  8004202bcd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202bd4:	00 00 00 
  8004202bd7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202bdb:	48 01 d0             	add    %rdx,%rax
  8004202bde:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	lcr3(boot_cr3);
  8004202be2:	48 b8 c0 c7 57 04 80 	movabs $0x800457c7c0,%rax
  8004202be9:	00 00 00 
  8004202bec:	48 8b 00             	mov    (%rax),%rax
  8004202bef:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202bf3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202bf7:	0f 22 d8             	mov    %rax,%cr3
}
  8004202bfa:	c9                   	leaveq 
  8004202bfb:	c3                   	retq   

0000008004202bfc <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202bfc:	55                   	push   %rbp
  8004202bfd:	48 89 e5             	mov    %rsp,%rbp
  8004202c00:	48 83 ec 20          	sub    $0x20,%rsp
	//
	// LAB 4: Your code here:

	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202c04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202c0b:	e9 cb 00 00 00       	jmpq   8004202cdb <mem_init_mp+0xdf>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
  8004202c10:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004202c13:	89 d0                	mov    %edx,%eax
  8004202c15:	01 c0                	add    %eax,%eax
  8004202c17:	01 d0                	add    %edx,%eax
  8004202c19:	c1 e0 0f             	shl    $0xf,%eax
  8004202c1c:	48 98                	cltq   
  8004202c1e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202c25:	00 00 00 
  8004202c28:	48 29 c2             	sub    %rax,%rdx
  8004202c2b:	48 89 d0             	mov    %rdx,%rax
  8004202c2e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
  8004202c32:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202c35:	48 98                	cltq   
  8004202c37:	48 c1 e0 10          	shl    $0x10,%rax
  8004202c3b:	48 89 c2             	mov    %rax,%rdx
  8004202c3e:	48 b8 00 f0 57 04 80 	movabs $0x800457f000,%rax
  8004202c45:	00 00 00 
  8004202c48:	48 01 d0             	add    %rdx,%rax
  8004202c4b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202c4f:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202c56:	00 00 00 
  8004202c59:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202c5d:	77 32                	ja     8004202c91 <mem_init_mp+0x95>
  8004202c5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c63:	48 89 c1             	mov    %rax,%rcx
  8004202c66:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  8004202c6d:	00 00 00 
  8004202c70:	be 72 01 00 00       	mov    $0x172,%esi
  8004202c75:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202c7c:	00 00 00 
  8004202c7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c84:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202c8b:	00 00 00 
  8004202c8e:	41 ff d0             	callq  *%r8
  8004202c91:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202c98:	ff ff ff 
  8004202c9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c9f:	48 01 c2             	add    %rax,%rdx
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
  8004202ca2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202ca6:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202cad:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004202cb4:	00 00 00 
  8004202cb7:	48 8b 00             	mov    (%rax),%rax
  8004202cba:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202cc0:	48 89 d1             	mov    %rdx,%rcx
  8004202cc3:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202cc8:	48 89 c7             	mov    %rax,%rdi
  8004202ccb:	48 b8 32 38 20 04 80 	movabs $0x8004203832,%rax
  8004202cd2:	00 00 00 
  8004202cd5:	ff d0                	callq  *%rax
	for (i = 0; i < NCPU; i++) {
  8004202cd7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202cdb:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202cdf:	0f 8e 2b ff ff ff    	jle    8004202c10 <mem_init_mp+0x14>
	}
}
  8004202ce5:	c9                   	leaveq 
  8004202ce6:	c3                   	retq   

0000008004202ce7 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202ce7:	55                   	push   %rbp
  8004202ce8:	48 89 e5             	mov    %rsp,%rbp
  8004202ceb:	48 83 ec 50          	sub    $0x50,%rsp
	// LAB 4:
	// Change your code to mark the physical page at MPENTRY_PADDR
	// as in use

	void *nextfree = boot_alloc(0);
  8004202cef:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202cf4:	48 b8 e5 25 20 04 80 	movabs $0x80042025e5,%rax
  8004202cfb:	00 00 00 
  8004202cfe:	ff d0                	callq  *%rax
  8004202d00:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
  8004202d04:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202d0b:	00 
	for (i = 0; i < npages; i++) {
  8004202d0c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202d13:	00 
  8004202d14:	e9 65 02 00 00       	jmpq   8004202f7e <page_init+0x297>
		// Off-limits until proven otherwise.
		inuse = 1;
  8004202d19:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		// The bottom basemem bytes are free except page 0.
		if (i != 0 && i < npages_basemem)
  8004202d20:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202d25:	74 1a                	je     8004202d41 <page_init+0x5a>
  8004202d27:	48 b8 50 b2 57 04 80 	movabs $0x800457b250,%rax
  8004202d2e:	00 00 00 
  8004202d31:	48 8b 00             	mov    (%rax),%rax
  8004202d34:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202d38:	73 07                	jae    8004202d41 <page_init+0x5a>
			inuse = 0;
  8004202d3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
		// Mark physical page at MPENTRY_PADDR as in use
		if (i == MPENTRY_PADDR / PGSIZE)
  8004202d41:	48 83 7d f8 07       	cmpq   $0x7,-0x8(%rbp)
  8004202d46:	75 07                	jne    8004202d4f <page_init+0x68>
			inuse = 1;
  8004202d48:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		// The IO hole and the kernel are non empty but
		// The memory past the kernel is free.
		if (i >= PADDR(nextfree) / PGSIZE)
  8004202d4f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202d53:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202d57:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202d5e:	00 00 00 
  8004202d61:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004202d65:	77 32                	ja     8004202d99 <page_init+0xb2>
  8004202d67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202d6b:	48 89 c1             	mov    %rax,%rcx
  8004202d6e:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  8004202d75:	00 00 00 
  8004202d78:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004202d7d:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202d84:	00 00 00 
  8004202d87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d8c:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202d93:	00 00 00 
  8004202d96:	41 ff d0             	callq  *%r8
  8004202d99:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202da0:	ff ff ff 
  8004202da3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202da7:	48 01 d0             	add    %rdx,%rax
  8004202daa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202dae:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004202db2:	77 07                	ja     8004202dbb <page_init+0xd4>
			inuse = 0;
  8004202db4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		uint64_t va = KERNBASE + i*PGSIZE;
  8004202dbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202dbf:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202dc5:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202dc9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (va>=BOOT_PAGE_TABLE_START && va<BOOT_PAGE_TABLE_END)
  8004202dcd:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202dd4:	00 00 00 
  8004202dd7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202ddb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202ddf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202de3:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004202de6:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004202de9:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202df0:	00 00 00 
  8004202df3:	48 8b 00             	mov    (%rax),%rax
  8004202df6:	48 39 c2             	cmp    %rax,%rdx
  8004202df9:	72 32                	jb     8004202e2d <page_init+0x146>
  8004202dfb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202dff:	48 89 c1             	mov    %rax,%rcx
  8004202e02:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004202e09:	00 00 00 
  8004202e0c:	be 9e 01 00 00       	mov    $0x19e,%esi
  8004202e11:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202e18:	00 00 00 
  8004202e1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e20:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202e27:	00 00 00 
  8004202e2a:	41 ff d0             	callq  *%r8
  8004202e2d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e34:	00 00 00 
  8004202e37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202e3b:	48 01 d0             	add    %rdx,%rax
  8004202e3e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202e42:	0f 87 84 00 00 00    	ja     8004202ecc <page_init+0x1e5>
  8004202e48:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e4f:	00 00 00 
  8004202e52:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202e58:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202e5c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202e60:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e64:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202e67:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202e6a:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202e71:	00 00 00 
  8004202e74:	48 8b 00             	mov    (%rax),%rax
  8004202e77:	48 39 c2             	cmp    %rax,%rdx
  8004202e7a:	72 32                	jb     8004202eae <page_init+0x1c7>
  8004202e7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202e80:	48 89 c1             	mov    %rax,%rcx
  8004202e83:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004202e8a:	00 00 00 
  8004202e8d:	be 9e 01 00 00       	mov    $0x19e,%esi
  8004202e92:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004202e99:	00 00 00 
  8004202e9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ea1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004202ea8:	00 00 00 
  8004202eab:	41 ff d0             	callq  *%r8
  8004202eae:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202eb5:	00 00 00 
  8004202eb8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202ebc:	48 01 d0             	add    %rdx,%rax
  8004202ebf:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202ec3:	76 07                	jbe    8004202ecc <page_init+0x1e5>
			inuse = 1;
  8004202ec5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		pages[i].pp_ref = inuse;
  8004202ecc:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004202ed3:	00 00 00 
  8004202ed6:	48 8b 00             	mov    (%rax),%rax
  8004202ed9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202edd:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ee1:	48 01 d0             	add    %rdx,%rax
  8004202ee4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004202ee7:	66 89 50 08          	mov    %dx,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202eeb:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004202ef2:	00 00 00 
  8004202ef5:	48 8b 00             	mov    (%rax),%rax
  8004202ef8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202efc:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f00:	48 01 d0             	add    %rdx,%rax
  8004202f03:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (!inuse) {
  8004202f0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004202f0e:	75 69                	jne    8004202f79 <page_init+0x292>
			if (last)
  8004202f10:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202f15:	74 21                	je     8004202f38 <page_init+0x251>
				last->pp_link = &pages[i];
  8004202f17:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004202f1e:	00 00 00 
  8004202f21:	48 8b 00             	mov    (%rax),%rax
  8004202f24:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f28:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f2c:	48 01 c2             	add    %rax,%rdx
  8004202f2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f33:	48 89 10             	mov    %rdx,(%rax)
  8004202f36:	eb 25                	jmp    8004202f5d <page_init+0x276>
			else
				page_free_list = &pages[i];
  8004202f38:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004202f3f:	00 00 00 
  8004202f42:	48 8b 00             	mov    (%rax),%rax
  8004202f45:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f49:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f4d:	48 01 c2             	add    %rax,%rdx
  8004202f50:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004202f57:	00 00 00 
  8004202f5a:	48 89 10             	mov    %rdx,(%rax)
			last = &pages[i];
  8004202f5d:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004202f64:	00 00 00 
  8004202f67:	48 8b 00             	mov    (%rax),%rax
  8004202f6a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f6e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f72:	48 01 d0             	add    %rdx,%rax
  8004202f75:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < npages; i++) {
  8004202f79:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202f7e:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004202f85:	00 00 00 
  8004202f88:	48 8b 00             	mov    (%rax),%rax
  8004202f8b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202f8f:	0f 82 84 fd ff ff    	jb     8004202d19 <page_init+0x32>
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	// NB: Make sure you preserve the direction in which your page_free_list
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
}
  8004202f95:	c9                   	leaveq 
  8004202f96:	c3                   	retq   

0000008004202f97 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202f97:	55                   	push   %rbp
  8004202f98:	48 89 e5             	mov    %rsp,%rbp
  8004202f9b:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f9f:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo *pp = page_free_list;
  8004202fa2:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004202fa9:	00 00 00 
  8004202fac:	48 8b 00             	mov    (%rax),%rax
  8004202faf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pp) {
  8004202fb3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202fb8:	74 5e                	je     8004203018 <page_alloc+0x81>
		//cprintf("alloc new page: struct page %x va %x pa %x \n", pp, page2kva(pp), page2pa(pp));
		page_free_list = page_free_list->pp_link;
  8004202fba:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004202fc1:	00 00 00 
  8004202fc4:	48 8b 00             	mov    (%rax),%rax
  8004202fc7:	48 8b 10             	mov    (%rax),%rdx
  8004202fca:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004202fd1:	00 00 00 
  8004202fd4:	48 89 10             	mov    %rdx,(%rax)
		pp->pp_link = NULL;
  8004202fd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fdb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (alloc_flags & ALLOC_ZERO)
  8004202fe2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202fe5:	83 e0 01             	and    $0x1,%eax
  8004202fe8:	85 c0                	test   %eax,%eax
  8004202fea:	74 2c                	je     8004203018 <page_alloc+0x81>
			memset(page2kva(pp), 0, PGSIZE);
  8004202fec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ff0:	48 89 c7             	mov    %rax,%rdi
  8004202ff3:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  8004202ffa:	00 00 00 
  8004202ffd:	ff d0                	callq  *%rax
  8004202fff:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203004:	be 00 00 00 00       	mov    $0x0,%esi
  8004203009:	48 89 c7             	mov    %rax,%rdi
  800420300c:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004203013:	00 00 00 
  8004203016:	ff d0                	callq  *%rax
	}
	return pp;
  8004203018:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420301c:	c9                   	leaveq 
  800420301d:	c3                   	retq   

000000800420301e <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  800420301e:	55                   	push   %rbp
  800420301f:	48 89 e5             	mov    %rsp,%rbp
  8004203022:	48 83 ec 10          	sub    $0x10,%rsp
  8004203026:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  800420302a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420302e:	ba 10 00 00 00       	mov    $0x10,%edx
  8004203033:	be 00 00 00 00       	mov    $0x0,%esi
  8004203038:	48 89 c7             	mov    %rax,%rdi
  800420303b:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004203042:	00 00 00 
  8004203045:	ff d0                	callq  *%rax
}
  8004203047:	c9                   	leaveq 
  8004203048:	c3                   	retq   

0000008004203049 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004203049:	55                   	push   %rbp
  800420304a:	48 89 e5             	mov    %rsp,%rbp
  800420304d:	48 83 ec 10          	sub    $0x10,%rsp
  8004203051:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref || pp->pp_link) {
  8004203055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203059:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420305d:	66 85 c0             	test   %ax,%ax
  8004203060:	75 0c                	jne    800420306e <page_free+0x25>
  8004203062:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203066:	48 8b 00             	mov    (%rax),%rax
  8004203069:	48 85 c0             	test   %rax,%rax
  800420306c:	74 2c                	je     800420309a <page_free+0x51>
		warn("page_free: attempt to free mapped page");
  800420306e:	48 ba a0 4c 21 04 80 	movabs $0x8004214ca0,%rdx
  8004203075:	00 00 00 
  8004203078:	be f3 01 00 00       	mov    $0x1f3,%esi
  800420307d:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203084:	00 00 00 
  8004203087:	b8 00 00 00 00       	mov    $0x0,%eax
  800420308c:	48 b9 e2 06 20 04 80 	movabs $0x80042006e2,%rcx
  8004203093:	00 00 00 
  8004203096:	ff d1                	callq  *%rcx
		return;		/* be conservative and assume page is still used */
  8004203098:	eb 2f                	jmp    80042030c9 <page_free+0x80>
	}
	pp->pp_link = page_free_list;
  800420309a:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  80042030a1:	00 00 00 
  80042030a4:	48 8b 10             	mov    (%rax),%rdx
  80042030a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030ab:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  80042030ae:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  80042030b5:	00 00 00 
  80042030b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042030bc:	48 89 10             	mov    %rdx,(%rax)
	pp->pp_ref = 0;
  80042030bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030c3:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
}
  80042030c9:	c9                   	leaveq 
  80042030ca:	c3                   	retq   

00000080042030cb <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  80042030cb:	55                   	push   %rbp
  80042030cc:	48 89 e5             	mov    %rsp,%rbp
  80042030cf:	48 83 ec 10          	sub    $0x10,%rsp
  80042030d3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  80042030d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030db:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030df:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042030e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030e6:	66 89 50 08          	mov    %dx,0x8(%rax)
  80042030ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030ee:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030f2:	66 85 c0             	test   %ax,%ax
  80042030f5:	75 13                	jne    800420310a <page_decref+0x3f>
		page_free(pp);
  80042030f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030fb:	48 89 c7             	mov    %rax,%rdi
  80042030fe:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  8004203105:	00 00 00 
  8004203108:	ff d0                	callq  *%rax
}
  800420310a:	c9                   	leaveq 
  800420310b:	c3                   	retq   

000000800420310c <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  800420310c:	55                   	push   %rbp
  800420310d:	48 89 e5             	mov    %rsp,%rbp
  8004203110:	53                   	push   %rbx
  8004203111:	48 83 ec 68          	sub    $0x68,%rsp
  8004203115:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203119:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420311d:	89 55 9c             	mov    %edx,-0x64(%rbp)
	if (pml4e) {
  8004203120:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203125:	0f 84 54 02 00 00    	je     800420337f <pml4e_walk+0x273>
		pdpe_t *pdpe  = (pdpe_t *)pml4e [PML4(va)];
  800420312b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420312f:	48 c1 e8 27          	shr    $0x27,%rax
  8004203133:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203138:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420313f:	00 
  8004203140:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203144:	48 01 d0             	add    %rdx,%rax
  8004203147:	48 8b 00             	mov    (%rax),%rax
  800420314a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pdpe & PTE_P) && create) {
  800420314e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203152:	83 e0 01             	and    $0x1,%eax
  8004203155:	48 85 c0             	test   %rax,%rax
  8004203158:	0f 85 82 01 00 00    	jne    80042032e0 <pml4e_walk+0x1d4>
  800420315e:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004203162:	0f 84 78 01 00 00    	je     80042032e0 <pml4e_walk+0x1d4>
			struct PageInfo *page   = NULL;
  8004203168:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420316f:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  8004203170:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203175:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  800420317c:	00 00 00 
  800420317f:	ff d0                	callq  *%rax
  8004203181:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203185:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420318a:	0f 84 46 01 00 00    	je     80042032d6 <pml4e_walk+0x1ca>
				page->pp_ref    += 1;
  8004203190:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203194:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203198:	8d 50 01             	lea    0x1(%rax),%edx
  800420319b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420319f:	66 89 50 08          	mov    %dx,0x8(%rax)
				pml4e [PML4(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  80042031a3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042031a7:	48 c1 e8 27          	shr    $0x27,%rax
  80042031ab:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042031b0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031b7:	00 
  80042031b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042031bc:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042031c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042031c4:	48 89 c7             	mov    %rax,%rdi
  80042031c7:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042031ce:	00 00 00 
  80042031d1:	ff d0                	callq  *%rax
  80042031d3:	48 83 c8 07          	or     $0x7,%rax
  80042031d7:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte= pdpe_walk(KADDR((uintptr_t)((pdpe_t *)(PTE_ADDR(pml4e [PML4(va)])))),va,create);
  80042031da:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042031de:	48 c1 e8 27          	shr    $0x27,%rax
  80042031e2:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042031e7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031ee:	00 
  80042031ef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042031f3:	48 01 d0             	add    %rdx,%rax
  80042031f6:	48 8b 00             	mov    (%rax),%rax
  80042031f9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042031ff:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203203:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203207:	48 c1 e8 0c          	shr    $0xc,%rax
  800420320b:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420320e:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203211:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203218:	00 00 00 
  800420321b:	48 8b 00             	mov    (%rax),%rax
  800420321e:	48 39 c2             	cmp    %rax,%rdx
  8004203221:	72 32                	jb     8004203255 <pml4e_walk+0x149>
  8004203223:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203227:	48 89 c1             	mov    %rax,%rcx
  800420322a:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004203231:	00 00 00 
  8004203234:	be 29 02 00 00       	mov    $0x229,%esi
  8004203239:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203240:	00 00 00 
  8004203243:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203248:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420324f:	00 00 00 
  8004203252:	41 ff d0             	callq  *%r8
  8004203255:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420325c:	00 00 00 
  800420325f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203263:	48 01 d0             	add    %rdx,%rax
  8004203266:	48 89 c1             	mov    %rax,%rcx
  8004203269:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420326c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203270:	48 89 c6             	mov    %rax,%rsi
  8004203273:	48 89 cf             	mov    %rcx,%rdi
  8004203276:	48 b8 8b 33 20 04 80 	movabs $0x800420338b,%rax
  800420327d:	00 00 00 
  8004203280:	ff d0                	callq  *%rax
  8004203282:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  8004203286:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420328b:	74 09                	je     8004203296 <pml4e_walk+0x18a>
  800420328d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203291:	e9 ee 00 00 00       	jmpq   8004203384 <pml4e_walk+0x278>
				else{
					pml4e[PML4(va)] = 0;
  8004203296:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420329a:	48 c1 e8 27          	shr    $0x27,%rax
  800420329e:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042032a3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042032aa:	00 
  80042032ab:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042032af:	48 01 d0             	add    %rdx,%rax
  80042032b2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  80042032b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042032bd:	48 89 c7             	mov    %rax,%rdi
  80042032c0:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  80042032c7:	00 00 00 
  80042032ca:	ff d0                	callq  *%rax
					return NULL;
  80042032cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032d1:	e9 ae 00 00 00       	jmpq   8004203384 <pml4e_walk+0x278>
				}
			}else
				return NULL;
  80042032d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032db:	e9 a4 00 00 00       	jmpq   8004203384 <pml4e_walk+0x278>
		} else if ((uint64_t)pdpe & PTE_P) {
  80042032e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032e4:	83 e0 01             	and    $0x1,%eax
  80042032e7:	48 85 c0             	test   %rax,%rax
  80042032ea:	0f 84 8f 00 00 00    	je     800420337f <pml4e_walk+0x273>
			return pdpe_walk(KADDR((uintptr_t)((pdpe_t *)PTE_ADDR(pdpe))),va,create);
  80042032f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032f4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042032fa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042032fe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203302:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203306:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203309:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420330c:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203313:	00 00 00 
  8004203316:	48 8b 00             	mov    (%rax),%rax
  8004203319:	48 39 c2             	cmp    %rax,%rdx
  800420331c:	72 32                	jb     8004203350 <pml4e_walk+0x244>
  800420331e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203322:	48 89 c1             	mov    %rax,%rcx
  8004203325:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  800420332c:	00 00 00 
  800420332f:	be 33 02 00 00       	mov    $0x233,%esi
  8004203334:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420333b:	00 00 00 
  800420333e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203343:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420334a:	00 00 00 
  800420334d:	41 ff d0             	callq  *%r8
  8004203350:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203357:	00 00 00 
  800420335a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420335e:	48 01 d0             	add    %rdx,%rax
  8004203361:	48 89 c1             	mov    %rax,%rcx
  8004203364:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203367:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420336b:	48 89 c6             	mov    %rax,%rsi
  800420336e:	48 89 cf             	mov    %rcx,%rdi
  8004203371:	48 b8 8b 33 20 04 80 	movabs $0x800420338b,%rax
  8004203378:	00 00 00 
  800420337b:	ff d0                	callq  *%rax
  800420337d:	eb 05                	jmp    8004203384 <pml4e_walk+0x278>
		}
	}
	return NULL;
  800420337f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203384:	48 83 c4 68          	add    $0x68,%rsp
  8004203388:	5b                   	pop    %rbx
  8004203389:	5d                   	pop    %rbp
  800420338a:	c3                   	retq   

000000800420338b <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  800420338b:	55                   	push   %rbp
  800420338c:	48 89 e5             	mov    %rsp,%rbp
  800420338f:	53                   	push   %rbx
  8004203390:	48 83 ec 68          	sub    $0x68,%rsp
  8004203394:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203398:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420339c:	89 55 9c             	mov    %edx,-0x64(%rbp)

	if (pdpe){
  800420339f:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042033a4:	0f 84 54 02 00 00    	je     80042035fe <pdpe_walk+0x273>
		pde_t * pdp = (pde_t *)pdpe[PDPE(va)];
  80042033aa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042033ae:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042033b2:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042033b7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033be:	00 
  80042033bf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033c3:	48 01 d0             	add    %rdx,%rax
  80042033c6:	48 8b 00             	mov    (%rax),%rax
  80042033c9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!((physaddr_t)pdp & PTE_P) && create){
  80042033cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033d1:	83 e0 01             	and    $0x1,%eax
  80042033d4:	48 85 c0             	test   %rax,%rax
  80042033d7:	0f 85 82 01 00 00    	jne    800420355f <pdpe_walk+0x1d4>
  80042033dd:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042033e1:	0f 84 78 01 00 00    	je     800420355f <pdpe_walk+0x1d4>
			struct PageInfo *page   = NULL;
  80042033e7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042033ee:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  80042033ef:	bf 01 00 00 00       	mov    $0x1,%edi
  80042033f4:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  80042033fb:	00 00 00 
  80042033fe:	ff d0                	callq  *%rax
  8004203400:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203404:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203409:	0f 84 46 01 00 00    	je     8004203555 <pdpe_walk+0x1ca>
				page->pp_ref    += 1;
  800420340f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203413:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203417:	8d 50 01             	lea    0x1(%rax),%edx
  800420341a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420341e:	66 89 50 08          	mov    %dx,0x8(%rax)
				pdpe [PDPE(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  8004203422:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203426:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420342a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420342f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203436:	00 
  8004203437:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420343b:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420343f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203443:	48 89 c7             	mov    %rax,%rdi
  8004203446:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  800420344d:	00 00 00 
  8004203450:	ff d0                	callq  *%rax
  8004203452:	48 83 c8 07          	or     $0x7,%rax
  8004203456:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte = pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdpe[PDPE(va)]))),va,create);
  8004203459:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420345d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203461:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203466:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420346d:	00 
  800420346e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203472:	48 01 d0             	add    %rdx,%rax
  8004203475:	48 8b 00             	mov    (%rax),%rax
  8004203478:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420347e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203482:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203486:	48 c1 e8 0c          	shr    $0xc,%rax
  800420348a:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420348d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203490:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203497:	00 00 00 
  800420349a:	48 8b 00             	mov    (%rax),%rax
  800420349d:	48 39 c2             	cmp    %rax,%rdx
  80042034a0:	72 32                	jb     80042034d4 <pdpe_walk+0x149>
  80042034a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034a6:	48 89 c1             	mov    %rax,%rcx
  80042034a9:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042034b0:	00 00 00 
  80042034b3:	be 48 02 00 00       	mov    $0x248,%esi
  80042034b8:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042034bf:	00 00 00 
  80042034c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034c7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042034ce:	00 00 00 
  80042034d1:	41 ff d0             	callq  *%r8
  80042034d4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042034db:	00 00 00 
  80042034de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034e2:	48 01 d0             	add    %rdx,%rax
  80042034e5:	48 89 c1             	mov    %rax,%rcx
  80042034e8:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042034eb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042034ef:	48 89 c6             	mov    %rax,%rsi
  80042034f2:	48 89 cf             	mov    %rcx,%rdi
  80042034f5:	48 b8 0a 36 20 04 80 	movabs $0x800420360a,%rax
  80042034fc:	00 00 00 
  80042034ff:	ff d0                	callq  *%rax
  8004203501:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  8004203505:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420350a:	74 09                	je     8004203515 <pdpe_walk+0x18a>
  800420350c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203510:	e9 ee 00 00 00       	jmpq   8004203603 <pdpe_walk+0x278>
				else{
					pdpe[PDPE(va)] = 0;
  8004203515:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203519:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420351d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203522:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203529:	00 
  800420352a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420352e:	48 01 d0             	add    %rdx,%rax
  8004203531:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  8004203538:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420353c:	48 89 c7             	mov    %rax,%rdi
  800420353f:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004203546:	00 00 00 
  8004203549:	ff d0                	callq  *%rax
					return NULL;
  800420354b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203550:	e9 ae 00 00 00       	jmpq   8004203603 <pdpe_walk+0x278>
				}
			}else
				return NULL;
  8004203555:	b8 00 00 00 00       	mov    $0x0,%eax
  800420355a:	e9 a4 00 00 00       	jmpq   8004203603 <pdpe_walk+0x278>
		}else if((uint64_t)pdp & PTE_P){
  800420355f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203563:	83 e0 01             	and    $0x1,%eax
  8004203566:	48 85 c0             	test   %rax,%rax
  8004203569:	0f 84 8f 00 00 00    	je     80042035fe <pdpe_walk+0x273>
			return pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdp))),va,create);
  800420356f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203573:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203579:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420357d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203581:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203585:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203588:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420358b:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203592:	00 00 00 
  8004203595:	48 8b 00             	mov    (%rax),%rax
  8004203598:	48 39 c2             	cmp    %rax,%rdx
  800420359b:	72 32                	jb     80042035cf <pdpe_walk+0x244>
  800420359d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042035a1:	48 89 c1             	mov    %rax,%rcx
  80042035a4:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042035ab:	00 00 00 
  80042035ae:	be 52 02 00 00       	mov    $0x252,%esi
  80042035b3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042035ba:	00 00 00 
  80042035bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035c2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042035c9:	00 00 00 
  80042035cc:	41 ff d0             	callq  *%r8
  80042035cf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042035d6:	00 00 00 
  80042035d9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042035dd:	48 01 d0             	add    %rdx,%rax
  80042035e0:	48 89 c1             	mov    %rax,%rcx
  80042035e3:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042035e6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042035ea:	48 89 c6             	mov    %rax,%rsi
  80042035ed:	48 89 cf             	mov    %rcx,%rdi
  80042035f0:	48 b8 0a 36 20 04 80 	movabs $0x800420360a,%rax
  80042035f7:	00 00 00 
  80042035fa:	ff d0                	callq  *%rax
  80042035fc:	eb 05                	jmp    8004203603 <pdpe_walk+0x278>
		}
	}
	return NULL;
  80042035fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203603:	48 83 c4 68          	add    $0x68,%rsp
  8004203607:	5b                   	pop    %rbx
  8004203608:	5d                   	pop    %rbp
  8004203609:	c3                   	retq   

000000800420360a <pgdir_walk>:
// The logic here is slightly different, in that it needs to look
// not just at the page directory, but also get the last-level page table entry.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  800420360a:	55                   	push   %rbp
  800420360b:	48 89 e5             	mov    %rsp,%rbp
  800420360e:	53                   	push   %rbx
  800420360f:	48 83 ec 58          	sub    $0x58,%rsp
  8004203613:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203617:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420361b:	89 55 ac             	mov    %edx,-0x54(%rbp)
// Fill this function in
	if (pgdir) {
  800420361e:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203623:	0f 84 fd 01 00 00    	je     8004203826 <pgdir_walk+0x21c>
		pte_t *pte  = (pte_t *)pgdir [PDX(va)];
  8004203629:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420362d:	48 c1 e8 15          	shr    $0x15,%rax
  8004203631:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203636:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420363d:	00 
  800420363e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203642:	48 01 d0             	add    %rdx,%rax
  8004203645:	48 8b 00             	mov    (%rax),%rax
  8004203648:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pte & PTE_P) && create) {
  800420364c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203650:	83 e0 01             	and    $0x1,%eax
  8004203653:	48 85 c0             	test   %rax,%rax
  8004203656:	0f 85 2f 01 00 00    	jne    800420378b <pgdir_walk+0x181>
  800420365c:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004203660:	0f 84 25 01 00 00    	je     800420378b <pgdir_walk+0x181>
			struct PageInfo *page   = NULL;
  8004203666:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420366d:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  800420366e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203673:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  800420367a:	00 00 00 
  800420367d:	ff d0                	callq  *%rax
  800420367f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203683:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203688:	0f 84 f3 00 00 00    	je     8004203781 <pgdir_walk+0x177>
				page->pp_ref    += 1;
  800420368e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203692:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203696:	8d 50 01             	lea    0x1(%rax),%edx
  8004203699:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420369d:	66 89 50 08          	mov    %dx,0x8(%rax)
				pgdir [PDX(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  80042036a1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036a5:	48 c1 e8 15          	shr    $0x15,%rax
  80042036a9:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036ae:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036b5:	00 
  80042036b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042036ba:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042036be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042036c2:	48 89 c7             	mov    %rax,%rdi
  80042036c5:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042036cc:	00 00 00 
  80042036cf:	ff d0                	callq  *%rax
  80042036d1:	48 83 c8 07          	or     $0x7,%rax
  80042036d5:	48 89 03             	mov    %rax,(%rbx)
				return KADDR((uintptr_t)((pte_t *)(PTE_ADDR(pgdir [PDX(va)])) + PTX(va)));
  80042036d8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036dc:	48 c1 e8 0c          	shr    $0xc,%rax
  80042036e0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036e5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036ec:	00 
  80042036ed:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036f1:	48 c1 e8 15          	shr    $0x15,%rax
  80042036f5:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036fa:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004203701:	00 
  8004203702:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203706:	48 01 c8             	add    %rcx,%rax
  8004203709:	48 8b 00             	mov    (%rax),%rax
  800420370c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203712:	48 01 d0             	add    %rdx,%rax
  8004203715:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203719:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420371d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203721:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203724:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203727:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420372e:	00 00 00 
  8004203731:	48 8b 00             	mov    (%rax),%rax
  8004203734:	48 39 c2             	cmp    %rax,%rdx
  8004203737:	72 32                	jb     800420376b <pgdir_walk+0x161>
  8004203739:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420373d:	48 89 c1             	mov    %rax,%rcx
  8004203740:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004203747:	00 00 00 
  800420374a:	be 6a 02 00 00       	mov    $0x26a,%esi
  800420374f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203756:	00 00 00 
  8004203759:	b8 00 00 00 00       	mov    $0x0,%eax
  800420375e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004203765:	00 00 00 
  8004203768:	41 ff d0             	callq  *%r8
  800420376b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203772:	00 00 00 
  8004203775:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203779:	48 01 d0             	add    %rdx,%rax
  800420377c:	e9 aa 00 00 00       	jmpq   800420382b <pgdir_walk+0x221>
			}else{
				return NULL;
  8004203781:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203786:	e9 a0 00 00 00       	jmpq   800420382b <pgdir_walk+0x221>
			}
		} else if ((uint64_t)pte & PTE_P) {
  800420378b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420378f:	83 e0 01             	and    $0x1,%eax
  8004203792:	48 85 c0             	test   %rax,%rax
  8004203795:	0f 84 8b 00 00 00    	je     8004203826 <pgdir_walk+0x21c>
			return KADDR((uintptr_t)((pte_t *)PTE_ADDR(pte) + PTX(va)));
  800420379b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420379f:	48 c1 e8 0c          	shr    $0xc,%rax
  80042037a3:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042037a8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042037af:	00 
  80042037b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037b4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042037ba:	48 01 d0             	add    %rdx,%rax
  80042037bd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042037c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042037c5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042037c9:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042037cc:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042037cf:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042037d6:	00 00 00 
  80042037d9:	48 8b 00             	mov    (%rax),%rax
  80042037dc:	48 39 c2             	cmp    %rax,%rdx
  80042037df:	72 32                	jb     8004203813 <pgdir_walk+0x209>
  80042037e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042037e5:	48 89 c1             	mov    %rax,%rcx
  80042037e8:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042037ef:	00 00 00 
  80042037f2:	be 6f 02 00 00       	mov    $0x26f,%esi
  80042037f7:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042037fe:	00 00 00 
  8004203801:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203806:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420380d:	00 00 00 
  8004203810:	41 ff d0             	callq  *%r8
  8004203813:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420381a:	00 00 00 
  800420381d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203821:	48 01 d0             	add    %rdx,%rax
  8004203824:	eb 05                	jmp    800420382b <pgdir_walk+0x221>
		}
	}
	return NULL;
  8004203826:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420382b:	48 83 c4 58          	add    $0x58,%rsp
  800420382f:	5b                   	pop    %rbx
  8004203830:	5d                   	pop    %rbp
  8004203831:	c3                   	retq   

0000008004203832 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203832:	55                   	push   %rbp
  8004203833:	48 89 e5             	mov    %rsp,%rbp
  8004203836:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800420383a:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420383e:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203842:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004203846:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  800420384a:	44 89 45 8c          	mov    %r8d,-0x74(%rbp)
// Fill this function in
	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  800420384e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203855:	00 
  8004203856:	e9 aa 02 00 00       	jmpq   8004203b05 <boot_map_region+0x2d3>
		pte_t *pte      = pml4e_walk(pml4e, (void *)(la + i), 1);
  800420385b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420385f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203863:	48 01 d0             	add    %rdx,%rax
  8004203866:	48 89 c1             	mov    %rax,%rcx
  8004203869:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420386d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203872:	48 89 ce             	mov    %rcx,%rsi
  8004203875:	48 89 c7             	mov    %rax,%rdi
  8004203878:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  800420387f:	00 00 00 
  8004203882:	ff d0                	callq  *%rax
  8004203884:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		physaddr_t addr = pa + i;
  8004203888:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420388c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203890:	48 01 d0             	add    %rdx,%rax
  8004203893:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pte != NULL) {
  8004203897:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420389c:	74 23                	je     80042038c1 <boot_map_region+0x8f>
			*pte    = PTE_ADDR(addr)|perm|PTE_P;
  800420389e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038a2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042038a8:	48 89 c2             	mov    %rax,%rdx
  80042038ab:	8b 45 8c             	mov    -0x74(%rbp),%eax
  80042038ae:	48 98                	cltq   
  80042038b0:	48 09 d0             	or     %rdx,%rax
  80042038b3:	48 83 c8 01          	or     $0x1,%rax
  80042038b7:	48 89 c2             	mov    %rax,%rdx
  80042038ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042038be:	48 89 10             	mov    %rdx,(%rax)
		}
		pml4e [PML4(la+i)]   = pml4e [PML4(la+i)]|perm|PTE_P;
  80042038c1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042038c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038c9:	48 01 d0             	add    %rdx,%rax
  80042038cc:	48 c1 e8 27          	shr    $0x27,%rax
  80042038d0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042038d5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042038dc:	00 
  80042038dd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042038e1:	48 01 d0             	add    %rdx,%rax
  80042038e4:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042038e8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042038ec:	48 01 ca             	add    %rcx,%rdx
  80042038ef:	48 c1 ea 27          	shr    $0x27,%rdx
  80042038f3:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042038f9:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203900:	00 
  8004203901:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203905:	48 01 ca             	add    %rcx,%rdx
  8004203908:	48 8b 0a             	mov    (%rdx),%rcx
  800420390b:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420390e:	48 63 d2             	movslq %edx,%rdx
  8004203911:	48 09 ca             	or     %rcx,%rdx
  8004203914:	48 83 ca 01          	or     $0x1,%rdx
  8004203918:	48 89 10             	mov    %rdx,(%rax)
		pdpe                 = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(la + i)]));
  800420391b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420391f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203923:	48 01 d0             	add    %rdx,%rax
  8004203926:	48 c1 e8 27          	shr    $0x27,%rax
  800420392a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420392f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203936:	00 
  8004203937:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420393b:	48 01 d0             	add    %rdx,%rax
  800420393e:	48 8b 00             	mov    (%rax),%rax
  8004203941:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203947:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420394b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420394f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203953:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203956:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203959:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203960:	00 00 00 
  8004203963:	48 8b 00             	mov    (%rax),%rax
  8004203966:	48 39 c2             	cmp    %rax,%rdx
  8004203969:	72 32                	jb     800420399d <boot_map_region+0x16b>
  800420396b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420396f:	48 89 c1             	mov    %rax,%rcx
  8004203972:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004203979:	00 00 00 
  800420397c:	be 8e 02 00 00       	mov    $0x28e,%esi
  8004203981:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203988:	00 00 00 
  800420398b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203990:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004203997:	00 00 00 
  800420399a:	41 ff d0             	callq  *%r8
  800420399d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042039a4:	00 00 00 
  80042039a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042039ab:	48 01 d0             	add    %rdx,%rax
  80042039ae:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
  80042039b2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042039b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039ba:	48 01 d0             	add    %rdx,%rax
  80042039bd:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042039c1:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042039c6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042039cd:	00 
  80042039ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042039d2:	48 01 d0             	add    %rdx,%rax
  80042039d5:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042039d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042039dd:	48 01 ca             	add    %rcx,%rdx
  80042039e0:	48 c1 ea 1e          	shr    $0x1e,%rdx
  80042039e4:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042039ea:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  80042039f1:	00 
  80042039f2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042039f6:	48 01 ca             	add    %rcx,%rdx
  80042039f9:	48 8b 0a             	mov    (%rdx),%rcx
  80042039fc:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042039ff:	48 63 d2             	movslq %edx,%rdx
  8004203a02:	48 09 ca             	or     %rcx,%rdx
  8004203a05:	48 83 ca 01          	or     $0x1,%rdx
  8004203a09:	48 89 10             	mov    %rdx,(%rax)
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
  8004203a0c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203a10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a14:	48 01 d0             	add    %rdx,%rax
  8004203a17:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203a1b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203a20:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203a27:	00 
  8004203a28:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203a2c:	48 01 d0             	add    %rdx,%rax
  8004203a2f:	48 8b 00             	mov    (%rax),%rax
  8004203a32:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203a38:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203a3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a40:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203a44:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203a47:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203a4a:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203a51:	00 00 00 
  8004203a54:	48 8b 00             	mov    (%rax),%rax
  8004203a57:	48 39 c2             	cmp    %rax,%rdx
  8004203a5a:	72 32                	jb     8004203a8e <boot_map_region+0x25c>
  8004203a5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a60:	48 89 c1             	mov    %rax,%rcx
  8004203a63:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004203a6a:	00 00 00 
  8004203a6d:	be 90 02 00 00       	mov    $0x290,%esi
  8004203a72:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203a79:	00 00 00 
  8004203a7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a81:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004203a88:	00 00 00 
  8004203a8b:	41 ff d0             	callq  *%r8
  8004203a8e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203a95:	00 00 00 
  8004203a98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a9c:	48 01 d0             	add    %rdx,%rax
  8004203a9f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
  8004203aa3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203aa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203aab:	48 01 d0             	add    %rdx,%rax
  8004203aae:	48 c1 e8 15          	shr    $0x15,%rax
  8004203ab2:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ab7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203abe:	00 
  8004203abf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203ac3:	48 01 d0             	add    %rdx,%rax
  8004203ac6:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203aca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ace:	48 01 ca             	add    %rcx,%rdx
  8004203ad1:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203ad5:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203adb:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203ae2:	00 
  8004203ae3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203ae7:	48 01 ca             	add    %rcx,%rdx
  8004203aea:	48 8b 0a             	mov    (%rdx),%rcx
  8004203aed:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203af0:	48 63 d2             	movslq %edx,%rdx
  8004203af3:	48 09 ca             	or     %rcx,%rdx
  8004203af6:	48 83 ca 01          	or     $0x1,%rdx
  8004203afa:	48 89 10             	mov    %rdx,(%rax)
	for (i = 0; i < size; i+=PGSIZE) {
  8004203afd:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203b04:	00 
  8004203b05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b09:	48 3b 45 98          	cmp    -0x68(%rbp),%rax
  8004203b0d:	0f 82 48 fd ff ff    	jb     800420385b <boot_map_region+0x29>
	}
}
  8004203b13:	c9                   	leaveq 
  8004203b14:	c3                   	retq   

0000008004203b15 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203b15:	55                   	push   %rbp
  8004203b16:	48 89 e5             	mov    %rsp,%rbp
  8004203b19:	48 83 ec 60          	sub    $0x60,%rsp
  8004203b1d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203b21:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203b25:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004203b29:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
	pdpe_t *pdpe;
	pde_t *pde;
	if (pml4e && pp) {
  8004203b2c:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203b31:	0f 84 4b 03 00 00    	je     8004203e82 <page_insert+0x36d>
  8004203b37:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004203b3c:	0f 84 40 03 00 00    	je     8004203e82 <page_insert+0x36d>
		pte_t *pte  = pml4e_walk(pml4e, va, 1);
  8004203b42:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004203b46:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203b4a:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203b4f:	48 89 ce             	mov    %rcx,%rsi
  8004203b52:	48 89 c7             	mov    %rax,%rdi
  8004203b55:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004203b5c:	00 00 00 
  8004203b5f:	ff d0                	callq  *%rax
  8004203b61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL) {
  8004203b65:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203b6a:	0f 84 0b 03 00 00    	je     8004203e7b <page_insert+0x366>
			pml4e [PML4(va)] = pml4e [PML4(va)]|(perm&(~PTE_AVAIL));
  8004203b70:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203b74:	48 c1 e8 27          	shr    $0x27,%rax
  8004203b78:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203b7d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203b84:	00 
  8004203b85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203b89:	48 01 d0             	add    %rdx,%rax
  8004203b8c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203b90:	48 c1 ea 27          	shr    $0x27,%rdx
  8004203b94:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203b9a:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203ba1:	00 
  8004203ba2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203ba6:	48 01 ca             	add    %rcx,%rdx
  8004203ba9:	48 8b 0a             	mov    (%rdx),%rcx
  8004203bac:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203baf:	80 e6 f1             	and    $0xf1,%dh
  8004203bb2:	48 63 d2             	movslq %edx,%rdx
  8004203bb5:	48 09 ca             	or     %rcx,%rdx
  8004203bb8:	48 89 10             	mov    %rdx,(%rax)
			pdpe = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004203bbb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bbf:	48 c1 e8 27          	shr    $0x27,%rax
  8004203bc3:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203bc8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203bcf:	00 
  8004203bd0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203bd4:	48 01 d0             	add    %rdx,%rax
  8004203bd7:	48 8b 00             	mov    (%rax),%rax
  8004203bda:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203be0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203be4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203be8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203bec:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004203bef:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004203bf2:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203bf9:	00 00 00 
  8004203bfc:	48 8b 00             	mov    (%rax),%rax
  8004203bff:	48 39 c2             	cmp    %rax,%rdx
  8004203c02:	72 32                	jb     8004203c36 <page_insert+0x121>
  8004203c04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c08:	48 89 c1             	mov    %rax,%rcx
  8004203c0b:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004203c12:	00 00 00 
  8004203c15:	be b7 02 00 00       	mov    $0x2b7,%esi
  8004203c1a:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203c21:	00 00 00 
  8004203c24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c29:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004203c30:	00 00 00 
  8004203c33:	41 ff d0             	callq  *%r8
  8004203c36:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203c3d:	00 00 00 
  8004203c40:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c44:	48 01 d0             	add    %rdx,%rax
  8004203c47:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			pdpe[PDPE(va)] = pdpe[PDPE(va)]|(perm&(~PTE_AVAIL));
  8004203c4b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203c4f:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203c53:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c58:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203c5f:	00 
  8004203c60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c64:	48 01 d0             	add    %rdx,%rax
  8004203c67:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203c6b:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004203c6f:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203c75:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203c7c:	00 
  8004203c7d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203c81:	48 01 ca             	add    %rcx,%rdx
  8004203c84:	48 8b 0a             	mov    (%rdx),%rcx
  8004203c87:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203c8a:	80 e6 f1             	and    $0xf1,%dh
  8004203c8d:	48 63 d2             	movslq %edx,%rdx
  8004203c90:	48 09 ca             	or     %rcx,%rdx
  8004203c93:	48 89 10             	mov    %rdx,(%rax)
			pde = (pde_t *)KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004203c96:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203c9a:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203c9e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ca3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203caa:	00 
  8004203cab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203caf:	48 01 d0             	add    %rdx,%rax
  8004203cb2:	48 8b 00             	mov    (%rax),%rax
  8004203cb5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203cbb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203cbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203cc3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203cc7:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203cca:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203ccd:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004203cd4:	00 00 00 
  8004203cd7:	48 8b 00             	mov    (%rax),%rax
  8004203cda:	48 39 c2             	cmp    %rax,%rdx
  8004203cdd:	72 32                	jb     8004203d11 <page_insert+0x1fc>
  8004203cdf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203ce3:	48 89 c1             	mov    %rax,%rcx
  8004203ce6:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004203ced:	00 00 00 
  8004203cf0:	be b9 02 00 00       	mov    $0x2b9,%esi
  8004203cf5:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203cfc:	00 00 00 
  8004203cff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d04:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004203d0b:	00 00 00 
  8004203d0e:	41 ff d0             	callq  *%r8
  8004203d11:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203d18:	00 00 00 
  8004203d1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203d1f:	48 01 d0             	add    %rdx,%rax
  8004203d22:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			pde[PDX(va)] = pde[PDX(va)]|(perm&(~PTE_AVAIL));
  8004203d26:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203d2a:	48 c1 e8 15          	shr    $0x15,%rax
  8004203d2e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203d33:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203d3a:	00 
  8004203d3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203d3f:	48 01 d0             	add    %rdx,%rax
  8004203d42:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203d46:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203d4a:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203d50:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203d57:	00 
  8004203d58:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203d5c:	48 01 ca             	add    %rcx,%rdx
  8004203d5f:	48 8b 0a             	mov    (%rdx),%rcx
  8004203d62:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203d65:	80 e6 f1             	and    $0xf1,%dh
  8004203d68:	48 63 d2             	movslq %edx,%rdx
  8004203d6b:	48 09 ca             	or     %rcx,%rdx
  8004203d6e:	48 89 10             	mov    %rdx,(%rax)
			if ((*pte & PTE_P) && (page2pa(pp) == PTE_ADDR(*pte))) {
  8004203d71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d75:	48 8b 00             	mov    (%rax),%rax
  8004203d78:	83 e0 01             	and    $0x1,%eax
  8004203d7b:	48 85 c0             	test   %rax,%rax
  8004203d7e:	74 72                	je     8004203df2 <page_insert+0x2dd>
  8004203d80:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d84:	48 89 c7             	mov    %rax,%rdi
  8004203d87:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004203d8e:	00 00 00 
  8004203d91:	ff d0                	callq  *%rax
  8004203d93:	48 89 c2             	mov    %rax,%rdx
  8004203d96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d9a:	48 8b 00             	mov    (%rax),%rax
  8004203d9d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203da3:	48 39 c2             	cmp    %rax,%rdx
  8004203da6:	75 4a                	jne    8004203df2 <page_insert+0x2dd>
				*pte    = PTE_ADDR(*pte)|perm|PTE_P;
  8004203da8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dac:	48 8b 00             	mov    (%rax),%rax
  8004203daf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203db5:	48 89 c2             	mov    %rax,%rdx
  8004203db8:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203dbb:	48 98                	cltq   
  8004203dbd:	48 09 d0             	or     %rdx,%rax
  8004203dc0:	48 83 c8 01          	or     $0x1,%rax
  8004203dc4:	48 89 c2             	mov    %rax,%rdx
  8004203dc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dcb:	48 89 10             	mov    %rdx,(%rax)
				tlb_invalidate(pml4e, va);
  8004203dce:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203dd2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203dd6:	48 89 d6             	mov    %rdx,%rsi
  8004203dd9:	48 89 c7             	mov    %rax,%rdi
  8004203ddc:	48 b8 87 3f 20 04 80 	movabs $0x8004203f87,%rax
  8004203de3:	00 00 00 
  8004203de6:	ff d0                	callq  *%rax
				return 0;
  8004203de8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ded:	e9 95 00 00 00       	jmpq   8004203e87 <page_insert+0x372>
			} else if (*pte & PTE_P) {
  8004203df2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203df6:	48 8b 00             	mov    (%rax),%rax
  8004203df9:	83 e0 01             	and    $0x1,%eax
  8004203dfc:	48 85 c0             	test   %rax,%rax
  8004203dff:	74 1a                	je     8004203e1b <page_insert+0x306>
				page_remove(pml4e, va);
  8004203e01:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203e05:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203e09:	48 89 d6             	mov    %rdx,%rsi
  8004203e0c:	48 89 c7             	mov    %rax,%rdi
  8004203e0f:	48 b8 14 3f 20 04 80 	movabs $0x8004203f14,%rax
  8004203e16:	00 00 00 
  8004203e19:	ff d0                	callq  *%rax
			}
			pp->pp_ref  += 1;
  8004203e1b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203e1f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203e23:	8d 50 01             	lea    0x1(%rax),%edx
  8004203e26:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203e2a:	66 89 50 08          	mov    %dx,0x8(%rax)
			*pte    = page2pa(pp)|perm|PTE_P;
  8004203e2e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203e32:	48 89 c7             	mov    %rax,%rdi
  8004203e35:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004203e3c:	00 00 00 
  8004203e3f:	ff d0                	callq  *%rax
  8004203e41:	48 89 c2             	mov    %rax,%rdx
  8004203e44:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203e47:	48 98                	cltq   
  8004203e49:	48 09 d0             	or     %rdx,%rax
  8004203e4c:	48 83 c8 01          	or     $0x1,%rax
  8004203e50:	48 89 c2             	mov    %rax,%rdx
  8004203e53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e57:	48 89 10             	mov    %rdx,(%rax)
			tlb_invalidate(pml4e, va);
  8004203e5a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203e5e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203e62:	48 89 d6             	mov    %rdx,%rsi
  8004203e65:	48 89 c7             	mov    %rax,%rdi
  8004203e68:	48 b8 87 3f 20 04 80 	movabs $0x8004203f87,%rax
  8004203e6f:	00 00 00 
  8004203e72:	ff d0                	callq  *%rax
			return 0;
  8004203e74:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e79:	eb 0c                	jmp    8004203e87 <page_insert+0x372>
		}else
			return -E_NO_MEM;
  8004203e7b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203e80:	eb 05                	jmp    8004203e87 <page_insert+0x372>
	}
	return -E_NO_MEM;
  8004203e82:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  8004203e87:	c9                   	leaveq 
  8004203e88:	c3                   	retq   

0000008004203e89 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203e89:	55                   	push   %rbp
  8004203e8a:	48 89 e5             	mov    %rsp,%rbp
  8004203e8d:	48 83 ec 30          	sub    $0x30,%rsp
  8004203e91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203e95:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203e99:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	if (pml4e != NULL) {
  8004203e9d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203ea2:	74 69                	je     8004203f0d <page_lookup+0x84>
		pte_t *pte  = pml4e_walk(pml4e, va, 0);
  8004203ea4:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203ea8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203eac:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203eb1:	48 89 ce             	mov    %rcx,%rsi
  8004203eb4:	48 89 c7             	mov    %rax,%rdi
  8004203eb7:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004203ebe:	00 00 00 
  8004203ec1:	ff d0                	callq  *%rax
  8004203ec3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL && (*pte & PTE_P)) {
  8004203ec7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ecc:	74 3f                	je     8004203f0d <page_lookup+0x84>
  8004203ece:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ed2:	48 8b 00             	mov    (%rax),%rax
  8004203ed5:	83 e0 01             	and    $0x1,%eax
  8004203ed8:	48 85 c0             	test   %rax,%rax
  8004203edb:	74 30                	je     8004203f0d <page_lookup+0x84>
			if (pte_store)
  8004203edd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203ee2:	74 0b                	je     8004203eef <page_lookup+0x66>
				*pte_store  = pte;
  8004203ee4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203ee8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203eec:	48 89 10             	mov    %rdx,(%rax)
			return pa2page(PTE_ADDR(*pte));
  8004203eef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ef3:	48 8b 00             	mov    (%rax),%rax
  8004203ef6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203efc:	48 89 c7             	mov    %rax,%rdi
  8004203eff:	48 b8 4f 1c 20 04 80 	movabs $0x8004201c4f,%rax
  8004203f06:	00 00 00 
  8004203f09:	ff d0                	callq  *%rax
  8004203f0b:	eb 05                	jmp    8004203f12 <page_lookup+0x89>
		}
	}
	return NULL;
  8004203f0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203f12:	c9                   	leaveq 
  8004203f13:	c3                   	retq   

0000008004203f14 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203f14:	55                   	push   %rbp
  8004203f15:	48 89 e5             	mov    %rsp,%rbp
  8004203f18:	48 83 ec 20          	sub    $0x20,%rsp
  8004203f1c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203f20:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	pte_t *pte;
	struct PageInfo *page   = page_lookup(pml4e, va, &pte);
  8004203f24:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203f28:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203f2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f30:	48 89 ce             	mov    %rcx,%rsi
  8004203f33:	48 89 c7             	mov    %rax,%rdi
  8004203f36:	48 b8 89 3e 20 04 80 	movabs $0x8004203e89,%rax
  8004203f3d:	00 00 00 
  8004203f40:	ff d0                	callq  *%rax
  8004203f42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (page != NULL) {
  8004203f46:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f4b:	74 38                	je     8004203f85 <page_remove+0x71>
		tlb_invalidate(pml4e, va);
  8004203f4d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203f51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f55:	48 89 d6             	mov    %rdx,%rsi
  8004203f58:	48 89 c7             	mov    %rax,%rdi
  8004203f5b:	48 b8 87 3f 20 04 80 	movabs $0x8004203f87,%rax
  8004203f62:	00 00 00 
  8004203f65:	ff d0                	callq  *%rax
		page_decref(page);
  8004203f67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f6b:	48 89 c7             	mov    %rax,%rdi
  8004203f6e:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004203f75:	00 00 00 
  8004203f78:	ff d0                	callq  *%rax
		*pte    = 0;
  8004203f7a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203f7e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
}
  8004203f85:	c9                   	leaveq 
  8004203f86:	c3                   	retq   

0000008004203f87 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203f87:	55                   	push   %rbp
  8004203f88:	48 89 e5             	mov    %rsp,%rbp
  8004203f8b:	48 83 ec 20          	sub    $0x20,%rsp
  8004203f8f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203f93:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203f97:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203f9c:	75 35                	jne    8004203fd3 <tlb_invalidate+0x4c>
  8004203f9e:	48 b9 c7 4c 21 04 80 	movabs $0x8004214cc7,%rcx
  8004203fa5:	00 00 00 
  8004203fa8:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004203faf:	00 00 00 
  8004203fb2:	be 08 03 00 00       	mov    $0x308,%esi
  8004203fb7:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004203fbe:	00 00 00 
  8004203fc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fc6:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004203fcd:	00 00 00 
  8004203fd0:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203fd3:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004203fda:	00 00 00 
  8004203fdd:	ff d0                	callq  *%rax
  8004203fdf:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004203fe6:	00 00 00 
  8004203fe9:	48 98                	cltq   
  8004203feb:	48 c1 e0 03          	shl    $0x3,%rax
  8004203fef:	48 89 c1             	mov    %rax,%rcx
  8004203ff2:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203ff6:	48 01 c8             	add    %rcx,%rax
  8004203ff9:	48 01 d0             	add    %rdx,%rax
  8004203ffc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004204000:	48 85 c0             	test   %rax,%rax
  8004204003:	74 3a                	je     800420403f <tlb_invalidate+0xb8>
  8004204005:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420400c:	00 00 00 
  800420400f:	ff d0                	callq  *%rax
  8004204011:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004204018:	00 00 00 
  800420401b:	48 98                	cltq   
  800420401d:	48 c1 e0 03          	shl    $0x3,%rax
  8004204021:	48 89 c1             	mov    %rax,%rcx
  8004204024:	48 c1 e1 04          	shl    $0x4,%rcx
  8004204028:	48 01 c8             	add    %rcx,%rax
  800420402b:	48 01 d0             	add    %rdx,%rax
  800420402e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004204032:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004204039:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420403d:	75 0f                	jne    800420404e <tlb_invalidate+0xc7>
  800420403f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204043:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004204047:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420404b:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  800420404e:	c9                   	leaveq 
  800420404f:	c3                   	retq   

0000008004204050 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004204050:	55                   	push   %rbp
  8004204051:	48 89 e5             	mov    %rsp,%rbp
  8004204054:	48 83 ec 30          	sub    $0x30,%rsp
  8004204058:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420405c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	uintptr_t va = base;
  8004204060:	48 b8 20 86 22 04 80 	movabs $0x8004228620,%rax
  8004204067:	00 00 00 
  800420406a:	48 8b 00             	mov    (%rax),%rax
  800420406d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size = ROUNDUP(size, PGSIZE);
  8004204071:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004204078:	00 
  8004204079:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420407d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204081:	48 01 d0             	add    %rdx,%rax
  8004204084:	48 83 e8 01          	sub    $0x1,%rax
  8004204088:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420408c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204090:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204095:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004204099:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420409d:	48 29 d0             	sub    %rdx,%rax
  80042040a0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	base += size;
  80042040a4:	48 b8 20 86 22 04 80 	movabs $0x8004228620,%rax
  80042040ab:	00 00 00 
  80042040ae:	48 8b 10             	mov    (%rax),%rdx
  80042040b1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042040b5:	48 01 c2             	add    %rax,%rdx
  80042040b8:	48 b8 20 86 22 04 80 	movabs $0x8004228620,%rax
  80042040bf:	00 00 00 
  80042040c2:	48 89 10             	mov    %rdx,(%rax)
	if (base >= MMIOLIM)
  80042040c5:	48 b8 20 86 22 04 80 	movabs $0x8004228620,%rax
  80042040cc:	00 00 00 
  80042040cf:	48 8b 10             	mov    (%rax),%rdx
  80042040d2:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042040d9:	00 00 00 
  80042040dc:	48 39 c2             	cmp    %rax,%rdx
  80042040df:	76 2a                	jbe    800420410b <mmio_map_region+0xbb>
		panic("MMIO mappings exceeded MMIOLIM");
  80042040e1:	48 ba d8 4c 21 04 80 	movabs $0x8004214cd8,%rdx
  80042040e8:	00 00 00 
  80042040eb:	be 32 03 00 00       	mov    $0x332,%esi
  80042040f0:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042040f7:	00 00 00 
  80042040fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040ff:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004204106:	00 00 00 
  8004204109:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, va, size, pa, PTE_P|PTE_W|PTE_PWT|PTE_PCD);
  800420410b:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004204112:	00 00 00 
  8004204115:	48 8b 00             	mov    (%rax),%rax
  8004204118:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420411c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204120:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004204124:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  800420412a:	48 89 c7             	mov    %rax,%rdi
  800420412d:	48 b8 32 38 20 04 80 	movabs $0x8004203832,%rax
  8004204134:	00 00 00 
  8004204137:	ff d0                	callq  *%rax
	return (void*) va;
  8004204139:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420413d:	c9                   	leaveq 
  800420413e:	c3                   	retq   

000000800420413f <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  800420413f:	55                   	push   %rbp
  8004204140:	48 89 e5             	mov    %rsp,%rbp
  8004204143:	48 83 ec 40          	sub    $0x40,%rsp
  8004204147:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420414b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420414f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004204153:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	const void *endva = (const void *) ((uintptr_t) va + len);
  8004204156:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420415a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420415e:	48 01 d0             	add    %rdx,%rax
  8004204161:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
  8004204165:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204169:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004204170:	00 00 00 
  8004204173:	48 39 c2             	cmp    %rax,%rdx
  8004204176:	77 0a                	ja     8004204182 <user_mem_check+0x43>
  8004204178:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420417c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204180:	76 1b                	jbe    800420419d <user_mem_check+0x5e>
		user_mem_check_addr = (uintptr_t) va;
  8004204182:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204186:	48 b8 60 b2 57 04 80 	movabs $0x800457b260,%rax
  800420418d:	00 00 00 
  8004204190:	48 89 10             	mov    %rdx,(%rax)
		return -E_FAULT;
  8004204193:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004204198:	e9 ba 00 00 00       	jmpq   8004204257 <user_mem_check+0x118>
	}
	while(va<endva){
  800420419d:	e9 a2 00 00 00       	jmpq   8004204244 <user_mem_check+0x105>
		ptep = pml4e_walk(env->env_pml4e,va,0);
  80042041a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042041a6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042041ad:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042041b1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042041b6:	48 89 ce             	mov    %rcx,%rsi
  80042041b9:	48 89 c7             	mov    %rax,%rdi
  80042041bc:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  80042041c3:	00 00 00 
  80042041c6:	ff d0                	callq  *%rax
  80042041c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!ptep || (*ptep & (perm | PTE_P)) != (perm | PTE_P)) {
  80042041cc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042041d1:	74 1f                	je     80042041f2 <user_mem_check+0xb3>
  80042041d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042041d7:	48 8b 10             	mov    (%rax),%rdx
  80042041da:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042041dd:	83 c8 01             	or     $0x1,%eax
  80042041e0:	48 98                	cltq   
  80042041e2:	48 21 c2             	and    %rax,%rdx
  80042041e5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042041e8:	83 c8 01             	or     $0x1,%eax
  80042041eb:	48 98                	cltq   
  80042041ed:	48 39 c2             	cmp    %rax,%rdx
  80042041f0:	74 18                	je     800420420a <user_mem_check+0xcb>
			user_mem_check_addr = (uintptr_t) va;
  80042041f2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042041f6:	48 b8 60 b2 57 04 80 	movabs $0x800457b260,%rax
  80042041fd:	00 00 00 
  8004204200:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004204203:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004204208:	eb 4d                	jmp    8004204257 <user_mem_check+0x118>
		}
		va = ROUNDUP(va+1,PGSIZE);
  800420420a:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004204211:	00 
  8004204212:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204216:	48 83 c0 01          	add    $0x1,%rax
  800420421a:	48 89 c2             	mov    %rax,%rdx
  800420421d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204221:	48 01 d0             	add    %rdx,%rax
  8004204224:	48 83 e8 01          	sub    $0x1,%rax
  8004204228:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420422c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204230:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204235:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004204239:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420423d:	48 29 d0             	sub    %rdx,%rax
  8004204240:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	while(va<endva){
  8004204244:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204248:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420424c:	0f 82 50 ff ff ff    	jb     80042041a2 <user_mem_check+0x63>
	}
	return 0;
  8004204252:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004204257:	c9                   	leaveq 
  8004204258:	c3                   	retq   

0000008004204259 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004204259:	55                   	push   %rbp
  800420425a:	48 89 e5             	mov    %rsp,%rbp
  800420425d:	48 83 ec 20          	sub    $0x20,%rsp
  8004204261:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004204265:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004204269:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420426d:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004204270:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204273:	83 c8 04             	or     $0x4,%eax
  8004204276:	89 c1                	mov    %eax,%ecx
  8004204278:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420427c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004204280:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204284:	48 89 c7             	mov    %rax,%rdi
  8004204287:	48 b8 3f 41 20 04 80 	movabs $0x800420413f,%rax
  800420428e:	00 00 00 
  8004204291:	ff d0                	callq  *%rax
  8004204293:	85 c0                	test   %eax,%eax
  8004204295:	79 47                	jns    80042042de <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004204297:	48 b8 60 b2 57 04 80 	movabs $0x800457b260,%rax
  800420429e:	00 00 00 
  80042042a1:	48 8b 10             	mov    (%rax),%rdx
  80042042a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042a8:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042042ae:	89 c6                	mov    %eax,%esi
  80042042b0:	48 bf f8 4c 21 04 80 	movabs $0x8004214cf8,%rdi
  80042042b7:	00 00 00 
  80042042ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042bf:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  80042042c6:	00 00 00 
  80042042c9:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042042cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042cf:	48 89 c7             	mov    %rax,%rdi
  80042042d2:	48 b8 4d 8e 20 04 80 	movabs $0x8004208e4d,%rax
  80042042d9:	00 00 00 
  80042042dc:	ff d0                	callq  *%rax
	}
}
  80042042de:	c9                   	leaveq 
  80042042df:	c3                   	retq   

00000080042042e0 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  80042042e0:	55                   	push   %rbp
  80042042e1:	48 89 e5             	mov    %rsp,%rbp
  80042042e4:	48 83 ec 60          	sub    $0x60,%rsp
  80042042e8:	89 f8                	mov    %edi,%eax
  80042042ea:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  80042042ed:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  80042042f1:	74 07                	je     80042042fa <check_page_free_list+0x1a>
  80042042f3:	b8 01 00 00 00       	mov    $0x1,%eax
  80042042f8:	eb 05                	jmp    80042042ff <check_page_free_list+0x1f>
  80042042fa:	b8 00 02 00 00       	mov    $0x200,%eax
  80042042ff:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004204302:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204309:	00 
  800420430a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204311:	00 
	void *first_free_page;

	if (!page_free_list)
  8004204312:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004204319:	00 00 00 
  800420431c:	48 8b 00             	mov    (%rax),%rax
  800420431f:	48 85 c0             	test   %rax,%rax
  8004204322:	75 2a                	jne    800420434e <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004204324:	48 ba 30 4d 21 04 80 	movabs $0x8004214d30,%rdx
  800420432b:	00 00 00 
  800420432e:	be 82 03 00 00       	mov    $0x382,%esi
  8004204333:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420433a:	00 00 00 
  800420433d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204342:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004204349:	00 00 00 
  800420434c:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  800420434e:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204352:	0f 84 a9 00 00 00    	je     8004204401 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004204358:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420435c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204360:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004204364:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204368:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  800420436f:	00 00 00 
  8004204372:	48 8b 00             	mov    (%rax),%rax
  8004204375:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204379:	eb 58                	jmp    80042043d3 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  800420437b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420437f:	48 89 c7             	mov    %rax,%rdi
  8004204382:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204389:	00 00 00 
  800420438c:	ff d0                	callq  *%rax
  800420438e:	48 c1 e8 15          	shr    $0x15,%rax
  8004204392:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204397:	48 89 c2             	mov    %rax,%rdx
  800420439a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420439d:	48 39 c2             	cmp    %rax,%rdx
  80042043a0:	0f 93 c0             	setae  %al
  80042043a3:	0f b6 c0             	movzbl %al,%eax
  80042043a6:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042043a9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042043ac:	48 98                	cltq   
  80042043ae:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042043b3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042043b7:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  80042043ba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042043be:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042043c1:	48 98                	cltq   
  80042043c3:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042043c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043cc:	48 8b 00             	mov    (%rax),%rax
  80042043cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042043d3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042043d8:	75 a1                	jne    800420437b <check_page_free_list+0x9b>
		}
		*tp[1] = 0;
  80042043da:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042043de:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  80042043e5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042043e9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042043ed:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  80042043f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042043f4:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  80042043fb:	00 00 00 
  80042043fe:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204401:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004204408:	00 00 00 
  800420440b:	48 8b 00             	mov    (%rax),%rax
  800420440e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204412:	eb 5e                	jmp    8004204472 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004204414:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204418:	48 89 c7             	mov    %rax,%rdi
  800420441b:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204422:	00 00 00 
  8004204425:	ff d0                	callq  *%rax
  8004204427:	48 c1 e8 15          	shr    $0x15,%rax
  800420442b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204430:	48 89 c2             	mov    %rax,%rdx
  8004204433:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204436:	48 39 c2             	cmp    %rax,%rdx
  8004204439:	73 2c                	jae    8004204467 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  800420443b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420443f:	48 89 c7             	mov    %rax,%rdi
  8004204442:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  8004204449:	00 00 00 
  800420444c:	ff d0                	callq  *%rax
  800420444e:	ba 80 00 00 00       	mov    $0x80,%edx
  8004204453:	be 97 00 00 00       	mov    $0x97,%esi
  8004204458:	48 89 c7             	mov    %rax,%rdi
  800420445b:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004204462:	00 00 00 
  8004204465:	ff d0                	callq  *%rax
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420446b:	48 8b 00             	mov    (%rax),%rax
  800420446e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204472:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204477:	75 9b                	jne    8004204414 <check_page_free_list+0x134>

	first_free_page = boot_alloc(0);
  8004204479:	bf 00 00 00 00       	mov    $0x0,%edi
  800420447e:	48 b8 e5 25 20 04 80 	movabs $0x80042025e5,%rax
  8004204485:	00 00 00 
  8004204488:	ff d0                	callq  *%rax
  800420448a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420448e:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004204495:	00 00 00 
  8004204498:	48 8b 00             	mov    (%rax),%rax
  800420449b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420449f:	e9 20 03 00 00       	jmpq   80042047c4 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042044a4:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  80042044ab:	00 00 00 
  80042044ae:	48 8b 00             	mov    (%rax),%rax
  80042044b1:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042044b5:	73 35                	jae    80042044ec <check_page_free_list+0x20c>
  80042044b7:	48 b9 54 4d 21 04 80 	movabs $0x8004214d54,%rcx
  80042044be:	00 00 00 
  80042044c1:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042044c8:	00 00 00 
  80042044cb:	be 9c 03 00 00       	mov    $0x39c,%esi
  80042044d0:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042044d7:	00 00 00 
  80042044da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044df:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042044e6:	00 00 00 
  80042044e9:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  80042044ec:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  80042044f3:	00 00 00 
  80042044f6:	48 8b 10             	mov    (%rax),%rdx
  80042044f9:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004204500:	00 00 00 
  8004204503:	48 8b 00             	mov    (%rax),%rax
  8004204506:	48 c1 e0 04          	shl    $0x4,%rax
  800420450a:	48 01 d0             	add    %rdx,%rax
  800420450d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204511:	77 35                	ja     8004204548 <check_page_free_list+0x268>
  8004204513:	48 b9 60 4d 21 04 80 	movabs $0x8004214d60,%rcx
  800420451a:	00 00 00 
  800420451d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204524:	00 00 00 
  8004204527:	be 9d 03 00 00       	mov    $0x39d,%esi
  800420452c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204533:	00 00 00 
  8004204536:	b8 00 00 00 00       	mov    $0x0,%eax
  800420453b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204542:	00 00 00 
  8004204545:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204548:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420454c:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004204553:	00 00 00 
  8004204556:	48 8b 00             	mov    (%rax),%rax
  8004204559:	48 29 c2             	sub    %rax,%rdx
  800420455c:	48 89 d0             	mov    %rdx,%rax
  800420455f:	83 e0 0f             	and    $0xf,%eax
  8004204562:	48 85 c0             	test   %rax,%rax
  8004204565:	74 35                	je     800420459c <check_page_free_list+0x2bc>
  8004204567:	48 b9 78 4d 21 04 80 	movabs $0x8004214d78,%rcx
  800420456e:	00 00 00 
  8004204571:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204578:	00 00 00 
  800420457b:	be 9e 03 00 00       	mov    $0x39e,%esi
  8004204580:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204587:	00 00 00 
  800420458a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420458f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204596:	00 00 00 
  8004204599:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  800420459c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045a0:	48 89 c7             	mov    %rax,%rdi
  80042045a3:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042045aa:	00 00 00 
  80042045ad:	ff d0                	callq  *%rax
  80042045af:	48 85 c0             	test   %rax,%rax
  80042045b2:	75 35                	jne    80042045e9 <check_page_free_list+0x309>
  80042045b4:	48 b9 aa 4d 21 04 80 	movabs $0x8004214daa,%rcx
  80042045bb:	00 00 00 
  80042045be:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042045c5:	00 00 00 
  80042045c8:	be a1 03 00 00       	mov    $0x3a1,%esi
  80042045cd:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042045d4:	00 00 00 
  80042045d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045dc:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042045e3:	00 00 00 
  80042045e6:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  80042045e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045ed:	48 89 c7             	mov    %rax,%rdi
  80042045f0:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042045f7:	00 00 00 
  80042045fa:	ff d0                	callq  *%rax
  80042045fc:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204602:	75 35                	jne    8004204639 <check_page_free_list+0x359>
  8004204604:	48 b9 bb 4d 21 04 80 	movabs $0x8004214dbb,%rcx
  800420460b:	00 00 00 
  800420460e:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204615:	00 00 00 
  8004204618:	be a2 03 00 00       	mov    $0x3a2,%esi
  800420461d:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204624:	00 00 00 
  8004204627:	b8 00 00 00 00       	mov    $0x0,%eax
  800420462c:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204633:	00 00 00 
  8004204636:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420463d:	48 89 c7             	mov    %rax,%rdi
  8004204640:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204647:	00 00 00 
  800420464a:	ff d0                	callq  *%rax
  800420464c:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204652:	75 35                	jne    8004204689 <check_page_free_list+0x3a9>
  8004204654:	48 b9 d8 4d 21 04 80 	movabs $0x8004214dd8,%rcx
  800420465b:	00 00 00 
  800420465e:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204665:	00 00 00 
  8004204668:	be a3 03 00 00       	mov    $0x3a3,%esi
  800420466d:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204674:	00 00 00 
  8004204677:	b8 00 00 00 00       	mov    $0x0,%eax
  800420467c:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204683:	00 00 00 
  8004204686:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004204689:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420468d:	48 89 c7             	mov    %rax,%rdi
  8004204690:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204697:	00 00 00 
  800420469a:	ff d0                	callq  *%rax
  800420469c:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042046a2:	75 35                	jne    80042046d9 <check_page_free_list+0x3f9>
  80042046a4:	48 b9 fb 4d 21 04 80 	movabs $0x8004214dfb,%rcx
  80042046ab:	00 00 00 
  80042046ae:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042046b5:	00 00 00 
  80042046b8:	be a4 03 00 00       	mov    $0x3a4,%esi
  80042046bd:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042046c4:	00 00 00 
  80042046c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046cc:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042046d3:	00 00 00 
  80042046d6:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || page2kva(pp) >= first_free_page);
  80042046d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046dd:	48 89 c7             	mov    %rax,%rdi
  80042046e0:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042046e7:	00 00 00 
  80042046ea:	ff d0                	callq  *%rax
  80042046ec:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042046f2:	76 4e                	jbe    8004204742 <check_page_free_list+0x462>
  80042046f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046f8:	48 89 c7             	mov    %rax,%rdi
  80042046fb:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  8004204702:	00 00 00 
  8004204705:	ff d0                	callq  *%rax
  8004204707:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420470b:	73 35                	jae    8004204742 <check_page_free_list+0x462>
  800420470d:	48 b9 18 4e 21 04 80 	movabs $0x8004214e18,%rcx
  8004204714:	00 00 00 
  8004204717:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420471e:	00 00 00 
  8004204721:	be a5 03 00 00       	mov    $0x3a5,%esi
  8004204726:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420472d:	00 00 00 
  8004204730:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204735:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420473c:	00 00 00 
  800420473f:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204742:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204746:	48 89 c7             	mov    %rax,%rdi
  8004204749:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204750:	00 00 00 
  8004204753:	ff d0                	callq  *%rax
  8004204755:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  800420475b:	75 35                	jne    8004204792 <check_page_free_list+0x4b2>
  800420475d:	48 b9 54 4e 21 04 80 	movabs $0x8004214e54,%rcx
  8004204764:	00 00 00 
  8004204767:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420476e:	00 00 00 
  8004204771:	be a7 03 00 00       	mov    $0x3a7,%esi
  8004204776:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420477d:	00 00 00 
  8004204780:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204785:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420478c:	00 00 00 
  800420478f:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004204792:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204796:	48 89 c7             	mov    %rax,%rdi
  8004204799:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042047a0:	00 00 00 
  80042047a3:	ff d0                	callq  *%rax
  80042047a5:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042047ab:	77 07                	ja     80042047b4 <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042047ad:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042047b2:	eb 05                	jmp    80042047b9 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042047b4:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042047b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047bd:	48 8b 00             	mov    (%rax),%rax
  80042047c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042047c4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042047c9:	0f 85 d5 fc ff ff    	jne    80042044a4 <check_page_free_list+0x1c4>
	}

	assert(nfree_extmem > 0);
  80042047cf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042047d4:	75 35                	jne    800420480b <check_page_free_list+0x52b>
  80042047d6:	48 b9 71 4e 21 04 80 	movabs $0x8004214e71,%rcx
  80042047dd:	00 00 00 
  80042047e0:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042047e7:	00 00 00 
  80042047ea:	be af 03 00 00       	mov    $0x3af,%esi
  80042047ef:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042047f6:	00 00 00 
  80042047f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047fe:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204805:	00 00 00 
  8004204808:	41 ff d0             	callq  *%r8
}
  800420480b:	c9                   	leaveq 
  800420480c:	c3                   	retq   

000000800420480d <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  800420480d:	55                   	push   %rbp
  800420480e:	48 89 e5             	mov    %rsp,%rbp
  8004204811:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204815:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  800420481c:	00 00 00 
  800420481f:	48 8b 00             	mov    (%rax),%rax
  8004204822:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204826:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420482d:	eb 37                	jmp    8004204866 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  800420482f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204833:	48 89 c7             	mov    %rax,%rdi
  8004204836:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  800420483d:	00 00 00 
  8004204840:	ff d0                	callq  *%rax
  8004204842:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204847:	be 97 00 00 00       	mov    $0x97,%esi
  800420484c:	48 89 c7             	mov    %rax,%rdi
  800420484f:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004204856:	00 00 00 
  8004204859:	ff d0                	callq  *%rax
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420485b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420485f:	48 8b 00             	mov    (%rax),%rax
  8004204862:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204866:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420486b:	75 c2                	jne    800420482f <check_page_alloc+0x22>
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420486d:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004204874:	00 00 00 
  8004204877:	48 8b 00             	mov    (%rax),%rax
  800420487a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420487e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204885:	e9 ec 01 00 00       	jmpq   8004204a76 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  800420488a:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004204891:	00 00 00 
  8004204894:	48 8b 00             	mov    (%rax),%rax
  8004204897:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420489b:	73 35                	jae    80042048d2 <check_page_alloc+0xc5>
  800420489d:	48 b9 82 4e 21 04 80 	movabs $0x8004214e82,%rcx
  80042048a4:	00 00 00 
  80042048a7:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042048ae:	00 00 00 
  80042048b1:	be c9 03 00 00       	mov    $0x3c9,%esi
  80042048b6:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042048bd:	00 00 00 
  80042048c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048c5:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042048cc:	00 00 00 
  80042048cf:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042048d2:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  80042048d9:	00 00 00 
  80042048dc:	48 8b 10             	mov    (%rax),%rdx
  80042048df:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042048e6:	00 00 00 
  80042048e9:	48 8b 00             	mov    (%rax),%rax
  80042048ec:	48 c1 e0 04          	shl    $0x4,%rax
  80042048f0:	48 01 d0             	add    %rdx,%rax
  80042048f3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042048f7:	77 35                	ja     800420492e <check_page_alloc+0x121>
  80042048f9:	48 b9 8f 4e 21 04 80 	movabs $0x8004214e8f,%rcx
  8004204900:	00 00 00 
  8004204903:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420490a:	00 00 00 
  800420490d:	be ca 03 00 00       	mov    $0x3ca,%esi
  8004204912:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204919:	00 00 00 
  800420491c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204921:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204928:	00 00 00 
  800420492b:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420492e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204932:	48 89 c7             	mov    %rax,%rdi
  8004204935:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  800420493c:	00 00 00 
  800420493f:	ff d0                	callq  *%rax
  8004204941:	48 85 c0             	test   %rax,%rax
  8004204944:	75 35                	jne    800420497b <check_page_alloc+0x16e>
  8004204946:	48 b9 a4 4e 21 04 80 	movabs $0x8004214ea4,%rcx
  800420494d:	00 00 00 
  8004204950:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204957:	00 00 00 
  800420495a:	be cd 03 00 00       	mov    $0x3cd,%esi
  800420495f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204966:	00 00 00 
  8004204969:	b8 00 00 00 00       	mov    $0x0,%eax
  800420496e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204975:	00 00 00 
  8004204978:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  800420497b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420497f:	48 89 c7             	mov    %rax,%rdi
  8004204982:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204989:	00 00 00 
  800420498c:	ff d0                	callq  *%rax
  800420498e:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204994:	75 35                	jne    80042049cb <check_page_alloc+0x1be>
  8004204996:	48 b9 b6 4e 21 04 80 	movabs $0x8004214eb6,%rcx
  800420499d:	00 00 00 
  80042049a0:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042049a7:	00 00 00 
  80042049aa:	be ce 03 00 00       	mov    $0x3ce,%esi
  80042049af:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042049b6:	00 00 00 
  80042049b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049be:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042049c5:	00 00 00 
  80042049c8:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042049cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049cf:	48 89 c7             	mov    %rax,%rdi
  80042049d2:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042049d9:	00 00 00 
  80042049dc:	ff d0                	callq  *%rax
  80042049de:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042049e4:	75 35                	jne    8004204a1b <check_page_alloc+0x20e>
  80042049e6:	48 b9 d0 4e 21 04 80 	movabs $0x8004214ed0,%rcx
  80042049ed:	00 00 00 
  80042049f0:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042049f7:	00 00 00 
  80042049fa:	be cf 03 00 00       	mov    $0x3cf,%esi
  80042049ff:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204a06:	00 00 00 
  8004204a09:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a0e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204a15:	00 00 00 
  8004204a18:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a1f:	48 89 c7             	mov    %rax,%rdi
  8004204a22:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204a29:	00 00 00 
  8004204a2c:	ff d0                	callq  *%rax
  8004204a2e:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204a34:	75 35                	jne    8004204a6b <check_page_alloc+0x25e>
  8004204a36:	48 b9 f4 4e 21 04 80 	movabs $0x8004214ef4,%rcx
  8004204a3d:	00 00 00 
  8004204a40:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204a47:	00 00 00 
  8004204a4a:	be d0 03 00 00       	mov    $0x3d0,%esi
  8004204a4f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204a56:	00 00 00 
  8004204a59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a5e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204a65:	00 00 00 
  8004204a68:	41 ff d0             	callq  *%r8
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204a6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a6f:	48 8b 00             	mov    (%rax),%rax
  8004204a72:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204a76:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a7b:	0f 85 09 fe ff ff    	jne    800420488a <check_page_alloc+0x7d>
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204a81:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204a88:	00 
  8004204a89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a8d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204a91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a95:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204a99:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a9e:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204aa5:	00 00 00 
  8004204aa8:	ff d0                	callq  *%rax
  8004204aaa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204aae:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204ab3:	75 35                	jne    8004204aea <check_page_alloc+0x2dd>
  8004204ab5:	48 b9 0f 4f 21 04 80 	movabs $0x8004214f0f,%rcx
  8004204abc:	00 00 00 
  8004204abf:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204ac6:	00 00 00 
  8004204ac9:	be d4 03 00 00       	mov    $0x3d4,%esi
  8004204ace:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204ad5:	00 00 00 
  8004204ad8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204add:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204ae4:	00 00 00 
  8004204ae7:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204aea:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204aef:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204af6:	00 00 00 
  8004204af9:	ff d0                	callq  *%rax
  8004204afb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204aff:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204b04:	75 35                	jne    8004204b3b <check_page_alloc+0x32e>
  8004204b06:	48 b9 25 4f 21 04 80 	movabs $0x8004214f25,%rcx
  8004204b0d:	00 00 00 
  8004204b10:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204b17:	00 00 00 
  8004204b1a:	be d5 03 00 00       	mov    $0x3d5,%esi
  8004204b1f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204b26:	00 00 00 
  8004204b29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b2e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204b35:	00 00 00 
  8004204b38:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204b3b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b40:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204b47:	00 00 00 
  8004204b4a:	ff d0                	callq  *%rax
  8004204b4c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204b50:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204b55:	75 35                	jne    8004204b8c <check_page_alloc+0x37f>
  8004204b57:	48 b9 3b 4f 21 04 80 	movabs $0x8004214f3b,%rcx
  8004204b5e:	00 00 00 
  8004204b61:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204b68:	00 00 00 
  8004204b6b:	be d6 03 00 00       	mov    $0x3d6,%esi
  8004204b70:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204b77:	00 00 00 
  8004204b7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b7f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204b86:	00 00 00 
  8004204b89:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204b8c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204b91:	75 35                	jne    8004204bc8 <check_page_alloc+0x3bb>
  8004204b93:	48 b9 51 4f 21 04 80 	movabs $0x8004214f51,%rcx
  8004204b9a:	00 00 00 
  8004204b9d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204ba4:	00 00 00 
  8004204ba7:	be d7 03 00 00       	mov    $0x3d7,%esi
  8004204bac:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204bb3:	00 00 00 
  8004204bb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bbb:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204bc2:	00 00 00 
  8004204bc5:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204bc8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204bcd:	74 0a                	je     8004204bd9 <check_page_alloc+0x3cc>
  8004204bcf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204bd3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204bd7:	75 35                	jne    8004204c0e <check_page_alloc+0x401>
  8004204bd9:	48 b9 55 4f 21 04 80 	movabs $0x8004214f55,%rcx
  8004204be0:	00 00 00 
  8004204be3:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204bea:	00 00 00 
  8004204bed:	be d8 03 00 00       	mov    $0x3d8,%esi
  8004204bf2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204bf9:	00 00 00 
  8004204bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c01:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204c08:	00 00 00 
  8004204c0b:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204c0e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204c13:	74 14                	je     8004204c29 <check_page_alloc+0x41c>
  8004204c15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c19:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204c1d:	74 0a                	je     8004204c29 <check_page_alloc+0x41c>
  8004204c1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c23:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204c27:	75 35                	jne    8004204c5e <check_page_alloc+0x451>
  8004204c29:	48 b9 68 4f 21 04 80 	movabs $0x8004214f68,%rcx
  8004204c30:	00 00 00 
  8004204c33:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204c3a:	00 00 00 
  8004204c3d:	be d9 03 00 00       	mov    $0x3d9,%esi
  8004204c42:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204c49:	00 00 00 
  8004204c4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c51:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204c58:	00 00 00 
  8004204c5b:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204c5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c62:	48 89 c7             	mov    %rax,%rdi
  8004204c65:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204c6c:	00 00 00 
  8004204c6f:	ff d0                	callq  *%rax
  8004204c71:	48 89 c2             	mov    %rax,%rdx
  8004204c74:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004204c7b:	00 00 00 
  8004204c7e:	48 8b 00             	mov    (%rax),%rax
  8004204c81:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204c85:	48 39 c2             	cmp    %rax,%rdx
  8004204c88:	72 35                	jb     8004204cbf <check_page_alloc+0x4b2>
  8004204c8a:	48 b9 88 4f 21 04 80 	movabs $0x8004214f88,%rcx
  8004204c91:	00 00 00 
  8004204c94:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204c9b:	00 00 00 
  8004204c9e:	be da 03 00 00       	mov    $0x3da,%esi
  8004204ca3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204caa:	00 00 00 
  8004204cad:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cb2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204cb9:	00 00 00 
  8004204cbc:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204cbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204cc3:	48 89 c7             	mov    %rax,%rdi
  8004204cc6:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204ccd:	00 00 00 
  8004204cd0:	ff d0                	callq  *%rax
  8004204cd2:	48 89 c2             	mov    %rax,%rdx
  8004204cd5:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004204cdc:	00 00 00 
  8004204cdf:	48 8b 00             	mov    (%rax),%rax
  8004204ce2:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204ce6:	48 39 c2             	cmp    %rax,%rdx
  8004204ce9:	72 35                	jb     8004204d20 <check_page_alloc+0x513>
  8004204ceb:	48 b9 a5 4f 21 04 80 	movabs $0x8004214fa5,%rcx
  8004204cf2:	00 00 00 
  8004204cf5:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204cfc:	00 00 00 
  8004204cff:	be db 03 00 00       	mov    $0x3db,%esi
  8004204d04:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204d0b:	00 00 00 
  8004204d0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d13:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204d1a:	00 00 00 
  8004204d1d:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204d20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d24:	48 89 c7             	mov    %rax,%rdi
  8004204d27:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004204d2e:	00 00 00 
  8004204d31:	ff d0                	callq  *%rax
  8004204d33:	48 89 c2             	mov    %rax,%rdx
  8004204d36:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004204d3d:	00 00 00 
  8004204d40:	48 8b 00             	mov    (%rax),%rax
  8004204d43:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204d47:	48 39 c2             	cmp    %rax,%rdx
  8004204d4a:	72 35                	jb     8004204d81 <check_page_alloc+0x574>
  8004204d4c:	48 b9 c2 4f 21 04 80 	movabs $0x8004214fc2,%rcx
  8004204d53:	00 00 00 
  8004204d56:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204d5d:	00 00 00 
  8004204d60:	be dc 03 00 00       	mov    $0x3dc,%esi
  8004204d65:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204d6c:	00 00 00 
  8004204d6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d74:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204d7b:	00 00 00 
  8004204d7e:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204d81:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004204d88:	00 00 00 
  8004204d8b:	48 8b 00             	mov    (%rax),%rax
  8004204d8e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204d92:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004204d99:	00 00 00 
  8004204d9c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204da3:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204da8:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204daf:	00 00 00 
  8004204db2:	ff d0                	callq  *%rax
  8004204db4:	48 85 c0             	test   %rax,%rax
  8004204db7:	74 35                	je     8004204dee <check_page_alloc+0x5e1>
  8004204db9:	48 b9 df 4f 21 04 80 	movabs $0x8004214fdf,%rcx
  8004204dc0:	00 00 00 
  8004204dc3:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204dca:	00 00 00 
  8004204dcd:	be e3 03 00 00       	mov    $0x3e3,%esi
  8004204dd2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204dd9:	00 00 00 
  8004204ddc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204de1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204de8:	00 00 00 
  8004204deb:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204dee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204df2:	48 89 c7             	mov    %rax,%rdi
  8004204df5:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  8004204dfc:	00 00 00 
  8004204dff:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204e01:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e05:	48 89 c7             	mov    %rax,%rdi
  8004204e08:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  8004204e0f:	00 00 00 
  8004204e12:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204e14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e18:	48 89 c7             	mov    %rax,%rdi
  8004204e1b:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  8004204e22:	00 00 00 
  8004204e25:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204e27:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204e2e:	00 
  8004204e2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e33:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204e37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204e3f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e44:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204e4b:	00 00 00 
  8004204e4e:	ff d0                	callq  *%rax
  8004204e50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204e54:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204e59:	75 35                	jne    8004204e90 <check_page_alloc+0x683>
  8004204e5b:	48 b9 0f 4f 21 04 80 	movabs $0x8004214f0f,%rcx
  8004204e62:	00 00 00 
  8004204e65:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204e6c:	00 00 00 
  8004204e6f:	be ea 03 00 00       	mov    $0x3ea,%esi
  8004204e74:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204e7b:	00 00 00 
  8004204e7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e83:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204e8a:	00 00 00 
  8004204e8d:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204e90:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e95:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204e9c:	00 00 00 
  8004204e9f:	ff d0                	callq  *%rax
  8004204ea1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204ea5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204eaa:	75 35                	jne    8004204ee1 <check_page_alloc+0x6d4>
  8004204eac:	48 b9 25 4f 21 04 80 	movabs $0x8004214f25,%rcx
  8004204eb3:	00 00 00 
  8004204eb6:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204ebd:	00 00 00 
  8004204ec0:	be eb 03 00 00       	mov    $0x3eb,%esi
  8004204ec5:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204ecc:	00 00 00 
  8004204ecf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ed4:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204edb:	00 00 00 
  8004204ede:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204ee1:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ee6:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004204eed:	00 00 00 
  8004204ef0:	ff d0                	callq  *%rax
  8004204ef2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204ef6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204efb:	75 35                	jne    8004204f32 <check_page_alloc+0x725>
  8004204efd:	48 b9 3b 4f 21 04 80 	movabs $0x8004214f3b,%rcx
  8004204f04:	00 00 00 
  8004204f07:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204f0e:	00 00 00 
  8004204f11:	be ec 03 00 00       	mov    $0x3ec,%esi
  8004204f16:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204f1d:	00 00 00 
  8004204f20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f25:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204f2c:	00 00 00 
  8004204f2f:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204f32:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204f37:	75 35                	jne    8004204f6e <check_page_alloc+0x761>
  8004204f39:	48 b9 51 4f 21 04 80 	movabs $0x8004214f51,%rcx
  8004204f40:	00 00 00 
  8004204f43:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204f4a:	00 00 00 
  8004204f4d:	be ed 03 00 00       	mov    $0x3ed,%esi
  8004204f52:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204f59:	00 00 00 
  8004204f5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f61:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204f68:	00 00 00 
  8004204f6b:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204f6e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204f73:	74 0a                	je     8004204f7f <check_page_alloc+0x772>
  8004204f75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204f79:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204f7d:	75 35                	jne    8004204fb4 <check_page_alloc+0x7a7>
  8004204f7f:	48 b9 55 4f 21 04 80 	movabs $0x8004214f55,%rcx
  8004204f86:	00 00 00 
  8004204f89:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204f90:	00 00 00 
  8004204f93:	be ee 03 00 00       	mov    $0x3ee,%esi
  8004204f98:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204f9f:	00 00 00 
  8004204fa2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fa7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204fae:	00 00 00 
  8004204fb1:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204fb4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204fb9:	74 14                	je     8004204fcf <check_page_alloc+0x7c2>
  8004204fbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204fbf:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204fc3:	74 0a                	je     8004204fcf <check_page_alloc+0x7c2>
  8004204fc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204fc9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204fcd:	75 35                	jne    8004205004 <check_page_alloc+0x7f7>
  8004204fcf:	48 b9 68 4f 21 04 80 	movabs $0x8004214f68,%rcx
  8004204fd6:	00 00 00 
  8004204fd9:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004204fe0:	00 00 00 
  8004204fe3:	be ef 03 00 00       	mov    $0x3ef,%esi
  8004204fe8:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004204fef:	00 00 00 
  8004204ff2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ff7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004204ffe:	00 00 00 
  8004205001:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004205004:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205009:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205010:	00 00 00 
  8004205013:	ff d0                	callq  *%rax
  8004205015:	48 85 c0             	test   %rax,%rax
  8004205018:	74 35                	je     800420504f <check_page_alloc+0x842>
  800420501a:	48 b9 df 4f 21 04 80 	movabs $0x8004214fdf,%rcx
  8004205021:	00 00 00 
  8004205024:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420502b:	00 00 00 
  800420502e:	be f0 03 00 00       	mov    $0x3f0,%esi
  8004205033:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420503a:	00 00 00 
  800420503d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205042:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205049:	00 00 00 
  800420504c:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  800420504f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205053:	48 89 c7             	mov    %rax,%rdi
  8004205056:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  800420505d:	00 00 00 
  8004205060:	ff d0                	callq  *%rax
  8004205062:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205067:	be 01 00 00 00       	mov    $0x1,%esi
  800420506c:	48 89 c7             	mov    %rax,%rdi
  800420506f:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004205076:	00 00 00 
  8004205079:	ff d0                	callq  *%rax
	page_free(pp0);
  800420507b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420507f:	48 89 c7             	mov    %rax,%rdi
  8004205082:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  8004205089:	00 00 00 
  800420508c:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  800420508e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004205093:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  800420509a:	00 00 00 
  800420509d:	ff d0                	callq  *%rax
  800420509f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042050a3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042050a8:	75 35                	jne    80042050df <check_page_alloc+0x8d2>
  80042050aa:	48 b9 ee 4f 21 04 80 	movabs $0x8004214fee,%rcx
  80042050b1:	00 00 00 
  80042050b4:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042050bb:	00 00 00 
  80042050be:	be f5 03 00 00       	mov    $0x3f5,%esi
  80042050c3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042050ca:	00 00 00 
  80042050cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050d2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042050d9:	00 00 00 
  80042050dc:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  80042050df:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042050e4:	74 0a                	je     80042050f0 <check_page_alloc+0x8e3>
  80042050e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050ea:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042050ee:	74 35                	je     8004205125 <check_page_alloc+0x918>
  80042050f0:	48 b9 0c 50 21 04 80 	movabs $0x800421500c,%rcx
  80042050f7:	00 00 00 
  80042050fa:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205101:	00 00 00 
  8004205104:	be f6 03 00 00       	mov    $0x3f6,%esi
  8004205109:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205110:	00 00 00 
  8004205113:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205118:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420511f:	00 00 00 
  8004205122:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004205125:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205129:	48 89 c7             	mov    %rax,%rdi
  800420512c:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  8004205133:	00 00 00 
  8004205136:	ff d0                	callq  *%rax
  8004205138:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  800420513c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004205143:	eb 4d                	jmp    8004205192 <check_page_alloc+0x985>
		assert(c[i] == 0);
  8004205145:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004205148:	48 63 d0             	movslq %eax,%rdx
  800420514b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420514f:	48 01 d0             	add    %rdx,%rax
  8004205152:	0f b6 00             	movzbl (%rax),%eax
  8004205155:	84 c0                	test   %al,%al
  8004205157:	74 35                	je     800420518e <check_page_alloc+0x981>
  8004205159:	48 b9 1c 50 21 04 80 	movabs $0x800421501c,%rcx
  8004205160:	00 00 00 
  8004205163:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420516a:	00 00 00 
  800420516d:	be f9 03 00 00       	mov    $0x3f9,%esi
  8004205172:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205179:	00 00 00 
  800420517c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205181:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205188:	00 00 00 
  800420518b:	41 ff d0             	callq  *%r8
	for (i = 0; i < PGSIZE; i++)
  800420518e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004205192:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004205199:	7e aa                	jle    8004205145 <check_page_alloc+0x938>

	// give free list back
	page_free_list = fl;
  800420519b:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  80042051a2:	00 00 00 
  80042051a5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042051a9:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042051ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051b0:	48 89 c7             	mov    %rax,%rdi
  80042051b3:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  80042051ba:	00 00 00 
  80042051bd:	ff d0                	callq  *%rax
	page_free(pp1);
  80042051bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042051c3:	48 89 c7             	mov    %rax,%rdi
  80042051c6:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  80042051cd:	00 00 00 
  80042051d0:	ff d0                	callq  *%rax
	page_free(pp2);
  80042051d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042051d6:	48 89 c7             	mov    %rax,%rdi
  80042051d9:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  80042051e0:	00 00 00 
  80042051e3:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  80042051e5:	48 bf 28 50 21 04 80 	movabs $0x8004215028,%rdi
  80042051ec:	00 00 00 
  80042051ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051f4:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042051fb:	00 00 00 
  80042051fe:	ff d2                	callq  *%rdx
}
  8004205200:	c9                   	leaveq 
  8004205201:	c3                   	retq   

0000008004205202 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004205202:	55                   	push   %rbp
  8004205203:	48 89 e5             	mov    %rsp,%rbp
  8004205206:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  800420520d:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004205214:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420521b:	00 00 00 
  800420521e:	48 8b 00             	mov    (%rax),%rax
  8004205221:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004205228:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  800420522f:	00 
  8004205230:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004205237:	00 00 00 
  800420523a:	48 8b 00             	mov    (%rax),%rax
  800420523d:	48 c1 e0 04          	shl    $0x4,%rax
  8004205241:	48 89 c2             	mov    %rax,%rdx
  8004205244:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205248:	48 01 d0             	add    %rdx,%rax
  800420524b:	48 83 e8 01          	sub    $0x1,%rax
  800420524f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205253:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205257:	ba 00 00 00 00       	mov    $0x0,%edx
  800420525c:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004205260:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205264:	48 29 d0             	sub    %rdx,%rax
  8004205267:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  800420526b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205272:	00 
  8004205273:	e9 da 00 00 00       	jmpq   8004205352 <check_boot_pml4e+0x150>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004205278:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  800420527f:	00 00 00 
  8004205282:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205286:	48 01 c2             	add    %rax,%rdx
  8004205289:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205290:	48 89 d6             	mov    %rdx,%rsi
  8004205293:	48 89 c7             	mov    %rax,%rdi
  8004205296:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  800420529d:	00 00 00 
  80042052a0:	ff d0                	callq  *%rax
  80042052a2:	48 89 c1             	mov    %rax,%rcx
  80042052a5:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  80042052ac:	00 00 00 
  80042052af:	48 8b 00             	mov    (%rax),%rax
  80042052b2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042052b6:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042052bd:	00 00 00 
  80042052c0:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042052c4:	77 32                	ja     80042052f8 <check_boot_pml4e+0xf6>
  80042052c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042052ca:	48 89 c1             	mov    %rax,%rcx
  80042052cd:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  80042052d4:	00 00 00 
  80042052d7:	be 19 04 00 00       	mov    $0x419,%esi
  80042052dc:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042052e3:	00 00 00 
  80042052e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052eb:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042052f2:	00 00 00 
  80042052f5:	41 ff d0             	callq  *%r8
  80042052f8:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042052ff:	ff ff ff 
  8004205302:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205306:	48 01 c2             	add    %rax,%rdx
  8004205309:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420530d:	48 01 d0             	add    %rdx,%rax
  8004205310:	48 39 c1             	cmp    %rax,%rcx
  8004205313:	74 35                	je     800420534a <check_boot_pml4e+0x148>
  8004205315:	48 b9 48 50 21 04 80 	movabs $0x8004215048,%rcx
  800420531c:	00 00 00 
  800420531f:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205326:	00 00 00 
  8004205329:	be 19 04 00 00       	mov    $0x419,%esi
  800420532e:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205335:	00 00 00 
  8004205338:	b8 00 00 00 00       	mov    $0x0,%eax
  800420533d:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205344:	00 00 00 
  8004205347:	41 ff d0             	callq  *%r8
	for (i = 0; i < n; i += PGSIZE) {
  800420534a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205351:	00 
  8004205352:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205356:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420535a:	0f 82 18 ff ff ff    	jb     8004205278 <check_boot_pml4e+0x76>
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004205360:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  8004205367:	00 
  8004205368:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420536c:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  8004205372:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205376:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420537a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420537f:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004205383:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205387:	48 29 d0             	sub    %rdx,%rax
  800420538a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  800420538e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205395:	00 
  8004205396:	e9 da 00 00 00       	jmpq   8004205475 <check_boot_pml4e+0x273>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  800420539b:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042053a2:	00 00 00 
  80042053a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053a9:	48 01 c2             	add    %rax,%rdx
  80042053ac:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042053b3:	48 89 d6             	mov    %rdx,%rsi
  80042053b6:	48 89 c7             	mov    %rax,%rdi
  80042053b9:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  80042053c0:	00 00 00 
  80042053c3:	ff d0                	callq  *%rax
  80042053c5:	48 89 c1             	mov    %rax,%rcx
  80042053c8:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  80042053cf:	00 00 00 
  80042053d2:	48 8b 00             	mov    (%rax),%rax
  80042053d5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042053d9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042053e0:	00 00 00 
  80042053e3:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  80042053e7:	77 32                	ja     800420541b <check_boot_pml4e+0x219>
  80042053e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042053ed:	48 89 c1             	mov    %rax,%rcx
  80042053f0:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  80042053f7:	00 00 00 
  80042053fa:	be 1f 04 00 00       	mov    $0x41f,%esi
  80042053ff:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205406:	00 00 00 
  8004205409:	b8 00 00 00 00       	mov    $0x0,%eax
  800420540e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205415:	00 00 00 
  8004205418:	41 ff d0             	callq  *%r8
  800420541b:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004205422:	ff ff ff 
  8004205425:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205429:	48 01 c2             	add    %rax,%rdx
  800420542c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205430:	48 01 d0             	add    %rdx,%rax
  8004205433:	48 39 c1             	cmp    %rax,%rcx
  8004205436:	74 35                	je     800420546d <check_boot_pml4e+0x26b>
  8004205438:	48 b9 80 50 21 04 80 	movabs $0x8004215080,%rcx
  800420543f:	00 00 00 
  8004205442:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205449:	00 00 00 
  800420544c:	be 1f 04 00 00       	mov    $0x41f,%esi
  8004205451:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205458:	00 00 00 
  800420545b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205460:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205467:	00 00 00 
  800420546a:	41 ff d0             	callq  *%r8
	for (i = 0; i < n; i += PGSIZE)
  800420546d:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205474:	00 
  8004205475:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205479:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420547d:	0f 82 18 ff ff ff    	jb     800420539b <check_boot_pml4e+0x199>

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004205483:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420548a:	00 
  800420548b:	eb 6d                	jmp    80042054fa <check_boot_pml4e+0x2f8>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  800420548d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205494:	00 00 00 
  8004205497:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420549b:	48 01 c2             	add    %rax,%rdx
  800420549e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042054a5:	48 89 d6             	mov    %rdx,%rsi
  80042054a8:	48 89 c7             	mov    %rax,%rdi
  80042054ab:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  80042054b2:	00 00 00 
  80042054b5:	ff d0                	callq  *%rax
  80042054b7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042054bb:	74 35                	je     80042054f2 <check_boot_pml4e+0x2f0>
  80042054bd:	48 b9 b8 50 21 04 80 	movabs $0x80042150b8,%rcx
  80042054c4:	00 00 00 
  80042054c7:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042054ce:	00 00 00 
  80042054d1:	be 23 04 00 00       	mov    $0x423,%esi
  80042054d6:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042054dd:	00 00 00 
  80042054e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054e5:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042054ec:	00 00 00 
  80042054ef:	41 ff d0             	callq  *%r8
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042054f2:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042054f9:	00 
  80042054fa:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004205501:	00 00 00 
  8004205504:	48 8b 00             	mov    (%rax),%rax
  8004205507:	48 c1 e0 0c          	shl    $0xc,%rax
  800420550b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420550f:	0f 87 78 ff ff ff    	ja     800420548d <check_boot_pml4e+0x28b>

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205515:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420551c:	00 
  800420551d:	e9 aa 01 00 00       	jmpq   80042056cc <check_boot_pml4e+0x4ca>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205522:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205526:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420552a:	48 89 d0             	mov    %rdx,%rax
  800420552d:	48 01 c0             	add    %rax,%rax
  8004205530:	48 01 d0             	add    %rdx,%rax
  8004205533:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205537:	48 89 c2             	mov    %rax,%rdx
  800420553a:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205541:	00 00 00 
  8004205544:	48 29 d0             	sub    %rdx,%rax
  8004205547:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420554b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205552:	00 
  8004205553:	e9 e6 00 00 00       	jmpq   800420563e <check_boot_pml4e+0x43c>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205558:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420555c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205560:	48 01 d0             	add    %rdx,%rax
  8004205563:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  800420556a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205571:	48 89 d6             	mov    %rdx,%rsi
  8004205574:	48 89 c7             	mov    %rax,%rdi
  8004205577:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  800420557e:	00 00 00 
  8004205581:	ff d0                	callq  *%rax
  8004205583:	48 89 c1             	mov    %rax,%rcx
  8004205586:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420558a:	48 c1 e0 10          	shl    $0x10,%rax
  800420558e:	48 89 c2             	mov    %rax,%rdx
  8004205591:	48 b8 00 f0 57 04 80 	movabs $0x800457f000,%rax
  8004205598:	00 00 00 
  800420559b:	48 01 d0             	add    %rdx,%rax
  800420559e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042055a2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042055a9:	00 00 00 
  80042055ac:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  80042055b0:	77 32                	ja     80042055e4 <check_boot_pml4e+0x3e2>
  80042055b2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042055b6:	48 89 c1             	mov    %rax,%rcx
  80042055b9:	48 ba 78 4c 21 04 80 	movabs $0x8004214c78,%rdx
  80042055c0:	00 00 00 
  80042055c3:	be 2b 04 00 00       	mov    $0x42b,%esi
  80042055c8:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042055cf:	00 00 00 
  80042055d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055d7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042055de:	00 00 00 
  80042055e1:	41 ff d0             	callq  *%r8
  80042055e4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042055eb:	ff ff ff 
  80042055ee:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042055f2:	48 01 c2             	add    %rax,%rdx
  80042055f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042055f9:	48 01 d0             	add    %rdx,%rax
  80042055fc:	48 39 c1             	cmp    %rax,%rcx
  80042055ff:	74 35                	je     8004205636 <check_boot_pml4e+0x434>
  8004205601:	48 b9 e0 50 21 04 80 	movabs $0x80042150e0,%rcx
  8004205608:	00 00 00 
  800420560b:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205612:	00 00 00 
  8004205615:	be 2b 04 00 00       	mov    $0x42b,%esi
  800420561a:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205621:	00 00 00 
  8004205624:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205629:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205630:	00 00 00 
  8004205633:	41 ff d0             	callq  *%r8
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205636:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420563d:	00 
  800420563e:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004205645:	00 
  8004205646:	0f 86 0c ff ff ff    	jbe    8004205558 <check_boot_pml4e+0x356>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  800420564c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205653:	00 
  8004205654:	eb 67                	jmp    80042056bd <check_boot_pml4e+0x4bb>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004205656:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420565a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420565e:	48 01 c2             	add    %rax,%rdx
  8004205661:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205668:	48 89 d6             	mov    %rdx,%rsi
  800420566b:	48 89 c7             	mov    %rax,%rdi
  800420566e:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004205675:	00 00 00 
  8004205678:	ff d0                	callq  *%rax
  800420567a:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420567e:	74 35                	je     80042056b5 <check_boot_pml4e+0x4b3>
  8004205680:	48 b9 28 51 21 04 80 	movabs $0x8004215128,%rcx
  8004205687:	00 00 00 
  800420568a:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205691:	00 00 00 
  8004205694:	be 2d 04 00 00       	mov    $0x42d,%esi
  8004205699:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042056a0:	00 00 00 
  80042056a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056a8:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042056af:	00 00 00 
  80042056b2:	41 ff d0             	callq  *%r8
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042056b5:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042056bc:	00 
  80042056bd:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042056c4:	00 
  80042056c5:	76 8f                	jbe    8004205656 <check_boot_pml4e+0x454>
	for (n = 0; n < NCPU; n++) {
  80042056c7:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042056cc:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  80042056d1:	0f 86 4b fe ff ff    	jbe    8004205522 <check_boot_pml4e+0x320>
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042056d7:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042056de:	00 00 00 
  80042056e1:	48 8b 00             	mov    (%rax),%rax
  80042056e4:	48 83 c0 08          	add    $0x8,%rax
  80042056e8:	48 8b 00             	mov    (%rax),%rax
  80042056eb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042056f1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042056f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042056f9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042056fd:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205700:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205703:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420570a:	00 00 00 
  800420570d:	48 8b 00             	mov    (%rax),%rax
  8004205710:	48 39 c2             	cmp    %rax,%rdx
  8004205713:	72 32                	jb     8004205747 <check_boot_pml4e+0x545>
  8004205715:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205719:	48 89 c1             	mov    %rax,%rcx
  800420571c:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004205723:	00 00 00 
  8004205726:	be 30 04 00 00       	mov    $0x430,%esi
  800420572b:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205732:	00 00 00 
  8004205735:	b8 00 00 00 00       	mov    $0x0,%eax
  800420573a:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205741:	00 00 00 
  8004205744:	41 ff d0             	callq  *%r8
  8004205747:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420574e:	00 00 00 
  8004205751:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205755:	48 01 d0             	add    %rdx,%rax
  8004205758:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  800420575c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205760:	48 8b 00             	mov    (%rax),%rax
  8004205763:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205769:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800420576d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205771:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205775:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205778:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420577b:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004205782:	00 00 00 
  8004205785:	48 8b 00             	mov    (%rax),%rax
  8004205788:	48 39 c2             	cmp    %rax,%rdx
  800420578b:	72 32                	jb     80042057bf <check_boot_pml4e+0x5bd>
  800420578d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205791:	48 89 c1             	mov    %rax,%rcx
  8004205794:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  800420579b:	00 00 00 
  800420579e:	be 31 04 00 00       	mov    $0x431,%esi
  80042057a3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042057aa:	00 00 00 
  80042057ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057b2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042057b9:	00 00 00 
  80042057bc:	41 ff d0             	callq  *%r8
  80042057bf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042057c6:	00 00 00 
  80042057c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042057cd:	48 01 d0             	add    %rdx,%rax
  80042057d0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042057d4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042057db:	00 
  80042057dc:	e9 44 01 00 00       	jmpq   8004205925 <check_boot_pml4e+0x723>
		switch (i) {
  80042057e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057e5:	48 83 f8 04          	cmp    $0x4,%rax
  80042057e9:	72 64                	jb     800420584f <check_boot_pml4e+0x64d>
  80042057eb:	48 83 f8 05          	cmp    $0x5,%rax
  80042057ef:	76 06                	jbe    80042057f7 <check_boot_pml4e+0x5f5>
  80042057f1:	48 83 f8 1f          	cmp    $0x1f,%rax
  80042057f5:	75 58                	jne    800420584f <check_boot_pml4e+0x64d>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  80042057f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057fb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205802:	00 
  8004205803:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205807:	48 01 d0             	add    %rdx,%rax
  800420580a:	48 8b 00             	mov    (%rax),%rax
  800420580d:	83 e0 01             	and    $0x1,%eax
  8004205810:	48 85 c0             	test   %rax,%rax
  8004205813:	75 35                	jne    800420584a <check_boot_pml4e+0x648>
  8004205815:	48 b9 4b 51 21 04 80 	movabs $0x800421514b,%rcx
  800420581c:	00 00 00 
  800420581f:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205826:	00 00 00 
  8004205829:	be 39 04 00 00       	mov    $0x439,%esi
  800420582e:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205835:	00 00 00 
  8004205838:	b8 00 00 00 00       	mov    $0x0,%eax
  800420583d:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205844:	00 00 00 
  8004205847:	41 ff d0             	callq  *%r8
			break;
  800420584a:	e9 d1 00 00 00       	jmpq   8004205920 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  800420584f:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205854:	0f 86 c5 00 00 00    	jbe    800420591f <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  800420585a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420585e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205865:	00 
  8004205866:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420586a:	48 01 d0             	add    %rdx,%rax
  800420586d:	48 8b 00             	mov    (%rax),%rax
  8004205870:	83 e0 01             	and    $0x1,%eax
  8004205873:	48 85 c0             	test   %rax,%rax
  8004205876:	74 57                	je     80042058cf <check_boot_pml4e+0x6cd>
					assert(pgdir[i] & PTE_W);
  8004205878:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420587c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205883:	00 
  8004205884:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205888:	48 01 d0             	add    %rdx,%rax
  800420588b:	48 8b 00             	mov    (%rax),%rax
  800420588e:	83 e0 02             	and    $0x2,%eax
  8004205891:	48 85 c0             	test   %rax,%rax
  8004205894:	0f 85 85 00 00 00    	jne    800420591f <check_boot_pml4e+0x71d>
  800420589a:	48 b9 5c 51 21 04 80 	movabs $0x800421515c,%rcx
  80042058a1:	00 00 00 
  80042058a4:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042058ab:	00 00 00 
  80042058ae:	be 3e 04 00 00       	mov    $0x43e,%esi
  80042058b3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042058ba:	00 00 00 
  80042058bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058c2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042058c9:	00 00 00 
  80042058cc:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042058cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058d3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042058da:	00 
  80042058db:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042058df:	48 01 d0             	add    %rdx,%rax
  80042058e2:	48 8b 00             	mov    (%rax),%rax
  80042058e5:	48 85 c0             	test   %rax,%rax
  80042058e8:	74 35                	je     800420591f <check_boot_pml4e+0x71d>
  80042058ea:	48 b9 6d 51 21 04 80 	movabs $0x800421516d,%rcx
  80042058f1:	00 00 00 
  80042058f4:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042058fb:	00 00 00 
  80042058fe:	be 40 04 00 00       	mov    $0x440,%esi
  8004205903:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420590a:	00 00 00 
  800420590d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205912:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205919:	00 00 00 
  800420591c:	41 ff d0             	callq  *%r8
			}
			break;
  800420591f:	90                   	nop
	for (i = 0; i < NPDENTRIES; i++) {
  8004205920:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205925:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  800420592c:	00 
  800420592d:	0f 86 ae fe ff ff    	jbe    80042057e1 <check_boot_pml4e+0x5df>
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205933:	48 bf 80 51 21 04 80 	movabs $0x8004215180,%rdi
  800420593a:	00 00 00 
  800420593d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205942:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004205949:	00 00 00 
  800420594c:	ff d2                	callq  *%rdx
}
  800420594e:	c9                   	leaveq 
  800420594f:	c3                   	retq   

0000008004205950 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205950:	55                   	push   %rbp
  8004205951:	48 89 e5             	mov    %rsp,%rbp
  8004205954:	48 83 ec 60          	sub    $0x60,%rsp
  8004205958:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420595c:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004205960:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205964:	48 c1 e8 27          	shr    $0x27,%rax
  8004205968:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420596d:	48 c1 e0 03          	shl    $0x3,%rax
  8004205971:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004205975:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205979:	48 8b 00             	mov    (%rax),%rax
  800420597c:	83 e0 01             	and    $0x1,%eax
  800420597f:	48 85 c0             	test   %rax,%rax
  8004205982:	75 0c                	jne    8004205990 <check_va2pa+0x40>
		return ~0;
  8004205984:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420598b:	e9 38 02 00 00       	jmpq   8004205bc8 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205990:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205994:	48 8b 00             	mov    (%rax),%rax
  8004205997:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420599d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042059a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059a5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042059a9:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042059ac:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042059af:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042059b6:	00 00 00 
  80042059b9:	48 8b 00             	mov    (%rax),%rax
  80042059bc:	48 39 c2             	cmp    %rax,%rdx
  80042059bf:	72 32                	jb     80042059f3 <check_va2pa+0xa3>
  80042059c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059c5:	48 89 c1             	mov    %rax,%rcx
  80042059c8:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042059cf:	00 00 00 
  80042059d2:	be 58 04 00 00       	mov    $0x458,%esi
  80042059d7:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042059de:	00 00 00 
  80042059e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059e6:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042059ed:	00 00 00 
  80042059f0:	41 ff d0             	callq  *%r8
  80042059f3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042059fa:	00 00 00 
  80042059fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205a01:	48 01 d0             	add    %rdx,%rax
  8004205a04:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205a08:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a0c:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205a10:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a15:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a1c:	00 
  8004205a1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a21:	48 01 d0             	add    %rdx,%rax
  8004205a24:	48 8b 00             	mov    (%rax),%rax
  8004205a27:	83 e0 01             	and    $0x1,%eax
  8004205a2a:	48 85 c0             	test   %rax,%rax
  8004205a2d:	75 0c                	jne    8004205a3b <check_va2pa+0xeb>
		return ~0;
  8004205a2f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205a36:	e9 8d 01 00 00       	jmpq   8004205bc8 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205a3b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a3f:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205a43:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a48:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a4f:	00 
  8004205a50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a54:	48 01 d0             	add    %rdx,%rax
  8004205a57:	48 8b 00             	mov    (%rax),%rax
  8004205a5a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a60:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205a64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a68:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a6c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205a6f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205a72:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004205a79:	00 00 00 
  8004205a7c:	48 8b 00             	mov    (%rax),%rax
  8004205a7f:	48 39 c2             	cmp    %rax,%rdx
  8004205a82:	72 32                	jb     8004205ab6 <check_va2pa+0x166>
  8004205a84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a88:	48 89 c1             	mov    %rax,%rcx
  8004205a8b:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004205a92:	00 00 00 
  8004205a95:	be 5c 04 00 00       	mov    $0x45c,%esi
  8004205a9a:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205aa1:	00 00 00 
  8004205aa4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205aa9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205ab0:	00 00 00 
  8004205ab3:	41 ff d0             	callq  *%r8
  8004205ab6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205abd:	00 00 00 
  8004205ac0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ac4:	48 01 d0             	add    %rdx,%rax
  8004205ac7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004205acb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205acf:	48 c1 e8 15          	shr    $0x15,%rax
  8004205ad3:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205ad8:	48 c1 e0 03          	shl    $0x3,%rax
  8004205adc:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205ae0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ae4:	48 8b 00             	mov    (%rax),%rax
  8004205ae7:	83 e0 01             	and    $0x1,%eax
  8004205aea:	48 85 c0             	test   %rax,%rax
  8004205aed:	75 0c                	jne    8004205afb <check_va2pa+0x1ab>
		return ~0;
  8004205aef:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205af6:	e9 cd 00 00 00       	jmpq   8004205bc8 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205afb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205aff:	48 8b 00             	mov    (%rax),%rax
  8004205b02:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205b08:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205b0c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b10:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205b14:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205b17:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205b1a:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004205b21:	00 00 00 
  8004205b24:	48 8b 00             	mov    (%rax),%rax
  8004205b27:	48 39 c2             	cmp    %rax,%rdx
  8004205b2a:	72 32                	jb     8004205b5e <check_va2pa+0x20e>
  8004205b2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b30:	48 89 c1             	mov    %rax,%rcx
  8004205b33:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004205b3a:	00 00 00 
  8004205b3d:	be 61 04 00 00       	mov    $0x461,%esi
  8004205b42:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205b49:	00 00 00 
  8004205b4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b51:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205b58:	00 00 00 
  8004205b5b:	41 ff d0             	callq  *%r8
  8004205b5e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205b65:	00 00 00 
  8004205b68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b6c:	48 01 d0             	add    %rdx,%rax
  8004205b6f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205b73:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205b77:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205b7b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205b80:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205b87:	00 
  8004205b88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205b8c:	48 01 d0             	add    %rdx,%rax
  8004205b8f:	48 8b 00             	mov    (%rax),%rax
  8004205b92:	83 e0 01             	and    $0x1,%eax
  8004205b95:	48 85 c0             	test   %rax,%rax
  8004205b98:	75 09                	jne    8004205ba3 <check_va2pa+0x253>
		return ~0;
  8004205b9a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205ba1:	eb 25                	jmp    8004205bc8 <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205ba3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205ba7:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205bab:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205bb0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205bb7:	00 
  8004205bb8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bbc:	48 01 d0             	add    %rdx,%rax
  8004205bbf:	48 8b 00             	mov    (%rax),%rax
  8004205bc2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205bc8:	c9                   	leaveq 
  8004205bc9:	c3                   	retq   

0000008004205bca <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205bca:	55                   	push   %rbp
  8004205bcb:	48 89 e5             	mov    %rsp,%rbp
  8004205bce:	53                   	push   %rbx
  8004205bcf:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205bd6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205bdd:	00 
  8004205bde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205be2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205be6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205bea:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205bee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205bf2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205bf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205bfa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205bfe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205c02:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205c06:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c0b:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205c12:	00 00 00 
  8004205c15:	ff d0                	callq  *%rax
  8004205c17:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205c1b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205c20:	75 35                	jne    8004205c57 <page_check+0x8d>
  8004205c22:	48 b9 9f 51 21 04 80 	movabs $0x800421519f,%rcx
  8004205c29:	00 00 00 
  8004205c2c:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205c33:	00 00 00 
  8004205c36:	be 77 04 00 00       	mov    $0x477,%esi
  8004205c3b:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205c42:	00 00 00 
  8004205c45:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c4a:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205c51:	00 00 00 
  8004205c54:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205c57:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c5c:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205c63:	00 00 00 
  8004205c66:	ff d0                	callq  *%rax
  8004205c68:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205c6c:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205c71:	75 35                	jne    8004205ca8 <page_check+0xde>
  8004205c73:	48 b9 b3 51 21 04 80 	movabs $0x80042151b3,%rcx
  8004205c7a:	00 00 00 
  8004205c7d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205c84:	00 00 00 
  8004205c87:	be 78 04 00 00       	mov    $0x478,%esi
  8004205c8c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205c93:	00 00 00 
  8004205c96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c9b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205ca2:	00 00 00 
  8004205ca5:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205ca8:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205cad:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205cb4:	00 00 00 
  8004205cb7:	ff d0                	callq  *%rax
  8004205cb9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205cbd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205cc2:	75 35                	jne    8004205cf9 <page_check+0x12f>
  8004205cc4:	48 b9 c7 51 21 04 80 	movabs $0x80042151c7,%rcx
  8004205ccb:	00 00 00 
  8004205cce:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205cd5:	00 00 00 
  8004205cd8:	be 79 04 00 00       	mov    $0x479,%esi
  8004205cdd:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205ce4:	00 00 00 
  8004205ce7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cec:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205cf3:	00 00 00 
  8004205cf6:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205cf9:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205cfe:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205d05:	00 00 00 
  8004205d08:	ff d0                	callq  *%rax
  8004205d0a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205d0e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205d13:	75 35                	jne    8004205d4a <page_check+0x180>
  8004205d15:	48 b9 db 51 21 04 80 	movabs $0x80042151db,%rcx
  8004205d1c:	00 00 00 
  8004205d1f:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205d26:	00 00 00 
  8004205d29:	be 7a 04 00 00       	mov    $0x47a,%esi
  8004205d2e:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205d35:	00 00 00 
  8004205d38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d3d:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205d44:	00 00 00 
  8004205d47:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205d4a:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d4f:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205d56:	00 00 00 
  8004205d59:	ff d0                	callq  *%rax
  8004205d5b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205d5f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205d64:	75 35                	jne    8004205d9b <page_check+0x1d1>
  8004205d66:	48 b9 ef 51 21 04 80 	movabs $0x80042151ef,%rcx
  8004205d6d:	00 00 00 
  8004205d70:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205d77:	00 00 00 
  8004205d7a:	be 7b 04 00 00       	mov    $0x47b,%esi
  8004205d7f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205d86:	00 00 00 
  8004205d89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d8e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205d95:	00 00 00 
  8004205d98:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205d9b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205da0:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004205da7:	00 00 00 
  8004205daa:	ff d0                	callq  *%rax
  8004205dac:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205db0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205db5:	75 35                	jne    8004205dec <page_check+0x222>
  8004205db7:	48 b9 03 52 21 04 80 	movabs $0x8004215203,%rcx
  8004205dbe:	00 00 00 
  8004205dc1:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205dc8:	00 00 00 
  8004205dcb:	be 7c 04 00 00       	mov    $0x47c,%esi
  8004205dd0:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205dd7:	00 00 00 
  8004205dda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ddf:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205de6:	00 00 00 
  8004205de9:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205dec:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205df1:	75 35                	jne    8004205e28 <page_check+0x25e>
  8004205df3:	48 b9 51 4f 21 04 80 	movabs $0x8004214f51,%rcx
  8004205dfa:	00 00 00 
  8004205dfd:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205e04:	00 00 00 
  8004205e07:	be 7e 04 00 00       	mov    $0x47e,%esi
  8004205e0c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205e13:	00 00 00 
  8004205e16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e1b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205e22:	00 00 00 
  8004205e25:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205e28:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205e2d:	74 0a                	je     8004205e39 <page_check+0x26f>
  8004205e2f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e33:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e37:	75 35                	jne    8004205e6e <page_check+0x2a4>
  8004205e39:	48 b9 55 4f 21 04 80 	movabs $0x8004214f55,%rcx
  8004205e40:	00 00 00 
  8004205e43:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205e4a:	00 00 00 
  8004205e4d:	be 7f 04 00 00       	mov    $0x47f,%esi
  8004205e52:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205e59:	00 00 00 
  8004205e5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e61:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205e68:	00 00 00 
  8004205e6b:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205e6e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205e73:	74 14                	je     8004205e89 <page_check+0x2bf>
  8004205e75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205e79:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205e7d:	74 0a                	je     8004205e89 <page_check+0x2bf>
  8004205e7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205e83:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e87:	75 35                	jne    8004205ebe <page_check+0x2f4>
  8004205e89:	48 b9 68 4f 21 04 80 	movabs $0x8004214f68,%rcx
  8004205e90:	00 00 00 
  8004205e93:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205e9a:	00 00 00 
  8004205e9d:	be 80 04 00 00       	mov    $0x480,%esi
  8004205ea2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205ea9:	00 00 00 
  8004205eac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205eb1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205eb8:	00 00 00 
  8004205ebb:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205ebe:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205ec3:	74 1e                	je     8004205ee3 <page_check+0x319>
  8004205ec5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ec9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205ecd:	74 14                	je     8004205ee3 <page_check+0x319>
  8004205ecf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ed3:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205ed7:	74 0a                	je     8004205ee3 <page_check+0x319>
  8004205ed9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205edd:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205ee1:	75 35                	jne    8004205f18 <page_check+0x34e>
  8004205ee3:	48 b9 18 52 21 04 80 	movabs $0x8004215218,%rcx
  8004205eea:	00 00 00 
  8004205eed:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205ef4:	00 00 00 
  8004205ef7:	be 81 04 00 00       	mov    $0x481,%esi
  8004205efc:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205f03:	00 00 00 
  8004205f06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f0b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205f12:	00 00 00 
  8004205f15:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205f18:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205f1d:	74 28                	je     8004205f47 <page_check+0x37d>
  8004205f1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f23:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205f27:	74 1e                	je     8004205f47 <page_check+0x37d>
  8004205f29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f2d:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205f31:	74 14                	je     8004205f47 <page_check+0x37d>
  8004205f33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f37:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205f3b:	74 0a                	je     8004205f47 <page_check+0x37d>
  8004205f3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f41:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205f45:	75 35                	jne    8004205f7c <page_check+0x3b2>
  8004205f47:	48 b9 48 52 21 04 80 	movabs $0x8004215248,%rcx
  8004205f4e:	00 00 00 
  8004205f51:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205f58:	00 00 00 
  8004205f5b:	be 82 04 00 00       	mov    $0x482,%esi
  8004205f60:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205f67:	00 00 00 
  8004205f6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f6f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205f76:	00 00 00 
  8004205f79:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205f7c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205f81:	74 32                	je     8004205fb5 <page_check+0x3eb>
  8004205f83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f87:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205f8b:	74 28                	je     8004205fb5 <page_check+0x3eb>
  8004205f8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f91:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205f95:	74 1e                	je     8004205fb5 <page_check+0x3eb>
  8004205f97:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f9b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205f9f:	74 14                	je     8004205fb5 <page_check+0x3eb>
  8004205fa1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fa5:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205fa9:	74 0a                	je     8004205fb5 <page_check+0x3eb>
  8004205fab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205faf:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205fb3:	75 35                	jne    8004205fea <page_check+0x420>
  8004205fb5:	48 b9 88 52 21 04 80 	movabs $0x8004215288,%rcx
  8004205fbc:	00 00 00 
  8004205fbf:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004205fc6:	00 00 00 
  8004205fc9:	be 83 04 00 00       	mov    $0x483,%esi
  8004205fce:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004205fd5:	00 00 00 
  8004205fd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fdd:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004205fe4:	00 00 00 
  8004205fe7:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205fea:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004205ff1:	00 00 00 
  8004205ff4:	48 8b 00             	mov    (%rax),%rax
  8004205ff7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205ffb:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004206002:	00 00 00 
  8004206005:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420600c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206011:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004206018:	00 00 00 
  800420601b:	ff d0                	callq  *%rax
  800420601d:	48 85 c0             	test   %rax,%rax
  8004206020:	74 35                	je     8004206057 <page_check+0x48d>
  8004206022:	48 b9 df 4f 21 04 80 	movabs $0x8004214fdf,%rcx
  8004206029:	00 00 00 
  800420602c:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206033:	00 00 00 
  8004206036:	be 8a 04 00 00       	mov    $0x48a,%esi
  800420603b:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206042:	00 00 00 
  8004206045:	b8 00 00 00 00       	mov    $0x0,%eax
  800420604a:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206051:	00 00 00 
  8004206054:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004206057:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420605e:	00 00 00 
  8004206061:	48 8b 00             	mov    (%rax),%rax
  8004206064:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  800420606b:	be 00 00 00 00       	mov    $0x0,%esi
  8004206070:	48 89 c7             	mov    %rax,%rdi
  8004206073:	48 b8 89 3e 20 04 80 	movabs $0x8004203e89,%rax
  800420607a:	00 00 00 
  800420607d:	ff d0                	callq  *%rax
  800420607f:	48 85 c0             	test   %rax,%rax
  8004206082:	74 35                	je     80042060b9 <page_check+0x4ef>
  8004206084:	48 b9 d8 52 21 04 80 	movabs $0x80042152d8,%rcx
  800420608b:	00 00 00 
  800420608e:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206095:	00 00 00 
  8004206098:	be 8d 04 00 00       	mov    $0x48d,%esi
  800420609d:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042060a4:	00 00 00 
  80042060a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060ac:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042060b3:	00 00 00 
  80042060b6:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042060b9:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042060c0:	00 00 00 
  80042060c3:	48 8b 00             	mov    (%rax),%rax
  80042060c6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042060ca:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042060cf:	ba 00 00 00 00       	mov    $0x0,%edx
  80042060d4:	48 89 c7             	mov    %rax,%rdi
  80042060d7:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  80042060de:	00 00 00 
  80042060e1:	ff d0                	callq  *%rax
  80042060e3:	85 c0                	test   %eax,%eax
  80042060e5:	78 35                	js     800420611c <page_check+0x552>
  80042060e7:	48 b9 10 53 21 04 80 	movabs $0x8004215310,%rcx
  80042060ee:	00 00 00 
  80042060f1:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042060f8:	00 00 00 
  80042060fb:	be 90 04 00 00       	mov    $0x490,%esi
  8004206100:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206107:	00 00 00 
  800420610a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420610f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206116:	00 00 00 
  8004206119:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  800420611c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206120:	48 89 c7             	mov    %rax,%rdi
  8004206123:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  800420612a:	00 00 00 
  800420612d:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420612f:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206136:	00 00 00 
  8004206139:	48 8b 00             	mov    (%rax),%rax
  800420613c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206140:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206145:	ba 00 00 00 00       	mov    $0x0,%edx
  800420614a:	48 89 c7             	mov    %rax,%rdi
  800420614d:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004206154:	00 00 00 
  8004206157:	ff d0                	callq  *%rax
  8004206159:	85 c0                	test   %eax,%eax
  800420615b:	78 35                	js     8004206192 <page_check+0x5c8>
  800420615d:	48 b9 10 53 21 04 80 	movabs $0x8004215310,%rcx
  8004206164:	00 00 00 
  8004206167:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420616e:	00 00 00 
  8004206171:	be 94 04 00 00       	mov    $0x494,%esi
  8004206176:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420617d:	00 00 00 
  8004206180:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206185:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420618c:	00 00 00 
  800420618f:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004206192:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206196:	48 89 c7             	mov    %rax,%rdi
  8004206199:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  80042061a0:	00 00 00 
  80042061a3:	ff d0                	callq  *%rax
	page_free(pp3);
  80042061a5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042061a9:	48 89 c7             	mov    %rax,%rdi
  80042061ac:	48 b8 49 30 20 04 80 	movabs $0x8004203049,%rax
  80042061b3:	00 00 00 
  80042061b6:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042061b8:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042061bf:	00 00 00 
  80042061c2:	48 8b 00             	mov    (%rax),%rax
  80042061c5:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042061c9:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042061ce:	ba 00 00 00 00       	mov    $0x0,%edx
  80042061d3:	48 89 c7             	mov    %rax,%rdi
  80042061d6:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  80042061dd:	00 00 00 
  80042061e0:	ff d0                	callq  *%rax
  80042061e2:	85 c0                	test   %eax,%eax
  80042061e4:	74 35                	je     800420621b <page_check+0x651>
  80042061e6:	48 b9 40 53 21 04 80 	movabs $0x8004215340,%rcx
  80042061ed:	00 00 00 
  80042061f0:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042061f7:	00 00 00 
  80042061fa:	be 9a 04 00 00       	mov    $0x49a,%esi
  80042061ff:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206206:	00 00 00 
  8004206209:	b8 00 00 00 00       	mov    $0x0,%eax
  800420620e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206215:	00 00 00 
  8004206218:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  800420621b:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206222:	00 00 00 
  8004206225:	48 8b 00             	mov    (%rax),%rax
  8004206228:	48 8b 00             	mov    (%rax),%rax
  800420622b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206231:	48 89 c3             	mov    %rax,%rbx
  8004206234:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206238:	48 89 c7             	mov    %rax,%rdi
  800420623b:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206242:	00 00 00 
  8004206245:	ff d0                	callq  *%rax
  8004206247:	48 39 c3             	cmp    %rax,%rbx
  800420624a:	0f 84 97 00 00 00    	je     80042062e7 <page_check+0x71d>
  8004206250:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206257:	00 00 00 
  800420625a:	48 8b 00             	mov    (%rax),%rax
  800420625d:	48 8b 00             	mov    (%rax),%rax
  8004206260:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206266:	48 89 c3             	mov    %rax,%rbx
  8004206269:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420626d:	48 89 c7             	mov    %rax,%rdi
  8004206270:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206277:	00 00 00 
  800420627a:	ff d0                	callq  *%rax
  800420627c:	48 39 c3             	cmp    %rax,%rbx
  800420627f:	74 66                	je     80042062e7 <page_check+0x71d>
  8004206281:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206288:	00 00 00 
  800420628b:	48 8b 00             	mov    (%rax),%rax
  800420628e:	48 8b 00             	mov    (%rax),%rax
  8004206291:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206297:	48 89 c3             	mov    %rax,%rbx
  800420629a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420629e:	48 89 c7             	mov    %rax,%rdi
  80042062a1:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042062a8:	00 00 00 
  80042062ab:	ff d0                	callq  *%rax
  80042062ad:	48 39 c3             	cmp    %rax,%rbx
  80042062b0:	74 35                	je     80042062e7 <page_check+0x71d>
  80042062b2:	48 b9 70 53 21 04 80 	movabs $0x8004215370,%rcx
  80042062b9:	00 00 00 
  80042062bc:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042062c3:	00 00 00 
  80042062c6:	be 9b 04 00 00       	mov    $0x49b,%esi
  80042062cb:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042062d2:	00 00 00 
  80042062d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062da:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042062e1:	00 00 00 
  80042062e4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  80042062e7:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042062ee:	00 00 00 
  80042062f1:	48 8b 00             	mov    (%rax),%rax
  80042062f4:	be 00 00 00 00       	mov    $0x0,%esi
  80042062f9:	48 89 c7             	mov    %rax,%rdi
  80042062fc:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206303:	00 00 00 
  8004206306:	ff d0                	callq  *%rax
  8004206308:	48 89 c3             	mov    %rax,%rbx
  800420630b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420630f:	48 89 c7             	mov    %rax,%rdi
  8004206312:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206319:	00 00 00 
  800420631c:	ff d0                	callq  *%rax
  800420631e:	48 39 c3             	cmp    %rax,%rbx
  8004206321:	74 35                	je     8004206358 <page_check+0x78e>
  8004206323:	48 b9 f8 53 21 04 80 	movabs $0x80042153f8,%rcx
  800420632a:	00 00 00 
  800420632d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206334:	00 00 00 
  8004206337:	be 9c 04 00 00       	mov    $0x49c,%esi
  800420633c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206343:	00 00 00 
  8004206346:	b8 00 00 00 00       	mov    $0x0,%eax
  800420634b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206352:	00 00 00 
  8004206355:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206358:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420635c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206360:	66 83 f8 01          	cmp    $0x1,%ax
  8004206364:	74 35                	je     800420639b <page_check+0x7d1>
  8004206366:	48 b9 25 54 21 04 80 	movabs $0x8004215425,%rcx
  800420636d:	00 00 00 
  8004206370:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206377:	00 00 00 
  800420637a:	be 9d 04 00 00       	mov    $0x49d,%esi
  800420637f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206386:	00 00 00 
  8004206389:	b8 00 00 00 00       	mov    $0x0,%eax
  800420638e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206395:	00 00 00 
  8004206398:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  800420639b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420639f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063a3:	66 83 f8 01          	cmp    $0x1,%ax
  80042063a7:	74 35                	je     80042063de <page_check+0x814>
  80042063a9:	48 b9 36 54 21 04 80 	movabs $0x8004215436,%rcx
  80042063b0:	00 00 00 
  80042063b3:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042063ba:	00 00 00 
  80042063bd:	be 9e 04 00 00       	mov    $0x49e,%esi
  80042063c2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042063c9:	00 00 00 
  80042063cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063d1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042063d8:	00 00 00 
  80042063db:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  80042063de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042063e2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063e6:	66 83 f8 01          	cmp    $0x1,%ax
  80042063ea:	74 35                	je     8004206421 <page_check+0x857>
  80042063ec:	48 b9 47 54 21 04 80 	movabs $0x8004215447,%rcx
  80042063f3:	00 00 00 
  80042063f6:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042063fd:	00 00 00 
  8004206400:	be 9f 04 00 00       	mov    $0x49f,%esi
  8004206405:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420640c:	00 00 00 
  800420640f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206414:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420641b:	00 00 00 
  800420641e:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206421:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206428:	00 00 00 
  800420642b:	48 8b 00             	mov    (%rax),%rax
  800420642e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206432:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206437:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420643c:	48 89 c7             	mov    %rax,%rdi
  800420643f:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004206446:	00 00 00 
  8004206449:	ff d0                	callq  *%rax
  800420644b:	85 c0                	test   %eax,%eax
  800420644d:	74 35                	je     8004206484 <page_check+0x8ba>
  800420644f:	48 b9 58 54 21 04 80 	movabs $0x8004215458,%rcx
  8004206456:	00 00 00 
  8004206459:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206460:	00 00 00 
  8004206463:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004206468:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420646f:	00 00 00 
  8004206472:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206477:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420647e:	00 00 00 
  8004206481:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206484:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420648b:	00 00 00 
  800420648e:	48 8b 00             	mov    (%rax),%rax
  8004206491:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206496:	48 89 c7             	mov    %rax,%rdi
  8004206499:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  80042064a0:	00 00 00 
  80042064a3:	ff d0                	callq  *%rax
  80042064a5:	48 89 c3             	mov    %rax,%rbx
  80042064a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064ac:	48 89 c7             	mov    %rax,%rdi
  80042064af:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  80042064b6:	00 00 00 
  80042064b9:	ff d0                	callq  *%rax
  80042064bb:	48 39 c3             	cmp    %rax,%rbx
  80042064be:	74 35                	je     80042064f5 <page_check+0x92b>
  80042064c0:	48 b9 90 54 21 04 80 	movabs $0x8004215490,%rcx
  80042064c7:	00 00 00 
  80042064ca:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042064d1:	00 00 00 
  80042064d4:	be a2 04 00 00       	mov    $0x4a2,%esi
  80042064d9:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042064e0:	00 00 00 
  80042064e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064e8:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042064ef:	00 00 00 
  80042064f2:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042064f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064f9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042064fd:	66 83 f8 02          	cmp    $0x2,%ax
  8004206501:	74 35                	je     8004206538 <page_check+0x96e>
  8004206503:	48 b9 c0 54 21 04 80 	movabs $0x80042154c0,%rcx
  800420650a:	00 00 00 
  800420650d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206514:	00 00 00 
  8004206517:	be a3 04 00 00       	mov    $0x4a3,%esi
  800420651c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206523:	00 00 00 
  8004206526:	b8 00 00 00 00       	mov    $0x0,%eax
  800420652b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206532:	00 00 00 
  8004206535:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004206538:	bf 00 00 00 00       	mov    $0x0,%edi
  800420653d:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004206544:	00 00 00 
  8004206547:	ff d0                	callq  *%rax
  8004206549:	48 85 c0             	test   %rax,%rax
  800420654c:	74 35                	je     8004206583 <page_check+0x9b9>
  800420654e:	48 b9 df 4f 21 04 80 	movabs $0x8004214fdf,%rcx
  8004206555:	00 00 00 
  8004206558:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420655f:	00 00 00 
  8004206562:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004206567:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420656e:	00 00 00 
  8004206571:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206576:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420657d:	00 00 00 
  8004206580:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206583:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420658a:	00 00 00 
  800420658d:	48 8b 00             	mov    (%rax),%rax
  8004206590:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206594:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206599:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420659e:	48 89 c7             	mov    %rax,%rdi
  80042065a1:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  80042065a8:	00 00 00 
  80042065ab:	ff d0                	callq  *%rax
  80042065ad:	85 c0                	test   %eax,%eax
  80042065af:	74 35                	je     80042065e6 <page_check+0xa1c>
  80042065b1:	48 b9 58 54 21 04 80 	movabs $0x8004215458,%rcx
  80042065b8:	00 00 00 
  80042065bb:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042065c2:	00 00 00 
  80042065c5:	be a9 04 00 00       	mov    $0x4a9,%esi
  80042065ca:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042065d1:	00 00 00 
  80042065d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065d9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042065e0:	00 00 00 
  80042065e3:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042065e6:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042065ed:	00 00 00 
  80042065f0:	48 8b 00             	mov    (%rax),%rax
  80042065f3:	be 00 10 00 00       	mov    $0x1000,%esi
  80042065f8:	48 89 c7             	mov    %rax,%rdi
  80042065fb:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206602:	00 00 00 
  8004206605:	ff d0                	callq  *%rax
  8004206607:	48 89 c3             	mov    %rax,%rbx
  800420660a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420660e:	48 89 c7             	mov    %rax,%rdi
  8004206611:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206618:	00 00 00 
  800420661b:	ff d0                	callq  *%rax
  800420661d:	48 39 c3             	cmp    %rax,%rbx
  8004206620:	74 35                	je     8004206657 <page_check+0xa8d>
  8004206622:	48 b9 90 54 21 04 80 	movabs $0x8004215490,%rcx
  8004206629:	00 00 00 
  800420662c:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206633:	00 00 00 
  8004206636:	be aa 04 00 00       	mov    $0x4aa,%esi
  800420663b:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206642:	00 00 00 
  8004206645:	b8 00 00 00 00       	mov    $0x0,%eax
  800420664a:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206651:	00 00 00 
  8004206654:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206657:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420665b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420665f:	66 83 f8 02          	cmp    $0x2,%ax
  8004206663:	74 35                	je     800420669a <page_check+0xad0>
  8004206665:	48 b9 c0 54 21 04 80 	movabs $0x80042154c0,%rcx
  800420666c:	00 00 00 
  800420666f:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206676:	00 00 00 
  8004206679:	be ab 04 00 00       	mov    $0x4ab,%esi
  800420667e:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206685:	00 00 00 
  8004206688:	b8 00 00 00 00       	mov    $0x0,%eax
  800420668d:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206694:	00 00 00 
  8004206697:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  800420669a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420669f:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  80042066a6:	00 00 00 
  80042066a9:	ff d0                	callq  *%rax
  80042066ab:	48 85 c0             	test   %rax,%rax
  80042066ae:	74 35                	je     80042066e5 <page_check+0xb1b>
  80042066b0:	48 b9 df 4f 21 04 80 	movabs $0x8004214fdf,%rcx
  80042066b7:	00 00 00 
  80042066ba:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042066c1:	00 00 00 
  80042066c4:	be af 04 00 00       	mov    $0x4af,%esi
  80042066c9:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042066d0:	00 00 00 
  80042066d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066d8:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042066df:	00 00 00 
  80042066e2:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  80042066e5:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042066ec:	00 00 00 
  80042066ef:	48 8b 00             	mov    (%rax),%rax
  80042066f2:	48 8b 00             	mov    (%rax),%rax
  80042066f5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042066fb:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042066ff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206703:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206707:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  800420670a:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  800420670d:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004206714:	00 00 00 
  8004206717:	48 8b 00             	mov    (%rax),%rax
  800420671a:	48 39 c2             	cmp    %rax,%rdx
  800420671d:	72 32                	jb     8004206751 <page_check+0xb87>
  800420671f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206723:	48 89 c1             	mov    %rax,%rcx
  8004206726:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  800420672d:	00 00 00 
  8004206730:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004206735:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420673c:	00 00 00 
  800420673f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206744:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420674b:	00 00 00 
  800420674e:	41 ff d0             	callq  *%r8
  8004206751:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206758:	00 00 00 
  800420675b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420675f:	48 01 d0             	add    %rdx,%rax
  8004206762:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004206766:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420676a:	48 8b 00             	mov    (%rax),%rax
  800420676d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206773:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004206777:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420677b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420677f:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004206782:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004206785:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420678c:	00 00 00 
  800420678f:	48 8b 00             	mov    (%rax),%rax
  8004206792:	48 39 c2             	cmp    %rax,%rdx
  8004206795:	72 32                	jb     80042067c9 <page_check+0xbff>
  8004206797:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420679b:	48 89 c1             	mov    %rax,%rcx
  800420679e:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042067a5:	00 00 00 
  80042067a8:	be b2 04 00 00       	mov    $0x4b2,%esi
  80042067ad:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042067b4:	00 00 00 
  80042067b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067bc:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042067c3:	00 00 00 
  80042067c6:	41 ff d0             	callq  *%r8
  80042067c9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042067d0:	00 00 00 
  80042067d3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042067d7:	48 01 d0             	add    %rdx,%rax
  80042067da:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  80042067de:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042067e2:	48 8b 00             	mov    (%rax),%rax
  80042067e5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042067eb:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042067f2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042067f9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042067fd:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004206803:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004206809:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004206810:	00 00 00 
  8004206813:	48 8b 00             	mov    (%rax),%rax
  8004206816:	48 39 c2             	cmp    %rax,%rdx
  8004206819:	72 35                	jb     8004206850 <page_check+0xc86>
  800420681b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206822:	48 89 c1             	mov    %rax,%rcx
  8004206825:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  800420682c:	00 00 00 
  800420682f:	be b3 04 00 00       	mov    $0x4b3,%esi
  8004206834:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420683b:	00 00 00 
  800420683e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206843:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420684a:	00 00 00 
  800420684d:	41 ff d0             	callq  *%r8
  8004206850:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206857:	00 00 00 
  800420685a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206861:	48 01 d0             	add    %rdx,%rax
  8004206864:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  800420686b:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206872:	00 00 00 
  8004206875:	48 8b 00             	mov    (%rax),%rax
  8004206878:	ba 00 00 00 00       	mov    $0x0,%edx
  800420687d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206882:	48 89 c7             	mov    %rax,%rdi
  8004206885:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  800420688c:	00 00 00 
  800420688f:	ff d0                	callq  *%rax
  8004206891:	48 89 c2             	mov    %rax,%rdx
  8004206894:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  800420689b:	48 83 c0 08          	add    $0x8,%rax
  800420689f:	48 39 c2             	cmp    %rax,%rdx
  80042068a2:	74 35                	je     80042068d9 <page_check+0xd0f>
  80042068a4:	48 b9 d8 54 21 04 80 	movabs $0x80042154d8,%rcx
  80042068ab:	00 00 00 
  80042068ae:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042068b5:	00 00 00 
  80042068b8:	be b4 04 00 00       	mov    $0x4b4,%esi
  80042068bd:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042068c4:	00 00 00 
  80042068c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068cc:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042068d3:	00 00 00 
  80042068d6:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  80042068d9:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042068e0:	00 00 00 
  80042068e3:	48 8b 00             	mov    (%rax),%rax
  80042068e6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042068ea:	b9 04 00 00 00       	mov    $0x4,%ecx
  80042068ef:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042068f4:	48 89 c7             	mov    %rax,%rdi
  80042068f7:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  80042068fe:	00 00 00 
  8004206901:	ff d0                	callq  *%rax
  8004206903:	85 c0                	test   %eax,%eax
  8004206905:	74 35                	je     800420693c <page_check+0xd72>
  8004206907:	48 b9 18 55 21 04 80 	movabs $0x8004215518,%rcx
  800420690e:	00 00 00 
  8004206911:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206918:	00 00 00 
  800420691b:	be b7 04 00 00       	mov    $0x4b7,%esi
  8004206920:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206927:	00 00 00 
  800420692a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420692f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206936:	00 00 00 
  8004206939:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420693c:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206943:	00 00 00 
  8004206946:	48 8b 00             	mov    (%rax),%rax
  8004206949:	be 00 10 00 00       	mov    $0x1000,%esi
  800420694e:	48 89 c7             	mov    %rax,%rdi
  8004206951:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206958:	00 00 00 
  800420695b:	ff d0                	callq  *%rax
  800420695d:	48 89 c3             	mov    %rax,%rbx
  8004206960:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206964:	48 89 c7             	mov    %rax,%rdi
  8004206967:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  800420696e:	00 00 00 
  8004206971:	ff d0                	callq  *%rax
  8004206973:	48 39 c3             	cmp    %rax,%rbx
  8004206976:	74 35                	je     80042069ad <page_check+0xde3>
  8004206978:	48 b9 90 54 21 04 80 	movabs $0x8004215490,%rcx
  800420697f:	00 00 00 
  8004206982:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206989:	00 00 00 
  800420698c:	be b8 04 00 00       	mov    $0x4b8,%esi
  8004206991:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206998:	00 00 00 
  800420699b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069a0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042069a7:	00 00 00 
  80042069aa:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042069ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069b1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042069b5:	66 83 f8 02          	cmp    $0x2,%ax
  80042069b9:	74 35                	je     80042069f0 <page_check+0xe26>
  80042069bb:	48 b9 c0 54 21 04 80 	movabs $0x80042154c0,%rcx
  80042069c2:	00 00 00 
  80042069c5:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042069cc:	00 00 00 
  80042069cf:	be b9 04 00 00       	mov    $0x4b9,%esi
  80042069d4:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042069db:	00 00 00 
  80042069de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069e3:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042069ea:	00 00 00 
  80042069ed:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  80042069f0:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042069f7:	00 00 00 
  80042069fa:	48 8b 00             	mov    (%rax),%rax
  80042069fd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206a02:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a07:	48 89 c7             	mov    %rax,%rdi
  8004206a0a:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004206a11:	00 00 00 
  8004206a14:	ff d0                	callq  *%rax
  8004206a16:	48 8b 00             	mov    (%rax),%rax
  8004206a19:	83 e0 04             	and    $0x4,%eax
  8004206a1c:	48 85 c0             	test   %rax,%rax
  8004206a1f:	75 35                	jne    8004206a56 <page_check+0xe8c>
  8004206a21:	48 b9 58 55 21 04 80 	movabs $0x8004215558,%rcx
  8004206a28:	00 00 00 
  8004206a2b:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206a32:	00 00 00 
  8004206a35:	be ba 04 00 00       	mov    $0x4ba,%esi
  8004206a3a:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206a41:	00 00 00 
  8004206a44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a49:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206a50:	00 00 00 
  8004206a53:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206a56:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206a5d:	00 00 00 
  8004206a60:	48 8b 00             	mov    (%rax),%rax
  8004206a63:	48 8b 00             	mov    (%rax),%rax
  8004206a66:	83 e0 04             	and    $0x4,%eax
  8004206a69:	48 85 c0             	test   %rax,%rax
  8004206a6c:	75 35                	jne    8004206aa3 <page_check+0xed9>
  8004206a6e:	48 b9 8b 55 21 04 80 	movabs $0x800421558b,%rcx
  8004206a75:	00 00 00 
  8004206a78:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206a7f:	00 00 00 
  8004206a82:	be bb 04 00 00       	mov    $0x4bb,%esi
  8004206a87:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206a8e:	00 00 00 
  8004206a91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a96:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206a9d:	00 00 00 
  8004206aa0:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206aa3:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206aaa:	00 00 00 
  8004206aad:	48 8b 00             	mov    (%rax),%rax
  8004206ab0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206ab4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206ab9:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206abe:	48 89 c7             	mov    %rax,%rdi
  8004206ac1:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004206ac8:	00 00 00 
  8004206acb:	ff d0                	callq  *%rax
  8004206acd:	85 c0                	test   %eax,%eax
  8004206acf:	78 35                	js     8004206b06 <page_check+0xf3c>
  8004206ad1:	48 b9 a8 55 21 04 80 	movabs $0x80042155a8,%rcx
  8004206ad8:	00 00 00 
  8004206adb:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206ae2:	00 00 00 
  8004206ae5:	be bf 04 00 00       	mov    $0x4bf,%esi
  8004206aea:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206af1:	00 00 00 
  8004206af4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206af9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206b00:	00 00 00 
  8004206b03:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206b06:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206b0d:	00 00 00 
  8004206b10:	48 8b 00             	mov    (%rax),%rax
  8004206b13:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206b17:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206b1c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206b21:	48 89 c7             	mov    %rax,%rdi
  8004206b24:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004206b2b:	00 00 00 
  8004206b2e:	ff d0                	callq  *%rax
  8004206b30:	85 c0                	test   %eax,%eax
  8004206b32:	74 35                	je     8004206b69 <page_check+0xf9f>
  8004206b34:	48 b9 e0 55 21 04 80 	movabs $0x80042155e0,%rcx
  8004206b3b:	00 00 00 
  8004206b3e:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206b45:	00 00 00 
  8004206b48:	be c2 04 00 00       	mov    $0x4c2,%esi
  8004206b4d:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206b54:	00 00 00 
  8004206b57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b5c:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206b63:	00 00 00 
  8004206b66:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206b69:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206b70:	00 00 00 
  8004206b73:	48 8b 00             	mov    (%rax),%rax
  8004206b76:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206b7b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206b80:	48 89 c7             	mov    %rax,%rdi
  8004206b83:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004206b8a:	00 00 00 
  8004206b8d:	ff d0                	callq  *%rax
  8004206b8f:	48 8b 00             	mov    (%rax),%rax
  8004206b92:	83 e0 04             	and    $0x4,%eax
  8004206b95:	48 85 c0             	test   %rax,%rax
  8004206b98:	74 35                	je     8004206bcf <page_check+0x1005>
  8004206b9a:	48 b9 18 56 21 04 80 	movabs $0x8004215618,%rcx
  8004206ba1:	00 00 00 
  8004206ba4:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206bab:	00 00 00 
  8004206bae:	be c3 04 00 00       	mov    $0x4c3,%esi
  8004206bb3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206bba:	00 00 00 
  8004206bbd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bc2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206bc9:	00 00 00 
  8004206bcc:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206bcf:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206bd6:	00 00 00 
  8004206bd9:	48 8b 00             	mov    (%rax),%rax
  8004206bdc:	be 00 00 00 00       	mov    $0x0,%esi
  8004206be1:	48 89 c7             	mov    %rax,%rdi
  8004206be4:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206beb:	00 00 00 
  8004206bee:	ff d0                	callq  *%rax
  8004206bf0:	48 89 c3             	mov    %rax,%rbx
  8004206bf3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206bf7:	48 89 c7             	mov    %rax,%rdi
  8004206bfa:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206c01:	00 00 00 
  8004206c04:	ff d0                	callq  *%rax
  8004206c06:	48 39 c3             	cmp    %rax,%rbx
  8004206c09:	74 35                	je     8004206c40 <page_check+0x1076>
  8004206c0b:	48 b9 50 56 21 04 80 	movabs $0x8004215650,%rcx
  8004206c12:	00 00 00 
  8004206c15:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206c1c:	00 00 00 
  8004206c1f:	be c6 04 00 00       	mov    $0x4c6,%esi
  8004206c24:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206c2b:	00 00 00 
  8004206c2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c33:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206c3a:	00 00 00 
  8004206c3d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206c40:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206c47:	00 00 00 
  8004206c4a:	48 8b 00             	mov    (%rax),%rax
  8004206c4d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206c52:	48 89 c7             	mov    %rax,%rdi
  8004206c55:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206c5c:	00 00 00 
  8004206c5f:	ff d0                	callq  *%rax
  8004206c61:	48 89 c3             	mov    %rax,%rbx
  8004206c64:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c68:	48 89 c7             	mov    %rax,%rdi
  8004206c6b:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206c72:	00 00 00 
  8004206c75:	ff d0                	callq  *%rax
  8004206c77:	48 39 c3             	cmp    %rax,%rbx
  8004206c7a:	74 35                	je     8004206cb1 <page_check+0x10e7>
  8004206c7c:	48 b9 80 56 21 04 80 	movabs $0x8004215680,%rcx
  8004206c83:	00 00 00 
  8004206c86:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206c8d:	00 00 00 
  8004206c90:	be c7 04 00 00       	mov    $0x4c7,%esi
  8004206c95:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206c9c:	00 00 00 
  8004206c9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ca4:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206cab:	00 00 00 
  8004206cae:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206cb1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206cb5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206cb9:	66 83 f8 02          	cmp    $0x2,%ax
  8004206cbd:	74 35                	je     8004206cf4 <page_check+0x112a>
  8004206cbf:	48 b9 b0 56 21 04 80 	movabs $0x80042156b0,%rcx
  8004206cc6:	00 00 00 
  8004206cc9:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206cd0:	00 00 00 
  8004206cd3:	be c9 04 00 00       	mov    $0x4c9,%esi
  8004206cd8:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206cdf:	00 00 00 
  8004206ce2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ce7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206cee:	00 00 00 
  8004206cf1:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206cf4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206cf8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206cfc:	66 83 f8 01          	cmp    $0x1,%ax
  8004206d00:	74 35                	je     8004206d37 <page_check+0x116d>
  8004206d02:	48 b9 c1 56 21 04 80 	movabs $0x80042156c1,%rcx
  8004206d09:	00 00 00 
  8004206d0c:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206d13:	00 00 00 
  8004206d16:	be ca 04 00 00       	mov    $0x4ca,%esi
  8004206d1b:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206d22:	00 00 00 
  8004206d25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d2a:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206d31:	00 00 00 
  8004206d34:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206d37:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206d3e:	00 00 00 
  8004206d41:	48 8b 00             	mov    (%rax),%rax
  8004206d44:	be 00 00 00 00       	mov    $0x0,%esi
  8004206d49:	48 89 c7             	mov    %rax,%rdi
  8004206d4c:	48 b8 14 3f 20 04 80 	movabs $0x8004203f14,%rax
  8004206d53:	00 00 00 
  8004206d56:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206d58:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206d5f:	00 00 00 
  8004206d62:	48 8b 00             	mov    (%rax),%rax
  8004206d65:	be 00 00 00 00       	mov    $0x0,%esi
  8004206d6a:	48 89 c7             	mov    %rax,%rdi
  8004206d6d:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206d74:	00 00 00 
  8004206d77:	ff d0                	callq  *%rax
  8004206d79:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206d7d:	74 35                	je     8004206db4 <page_check+0x11ea>
  8004206d7f:	48 b9 d8 56 21 04 80 	movabs $0x80042156d8,%rcx
  8004206d86:	00 00 00 
  8004206d89:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206d90:	00 00 00 
  8004206d93:	be cf 04 00 00       	mov    $0x4cf,%esi
  8004206d98:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206d9f:	00 00 00 
  8004206da2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206da7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206dae:	00 00 00 
  8004206db1:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206db4:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206dbb:	00 00 00 
  8004206dbe:	48 8b 00             	mov    (%rax),%rax
  8004206dc1:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206dc6:	48 89 c7             	mov    %rax,%rdi
  8004206dc9:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206dd0:	00 00 00 
  8004206dd3:	ff d0                	callq  *%rax
  8004206dd5:	48 89 c3             	mov    %rax,%rbx
  8004206dd8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206ddc:	48 89 c7             	mov    %rax,%rdi
  8004206ddf:	48 b8 2a 1c 20 04 80 	movabs $0x8004201c2a,%rax
  8004206de6:	00 00 00 
  8004206de9:	ff d0                	callq  *%rax
  8004206deb:	48 39 c3             	cmp    %rax,%rbx
  8004206dee:	74 35                	je     8004206e25 <page_check+0x125b>
  8004206df0:	48 b9 80 56 21 04 80 	movabs $0x8004215680,%rcx
  8004206df7:	00 00 00 
  8004206dfa:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206e01:	00 00 00 
  8004206e04:	be d0 04 00 00       	mov    $0x4d0,%esi
  8004206e09:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206e10:	00 00 00 
  8004206e13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e18:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206e1f:	00 00 00 
  8004206e22:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206e25:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e29:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e2d:	66 83 f8 01          	cmp    $0x1,%ax
  8004206e31:	74 35                	je     8004206e68 <page_check+0x129e>
  8004206e33:	48 b9 25 54 21 04 80 	movabs $0x8004215425,%rcx
  8004206e3a:	00 00 00 
  8004206e3d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206e44:	00 00 00 
  8004206e47:	be d1 04 00 00       	mov    $0x4d1,%esi
  8004206e4c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206e53:	00 00 00 
  8004206e56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e5b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206e62:	00 00 00 
  8004206e65:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206e68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206e6c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e70:	66 83 f8 01          	cmp    $0x1,%ax
  8004206e74:	74 35                	je     8004206eab <page_check+0x12e1>
  8004206e76:	48 b9 c1 56 21 04 80 	movabs $0x80042156c1,%rcx
  8004206e7d:	00 00 00 
  8004206e80:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206e87:	00 00 00 
  8004206e8a:	be d2 04 00 00       	mov    $0x4d2,%esi
  8004206e8f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206e96:	00 00 00 
  8004206e99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e9e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206ea5:	00 00 00 
  8004206ea8:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206eab:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206eb2:	00 00 00 
  8004206eb5:	48 8b 00             	mov    (%rax),%rax
  8004206eb8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206ebc:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206ec1:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206ec6:	48 89 c7             	mov    %rax,%rdi
  8004206ec9:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004206ed0:	00 00 00 
  8004206ed3:	ff d0                	callq  *%rax
  8004206ed5:	85 c0                	test   %eax,%eax
  8004206ed7:	74 35                	je     8004206f0e <page_check+0x1344>
  8004206ed9:	48 b9 e0 55 21 04 80 	movabs $0x80042155e0,%rcx
  8004206ee0:	00 00 00 
  8004206ee3:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206eea:	00 00 00 
  8004206eed:	be d6 04 00 00       	mov    $0x4d6,%esi
  8004206ef2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206ef9:	00 00 00 
  8004206efc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f01:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206f08:	00 00 00 
  8004206f0b:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206f0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f12:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f16:	66 85 c0             	test   %ax,%ax
  8004206f19:	75 35                	jne    8004206f50 <page_check+0x1386>
  8004206f1b:	48 b9 fb 56 21 04 80 	movabs $0x80042156fb,%rcx
  8004206f22:	00 00 00 
  8004206f25:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206f2c:	00 00 00 
  8004206f2f:	be d7 04 00 00       	mov    $0x4d7,%esi
  8004206f34:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206f3b:	00 00 00 
  8004206f3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f43:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206f4a:	00 00 00 
  8004206f4d:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206f50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f54:	48 8b 00             	mov    (%rax),%rax
  8004206f57:	48 85 c0             	test   %rax,%rax
  8004206f5a:	74 35                	je     8004206f91 <page_check+0x13c7>
  8004206f5c:	48 b9 07 57 21 04 80 	movabs $0x8004215707,%rcx
  8004206f63:	00 00 00 
  8004206f66:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206f6d:	00 00 00 
  8004206f70:	be d8 04 00 00       	mov    $0x4d8,%esi
  8004206f75:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206f7c:	00 00 00 
  8004206f7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f84:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004206f8b:	00 00 00 
  8004206f8e:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206f91:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206f98:	00 00 00 
  8004206f9b:	48 8b 00             	mov    (%rax),%rax
  8004206f9e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206fa3:	48 89 c7             	mov    %rax,%rdi
  8004206fa6:	48 b8 14 3f 20 04 80 	movabs $0x8004203f14,%rax
  8004206fad:	00 00 00 
  8004206fb0:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206fb2:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004206fb9:	00 00 00 
  8004206fbc:	48 8b 00             	mov    (%rax),%rax
  8004206fbf:	be 00 00 00 00       	mov    $0x0,%esi
  8004206fc4:	48 89 c7             	mov    %rax,%rdi
  8004206fc7:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004206fce:	00 00 00 
  8004206fd1:	ff d0                	callq  *%rax
  8004206fd3:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206fd7:	74 35                	je     800420700e <page_check+0x1444>
  8004206fd9:	48 b9 d8 56 21 04 80 	movabs $0x80042156d8,%rcx
  8004206fe0:	00 00 00 
  8004206fe3:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004206fea:	00 00 00 
  8004206fed:	be dc 04 00 00       	mov    $0x4dc,%esi
  8004206ff2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004206ff9:	00 00 00 
  8004206ffc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207001:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207008:	00 00 00 
  800420700b:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  800420700e:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207015:	00 00 00 
  8004207018:	48 8b 00             	mov    (%rax),%rax
  800420701b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207020:	48 89 c7             	mov    %rax,%rdi
  8004207023:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  800420702a:	00 00 00 
  800420702d:	ff d0                	callq  *%rax
  800420702f:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207033:	74 35                	je     800420706a <page_check+0x14a0>
  8004207035:	48 b9 20 57 21 04 80 	movabs $0x8004215720,%rcx
  800420703c:	00 00 00 
  800420703f:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207046:	00 00 00 
  8004207049:	be dd 04 00 00       	mov    $0x4dd,%esi
  800420704e:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207055:	00 00 00 
  8004207058:	b8 00 00 00 00       	mov    $0x0,%eax
  800420705d:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207064:	00 00 00 
  8004207067:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  800420706a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420706e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207072:	66 85 c0             	test   %ax,%ax
  8004207075:	74 35                	je     80042070ac <page_check+0x14e2>
  8004207077:	48 b9 46 57 21 04 80 	movabs $0x8004215746,%rcx
  800420707e:	00 00 00 
  8004207081:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207088:	00 00 00 
  800420708b:	be de 04 00 00       	mov    $0x4de,%esi
  8004207090:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207097:	00 00 00 
  800420709a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420709f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042070a6:	00 00 00 
  80042070a9:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042070ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042070b0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042070b4:	66 83 f8 01          	cmp    $0x1,%ax
  80042070b8:	74 35                	je     80042070ef <page_check+0x1525>
  80042070ba:	48 b9 c1 56 21 04 80 	movabs $0x80042156c1,%rcx
  80042070c1:	00 00 00 
  80042070c4:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042070cb:	00 00 00 
  80042070ce:	be df 04 00 00       	mov    $0x4df,%esi
  80042070d3:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042070da:	00 00 00 
  80042070dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070e2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042070e9:	00 00 00 
  80042070ec:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  80042070ef:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042070f6:	00 00 00 
  80042070f9:	48 8b 00             	mov    (%rax),%rax
  80042070fc:	48 8b 00             	mov    (%rax),%rax
  80042070ff:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207105:	48 89 c7             	mov    %rax,%rdi
  8004207108:	48 b8 4f 1c 20 04 80 	movabs $0x8004201c4f,%rax
  800420710f:	00 00 00 
  8004207112:	ff d0                	callq  *%rax
  8004207114:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  800420711b:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207122:	00 00 00 
  8004207125:	48 8b 00             	mov    (%rax),%rax
  8004207128:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  800420712f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207133:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207137:	66 83 f8 01          	cmp    $0x1,%ax
  800420713b:	74 35                	je     8004207172 <page_check+0x15a8>
  800420713d:	48 b9 c1 56 21 04 80 	movabs $0x80042156c1,%rcx
  8004207144:	00 00 00 
  8004207147:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420714e:	00 00 00 
  8004207151:	be f5 04 00 00       	mov    $0x4f5,%esi
  8004207156:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420715d:	00 00 00 
  8004207160:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207165:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420716c:	00 00 00 
  800420716f:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  8004207172:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207179:	48 89 c7             	mov    %rax,%rdi
  800420717c:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004207183:	00 00 00 
  8004207186:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  8004207188:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420718f:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004207193:	74 13                	je     80042071a8 <page_check+0x15de>
  8004207195:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207199:	48 89 c7             	mov    %rax,%rdi
  800420719c:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  80042071a3:	00 00 00 
  80042071a6:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  80042071a8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042071af:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042071b3:	74 13                	je     80042071c8 <page_check+0x15fe>
  80042071b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042071b9:	48 89 c7             	mov    %rax,%rdi
  80042071bc:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  80042071c3:	00 00 00 
  80042071c6:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  80042071c8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042071cf:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042071d3:	74 13                	je     80042071e8 <page_check+0x161e>
  80042071d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042071d9:	48 89 c7             	mov    %rax,%rdi
  80042071dc:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  80042071e3:	00 00 00 
  80042071e6:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  80042071e8:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  80042071ef:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  80042071f3:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042071fa:	00 00 00 
  80042071fd:	48 8b 00             	mov    (%rax),%rax
  8004207200:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004207207:	ba 01 00 00 00       	mov    $0x1,%edx
  800420720c:	48 89 ce             	mov    %rcx,%rsi
  800420720f:	48 89 c7             	mov    %rax,%rdi
  8004207212:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004207219:	00 00 00 
  800420721c:	ff d0                	callq  *%rax
  800420721e:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004207225:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420722c:	00 00 00 
  800420722f:	48 8b 00             	mov    (%rax),%rax
  8004207232:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004207239:	48 c1 ea 27          	shr    $0x27,%rdx
  800420723d:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004207243:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207247:	48 01 d0             	add    %rdx,%rax
  800420724a:	48 8b 00             	mov    (%rax),%rax
  800420724d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207253:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  800420725a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004207261:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207265:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  800420726b:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  8004207271:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004207278:	00 00 00 
  800420727b:	48 8b 00             	mov    (%rax),%rax
  800420727e:	48 39 c2             	cmp    %rax,%rdx
  8004207281:	72 35                	jb     80042072b8 <page_check+0x16ee>
  8004207283:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420728a:	48 89 c1             	mov    %rax,%rcx
  800420728d:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004207294:	00 00 00 
  8004207297:	be fd 04 00 00       	mov    $0x4fd,%esi
  800420729c:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042072a3:	00 00 00 
  80042072a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072ab:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042072b2:	00 00 00 
  80042072b5:	41 ff d0             	callq  *%r8
  80042072b8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042072bf:	00 00 00 
  80042072c2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042072c9:	48 01 d0             	add    %rdx,%rax
  80042072cc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042072d0:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042072d7:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042072db:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042072e0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042072e7:	00 
  80042072e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042072ec:	48 01 d0             	add    %rdx,%rax
  80042072ef:	48 8b 00             	mov    (%rax),%rax
  80042072f2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042072f8:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  80042072ff:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004207306:	48 c1 e8 0c          	shr    $0xc,%rax
  800420730a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004207310:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  8004207316:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420731d:	00 00 00 
  8004207320:	48 8b 00             	mov    (%rax),%rax
  8004207323:	48 39 c2             	cmp    %rax,%rdx
  8004207326:	72 35                	jb     800420735d <page_check+0x1793>
  8004207328:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420732f:	48 89 c1             	mov    %rax,%rcx
  8004207332:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004207339:	00 00 00 
  800420733c:	be fe 04 00 00       	mov    $0x4fe,%esi
  8004207341:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207348:	00 00 00 
  800420734b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207350:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207357:	00 00 00 
  800420735a:	41 ff d0             	callq  *%r8
  800420735d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207364:	00 00 00 
  8004207367:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420736e:	48 01 d0             	add    %rdx,%rax
  8004207371:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004207375:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420737c:	48 c1 e8 15          	shr    $0x15,%rax
  8004207380:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207385:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420738c:	00 
  800420738d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207391:	48 01 d0             	add    %rdx,%rax
  8004207394:	48 8b 00             	mov    (%rax),%rax
  8004207397:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420739d:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042073a4:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042073ab:	48 c1 e8 0c          	shr    $0xc,%rax
  80042073af:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  80042073b5:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  80042073bb:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042073c2:	00 00 00 
  80042073c5:	48 8b 00             	mov    (%rax),%rax
  80042073c8:	48 39 c2             	cmp    %rax,%rdx
  80042073cb:	72 35                	jb     8004207402 <page_check+0x1838>
  80042073cd:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042073d4:	48 89 c1             	mov    %rax,%rcx
  80042073d7:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042073de:	00 00 00 
  80042073e1:	be ff 04 00 00       	mov    $0x4ff,%esi
  80042073e6:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042073ed:	00 00 00 
  80042073f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073f5:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042073fc:	00 00 00 
  80042073ff:	41 ff d0             	callq  *%r8
  8004207402:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207409:	00 00 00 
  800420740c:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207413:	48 01 d0             	add    %rdx,%rax
  8004207416:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  800420741d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207424:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207428:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420742d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207434:	00 
  8004207435:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420743c:	48 01 c2             	add    %rax,%rdx
  800420743f:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004207446:	48 39 c2             	cmp    %rax,%rdx
  8004207449:	74 35                	je     8004207480 <page_check+0x18b6>
  800420744b:	48 b9 57 57 21 04 80 	movabs $0x8004215757,%rcx
  8004207452:	00 00 00 
  8004207455:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420745c:	00 00 00 
  800420745f:	be 00 05 00 00       	mov    $0x500,%esi
  8004207464:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420746b:	00 00 00 
  800420746e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207473:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420747a:	00 00 00 
  800420747d:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004207480:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207484:	48 89 c7             	mov    %rax,%rdi
  8004207487:	48 b8 c0 1c 20 04 80 	movabs $0x8004201cc0,%rax
  800420748e:	00 00 00 
  8004207491:	ff d0                	callq  *%rax
  8004207493:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207498:	be ff 00 00 00       	mov    $0xff,%esi
  800420749d:	48 89 c7             	mov    %rax,%rdi
  80042074a0:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  80042074a7:	00 00 00 
  80042074aa:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  80042074ac:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042074b3:	00 00 00 
  80042074b6:	48 8b 00             	mov    (%rax),%rax
  80042074b9:	ba 01 00 00 00       	mov    $0x1,%edx
  80042074be:	be 00 00 00 00       	mov    $0x0,%esi
  80042074c3:	48 89 c7             	mov    %rax,%rdi
  80042074c6:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  80042074cd:	00 00 00 
  80042074d0:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  80042074d2:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042074d9:	00 00 00 
  80042074dc:	48 8b 00             	mov    (%rax),%rax
  80042074df:	48 8b 00             	mov    (%rax),%rax
  80042074e2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042074e8:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  80042074ef:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042074f6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042074fa:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  8004207500:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  8004207506:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  800420750d:	00 00 00 
  8004207510:	48 8b 00             	mov    (%rax),%rax
  8004207513:	48 39 c2             	cmp    %rax,%rdx
  8004207516:	72 35                	jb     800420754d <page_check+0x1983>
  8004207518:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420751f:	48 89 c1             	mov    %rax,%rcx
  8004207522:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  8004207529:	00 00 00 
  800420752c:	be 05 05 00 00       	mov    $0x505,%esi
  8004207531:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207538:	00 00 00 
  800420753b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207540:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207547:	00 00 00 
  800420754a:	41 ff d0             	callq  *%r8
  800420754d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207554:	00 00 00 
  8004207557:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420755e:	48 01 d0             	add    %rdx,%rax
  8004207561:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004207565:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207569:	48 8b 00             	mov    (%rax),%rax
  800420756c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207572:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004207579:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004207580:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207584:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  800420758a:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004207590:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004207597:	00 00 00 
  800420759a:	48 8b 00             	mov    (%rax),%rax
  800420759d:	48 39 c2             	cmp    %rax,%rdx
  80042075a0:	72 35                	jb     80042075d7 <page_check+0x1a0d>
  80042075a2:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042075a9:	48 89 c1             	mov    %rax,%rcx
  80042075ac:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  80042075b3:	00 00 00 
  80042075b6:	be 06 05 00 00       	mov    $0x506,%esi
  80042075bb:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042075c2:	00 00 00 
  80042075c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075ca:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042075d1:	00 00 00 
  80042075d4:	41 ff d0             	callq  *%r8
  80042075d7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042075de:	00 00 00 
  80042075e1:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042075e8:	48 01 d0             	add    %rdx,%rax
  80042075eb:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  80042075ef:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042075f3:	48 8b 00             	mov    (%rax),%rax
  80042075f6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042075fc:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004207603:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420760a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420760e:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  8004207614:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  800420761a:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004207621:	00 00 00 
  8004207624:	48 8b 00             	mov    (%rax),%rax
  8004207627:	48 39 c2             	cmp    %rax,%rdx
  800420762a:	72 35                	jb     8004207661 <page_check+0x1a97>
  800420762c:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004207633:	48 89 c1             	mov    %rax,%rcx
  8004207636:	48 ba c8 4a 21 04 80 	movabs $0x8004214ac8,%rdx
  800420763d:	00 00 00 
  8004207640:	be 07 05 00 00       	mov    $0x507,%esi
  8004207645:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420764c:	00 00 00 
  800420764f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207654:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420765b:	00 00 00 
  800420765e:	41 ff d0             	callq  *%r8
  8004207661:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207668:	00 00 00 
  800420766b:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004207672:	48 01 d0             	add    %rdx,%rax
  8004207675:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  800420767c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004207683:	eb 58                	jmp    80042076dd <page_check+0x1b13>
		assert((ptep[i] & PTE_P) == 0);
  8004207685:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  800420768c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420768f:	48 63 d2             	movslq %edx,%rdx
  8004207692:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207696:	48 01 d0             	add    %rdx,%rax
  8004207699:	48 8b 00             	mov    (%rax),%rax
  800420769c:	83 e0 01             	and    $0x1,%eax
  800420769f:	48 85 c0             	test   %rax,%rax
  80042076a2:	74 35                	je     80042076d9 <page_check+0x1b0f>
  80042076a4:	48 b9 6f 57 21 04 80 	movabs $0x800421576f,%rcx
  80042076ab:	00 00 00 
  80042076ae:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042076b5:	00 00 00 
  80042076b8:	be 09 05 00 00       	mov    $0x509,%esi
  80042076bd:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042076c4:	00 00 00 
  80042076c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076cc:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042076d3:	00 00 00 
  80042076d6:	41 ff d0             	callq  *%r8
	for(i=0; i<NPTENTRIES; i++)
  80042076d9:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042076dd:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042076e4:	7e 9f                	jle    8004207685 <page_check+0x1abb>
	boot_pml4e[0] = 0;
  80042076e6:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  80042076ed:	00 00 00 
  80042076f0:	48 8b 00             	mov    (%rax),%rax
  80042076f3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  80042076fa:	48 b8 58 b2 57 04 80 	movabs $0x800457b258,%rax
  8004207701:	00 00 00 
  8004207704:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207708:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  800420770b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420770f:	48 89 c7             	mov    %rax,%rdi
  8004207712:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004207719:	00 00 00 
  800420771c:	ff d0                	callq  *%rax
	page_decref(pp2);
  800420771e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207722:	48 89 c7             	mov    %rax,%rdi
  8004207725:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  800420772c:	00 00 00 
  800420772f:	ff d0                	callq  *%rax
	page_decref(pp3);
  8004207731:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207735:	48 89 c7             	mov    %rax,%rdi
  8004207738:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  800420773f:	00 00 00 
  8004207742:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  8004207744:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207748:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420774c:	66 85 c0             	test   %ax,%ax
  800420774f:	74 35                	je     8004207786 <page_check+0x1bbc>
  8004207751:	48 b9 86 57 21 04 80 	movabs $0x8004215786,%rcx
  8004207758:	00 00 00 
  800420775b:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207762:	00 00 00 
  8004207765:	be 15 05 00 00       	mov    $0x515,%esi
  800420776a:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207771:	00 00 00 
  8004207774:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207779:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207780:	00 00 00 
  8004207783:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004207786:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420778a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420778e:	66 85 c0             	test   %ax,%ax
  8004207791:	74 35                	je     80042077c8 <page_check+0x1bfe>
  8004207793:	48 b9 46 57 21 04 80 	movabs $0x8004215746,%rcx
  800420779a:	00 00 00 
  800420779d:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042077a4:	00 00 00 
  80042077a7:	be 16 05 00 00       	mov    $0x516,%esi
  80042077ac:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042077b3:	00 00 00 
  80042077b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077bb:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042077c2:	00 00 00 
  80042077c5:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  80042077c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042077cc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042077d0:	66 85 c0             	test   %ax,%ax
  80042077d3:	74 35                	je     800420780a <page_check+0x1c40>
  80042077d5:	48 b9 97 57 21 04 80 	movabs $0x8004215797,%rcx
  80042077dc:	00 00 00 
  80042077df:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042077e6:	00 00 00 
  80042077e9:	be 17 05 00 00       	mov    $0x517,%esi
  80042077ee:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042077f5:	00 00 00 
  80042077f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077fd:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207804:	00 00 00 
  8004207807:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  800420780a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420780e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207812:	66 85 c0             	test   %ax,%ax
  8004207815:	74 35                	je     800420784c <page_check+0x1c82>
  8004207817:	48 b9 a8 57 21 04 80 	movabs $0x80042157a8,%rcx
  800420781e:	00 00 00 
  8004207821:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207828:	00 00 00 
  800420782b:	be 18 05 00 00       	mov    $0x518,%esi
  8004207830:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207837:	00 00 00 
  800420783a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420783f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207846:	00 00 00 
  8004207849:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  800420784c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207850:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207854:	66 85 c0             	test   %ax,%ax
  8004207857:	74 35                	je     800420788e <page_check+0x1cc4>
  8004207859:	48 b9 b9 57 21 04 80 	movabs $0x80042157b9,%rcx
  8004207860:	00 00 00 
  8004207863:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420786a:	00 00 00 
  800420786d:	be 19 05 00 00       	mov    $0x519,%esi
  8004207872:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207879:	00 00 00 
  800420787c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207881:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207888:	00 00 00 
  800420788b:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  800420788e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207892:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207896:	66 85 c0             	test   %ax,%ax
  8004207899:	74 35                	je     80042078d0 <page_check+0x1d06>
  800420789b:	48 b9 ca 57 21 04 80 	movabs $0x80042157ca,%rcx
  80042078a2:	00 00 00 
  80042078a5:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042078ac:	00 00 00 
  80042078af:	be 1a 05 00 00       	mov    $0x51a,%esi
  80042078b4:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042078bb:	00 00 00 
  80042078be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078c3:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042078ca:	00 00 00 
  80042078cd:	41 ff d0             	callq  *%r8

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  80042078d0:	be 01 10 00 00       	mov    $0x1001,%esi
  80042078d5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042078da:	48 b8 50 40 20 04 80 	movabs $0x8004204050,%rax
  80042078e1:	00 00 00 
  80042078e4:	ff d0                	callq  *%rax
  80042078e6:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  80042078ed:	be 00 10 00 00       	mov    $0x1000,%esi
  80042078f2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042078f7:	48 b8 50 40 20 04 80 	movabs $0x8004204050,%rax
  80042078fe:	00 00 00 
  8004207901:	ff d0                	callq  *%rax
  8004207903:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  800420790a:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207911:	00 00 00 
  8004207914:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  800420791b:	76 1d                	jbe    800420793a <page_check+0x1d70>
  800420791d:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207924:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  800420792b:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207932:	00 00 00 
  8004207935:	48 39 c2             	cmp    %rax,%rdx
  8004207938:	76 35                	jbe    800420796f <page_check+0x1da5>
  800420793a:	48 b9 e0 57 21 04 80 	movabs $0x80042157e0,%rcx
  8004207941:	00 00 00 
  8004207944:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  800420794b:	00 00 00 
  800420794e:	be 20 05 00 00       	mov    $0x520,%esi
  8004207953:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  800420795a:	00 00 00 
  800420795d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207962:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207969:	00 00 00 
  800420796c:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  800420796f:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207976:	00 00 00 
  8004207979:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  8004207980:	76 1d                	jbe    800420799f <page_check+0x1dd5>
  8004207982:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207989:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207990:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207997:	00 00 00 
  800420799a:	48 39 c2             	cmp    %rax,%rdx
  800420799d:	76 35                	jbe    80042079d4 <page_check+0x1e0a>
  800420799f:	48 b9 08 58 21 04 80 	movabs $0x8004215808,%rcx
  80042079a6:	00 00 00 
  80042079a9:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  80042079b0:	00 00 00 
  80042079b3:	be 21 05 00 00       	mov    $0x521,%esi
  80042079b8:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  80042079bf:	00 00 00 
  80042079c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079c7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042079ce:	00 00 00 
  80042079d1:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  80042079d4:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042079db:	25 ff 0f 00 00       	and    $0xfff,%eax
  80042079e0:	48 85 c0             	test   %rax,%rax
  80042079e3:	75 11                	jne    80042079f6 <page_check+0x1e2c>
  80042079e5:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042079ec:	25 ff 0f 00 00       	and    $0xfff,%eax
  80042079f1:	48 85 c0             	test   %rax,%rax
  80042079f4:	74 35                	je     8004207a2b <page_check+0x1e61>
  80042079f6:	48 b9 30 58 21 04 80 	movabs $0x8004215830,%rcx
  80042079fd:	00 00 00 
  8004207a00:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207a07:	00 00 00 
  8004207a0a:	be 23 05 00 00       	mov    $0x523,%esi
  8004207a0f:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207a16:	00 00 00 
  8004207a19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a1e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207a25:	00 00 00 
  8004207a28:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207a2b:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207a32:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004207a38:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  8004207a3f:	76 35                	jbe    8004207a76 <page_check+0x1eac>
  8004207a41:	48 b9 57 58 21 04 80 	movabs $0x8004215857,%rcx
  8004207a48:	00 00 00 
  8004207a4b:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207a52:	00 00 00 
  8004207a55:	be 25 05 00 00       	mov    $0x525,%esi
  8004207a5a:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207a61:	00 00 00 
  8004207a64:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a69:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207a70:	00 00 00 
  8004207a73:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004207a76:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207a7d:	00 00 00 
  8004207a80:	48 8b 00             	mov    (%rax),%rax
  8004207a83:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004207a8a:	48 89 d6             	mov    %rdx,%rsi
  8004207a8d:	48 89 c7             	mov    %rax,%rdi
  8004207a90:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004207a97:	00 00 00 
  8004207a9a:	ff d0                	callq  *%rax
  8004207a9c:	48 85 c0             	test   %rax,%rax
  8004207a9f:	74 35                	je     8004207ad6 <page_check+0x1f0c>
  8004207aa1:	48 b9 70 58 21 04 80 	movabs $0x8004215870,%rcx
  8004207aa8:	00 00 00 
  8004207aab:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207ab2:	00 00 00 
  8004207ab5:	be 28 05 00 00       	mov    $0x528,%esi
  8004207aba:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207ac1:	00 00 00 
  8004207ac4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ac9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207ad0:	00 00 00 
  8004207ad3:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207ad6:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207add:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207ae4:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207aeb:	00 00 00 
  8004207aee:	48 8b 00             	mov    (%rax),%rax
  8004207af1:	48 89 d6             	mov    %rdx,%rsi
  8004207af4:	48 89 c7             	mov    %rax,%rdi
  8004207af7:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004207afe:	00 00 00 
  8004207b01:	ff d0                	callq  *%rax
  8004207b03:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207b09:	74 35                	je     8004207b40 <page_check+0x1f76>
  8004207b0b:	48 b9 98 58 21 04 80 	movabs $0x8004215898,%rcx
  8004207b12:	00 00 00 
  8004207b15:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207b1c:	00 00 00 
  8004207b1f:	be 29 05 00 00       	mov    $0x529,%esi
  8004207b24:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207b2b:	00 00 00 
  8004207b2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b33:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207b3a:	00 00 00 
  8004207b3d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207b40:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207b47:	00 00 00 
  8004207b4a:	48 8b 00             	mov    (%rax),%rax
  8004207b4d:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004207b54:	48 89 d6             	mov    %rdx,%rsi
  8004207b57:	48 89 c7             	mov    %rax,%rdi
  8004207b5a:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004207b61:	00 00 00 
  8004207b64:	ff d0                	callq  *%rax
  8004207b66:	48 85 c0             	test   %rax,%rax
  8004207b69:	74 35                	je     8004207ba0 <page_check+0x1fd6>
  8004207b6b:	48 b9 c8 58 21 04 80 	movabs $0x80042158c8,%rcx
  8004207b72:	00 00 00 
  8004207b75:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207b7c:	00 00 00 
  8004207b7f:	be 2a 05 00 00       	mov    $0x52a,%esi
  8004207b84:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207b8b:	00 00 00 
  8004207b8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b93:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207b9a:	00 00 00 
  8004207b9d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207ba0:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207ba7:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207bae:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207bb5:	00 00 00 
  8004207bb8:	48 8b 00             	mov    (%rax),%rax
  8004207bbb:	48 89 d6             	mov    %rdx,%rsi
  8004207bbe:	48 89 c7             	mov    %rax,%rdi
  8004207bc1:	48 b8 50 59 20 04 80 	movabs $0x8004205950,%rax
  8004207bc8:	00 00 00 
  8004207bcb:	ff d0                	callq  *%rax
  8004207bcd:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207bd1:	74 35                	je     8004207c08 <page_check+0x203e>
  8004207bd3:	48 b9 f0 58 21 04 80 	movabs $0x80042158f0,%rcx
  8004207bda:	00 00 00 
  8004207bdd:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207be4:	00 00 00 
  8004207be7:	be 2b 05 00 00       	mov    $0x52b,%esi
  8004207bec:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207bf3:	00 00 00 
  8004207bf6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207bfb:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207c02:	00 00 00 
  8004207c05:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207c08:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207c0f:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207c16:	00 00 00 
  8004207c19:	48 8b 00             	mov    (%rax),%rax
  8004207c1c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c21:	48 89 ce             	mov    %rcx,%rsi
  8004207c24:	48 89 c7             	mov    %rax,%rdi
  8004207c27:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004207c2e:	00 00 00 
  8004207c31:	ff d0                	callq  *%rax
  8004207c33:	48 8b 00             	mov    (%rax),%rax
  8004207c36:	83 e0 1a             	and    $0x1a,%eax
  8004207c39:	48 85 c0             	test   %rax,%rax
  8004207c3c:	75 35                	jne    8004207c73 <page_check+0x20a9>
  8004207c3e:	48 b9 20 59 21 04 80 	movabs $0x8004215920,%rcx
  8004207c45:	00 00 00 
  8004207c48:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207c4f:	00 00 00 
  8004207c52:	be 2d 05 00 00       	mov    $0x52d,%esi
  8004207c57:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207c5e:	00 00 00 
  8004207c61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c66:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207c6d:	00 00 00 
  8004207c70:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207c73:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207c7a:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207c81:	00 00 00 
  8004207c84:	48 8b 00             	mov    (%rax),%rax
  8004207c87:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c8c:	48 89 ce             	mov    %rcx,%rsi
  8004207c8f:	48 89 c7             	mov    %rax,%rdi
  8004207c92:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004207c99:	00 00 00 
  8004207c9c:	ff d0                	callq  *%rax
  8004207c9e:	48 8b 00             	mov    (%rax),%rax
  8004207ca1:	83 e0 04             	and    $0x4,%eax
  8004207ca4:	48 85 c0             	test   %rax,%rax
  8004207ca7:	74 35                	je     8004207cde <page_check+0x2114>
  8004207ca9:	48 b9 68 59 21 04 80 	movabs $0x8004215968,%rcx
  8004207cb0:	00 00 00 
  8004207cb3:	48 ba 41 4b 21 04 80 	movabs $0x8004214b41,%rdx
  8004207cba:	00 00 00 
  8004207cbd:	be 2e 05 00 00       	mov    $0x52e,%esi
  8004207cc2:	48 bf 56 4b 21 04 80 	movabs $0x8004214b56,%rdi
  8004207cc9:	00 00 00 
  8004207ccc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207cd1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207cd8:	00 00 00 
  8004207cdb:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207cde:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207ce5:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207cec:	00 00 00 
  8004207cef:	48 8b 00             	mov    (%rax),%rax
  8004207cf2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207cf7:	48 89 ce             	mov    %rcx,%rsi
  8004207cfa:	48 89 c7             	mov    %rax,%rdi
  8004207cfd:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004207d04:	00 00 00 
  8004207d07:	ff d0                	callq  *%rax
  8004207d09:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207d10:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207d17:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207d1d:	48 89 c1             	mov    %rax,%rcx
  8004207d20:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207d27:	00 00 00 
  8004207d2a:	48 8b 00             	mov    (%rax),%rax
  8004207d2d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207d32:	48 89 ce             	mov    %rcx,%rsi
  8004207d35:	48 89 c7             	mov    %rax,%rdi
  8004207d38:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004207d3f:	00 00 00 
  8004207d42:	ff d0                	callq  *%rax
  8004207d44:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207d4b:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207d52:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  8004207d59:	00 00 00 
  8004207d5c:	48 8b 00             	mov    (%rax),%rax
  8004207d5f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207d64:	48 89 ce             	mov    %rcx,%rsi
  8004207d67:	48 89 c7             	mov    %rax,%rdi
  8004207d6a:	48 b8 0c 31 20 04 80 	movabs $0x800420310c,%rax
  8004207d71:	00 00 00 
  8004207d74:	ff d0                	callq  *%rax
  8004207d76:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207d7d:	48 bf 9b 59 21 04 80 	movabs $0x800421599b,%rdi
  8004207d84:	00 00 00 
  8004207d87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d8c:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004207d93:	00 00 00 
  8004207d96:	ff d2                	callq  *%rdx
}
  8004207d98:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207d9f:	5b                   	pop    %rbx
  8004207da0:	5d                   	pop    %rbp
  8004207da1:	c3                   	retq   

0000008004207da2 <page2ppn>:
{
  8004207da2:	55                   	push   %rbp
  8004207da3:	48 89 e5             	mov    %rsp,%rbp
  8004207da6:	48 83 ec 08          	sub    $0x8,%rsp
  8004207daa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207dae:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207db2:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004207db9:	00 00 00 
  8004207dbc:	48 8b 00             	mov    (%rax),%rax
  8004207dbf:	48 29 c2             	sub    %rax,%rdx
  8004207dc2:	48 89 d0             	mov    %rdx,%rax
  8004207dc5:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207dc9:	c9                   	leaveq 
  8004207dca:	c3                   	retq   

0000008004207dcb <page2pa>:
{
  8004207dcb:	55                   	push   %rbp
  8004207dcc:	48 89 e5             	mov    %rsp,%rbp
  8004207dcf:	48 83 ec 08          	sub    $0x8,%rsp
  8004207dd3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207dd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ddb:	48 89 c7             	mov    %rax,%rdi
  8004207dde:	48 b8 a2 7d 20 04 80 	movabs $0x8004207da2,%rax
  8004207de5:	00 00 00 
  8004207de8:	ff d0                	callq  *%rax
  8004207dea:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207dee:	c9                   	leaveq 
  8004207def:	c3                   	retq   

0000008004207df0 <pa2page>:
{
  8004207df0:	55                   	push   %rbp
  8004207df1:	48 89 e5             	mov    %rsp,%rbp
  8004207df4:	48 83 ec 10          	sub    $0x10,%rsp
  8004207df8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207dfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e00:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207e04:	48 89 c2             	mov    %rax,%rdx
  8004207e07:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004207e0e:	00 00 00 
  8004207e11:	48 8b 00             	mov    (%rax),%rax
  8004207e14:	48 39 c2             	cmp    %rax,%rdx
  8004207e17:	72 2a                	jb     8004207e43 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207e19:	48 ba b8 59 21 04 80 	movabs $0x80042159b8,%rdx
  8004207e20:	00 00 00 
  8004207e23:	be 54 00 00 00       	mov    $0x54,%esi
  8004207e28:	48 bf d7 59 21 04 80 	movabs $0x80042159d7,%rdi
  8004207e2f:	00 00 00 
  8004207e32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e37:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004207e3e:	00 00 00 
  8004207e41:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207e43:	48 b8 d8 c7 57 04 80 	movabs $0x800457c7d8,%rax
  8004207e4a:	00 00 00 
  8004207e4d:	48 8b 00             	mov    (%rax),%rax
  8004207e50:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207e54:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207e58:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207e5c:	48 01 d0             	add    %rdx,%rax
}
  8004207e5f:	c9                   	leaveq 
  8004207e60:	c3                   	retq   

0000008004207e61 <page2kva>:
{
  8004207e61:	55                   	push   %rbp
  8004207e62:	48 89 e5             	mov    %rsp,%rbp
  8004207e65:	48 83 ec 20          	sub    $0x20,%rsp
  8004207e69:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207e6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e71:	48 89 c7             	mov    %rax,%rdi
  8004207e74:	48 b8 cb 7d 20 04 80 	movabs $0x8004207dcb,%rax
  8004207e7b:	00 00 00 
  8004207e7e:	ff d0                	callq  *%rax
  8004207e80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207e84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e88:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207e8c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207e8f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207e92:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004207e99:	00 00 00 
  8004207e9c:	48 8b 00             	mov    (%rax),%rax
  8004207e9f:	48 39 c2             	cmp    %rax,%rdx
  8004207ea2:	72 32                	jb     8004207ed6 <page2kva+0x75>
  8004207ea4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ea8:	48 89 c1             	mov    %rax,%rcx
  8004207eab:	48 ba e8 59 21 04 80 	movabs $0x80042159e8,%rdx
  8004207eb2:	00 00 00 
  8004207eb5:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207eba:	48 bf d7 59 21 04 80 	movabs $0x80042159d7,%rdi
  8004207ec1:	00 00 00 
  8004207ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ec9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004207ed0:	00 00 00 
  8004207ed3:	41 ff d0             	callq  *%r8
  8004207ed6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207edd:	00 00 00 
  8004207ee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ee4:	48 01 d0             	add    %rdx,%rax
}
  8004207ee7:	c9                   	leaveq 
  8004207ee8:	c3                   	retq   

0000008004207ee9 <unlock_kernel>:
	spin_lock(&kernel_lock);
}

static inline void
unlock_kernel(void)
{
  8004207ee9:	55                   	push   %rbp
  8004207eea:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207eed:	48 bf c0 87 22 04 80 	movabs $0x80042287c0,%rdi
  8004207ef4:	00 00 00 
  8004207ef7:	48 b8 5b 38 21 04 80 	movabs $0x800421385b,%rax
  8004207efe:	00 00 00 
  8004207f01:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207f03:	f3 90                	pause  
}
  8004207f05:	5d                   	pop    %rbp
  8004207f06:	c3                   	retq   

0000008004207f07 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207f07:	55                   	push   %rbp
  8004207f08:	48 89 e5             	mov    %rsp,%rbp
  8004207f0b:	53                   	push   %rbx
  8004207f0c:	48 83 ec 28          	sub    $0x28,%rsp
  8004207f10:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207f13:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207f17:	89 d0                	mov    %edx,%eax
  8004207f19:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207f1c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207f20:	75 3e                	jne    8004207f60 <envid2env+0x59>
		*env_store = curenv;
  8004207f22:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004207f29:	00 00 00 
  8004207f2c:	ff d0                	callq  *%rax
  8004207f2e:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004207f35:	00 00 00 
  8004207f38:	48 98                	cltq   
  8004207f3a:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f3e:	48 89 c1             	mov    %rax,%rcx
  8004207f41:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207f45:	48 01 c8             	add    %rcx,%rax
  8004207f48:	48 01 d0             	add    %rdx,%rax
  8004207f4b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004207f4f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f53:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207f56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f5b:	e9 f7 00 00 00       	jmpq   8004208057 <envid2env+0x150>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207f60:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  8004207f67:	00 00 00 
  8004207f6a:	48 8b 10             	mov    (%rax),%rdx
  8004207f6d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207f70:	48 98                	cltq   
  8004207f72:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207f77:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207f7e:	48 01 d0             	add    %rdx,%rax
  8004207f81:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207f85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f89:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207f8f:	85 c0                	test   %eax,%eax
  8004207f91:	74 0f                	je     8004207fa2 <envid2env+0x9b>
  8004207f93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f97:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207f9d:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207fa0:	74 15                	je     8004207fb7 <envid2env+0xb0>
		*env_store = 0;
  8004207fa2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207fa6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207fad:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207fb2:	e9 a0 00 00 00       	jmpq   8004208057 <envid2env+0x150>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207fb7:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207fbb:	0f 84 86 00 00 00    	je     8004208047 <envid2env+0x140>
  8004207fc1:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004207fc8:	00 00 00 
  8004207fcb:	ff d0                	callq  *%rax
  8004207fcd:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004207fd4:	00 00 00 
  8004207fd7:	48 98                	cltq   
  8004207fd9:	48 c1 e0 03          	shl    $0x3,%rax
  8004207fdd:	48 89 c1             	mov    %rax,%rcx
  8004207fe0:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207fe4:	48 01 c8             	add    %rcx,%rax
  8004207fe7:	48 01 d0             	add    %rdx,%rax
  8004207fea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207fee:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207ff2:	74 53                	je     8004208047 <envid2env+0x140>
  8004207ff4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ff8:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207ffe:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004208005:	00 00 00 
  8004208008:	ff d0                	callq  *%rax
  800420800a:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004208011:	00 00 00 
  8004208014:	48 98                	cltq   
  8004208016:	48 c1 e0 03          	shl    $0x3,%rax
  800420801a:	48 89 c1             	mov    %rax,%rcx
  800420801d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208021:	48 01 c8             	add    %rcx,%rax
  8004208024:	48 01 d0             	add    %rdx,%rax
  8004208027:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420802b:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208031:	39 c3                	cmp    %eax,%ebx
  8004208033:	74 12                	je     8004208047 <envid2env+0x140>
		*env_store = 0;
  8004208035:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208039:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004208040:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004208045:	eb 10                	jmp    8004208057 <envid2env+0x150>
	}

	*env_store = e;
  8004208047:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420804b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420804f:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004208052:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208057:	48 83 c4 28          	add    $0x28,%rsp
  800420805b:	5b                   	pop    %rbx
  800420805c:	5d                   	pop    %rbp
  800420805d:	c3                   	retq   

000000800420805e <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  800420805e:	55                   	push   %rbp
  800420805f:	48 89 e5             	mov    %rsp,%rbp
  8004208062:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	int i;
	for (i = 0; i < NENV; i++) {
  8004208066:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420806d:	eb 6d                	jmp    80042080dc <env_init+0x7e>
		envs[i].env_status = ENV_FREE;
  800420806f:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  8004208076:	00 00 00 
  8004208079:	48 8b 10             	mov    (%rax),%rdx
  800420807c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420807f:	48 98                	cltq   
  8004208081:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004208088:	48 01 d0             	add    %rdx,%rax
  800420808b:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208092:	00 00 00 
		envs[i].env_link = &envs[i+1];
  8004208095:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420809c:	00 00 00 
  800420809f:	48 8b 10             	mov    (%rax),%rdx
  80042080a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042080a5:	48 98                	cltq   
  80042080a7:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  80042080ae:	48 01 c2             	add    %rax,%rdx
  80042080b1:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  80042080b8:	00 00 00 
  80042080bb:	48 8b 08             	mov    (%rax),%rcx
  80042080be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042080c1:	48 98                	cltq   
  80042080c3:	48 83 c0 01          	add    $0x1,%rax
  80042080c7:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  80042080ce:	48 01 c8             	add    %rcx,%rax
  80042080d1:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
	for (i = 0; i < NENV; i++) {
  80042080d8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042080dc:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  80042080e3:	7e 8a                	jle    800420806f <env_init+0x11>
	}
	envs[NENV-1].env_link = NULL;
  80042080e5:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  80042080ec:	00 00 00 
  80042080ef:	48 8b 00             	mov    (%rax),%rax
  80042080f2:	48 05 98 9e 05 00    	add    $0x59e98,%rax
  80042080f8:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  80042080ff:	00 00 00 00 
	env_free_list = &envs[0];
  8004208103:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420810a:	00 00 00 
  800420810d:	48 8b 10             	mov    (%rax),%rdx
  8004208110:	48 b8 80 b2 57 04 80 	movabs $0x800457b280,%rax
  8004208117:	00 00 00 
  800420811a:	48 89 10             	mov    %rdx,(%rax)

	// Per-CPU part of the initialization
	env_init_percpu();
  800420811d:	48 b8 2b 81 20 04 80 	movabs $0x800420812b,%rax
  8004208124:	00 00 00 
  8004208127:	ff d0                	callq  *%rax
}
  8004208129:	c9                   	leaveq 
  800420812a:	c3                   	retq   

000000800420812b <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  800420812b:	55                   	push   %rbp
  800420812c:	48 89 e5             	mov    %rsp,%rbp
  800420812f:	53                   	push   %rbx
  8004208130:	48 83 ec 10          	sub    $0x10,%rsp
  8004208134:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  800420813b:	00 00 00 
  800420813e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004208142:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208146:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004208149:	b8 23 00 00 00       	mov    $0x23,%eax
  800420814e:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004208150:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208155:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004208157:	b8 10 00 00 00       	mov    $0x10,%eax
  800420815c:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  800420815e:	b8 10 00 00 00       	mov    $0x10,%eax
  8004208163:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004208165:	b8 10 00 00 00       	mov    $0x10,%eax
  800420816a:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  800420816c:	b8 08 00 00 00       	mov    $0x8,%eax
  8004208171:	89 c3                	mov    %eax,%ebx
  8004208173:	53                   	push   %rbx
  8004208174:	48 b8 81 81 20 04 80 	movabs $0x8004208181,%rax
  800420817b:	00 00 00 
  800420817e:	50                   	push   %rax
  800420817f:	48 cb                	lretq  
  8004208181:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
	__asm __volatile("lldt %0" : : "r" (sel));
  8004208187:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420818b:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  800420818e:	48 83 c4 10          	add    $0x10,%rsp
  8004208192:	5b                   	pop    %rbx
  8004208193:	5d                   	pop    %rbp
  8004208194:	c3                   	retq   

0000008004208195 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004208195:	55                   	push   %rbp
  8004208196:	48 89 e5             	mov    %rsp,%rbp
  8004208199:	48 83 ec 20          	sub    $0x20,%rsp
  800420819d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042081a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042081a8:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  80042081a9:	bf 01 00 00 00       	mov    $0x1,%edi
  80042081ae:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  80042081b5:	00 00 00 
  80042081b8:	ff d0                	callq  *%rax
  80042081ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042081be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042081c3:	75 0a                	jne    80042081cf <env_setup_vm+0x3a>
		return -E_NO_MEM;
  80042081c5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042081ca:	e9 c2 00 00 00       	jmpq   8004208291 <env_setup_vm+0xfc>
	//	is an exception -- you need to increment env_pml4e's
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.
	p->pp_ref       += 1;
  80042081cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042081d3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042081d7:	8d 50 01             	lea    0x1(%rax),%edx
  80042081da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042081de:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  80042081e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042081e6:	48 89 c7             	mov    %rax,%rdi
  80042081e9:	48 b8 61 7e 20 04 80 	movabs $0x8004207e61,%rax
  80042081f0:	00 00 00 
  80042081f3:	ff d0                	callq  *%rax
  80042081f5:	48 89 c2             	mov    %rax,%rdx
  80042081f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081fc:	48 89 90 e0 00 00 00 	mov    %rdx,0xe0(%rax)
	e->env_cr3      = page2pa(p);
  8004208203:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208207:	48 89 c7             	mov    %rax,%rdi
  800420820a:	48 b8 cb 7d 20 04 80 	movabs $0x8004207dcb,%rax
  8004208211:	00 00 00 
  8004208214:	ff d0                	callq  *%rax
  8004208216:	48 89 c2             	mov    %rax,%rdx
  8004208219:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420821d:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	memset(e->env_pml4e, 0, PGSIZE);
  8004208224:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208228:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420822f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208234:	be 00 00 00 00       	mov    $0x0,%esi
  8004208239:	48 89 c7             	mov    %rax,%rdi
  800420823c:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004208243:	00 00 00 
  8004208246:	ff d0                	callq  *%rax
	e->env_pml4e[1] = boot_pml4e[1];
  8004208248:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420824c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208253:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208257:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420825e:	00 00 00 
  8004208261:	48 8b 00             	mov    (%rax),%rax
  8004208264:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208268:	48 89 02             	mov    %rax,(%rdx)

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  800420826b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420826f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208276:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420827a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420827e:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208285:	48 83 c8 05          	or     $0x5,%rax
  8004208289:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  800420828c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208291:	c9                   	leaveq 
  8004208292:	c3                   	retq   

0000008004208293 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004208293:	55                   	push   %rbp
  8004208294:	48 89 e5             	mov    %rsp,%rbp
  8004208297:	48 83 ec 30          	sub    $0x30,%rsp
  800420829b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420829f:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042082a2:	48 b8 80 b2 57 04 80 	movabs $0x800457b280,%rax
  80042082a9:	00 00 00 
  80042082ac:	48 8b 00             	mov    (%rax),%rax
  80042082af:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042082b3:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042082b8:	75 0a                	jne    80042082c4 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042082ba:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042082bf:	e9 69 01 00 00       	jmpq   800420842d <env_alloc+0x19a>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042082c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082c8:	48 89 c7             	mov    %rax,%rdi
  80042082cb:	48 b8 95 81 20 04 80 	movabs $0x8004208195,%rax
  80042082d2:	00 00 00 
  80042082d5:	ff d0                	callq  *%rax
  80042082d7:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042082da:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042082de:	79 08                	jns    80042082e8 <env_alloc+0x55>
		return r;
  80042082e0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042082e3:	e9 45 01 00 00       	jmpq   800420842d <env_alloc+0x19a>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  80042082e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082ec:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042082f2:	05 00 10 00 00       	add    $0x1000,%eax
  80042082f7:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  80042082fc:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  80042082ff:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208303:	7f 07                	jg     800420830c <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004208305:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  800420830c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208310:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  8004208317:	00 00 00 
  800420831a:	48 8b 00             	mov    (%rax),%rax
  800420831d:	48 29 c2             	sub    %rax,%rdx
  8004208320:	48 89 d0             	mov    %rdx,%rax
  8004208323:	48 c1 f8 03          	sar    $0x3,%rax
  8004208327:	48 89 c2             	mov    %rax,%rdx
  800420832a:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  8004208331:	fa a4 4f 
  8004208334:	48 0f af c2          	imul   %rdx,%rax
  8004208338:	0b 45 fc             	or     -0x4(%rbp),%eax
  800420833b:	89 c2                	mov    %eax,%edx
  800420833d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208341:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208347:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420834b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420834e:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004208354:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208358:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  800420835f:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004208362:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208366:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420836d:	00 00 00 
	e->env_runs = 0;
  8004208370:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208374:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  800420837b:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  800420837e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208382:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208387:	be 00 00 00 00       	mov    $0x0,%esi
  800420838c:	48 89 c7             	mov    %rax,%rdi
  800420838f:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004208396:	00 00 00 
  8004208399:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  800420839b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420839f:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  80042083a6:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  80042083a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083ac:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  80042083b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083b6:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042083bd:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  80042083bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083c3:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  80042083c8:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  80042083cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083d3:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  80042083da:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags = FL_IF; // interrupts enabled
  80042083dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083e0:	48 c7 80 a8 00 00 00 	movq   $0x200,0xa8(%rax)
  80042083e7:	00 02 00 00 

	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  80042083eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083ef:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  80042083f6:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  80042083fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083fe:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004208405:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208409:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208410:	48 b8 80 b2 57 04 80 	movabs $0x800457b280,%rax
  8004208417:	00 00 00 
  800420841a:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  800420841d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208421:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208425:	48 89 10             	mov    %rdx,(%rax)

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004208428:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420842d:	c9                   	leaveq 
  800420842e:	c3                   	retq   

000000800420842f <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  800420842f:	55                   	push   %rbp
  8004208430:	48 89 e5             	mov    %rsp,%rbp
  8004208433:	48 83 ec 40          	sub    $0x40,%rsp
  8004208437:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420843b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420843f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	
	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;
  8004208443:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208447:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420844b:	48 01 d0             	add    %rdx,%rax
  800420844e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (va < endva) {
  8004208452:	e9 c8 00 00 00       	jmpq   800420851f <region_alloc+0xf0>
		// Allocate and map a page covering virtual address va.
		if (!(pp = page_alloc(0)))
  8004208457:	bf 00 00 00 00       	mov    $0x0,%edi
  800420845c:	48 b8 97 2f 20 04 80 	movabs $0x8004202f97,%rax
  8004208463:	00 00 00 
  8004208466:	ff d0                	callq  *%rax
  8004208468:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420846c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004208471:	75 30                	jne    80042084a3 <region_alloc+0x74>
			panic("map_segment: could not alloc page: %e\n", -E_NO_MEM);
  8004208473:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  8004208478:	48 ba 10 5a 21 04 80 	movabs $0x8004215a10,%rdx
  800420847f:	00 00 00 
  8004208482:	be b2 01 00 00       	mov    $0x1b2,%esi
  8004208487:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  800420848e:	00 00 00 
  8004208491:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208496:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420849d:	00 00 00 
  80042084a0:	41 ff d0             	callq  *%r8

		// Insert the page into the env's address space
		if ((r = page_insert(e->env_pml4e, pp, va, PTE_P|PTE_W|PTE_U)) < 0)
  80042084a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042084a7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042084ae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042084b2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042084b6:	b9 07 00 00 00       	mov    $0x7,%ecx
  80042084bb:	48 89 c7             	mov    %rax,%rdi
  80042084be:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  80042084c5:	00 00 00 
  80042084c8:	ff d0                	callq  *%rax
  80042084ca:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042084cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042084d1:	79 30                	jns    8004208503 <region_alloc+0xd4>
			panic("map_segment: could not insert page: %e\n", r);
  80042084d3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042084d6:	89 c1                	mov    %eax,%ecx
  80042084d8:	48 ba 48 5a 21 04 80 	movabs $0x8004215a48,%rdx
  80042084df:	00 00 00 
  80042084e2:	be b6 01 00 00       	mov    $0x1b6,%esi
  80042084e7:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  80042084ee:	00 00 00 
  80042084f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042084f6:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042084fd:	00 00 00 
  8004208500:	41 ff d0             	callq  *%r8

		va = ROUNDDOWN((uint8_t*) va + PGSIZE, PGSIZE);
  8004208503:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208507:	48 05 00 10 00 00    	add    $0x1000,%rax
  800420850d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208511:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208515:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420851b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	while (va < endva) {
  800420851f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208523:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208527:	0f 82 2a ff ff ff    	jb     8004208457 <region_alloc+0x28>
	}
}
  800420852d:	c9                   	leaveq 
  800420852e:	c3                   	retq   

000000800420852f <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  800420852f:	55                   	push   %rbp
  8004208530:	48 89 e5             	mov    %rsp,%rbp
  8004208533:	48 83 ec 70          	sub    $0x70,%rsp
  8004208537:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  800420853b:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
	struct Elf *elf = (struct Elf *)binary;
  800420853f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208543:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  8004208547:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420854c:	0f 84 72 03 00 00    	je     80042088c4 <load_icode+0x395>
  8004208552:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208556:	8b 00                	mov    (%rax),%eax
  8004208558:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  800420855d:	0f 85 61 03 00 00    	jne    80042088c4 <load_icode+0x395>
		lcr3(PADDR((uint64_t)e->env_pml4e));
  8004208563:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208567:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420856e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208572:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208579:	00 00 00 
  800420857c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004208580:	77 32                	ja     80042085b4 <load_icode+0x85>
  8004208582:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208586:	48 89 c1             	mov    %rax,%rcx
  8004208589:	48 ba 70 5a 21 04 80 	movabs $0x8004215a70,%rdx
  8004208590:	00 00 00 
  8004208593:	be d9 01 00 00       	mov    $0x1d9,%esi
  8004208598:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  800420859f:	00 00 00 
  80042085a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042085a7:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042085ae:	00 00 00 
  80042085b1:	41 ff d0             	callq  *%r8
  80042085b4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042085bb:	ff ff ff 
  80042085be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042085c2:	48 01 d0             	add    %rdx,%rax
  80042085c5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042085c9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042085cd:	0f 22 d8             	mov    %rax,%cr3
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
  80042085d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085d4:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042085d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085dc:	48 01 d0             	add    %rdx,%rax
  80042085df:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		eph = ph + elf->e_phnum;
  80042085e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085e7:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  80042085eb:	0f b7 c0             	movzwl %ax,%eax
  80042085ee:	48 c1 e0 03          	shl    $0x3,%rax
  80042085f2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042085f9:	00 
  80042085fa:	48 29 c2             	sub    %rax,%rdx
  80042085fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208601:	48 01 d0             	add    %rdx,%rax
  8004208604:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		for(;ph < eph; ph++) {
  8004208608:	e9 c0 00 00 00       	jmpq   80042086cd <load_icode+0x19e>
			if (ph->p_type == ELF_PROG_LOAD) {
  800420860d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208611:	8b 00                	mov    (%rax),%eax
  8004208613:	83 f8 01             	cmp    $0x1,%eax
  8004208616:	0f 85 ac 00 00 00    	jne    80042086c8 <load_icode+0x199>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  800420861c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208620:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208624:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208628:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420862c:	48 89 c1             	mov    %rax,%rcx
  800420862f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208633:	48 89 ce             	mov    %rcx,%rsi
  8004208636:	48 89 c7             	mov    %rax,%rdi
  8004208639:	48 b8 2f 84 20 04 80 	movabs $0x800420842f,%rax
  8004208640:	00 00 00 
  8004208643:	ff d0                	callq  *%rax
				memcpy((void *)ph->p_va, (void *)((uint8_t *)elf + ph->p_offset), ph->p_filesz);
  8004208645:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208649:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420864d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208651:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208655:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004208659:	48 01 d1             	add    %rdx,%rcx
  800420865c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208660:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208664:	48 89 d7             	mov    %rdx,%rdi
  8004208667:	48 89 c2             	mov    %rax,%rdx
  800420866a:	48 89 ce             	mov    %rcx,%rsi
  800420866d:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  8004208674:	00 00 00 
  8004208677:	ff d0                	callq  *%rax
				if (ph->p_filesz < ph->p_memsz) {
  8004208679:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420867d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208681:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208685:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004208689:	48 39 c2             	cmp    %rax,%rdx
  800420868c:	73 3a                	jae    80042086c8 <load_icode+0x199>
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
  800420868e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208692:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208696:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420869a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420869e:	48 29 c2             	sub    %rax,%rdx
  80042086a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086a5:	48 8b 48 10          	mov    0x10(%rax),%rcx
  80042086a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086ad:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042086b1:	48 01 c8             	add    %rcx,%rax
  80042086b4:	be 00 00 00 00       	mov    $0x0,%esi
  80042086b9:	48 89 c7             	mov    %rax,%rdi
  80042086bc:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  80042086c3:	00 00 00 
  80042086c6:	ff d0                	callq  *%rax
		for(;ph < eph; ph++) {
  80042086c8:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  80042086cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086d1:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042086d5:	0f 82 32 ff ff ff    	jb     800420860d <load_icode+0xde>
				}
			}
		}
		region_alloc(e, (void*) (USTACKTOP - PGSIZE), PGSIZE);
  80042086db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042086df:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042086e4:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  80042086e9:	48 89 c7             	mov    %rax,%rdi
  80042086ec:	48 b8 2f 84 20 04 80 	movabs $0x800420842f,%rax
  80042086f3:	00 00 00 
  80042086f6:	ff d0                	callq  *%rax
		e->env_tf.tf_rip    = elf->e_entry;
  80042086f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042086fc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208700:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208704:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		e->env_tf.tf_rsp    = USTACKTOP; //keeping stack 8 byte aligned
  800420870b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420870f:	be 00 e0 7f ef       	mov    $0xef7fe000,%esi
  8004208714:	48 89 b0 b0 00 00 00 	mov    %rsi,0xb0(%rax)

		uintptr_t debug_address = USTABDATA;
  800420871b:	48 c7 45 f0 00 00 20 	movq   $0x200000,-0x10(%rbp)
  8004208722:	00 
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
  8004208723:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208727:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420872b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420872f:	48 01 d0             	add    %rdx,%rax
  8004208732:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
  8004208736:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420873a:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800420873e:	0f b7 c0             	movzwl %ax,%eax
  8004208741:	48 c1 e0 06          	shl    $0x6,%rax
  8004208745:	48 89 c2             	mov    %rax,%rdx
  8004208748:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420874c:	48 01 d0             	add    %rdx,%rax
  800420874f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		struct Secthdr* esh = sh + elf->e_shnum;
  8004208753:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208757:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800420875b:	0f b7 c0             	movzwl %ax,%eax
  800420875e:	48 c1 e0 06          	shl    $0x6,%rax
  8004208762:	48 89 c2             	mov    %rax,%rdx
  8004208765:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208769:	48 01 d0             	add    %rdx,%rax
  800420876c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		for(;sh < esh; sh++) {
  8004208770:	e9 27 01 00 00       	jmpq   800420889c <load_icode+0x36d>
			char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004208775:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208779:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420877d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208781:	8b 00                	mov    (%rax),%eax
  8004208783:	89 c0                	mov    %eax,%eax
  8004208785:	48 01 c2             	add    %rax,%rdx
  8004208788:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420878c:	48 01 d0             	add    %rdx,%rax
  800420878f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			if(!strcmp(name, ".debug_info") || !strcmp(name, ".debug_abbrev")
  8004208793:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208797:	48 be 94 5a 21 04 80 	movabs $0x8004215a94,%rsi
  800420879e:	00 00 00 
  80042087a1:	48 89 c7             	mov    %rax,%rdi
  80042087a4:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042087ab:	00 00 00 
  80042087ae:	ff d0                	callq  *%rax
  80042087b0:	85 c0                	test   %eax,%eax
  80042087b2:	0f 84 84 00 00 00    	je     800420883c <load_icode+0x30d>
  80042087b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042087bc:	48 be a0 5a 21 04 80 	movabs $0x8004215aa0,%rsi
  80042087c3:	00 00 00 
  80042087c6:	48 89 c7             	mov    %rax,%rdi
  80042087c9:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042087d0:	00 00 00 
  80042087d3:	ff d0                	callq  *%rax
  80042087d5:	85 c0                	test   %eax,%eax
  80042087d7:	74 63                	je     800420883c <load_icode+0x30d>
			   || !strcmp(name, ".debug_line") || !strcmp(name, ".eh_frame")
  80042087d9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042087dd:	48 be ae 5a 21 04 80 	movabs $0x8004215aae,%rsi
  80042087e4:	00 00 00 
  80042087e7:	48 89 c7             	mov    %rax,%rdi
  80042087ea:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042087f1:	00 00 00 
  80042087f4:	ff d0                	callq  *%rax
  80042087f6:	85 c0                	test   %eax,%eax
  80042087f8:	74 42                	je     800420883c <load_icode+0x30d>
  80042087fa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042087fe:	48 be ba 5a 21 04 80 	movabs $0x8004215aba,%rsi
  8004208805:	00 00 00 
  8004208808:	48 89 c7             	mov    %rax,%rdi
  800420880b:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004208812:	00 00 00 
  8004208815:	ff d0                	callq  *%rax
  8004208817:	85 c0                	test   %eax,%eax
  8004208819:	74 21                	je     800420883c <load_icode+0x30d>
			   || !strcmp(name, ".debug_str")) {
  800420881b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420881f:	48 be c4 5a 21 04 80 	movabs $0x8004215ac4,%rsi
  8004208826:	00 00 00 
  8004208829:	48 89 c7             	mov    %rax,%rdi
  800420882c:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004208833:	00 00 00 
  8004208836:	ff d0                	callq  *%rax
  8004208838:	85 c0                	test   %eax,%eax
  800420883a:	75 5b                	jne    8004208897 <load_icode+0x368>
				region_alloc(e ,(void*)debug_address, sh->sh_size);
  800420883c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208840:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208844:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004208848:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420884c:	48 89 ce             	mov    %rcx,%rsi
  800420884f:	48 89 c7             	mov    %rax,%rdi
  8004208852:	48 b8 2f 84 20 04 80 	movabs $0x800420842f,%rax
  8004208859:	00 00 00 
  800420885c:	ff d0                	callq  *%rax
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset),
  800420885e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208862:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208866:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420886a:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420886e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208872:	48 01 c1             	add    %rax,%rcx
  8004208875:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208879:	48 89 ce             	mov    %rcx,%rsi
  800420887c:	48 89 c7             	mov    %rax,%rdi
  800420887f:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  8004208886:	00 00 00 
  8004208889:	ff d0                	callq  *%rax
				       sh->sh_size);
				debug_address += sh->sh_size;
  800420888b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420888f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208893:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		for(;sh < esh; sh++) {
  8004208897:	48 83 45 e8 40       	addq   $0x40,-0x18(%rbp)
  800420889c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042088a0:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042088a4:	0f 82 cb fe ff ff    	jb     8004208775 <load_icode+0x246>
			}
		}
		lcr3(boot_cr3);
  80042088aa:	48 b8 c0 c7 57 04 80 	movabs $0x800457c7c0,%rax
  80042088b1:	00 00 00 
  80042088b4:	48 8b 00             	mov    (%rax),%rax
  80042088b7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042088bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042088bf:	0f 22 d8             	mov    %rax,%cr3
	if (elf && elf->e_magic == ELF_MAGIC) {
  80042088c2:	eb 2a                	jmp    80042088ee <load_icode+0x3bf>
	} else {
		panic("Invalid Binary");
  80042088c4:	48 ba cf 5a 21 04 80 	movabs $0x8004215acf,%rdx
  80042088cb:	00 00 00 
  80042088ce:	be fa 01 00 00       	mov    $0x1fa,%esi
  80042088d3:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  80042088da:	00 00 00 
  80042088dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042088e2:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  80042088e9:	00 00 00 
  80042088ec:	ff d1                	callq  *%rcx
	// LAB 3: Your code here
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.

	// LAB 3: Your code here.
	e->elf = binary;
  80042088ee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042088f2:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042088f6:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  80042088fd:	c9                   	leaveq 
  80042088fe:	c3                   	retq   

00000080042088ff <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  80042088ff:	55                   	push   %rbp
  8004208900:	48 89 e5             	mov    %rsp,%rbp
  8004208903:	48 83 ec 20          	sub    $0x20,%rsp
  8004208907:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420890b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.
	int r;
	struct Env *e;
	if ((r = env_alloc(&e, 0)) < 0)
  800420890e:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004208912:	be 00 00 00 00       	mov    $0x0,%esi
  8004208917:	48 89 c7             	mov    %rax,%rdi
  800420891a:	48 b8 93 82 20 04 80 	movabs $0x8004208293,%rax
  8004208921:	00 00 00 
  8004208924:	ff d0                	callq  *%rax
  8004208926:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004208929:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420892d:	79 30                	jns    800420895f <env_create+0x60>
		panic("env_create: could not allocate env: %e\n", r);
  800420892f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208932:	89 c1                	mov    %eax,%ecx
  8004208934:	48 ba e0 5a 21 04 80 	movabs $0x8004215ae0,%rdx
  800420893b:	00 00 00 
  800420893e:	be 2f 02 00 00       	mov    $0x22f,%esi
  8004208943:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  800420894a:	00 00 00 
  800420894d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208952:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004208959:	00 00 00 
  800420895c:	41 ff d0             	callq  *%r8
	load_icode(e, binary);
  800420895f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208963:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208967:	48 89 d6             	mov    %rdx,%rsi
  800420896a:	48 89 c7             	mov    %rax,%rdi
  800420896d:	48 b8 2f 85 20 04 80 	movabs $0x800420852f,%rax
  8004208974:	00 00 00 
  8004208977:	ff d0                	callq  *%rax
	e->env_type = type;
  8004208979:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420897d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208980:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
	if (type == ENV_TYPE_FS)
  8004208986:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420898a:	75 19                	jne    80042089a5 <env_create+0xa6>
		e->env_tf.tf_eflags |= FL_IOPL_3;
  800420898c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208990:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208994:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420899b:	80 ce 30             	or     $0x30,%dh
  800420899e:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  80042089a5:	c9                   	leaveq 
  80042089a6:	c3                   	retq   

00000080042089a7 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  80042089a7:	55                   	push   %rbp
  80042089a8:	48 89 e5             	mov    %rsp,%rbp
  80042089ab:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042089b2:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
#endif

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  80042089b9:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042089c0:	00 00 00 
  80042089c3:	ff d0                	callq  *%rax
  80042089c5:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  80042089cc:	00 00 00 
  80042089cf:	48 98                	cltq   
  80042089d1:	48 c1 e0 03          	shl    $0x3,%rax
  80042089d5:	48 89 c1             	mov    %rax,%rcx
  80042089d8:	48 c1 e1 04          	shl    $0x4,%rcx
  80042089dc:	48 01 c8             	add    %rcx,%rax
  80042089df:	48 01 d0             	add    %rdx,%rax
  80042089e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042089e6:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  80042089ed:	75 18                	jne    8004208a07 <env_free+0x60>
		lcr3(boot_cr3);
  80042089ef:	48 b8 c0 c7 57 04 80 	movabs $0x800457c7c0,%rax
  80042089f6:	00 00 00 
  80042089f9:	48 8b 00             	mov    (%rax),%rax
  80042089fc:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004208a00:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208a04:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	if (e->env_pml4e[0] & PTE_P) {
  8004208a07:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a0e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208a15:	48 8b 00             	mov    (%rax),%rax
  8004208a18:	83 e0 01             	and    $0x1,%eax
  8004208a1b:	48 85 c0             	test   %rax,%rax
  8004208a1e:	0f 84 7a 03 00 00    	je     8004208d9e <env_free+0x3f7>
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208a24:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a2b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208a32:	48 8b 00             	mov    (%rax),%rax
  8004208a35:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208a3b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208a3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208a43:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208a47:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004208a4a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208a4d:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004208a54:	00 00 00 
  8004208a57:	48 8b 00             	mov    (%rax),%rax
  8004208a5a:	48 39 c2             	cmp    %rax,%rdx
  8004208a5d:	72 32                	jb     8004208a91 <env_free+0xea>
  8004208a5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208a63:	48 89 c1             	mov    %rax,%rcx
  8004208a66:	48 ba e8 59 21 04 80 	movabs $0x80042159e8,%rdx
  8004208a6d:	00 00 00 
  8004208a70:	be 54 02 00 00       	mov    $0x254,%esi
  8004208a75:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  8004208a7c:	00 00 00 
  8004208a7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208a84:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004208a8b:	00 00 00 
  8004208a8e:	41 ff d0             	callq  *%r8
  8004208a91:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208a98:	00 00 00 
  8004208a9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208a9f:	48 01 d0             	add    %rdx,%rax
  8004208aa2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208aa6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208aad:	00 
  8004208aae:	e9 ab 02 00 00       	jmpq   8004208d5e <env_free+0x3b7>
			if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208ab3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208ab7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208abe:	00 
  8004208abf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208ac3:	48 01 d0             	add    %rdx,%rax
  8004208ac6:	48 8b 00             	mov    (%rax),%rax
  8004208ac9:	83 e0 01             	and    $0x1,%eax
  8004208acc:	48 85 c0             	test   %rax,%rax
  8004208acf:	75 05                	jne    8004208ad6 <env_free+0x12f>
				continue;
  8004208ad1:	e9 83 02 00 00       	jmpq   8004208d59 <env_free+0x3b2>
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208ad6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208ada:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208ae1:	00 
  8004208ae2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208ae6:	48 01 d0             	add    %rdx,%rax
  8004208ae9:	48 8b 00             	mov    (%rax),%rax
  8004208aec:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208af2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208af6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208afa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208afe:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208b01:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208b04:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004208b0b:	00 00 00 
  8004208b0e:	48 8b 00             	mov    (%rax),%rax
  8004208b11:	48 39 c2             	cmp    %rax,%rdx
  8004208b14:	72 32                	jb     8004208b48 <env_free+0x1a1>
  8004208b16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208b1a:	48 89 c1             	mov    %rax,%rcx
  8004208b1d:	48 ba e8 59 21 04 80 	movabs $0x80042159e8,%rdx
  8004208b24:	00 00 00 
  8004208b27:	be 5c 02 00 00       	mov    $0x25c,%esi
  8004208b2c:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  8004208b33:	00 00 00 
  8004208b36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208b3b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004208b42:	00 00 00 
  8004208b45:	41 ff d0             	callq  *%r8
  8004208b48:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208b4f:	00 00 00 
  8004208b52:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208b56:	48 01 d0             	add    %rdx,%rax
  8004208b59:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208b5d:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208b62:	75 07                	jne    8004208b6b <env_free+0x1c4>
  8004208b64:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208b69:	eb 05                	jmp    8004208b70 <env_free+0x1c9>
  8004208b6b:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208b70:	89 45 b4             	mov    %eax,-0x4c(%rbp)
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208b73:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208b7a:	00 
  8004208b7b:	e9 6e 01 00 00       	jmpq   8004208cee <env_free+0x347>

				// only look at mapped page tables
				if (!(env_pgdir[pdeno] & PTE_P))
  8004208b80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b84:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208b8b:	00 
  8004208b8c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208b90:	48 01 d0             	add    %rdx,%rax
  8004208b93:	48 8b 00             	mov    (%rax),%rax
  8004208b96:	83 e0 01             	and    $0x1,%eax
  8004208b99:	48 85 c0             	test   %rax,%rax
  8004208b9c:	75 05                	jne    8004208ba3 <env_free+0x1fc>
					continue;
  8004208b9e:	e9 46 01 00 00       	jmpq   8004208ce9 <env_free+0x342>
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208ba3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208ba7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208bae:	00 
  8004208baf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208bb3:	48 01 d0             	add    %rdx,%rax
  8004208bb6:	48 8b 00             	mov    (%rax),%rax
  8004208bb9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208bbf:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				pt = (pte_t*) KADDR(pa);
  8004208bc3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208bc7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208bcb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208bcf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208bd3:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208bd6:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208bd9:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004208be0:	00 00 00 
  8004208be3:	48 8b 00             	mov    (%rax),%rax
  8004208be6:	48 39 c2             	cmp    %rax,%rdx
  8004208be9:	72 32                	jb     8004208c1d <env_free+0x276>
  8004208beb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208bef:	48 89 c1             	mov    %rax,%rcx
  8004208bf2:	48 ba e8 59 21 04 80 	movabs $0x80042159e8,%rdx
  8004208bf9:	00 00 00 
  8004208bfc:	be 66 02 00 00       	mov    $0x266,%esi
  8004208c01:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  8004208c08:	00 00 00 
  8004208c0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c10:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004208c17:	00 00 00 
  8004208c1a:	41 ff d0             	callq  *%r8
  8004208c1d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208c24:	00 00 00 
  8004208c27:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208c2b:	48 01 d0             	add    %rdx,%rax
  8004208c2e:	48 89 45 90          	mov    %rax,-0x70(%rbp)

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208c32:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004208c39:	00 
  8004208c3a:	eb 67                	jmp    8004208ca3 <env_free+0x2fc>
					if (pt[pteno] & PTE_P){
  8004208c3c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208c40:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c47:	00 
  8004208c48:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208c4c:	48 01 d0             	add    %rdx,%rax
  8004208c4f:	48 8b 00             	mov    (%rax),%rax
  8004208c52:	83 e0 01             	and    $0x1,%eax
  8004208c55:	48 85 c0             	test   %rax,%rax
  8004208c58:	74 44                	je     8004208c9e <env_free+0x2f7>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208c5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c5e:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208c62:	48 89 c2             	mov    %rax,%rdx
  8004208c65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208c69:	48 c1 e0 15          	shl    $0x15,%rax
  8004208c6d:	48 09 c2             	or     %rax,%rdx
  8004208c70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208c74:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208c78:	48 09 d0             	or     %rdx,%rax
  8004208c7b:	48 89 c2             	mov    %rax,%rdx
  8004208c7e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208c85:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208c8c:	48 89 d6             	mov    %rdx,%rsi
  8004208c8f:	48 89 c7             	mov    %rax,%rdi
  8004208c92:	48 b8 14 3f 20 04 80 	movabs $0x8004203f14,%rax
  8004208c99:	00 00 00 
  8004208c9c:	ff d0                	callq  *%rax
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208c9e:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208ca3:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208caa:	00 
  8004208cab:	76 8f                	jbe    8004208c3c <env_free+0x295>
					}
				}

				// free the page table itself
				env_pgdir[pdeno] = 0;
  8004208cad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208cb1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208cb8:	00 
  8004208cb9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208cbd:	48 01 d0             	add    %rdx,%rax
  8004208cc0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
				page_decref(pa2page(pa));
  8004208cc7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208ccb:	48 89 c7             	mov    %rax,%rdi
  8004208cce:	48 b8 f0 7d 20 04 80 	movabs $0x8004207df0,%rax
  8004208cd5:	00 00 00 
  8004208cd8:	ff d0                	callq  *%rax
  8004208cda:	48 89 c7             	mov    %rax,%rdi
  8004208cdd:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004208ce4:	00 00 00 
  8004208ce7:	ff d0                	callq  *%rax
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208ce9:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208cee:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208cf1:	48 98                	cltq   
  8004208cf3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208cf7:	0f 87 83 fe ff ff    	ja     8004208b80 <env_free+0x1d9>
			}
			// free the page directory
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208cfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208d01:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d08:	00 
  8004208d09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208d0d:	48 01 d0             	add    %rdx,%rax
  8004208d10:	48 8b 00             	mov    (%rax),%rax
  8004208d13:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208d19:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			env_pdpe[pdpe_index] = 0;
  8004208d1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208d21:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d28:	00 
  8004208d29:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208d2d:	48 01 d0             	add    %rdx,%rax
  8004208d30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208d37:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208d3b:	48 89 c7             	mov    %rax,%rdi
  8004208d3e:	48 b8 f0 7d 20 04 80 	movabs $0x8004207df0,%rax
  8004208d45:	00 00 00 
  8004208d48:	ff d0                	callq  *%rax
  8004208d4a:	48 89 c7             	mov    %rax,%rdi
  8004208d4d:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004208d54:	00 00 00 
  8004208d57:	ff d0                	callq  *%rax
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208d59:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208d5e:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208d63:	0f 86 4a fd ff ff    	jbe    8004208ab3 <env_free+0x10c>
		}
		// free the page directory pointer
		page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208d69:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d70:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208d77:	48 8b 00             	mov    (%rax),%rax
  8004208d7a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208d80:	48 89 c7             	mov    %rax,%rdi
  8004208d83:	48 b8 f0 7d 20 04 80 	movabs $0x8004207df0,%rax
  8004208d8a:	00 00 00 
  8004208d8d:	ff d0                	callq  *%rax
  8004208d8f:	48 89 c7             	mov    %rax,%rdi
  8004208d92:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004208d99:	00 00 00 
  8004208d9c:	ff d0                	callq  *%rax
	}
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208d9e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208da5:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208dac:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208db3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208dba:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208dc1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208dc5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208dcc:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208dd3:	00 00 00 00 
	e->env_cr3 = 0;
  8004208dd7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208dde:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208de5:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208de9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208ded:	48 89 c7             	mov    %rax,%rdi
  8004208df0:	48 b8 f0 7d 20 04 80 	movabs $0x8004207df0,%rax
  8004208df7:	00 00 00 
  8004208dfa:	ff d0                	callq  *%rax
  8004208dfc:	48 89 c7             	mov    %rax,%rdi
  8004208dff:	48 b8 cb 30 20 04 80 	movabs $0x80042030cb,%rax
  8004208e06:	00 00 00 
  8004208e09:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208e0b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208e12:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208e19:	00 00 00 
	e->env_link = env_free_list;
  8004208e1c:	48 b8 80 b2 57 04 80 	movabs $0x800457b280,%rax
  8004208e23:	00 00 00 
  8004208e26:	48 8b 10             	mov    (%rax),%rdx
  8004208e29:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208e30:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208e37:	48 b8 80 b2 57 04 80 	movabs $0x800457b280,%rax
  8004208e3e:	00 00 00 
  8004208e41:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004208e48:	48 89 10             	mov    %rdx,(%rax)
}
  8004208e4b:	c9                   	leaveq 
  8004208e4c:	c3                   	retq   

0000008004208e4d <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004208e4d:	55                   	push   %rbp
  8004208e4e:	48 89 e5             	mov    %rsp,%rbp
  8004208e51:	48 83 ec 10          	sub    $0x10,%rsp
  8004208e55:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208e59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e5d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208e63:	83 f8 03             	cmp    $0x3,%eax
  8004208e66:	75 46                	jne    8004208eae <env_destroy+0x61>
  8004208e68:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004208e6f:	00 00 00 
  8004208e72:	ff d0                	callq  *%rax
  8004208e74:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004208e7b:	00 00 00 
  8004208e7e:	48 98                	cltq   
  8004208e80:	48 c1 e0 03          	shl    $0x3,%rax
  8004208e84:	48 89 c1             	mov    %rax,%rcx
  8004208e87:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208e8b:	48 01 c8             	add    %rcx,%rax
  8004208e8e:	48 01 d0             	add    %rdx,%rax
  8004208e91:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208e95:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208e99:	74 13                	je     8004208eae <env_destroy+0x61>
		e->env_status = ENV_DYING;
  8004208e9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e9f:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208ea6:	00 00 00 
		return;
  8004208ea9:	e9 83 00 00 00       	jmpq   8004208f31 <env_destroy+0xe4>
	}

	env_free(e);
  8004208eae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208eb2:	48 89 c7             	mov    %rax,%rdi
  8004208eb5:	48 b8 a7 89 20 04 80 	movabs $0x80042089a7,%rax
  8004208ebc:	00 00 00 
  8004208ebf:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208ec1:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004208ec8:	00 00 00 
  8004208ecb:	ff d0                	callq  *%rax
  8004208ecd:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004208ed4:	00 00 00 
  8004208ed7:	48 98                	cltq   
  8004208ed9:	48 c1 e0 03          	shl    $0x3,%rax
  8004208edd:	48 89 c1             	mov    %rax,%rcx
  8004208ee0:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208ee4:	48 01 c8             	add    %rcx,%rax
  8004208ee7:	48 01 d0             	add    %rdx,%rax
  8004208eea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208eee:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208ef2:	75 3d                	jne    8004208f31 <env_destroy+0xe4>
		curenv = NULL;
  8004208ef4:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004208efb:	00 00 00 
  8004208efe:	ff d0                	callq  *%rax
  8004208f00:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004208f07:	00 00 00 
  8004208f0a:	48 98                	cltq   
  8004208f0c:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f10:	48 89 c1             	mov    %rax,%rcx
  8004208f13:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208f17:	48 01 c8             	add    %rcx,%rax
  8004208f1a:	48 01 d0             	add    %rdx,%rax
  8004208f1d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004208f24:	00 
		sched_yield();
  8004208f25:	48 b8 c5 a3 20 04 80 	movabs $0x800420a3c5,%rax
  8004208f2c:	00 00 00 
  8004208f2f:	ff d0                	callq  *%rax
	}
}
  8004208f31:	c9                   	leaveq 
  8004208f32:	c3                   	retq   

0000008004208f33 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004208f33:	55                   	push   %rbp
  8004208f34:	48 89 e5             	mov    %rsp,%rbp
  8004208f37:	53                   	push   %rbx
  8004208f38:	48 83 ec 18          	sub    $0x18,%rsp
  8004208f3c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208f40:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004208f47:	00 00 00 
  8004208f4a:	ff d0                	callq  *%rax
  8004208f4c:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004208f53:	00 00 00 
  8004208f56:	48 98                	cltq   
  8004208f58:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f5c:	48 89 c1             	mov    %rax,%rcx
  8004208f5f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208f63:	48 01 c8             	add    %rcx,%rax
  8004208f66:	48 01 d0             	add    %rdx,%rax
  8004208f69:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004208f6d:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004208f74:	00 00 00 
  8004208f77:	ff d0                	callq  *%rax
  8004208f79:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  8004208f7f:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208f83:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208f87:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208f8c:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208f91:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208f96:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208f9b:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208fa0:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208fa5:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208faa:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208faf:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208fb4:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208fb9:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208fbe:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208fc3:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208fc8:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208fcd:	48 83 c4 78          	add    $0x78,%rsp
  8004208fd1:	8e 04 24             	mov    (%rsp),%es
  8004208fd4:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208fd8:	48 83 c4 10          	add    $0x10,%rsp
  8004208fdc:	48 83 c4 10          	add    $0x10,%rsp
  8004208fe0:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208fe2:	48 ba 08 5b 21 04 80 	movabs $0x8004215b08,%rdx
  8004208fe9:	00 00 00 
  8004208fec:	be b3 02 00 00       	mov    $0x2b3,%esi
  8004208ff1:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  8004208ff8:	00 00 00 
  8004208ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209000:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004209007:	00 00 00 
  800420900a:	ff d1                	callq  *%rcx

000000800420900c <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  800420900c:	55                   	push   %rbp
  800420900d:	48 89 e5             	mov    %rsp,%rbp
  8004209010:	48 83 ec 20          	sub    $0x20,%rsp
  8004209014:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Is this a context switch or just a return?
	if (curenv != e) {
  8004209018:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420901f:	00 00 00 
  8004209022:	ff d0                	callq  *%rax
  8004209024:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420902b:	00 00 00 
  800420902e:	48 98                	cltq   
  8004209030:	48 c1 e0 03          	shl    $0x3,%rax
  8004209034:	48 89 c1             	mov    %rax,%rcx
  8004209037:	48 c1 e1 04          	shl    $0x4,%rcx
  800420903b:	48 01 c8             	add    %rcx,%rax
  800420903e:	48 01 d0             	add    %rdx,%rax
  8004209041:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004209045:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004209049:	0f 84 1c 01 00 00    	je     800420916b <env_run+0x15f>
		if (curenv && curenv->env_status == ENV_RUNNING)
  800420904f:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004209056:	00 00 00 
  8004209059:	ff d0                	callq  *%rax
  800420905b:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004209062:	00 00 00 
  8004209065:	48 98                	cltq   
  8004209067:	48 c1 e0 03          	shl    $0x3,%rax
  800420906b:	48 89 c1             	mov    %rax,%rcx
  800420906e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209072:	48 01 c8             	add    %rcx,%rax
  8004209075:	48 01 d0             	add    %rdx,%rax
  8004209078:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420907c:	48 85 c0             	test   %rax,%rax
  800420907f:	74 6f                	je     80042090f0 <env_run+0xe4>
  8004209081:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004209088:	00 00 00 
  800420908b:	ff d0                	callq  *%rax
  800420908d:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004209094:	00 00 00 
  8004209097:	48 98                	cltq   
  8004209099:	48 c1 e0 03          	shl    $0x3,%rax
  800420909d:	48 89 c1             	mov    %rax,%rcx
  80042090a0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042090a4:	48 01 c8             	add    %rcx,%rax
  80042090a7:	48 01 d0             	add    %rdx,%rax
  80042090aa:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042090ae:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042090b4:	83 f8 03             	cmp    $0x3,%eax
  80042090b7:	75 37                	jne    80042090f0 <env_run+0xe4>
			curenv->env_status = ENV_RUNNABLE;
  80042090b9:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042090c0:	00 00 00 
  80042090c3:	ff d0                	callq  *%rax
  80042090c5:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  80042090cc:	00 00 00 
  80042090cf:	48 98                	cltq   
  80042090d1:	48 c1 e0 03          	shl    $0x3,%rax
  80042090d5:	48 89 c1             	mov    %rax,%rcx
  80042090d8:	48 c1 e1 04          	shl    $0x4,%rcx
  80042090dc:	48 01 c8             	add    %rcx,%rax
  80042090df:	48 01 d0             	add    %rdx,%rax
  80042090e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042090e6:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042090ed:	00 00 00 
		//cprintf("cpu %d switch from env %d to env %d\n",
		//	cpunum(), curenv ? curenv - envs : -1, e - envs);

		// keep track of which environment we're currently
		// running
		curenv = e;
  80042090f0:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042090f7:	00 00 00 
  80042090fa:	ff d0                	callq  *%rax
  80042090fc:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004209103:	00 00 00 
  8004209106:	48 98                	cltq   
  8004209108:	48 c1 e0 03          	shl    $0x3,%rax
  800420910c:	48 89 c1             	mov    %rax,%rcx
  800420910f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209113:	48 01 c8             	add    %rcx,%rax
  8004209116:	48 01 c2             	add    %rax,%rdx
  8004209119:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420911d:	48 89 42 08          	mov    %rax,0x8(%rdx)
		e->env_status = ENV_RUNNING;
  8004209121:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209125:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420912c:	00 00 00 
		e->env_runs++;
  800420912f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209133:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8004209139:	8d 50 01             	lea    0x1(%rax),%edx
  800420913c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209140:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

		// restore e's address space
#if LAB >= 8
		if(e->env_type != ENV_TYPE_GUEST)
  8004209146:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420914a:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004209150:	83 f8 03             	cmp    $0x3,%eax
  8004209153:	74 16                	je     800420916b <env_run+0x15f>
			lcr3(e->env_cr3);
  8004209155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209159:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004209160:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004209164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209168:	0f 22 d8             	mov    %rax,%cr3
#else
		lcr3(e->env_cr3);
#endif
	}

	assert(e->env_status == ENV_RUNNING);
  800420916b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420916f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004209175:	83 f8 03             	cmp    $0x3,%eax
  8004209178:	74 35                	je     80042091af <env_run+0x1a3>
  800420917a:	48 b9 14 5b 21 04 80 	movabs $0x8004215b14,%rcx
  8004209181:	00 00 00 
  8004209184:	48 ba 31 5b 21 04 80 	movabs $0x8004215b31,%rdx
  800420918b:	00 00 00 
  800420918e:	be d6 02 00 00       	mov    $0x2d6,%esi
  8004209193:	48 bf 37 5a 21 04 80 	movabs $0x8004215a37,%rdi
  800420919a:	00 00 00 
  800420919d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042091a2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042091a9:	00 00 00 
  80042091ac:	41 ff d0             	callq  *%r8
	if(e->env_type == ENV_TYPE_GUEST) {
		vmx_vmrun(e);
		panic ("vmx_run never returns\n");
	}
#endif /* not VMM_GUEST */
	unlock_kernel();
  80042091af:	48 b8 e9 7e 20 04 80 	movabs $0x8004207ee9,%rax
  80042091b6:	00 00 00 
  80042091b9:	ff d0                	callq  *%rax
	env_pop_tf(&e->env_tf);
  80042091bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042091bf:	48 89 c7             	mov    %rax,%rdi
  80042091c2:	48 b8 33 8f 20 04 80 	movabs $0x8004208f33,%rax
  80042091c9:	00 00 00 
  80042091cc:	ff d0                	callq  *%rax

00000080042091ce <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  80042091ce:	55                   	push   %rbp
  80042091cf:	48 89 e5             	mov    %rsp,%rbp
  80042091d2:	48 83 ec 18          	sub    $0x18,%rsp
  80042091d6:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  80042091d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042091dc:	0f b6 c0             	movzbl %al,%eax
  80042091df:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042091e6:	88 45 fb             	mov    %al,-0x5(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042091e9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042091ed:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042091f0:	ee                   	out    %al,(%dx)
  80042091f1:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042091f8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042091fb:	89 c2                	mov    %eax,%edx
  80042091fd:	ec                   	in     (%dx),%al
  80042091fe:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004209201:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004209205:	0f b6 c0             	movzbl %al,%eax
}
  8004209208:	c9                   	leaveq 
  8004209209:	c3                   	retq   

000000800420920a <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  800420920a:	55                   	push   %rbp
  800420920b:	48 89 e5             	mov    %rsp,%rbp
  800420920e:	48 83 ec 18          	sub    $0x18,%rsp
  8004209212:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004209215:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004209218:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420921b:	0f b6 c0             	movzbl %al,%eax
  800420921e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004209225:	88 45 fb             	mov    %al,-0x5(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004209228:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420922c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420922f:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004209230:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004209233:	0f b6 c0             	movzbl %al,%eax
  8004209236:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  800420923d:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209240:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209244:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209247:	ee                   	out    %al,(%dx)
}
  8004209248:	c9                   	leaveq 
  8004209249:	c3                   	retq   

000000800420924a <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  800420924a:	55                   	push   %rbp
  800420924b:	48 89 e5             	mov    %rsp,%rbp
  800420924e:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004209252:	48 b8 88 b2 57 04 80 	movabs $0x800457b288,%rax
  8004209259:	00 00 00 
  800420925c:	c6 00 01             	movb   $0x1,(%rax)
  800420925f:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004209266:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  800420926a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420926e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209271:	ee                   	out    %al,(%dx)
  8004209272:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004209279:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  800420927d:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209281:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209284:	ee                   	out    %al,(%dx)
  8004209285:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  800420928c:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004209290:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004209294:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004209297:	ee                   	out    %al,(%dx)
  8004209298:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  800420929f:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  80042092a3:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042092a7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042092aa:	ee                   	out    %al,(%dx)
  80042092ab:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  80042092b2:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  80042092b6:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042092ba:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042092bd:	ee                   	out    %al,(%dx)
  80042092be:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  80042092c5:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  80042092c9:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042092cd:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042092d0:	ee                   	out    %al,(%dx)
  80042092d1:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  80042092d8:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  80042092dc:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042092e0:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042092e3:	ee                   	out    %al,(%dx)
  80042092e4:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  80042092eb:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  80042092ef:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  80042092f3:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042092f6:	ee                   	out    %al,(%dx)
  80042092f7:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  80042092fe:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004209302:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004209306:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004209309:	ee                   	out    %al,(%dx)
  800420930a:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004209311:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004209315:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004209319:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420931c:	ee                   	out    %al,(%dx)
  800420931d:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004209324:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004209328:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  800420932c:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420932f:	ee                   	out    %al,(%dx)
  8004209330:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004209337:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  800420933b:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  800420933f:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004209342:	ee                   	out    %al,(%dx)
  8004209343:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  800420934a:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  800420934e:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004209352:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004209355:	ee                   	out    %al,(%dx)
  8004209356:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  800420935d:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004209361:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004209365:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004209368:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004209369:	48 b8 b2 86 22 04 80 	movabs $0x80042286b2,%rax
  8004209370:	00 00 00 
  8004209373:	0f b7 00             	movzwl (%rax),%eax
  8004209376:	66 83 f8 ff          	cmp    $0xffff,%ax
  800420937a:	74 1e                	je     800420939a <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  800420937c:	48 b8 b2 86 22 04 80 	movabs $0x80042286b2,%rax
  8004209383:	00 00 00 
  8004209386:	0f b7 00             	movzwl (%rax),%eax
  8004209389:	0f b7 c0             	movzwl %ax,%eax
  800420938c:	89 c7                	mov    %eax,%edi
  800420938e:	48 b8 9c 93 20 04 80 	movabs $0x800420939c,%rax
  8004209395:	00 00 00 
  8004209398:	ff d0                	callq  *%rax
}
  800420939a:	c9                   	leaveq 
  800420939b:	c3                   	retq   

000000800420939c <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  800420939c:	55                   	push   %rbp
  800420939d:	48 89 e5             	mov    %rsp,%rbp
  80042093a0:	48 83 ec 30          	sub    $0x30,%rsp
  80042093a4:	89 f8                	mov    %edi,%eax
  80042093a6:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  80042093aa:	48 b8 b2 86 22 04 80 	movabs $0x80042286b2,%rax
  80042093b1:	00 00 00 
  80042093b4:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80042093b8:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  80042093bb:	48 b8 88 b2 57 04 80 	movabs $0x800457b288,%rax
  80042093c2:	00 00 00 
  80042093c5:	0f b6 00             	movzbl (%rax),%eax
  80042093c8:	83 f0 01             	xor    $0x1,%eax
  80042093cb:	84 c0                	test   %al,%al
  80042093cd:	74 05                	je     80042093d4 <irq_setmask_8259A+0x38>
		return;
  80042093cf:	e9 b7 00 00 00       	jmpq   800420948b <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  80042093d4:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042093d8:	0f b6 c0             	movzbl %al,%eax
  80042093db:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  80042093e2:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042093e5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042093e9:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042093ec:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  80042093ed:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042093f1:	66 c1 e8 08          	shr    $0x8,%ax
  80042093f5:	0f b6 c0             	movzbl %al,%eax
  80042093f8:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  80042093ff:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004209402:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004209406:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004209409:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  800420940a:	48 bf 46 5b 21 04 80 	movabs $0x8004215b46,%rdi
  8004209411:	00 00 00 
  8004209414:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209419:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209420:	00 00 00 
  8004209423:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004209425:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420942c:	eb 3c                	jmp    800420946a <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  800420942e:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209432:	f7 d0                	not    %eax
  8004209434:	89 c2                	mov    %eax,%edx
  8004209436:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209439:	89 c1                	mov    %eax,%ecx
  800420943b:	d3 fa                	sar    %cl,%edx
  800420943d:	89 d0                	mov    %edx,%eax
  800420943f:	83 e0 01             	and    $0x1,%eax
  8004209442:	85 c0                	test   %eax,%eax
  8004209444:	74 20                	je     8004209466 <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004209446:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209449:	89 c6                	mov    %eax,%esi
  800420944b:	48 bf 5a 5b 21 04 80 	movabs $0x8004215b5a,%rdi
  8004209452:	00 00 00 
  8004209455:	b8 00 00 00 00       	mov    $0x0,%eax
  800420945a:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209461:	00 00 00 
  8004209464:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004209466:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420946a:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420946e:	7e be                	jle    800420942e <irq_setmask_8259A+0x92>
	cprintf("\n");
  8004209470:	48 bf 5e 5b 21 04 80 	movabs $0x8004215b5e,%rdi
  8004209477:	00 00 00 
  800420947a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420947f:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209486:	00 00 00 
  8004209489:	ff d2                	callq  *%rdx
}
  800420948b:	c9                   	leaveq 
  800420948c:	c3                   	retq   

000000800420948d <irq_eoi>:

void
irq_eoi(void)
{
  800420948d:	55                   	push   %rbp
  800420948e:	48 89 e5             	mov    %rsp,%rbp
  8004209491:	48 83 ec 10          	sub    $0x10,%rsp
  8004209495:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  800420949c:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  80042094a0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042094a4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042094a7:	ee                   	out    %al,(%dx)
  80042094a8:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  80042094af:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  80042094b3:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042094b7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042094ba:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  80042094bb:	c9                   	leaveq 
  80042094bc:	c3                   	retq   

00000080042094bd <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  80042094bd:	55                   	push   %rbp
  80042094be:	48 89 e5             	mov    %rsp,%rbp
  80042094c1:	48 83 ec 10          	sub    $0x10,%rsp
  80042094c5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042094c8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  80042094cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042094cf:	89 c7                	mov    %eax,%edi
  80042094d1:	48 b8 00 13 20 04 80 	movabs $0x8004201300,%rax
  80042094d8:	00 00 00 
  80042094db:	ff d0                	callq  *%rax
	*cnt++;
  80042094dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042094e1:	48 83 c0 04          	add    $0x4,%rax
  80042094e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  80042094e9:	c9                   	leaveq 
  80042094ea:	c3                   	retq   

00000080042094eb <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80042094eb:	55                   	push   %rbp
  80042094ec:	48 89 e5             	mov    %rsp,%rbp
  80042094ef:	48 83 ec 30          	sub    $0x30,%rsp
  80042094f3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042094f7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  80042094fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209502:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004209506:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420950a:	48 8b 0a             	mov    (%rdx),%rcx
  800420950d:	48 89 08             	mov    %rcx,(%rax)
  8004209510:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209514:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209518:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420951c:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004209520:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004209524:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004209528:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  800420952c:	48 89 c6             	mov    %rax,%rsi
  800420952f:	48 bf bd 94 20 04 80 	movabs $0x80042094bd,%rdi
  8004209536:	00 00 00 
  8004209539:	48 b8 ff b8 20 04 80 	movabs $0x800420b8ff,%rax
  8004209540:	00 00 00 
  8004209543:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004209545:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004209548:	c9                   	leaveq 
  8004209549:	c3                   	retq   

000000800420954a <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800420954a:	55                   	push   %rbp
  800420954b:	48 89 e5             	mov    %rsp,%rbp
  800420954e:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004209555:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  800420955c:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209563:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420956a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004209571:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004209578:	84 c0                	test   %al,%al
  800420957a:	74 20                	je     800420959c <cprintf+0x52>
  800420957c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004209580:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004209584:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004209588:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420958c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004209590:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004209594:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004209598:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420959c:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  80042095a3:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  80042095aa:	00 00 00 
  80042095ad:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80042095b4:	00 00 00 
  80042095b7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042095bb:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042095c2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042095c9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042095d0:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  80042095d7:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80042095de:	48 8b 0a             	mov    (%rdx),%rcx
  80042095e1:	48 89 08             	mov    %rcx,(%rax)
  80042095e4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042095e8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042095ec:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042095f0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  80042095f4:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  80042095fb:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209602:	48 89 d6             	mov    %rdx,%rsi
  8004209605:	48 89 c7             	mov    %rax,%rdi
  8004209608:	48 b8 eb 94 20 04 80 	movabs $0x80042094eb,%rax
  800420960f:	00 00 00 
  8004209612:	ff d0                	callq  *%rax
  8004209614:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  800420961a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209620:	c9                   	leaveq 
  8004209621:	c3                   	retq   

0000008004209622 <xchg>:
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209622:	55                   	push   %rbp
  8004209623:	48 89 e5             	mov    %rsp,%rbp
  8004209626:	48 83 ec 20          	sub    $0x20,%rsp
  800420962a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420962e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	__asm __volatile("lock; xchgl %0, %1":
  8004209631:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004209635:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004209638:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420963c:	f0 87 02             	lock xchg %eax,(%rdx)
  800420963f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return result;
  8004209642:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004209645:	c9                   	leaveq 
  8004209646:	c3                   	retq   

0000008004209647 <lock_kernel>:
{
  8004209647:	55                   	push   %rbp
  8004209648:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800420964b:	48 bf c0 87 22 04 80 	movabs $0x80042287c0,%rdi
  8004209652:	00 00 00 
  8004209655:	48 b8 84 37 21 04 80 	movabs $0x8004213784,%rax
  800420965c:	00 00 00 
  800420965f:	ff d0                	callq  *%rax
}
  8004209661:	5d                   	pop    %rbp
  8004209662:	c3                   	retq   

0000008004209663 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209663:	55                   	push   %rbp
  8004209664:	48 89 e5             	mov    %rsp,%rbp
  8004209667:	48 83 ec 08          	sub    $0x8,%rsp
  800420966b:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  800420966e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209671:	83 f8 13             	cmp    $0x13,%eax
  8004209674:	77 16                	ja     800420968c <trapname+0x29>
		return excnames[trapno];
  8004209676:	48 b8 80 5f 21 04 80 	movabs $0x8004215f80,%rax
  800420967d:	00 00 00 
  8004209680:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209683:	48 63 d2             	movslq %edx,%rdx
  8004209686:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420968a:	eb 34                	jmp    80042096c0 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  800420968c:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004209690:	75 0c                	jne    800420969e <trapname+0x3b>
		return "System call";
  8004209692:	48 b8 80 5b 21 04 80 	movabs $0x8004215b80,%rax
  8004209699:	00 00 00 
  800420969c:	eb 22                	jmp    80042096c0 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  800420969e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80042096a2:	7e 12                	jle    80042096b6 <trapname+0x53>
  80042096a4:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  80042096a8:	7f 0c                	jg     80042096b6 <trapname+0x53>
		return "Hardware Interrupt";
  80042096aa:	48 b8 8c 5b 21 04 80 	movabs $0x8004215b8c,%rax
  80042096b1:	00 00 00 
  80042096b4:	eb 0a                	jmp    80042096c0 <trapname+0x5d>
	return "(unknown trap)";
  80042096b6:	48 b8 9f 5b 21 04 80 	movabs $0x8004215b9f,%rax
  80042096bd:	00 00 00 
}
  80042096c0:	c9                   	leaveq 
  80042096c1:	c3                   	retq   

00000080042096c2 <trap_init>:


void
trap_init(void)
{
  80042096c2:	55                   	push   %rbp
  80042096c3:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
	idt_pd.pd_lim = sizeof(idt)-1;
  80042096c6:	48 b8 c0 c2 57 04 80 	movabs $0x800457c2c0,%rax
  80042096cd:	00 00 00 
  80042096d0:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  80042096d5:	48 ba c0 b2 57 04 80 	movabs $0x800457b2c0,%rdx
  80042096dc:	00 00 00 
  80042096df:	48 b8 c0 c2 57 04 80 	movabs $0x800457c2c0,%rax
  80042096e6:	00 00 00 
  80042096e9:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  80042096ed:	48 b8 fb 96 20 04 80 	movabs $0x80042096fb,%rax
  80042096f4:	00 00 00 
  80042096f7:	ff d0                	callq  *%rax
}
  80042096f9:	5d                   	pop    %rbp
  80042096fa:	c3                   	retq   

00000080042096fb <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  80042096fb:	55                   	push   %rbp
  80042096fc:	48 89 e5             	mov    %rsp,%rbp
  80042096ff:	48 83 ec 10          	sub    $0x10,%rsp
	// LAB 4: Your code here:


	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	ts.ts_esp0 = KSTACKTOP;
  8004209703:	48 b8 00 c8 57 04 80 	movabs $0x800457c800,%rax
  800420970a:	00 00 00 
  800420970d:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  8004209714:	00 00 00 
  8004209717:	48 89 48 04          	mov    %rcx,0x4(%rax)

	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40),STS_T64A, (uint64_t) (&ts),sizeof(struct Taskstate), 0);
  800420971b:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  8004209722:	00 00 00 
  8004209725:	48 8b 00             	mov    (%rax),%rax
  8004209728:	48 c1 f8 10          	sar    $0x10,%rax
  800420972c:	48 83 c0 28          	add    $0x28,%rax
  8004209730:	66 c7 00 68 00       	movw   $0x68,(%rax)
  8004209735:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  800420973c:	00 00 00 
  800420973f:	48 8b 00             	mov    (%rax),%rax
  8004209742:	48 c1 f8 10          	sar    $0x10,%rax
  8004209746:	48 83 c0 28          	add    $0x28,%rax
  800420974a:	48 89 c2             	mov    %rax,%rdx
  800420974d:	48 b8 00 c8 57 04 80 	movabs $0x800457c800,%rax
  8004209754:	00 00 00 
  8004209757:	66 89 42 02          	mov    %ax,0x2(%rdx)
  800420975b:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  8004209762:	00 00 00 
  8004209765:	48 8b 00             	mov    (%rax),%rax
  8004209768:	48 c1 f8 10          	sar    $0x10,%rax
  800420976c:	48 83 c0 28          	add    $0x28,%rax
  8004209770:	48 89 c2             	mov    %rax,%rdx
  8004209773:	48 b8 00 c8 57 04 80 	movabs $0x800457c800,%rax
  800420977a:	00 00 00 
  800420977d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209781:	88 42 04             	mov    %al,0x4(%rdx)
  8004209784:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  800420978b:	00 00 00 
  800420978e:	48 8b 00             	mov    (%rax),%rax
  8004209791:	48 c1 f8 10          	sar    $0x10,%rax
  8004209795:	48 83 c0 28          	add    $0x28,%rax
  8004209799:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420979d:	83 e2 f0             	and    $0xfffffff0,%edx
  80042097a0:	83 ca 09             	or     $0x9,%edx
  80042097a3:	88 50 05             	mov    %dl,0x5(%rax)
  80042097a6:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  80042097ad:	00 00 00 
  80042097b0:	48 8b 00             	mov    (%rax),%rax
  80042097b3:	48 c1 f8 10          	sar    $0x10,%rax
  80042097b7:	48 83 c0 28          	add    $0x28,%rax
  80042097bb:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097bf:	83 e2 ef             	and    $0xffffffef,%edx
  80042097c2:	88 50 05             	mov    %dl,0x5(%rax)
  80042097c5:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  80042097cc:	00 00 00 
  80042097cf:	48 8b 00             	mov    (%rax),%rax
  80042097d2:	48 c1 f8 10          	sar    $0x10,%rax
  80042097d6:	48 83 c0 28          	add    $0x28,%rax
  80042097da:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097de:	83 e2 9f             	and    $0xffffff9f,%edx
  80042097e1:	88 50 05             	mov    %dl,0x5(%rax)
  80042097e4:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  80042097eb:	00 00 00 
  80042097ee:	48 8b 00             	mov    (%rax),%rax
  80042097f1:	48 c1 f8 10          	sar    $0x10,%rax
  80042097f5:	48 83 c0 28          	add    $0x28,%rax
  80042097f9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097fd:	83 ca 80             	or     $0xffffff80,%edx
  8004209800:	88 50 05             	mov    %dl,0x5(%rax)
  8004209803:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  800420980a:	00 00 00 
  800420980d:	48 8b 00             	mov    (%rax),%rax
  8004209810:	48 c1 f8 10          	sar    $0x10,%rax
  8004209814:	48 83 c0 28          	add    $0x28,%rax
  8004209818:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420981c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420981f:	88 50 06             	mov    %dl,0x6(%rax)
  8004209822:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  8004209829:	00 00 00 
  800420982c:	48 8b 00             	mov    (%rax),%rax
  800420982f:	48 c1 f8 10          	sar    $0x10,%rax
  8004209833:	48 83 c0 28          	add    $0x28,%rax
  8004209837:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420983b:	83 e2 ef             	and    $0xffffffef,%edx
  800420983e:	88 50 06             	mov    %dl,0x6(%rax)
  8004209841:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  8004209848:	00 00 00 
  800420984b:	48 8b 00             	mov    (%rax),%rax
  800420984e:	48 c1 f8 10          	sar    $0x10,%rax
  8004209852:	48 83 c0 28          	add    $0x28,%rax
  8004209856:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420985a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420985d:	88 50 06             	mov    %dl,0x6(%rax)
  8004209860:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  8004209867:	00 00 00 
  800420986a:	48 8b 00             	mov    (%rax),%rax
  800420986d:	48 c1 f8 10          	sar    $0x10,%rax
  8004209871:	48 83 c0 28          	add    $0x28,%rax
  8004209875:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  8004209879:	83 e2 7f             	and    $0x7f,%edx
  800420987c:	88 50 06             	mov    %dl,0x6(%rax)
  800420987f:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  8004209886:	00 00 00 
  8004209889:	48 8b 00             	mov    (%rax),%rax
  800420988c:	48 c1 f8 10          	sar    $0x10,%rax
  8004209890:	48 83 c0 28          	add    $0x28,%rax
  8004209894:	48 89 c2             	mov    %rax,%rdx
  8004209897:	48 b8 00 c8 57 04 80 	movabs $0x800457c800,%rax
  800420989e:	00 00 00 
  80042098a1:	48 c1 e8 18          	shr    $0x18,%rax
  80042098a5:	88 42 07             	mov    %al,0x7(%rdx)
  80042098a8:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  80042098af:	00 00 00 
  80042098b2:	48 8b 00             	mov    (%rax),%rax
  80042098b5:	48 c1 f8 10          	sar    $0x10,%rax
  80042098b9:	48 83 c0 28          	add    $0x28,%rax
  80042098bd:	48 89 c2             	mov    %rax,%rdx
  80042098c0:	48 b8 00 c8 57 04 80 	movabs $0x800457c800,%rax
  80042098c7:	00 00 00 
  80042098ca:	48 c1 e8 20          	shr    $0x20,%rax
  80042098ce:	89 42 08             	mov    %eax,0x8(%rdx)
  80042098d1:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  80042098d8:	00 00 00 
  80042098db:	48 8b 00             	mov    (%rax),%rax
  80042098de:	48 c1 f8 10          	sar    $0x10,%rax
  80042098e2:	48 83 c0 28          	add    $0x28,%rax
  80042098e6:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  80042098ea:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  80042098f1:	00 00 00 
  80042098f4:	48 8b 00             	mov    (%rax),%rax
  80042098f7:	48 c1 f8 10          	sar    $0x10,%rax
  80042098fb:	48 83 c0 28          	add    $0x28,%rax
  80042098ff:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  8004209903:	48 b8 a8 86 22 04 80 	movabs $0x80042286a8,%rax
  800420990a:	00 00 00 
  800420990d:	48 8b 00             	mov    (%rax),%rax
  8004209910:	48 c1 f8 10          	sar    $0x10,%rax
  8004209914:	48 83 c0 28          	add    $0x28,%rax
  8004209918:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
  800420991e:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%rbp)
	__asm __volatile("ltr %0" : : "r" (sel));
  8004209924:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8004209928:	0f 00 d8             	ltr    %ax
  800420992b:	48 b8 c0 c2 57 04 80 	movabs $0x800457c2c0,%rax
  8004209932:	00 00 00 
  8004209935:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	__asm __volatile("lidt (%0)" : : "r" (p));
  8004209939:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420993d:	0f 01 18             	lidt   (%rax)
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0);

	// Load the IDT
	lidt(&idt_pd);
}
  8004209940:	c9                   	leaveq 
  8004209941:	c3                   	retq   

0000008004209942 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  8004209942:	55                   	push   %rbp
  8004209943:	48 89 e5             	mov    %rsp,%rbp
  8004209946:	48 83 ec 20          	sub    $0x20,%rsp
  800420994a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420994e:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004209955:	00 00 00 
  8004209958:	ff d0                	callq  *%rax
  800420995a:	89 c2                	mov    %eax,%edx
  800420995c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209960:	48 89 c6             	mov    %rax,%rsi
  8004209963:	48 bf ae 5b 21 04 80 	movabs $0x8004215bae,%rdi
  800420996a:	00 00 00 
  800420996d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209972:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  8004209979:	00 00 00 
  800420997c:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420997e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209982:	48 89 c7             	mov    %rax,%rdi
  8004209985:	48 b8 53 9c 20 04 80 	movabs $0x8004209c53,%rax
  800420998c:	00 00 00 
  800420998f:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  8004209991:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209995:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  8004209999:	0f b7 c0             	movzwl %ax,%eax
  800420999c:	89 c6                	mov    %eax,%esi
  800420999e:	48 bf cc 5b 21 04 80 	movabs $0x8004215bcc,%rdi
  80042099a5:	00 00 00 
  80042099a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042099ad:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042099b4:	00 00 00 
  80042099b7:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  80042099b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042099bd:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  80042099c4:	0f b7 c0             	movzwl %ax,%eax
  80042099c7:	89 c6                	mov    %eax,%esi
  80042099c9:	48 bf df 5b 21 04 80 	movabs $0x8004215bdf,%rdi
  80042099d0:	00 00 00 
  80042099d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042099d8:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  80042099df:	00 00 00 
  80042099e2:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  80042099e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042099e8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042099ef:	89 c7                	mov    %eax,%edi
  80042099f1:	48 b8 63 96 20 04 80 	movabs $0x8004209663,%rax
  80042099f8:	00 00 00 
  80042099fb:	ff d0                	callq  *%rax
  80042099fd:	48 89 c2             	mov    %rax,%rdx
  8004209a00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209a04:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004209a0b:	48 89 c6             	mov    %rax,%rsi
  8004209a0e:	48 bf f2 5b 21 04 80 	movabs $0x8004215bf2,%rdi
  8004209a15:	00 00 00 
  8004209a18:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209a1d:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  8004209a24:	00 00 00 
  8004209a27:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  8004209a29:	48 b8 d0 c2 57 04 80 	movabs $0x800457c2d0,%rax
  8004209a30:	00 00 00 
  8004209a33:	48 8b 00             	mov    (%rax),%rax
  8004209a36:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004209a3a:	75 3a                	jne    8004209a76 <print_trapframe+0x134>
  8004209a3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209a40:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004209a47:	48 83 f8 0e          	cmp    $0xe,%rax
  8004209a4b:	75 29                	jne    8004209a76 <print_trapframe+0x134>
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  8004209a4d:	0f 20 d0             	mov    %cr2,%rax
  8004209a50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  8004209a54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  8004209a58:	48 89 c6             	mov    %rax,%rsi
  8004209a5b:	48 bf 04 5c 21 04 80 	movabs $0x8004215c04,%rdi
  8004209a62:	00 00 00 
  8004209a65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209a6a:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209a71:	00 00 00 
  8004209a74:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  8004209a76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209a7a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8004209a81:	48 89 c6             	mov    %rax,%rsi
  8004209a84:	48 bf 13 5c 21 04 80 	movabs $0x8004215c13,%rdi
  8004209a8b:	00 00 00 
  8004209a8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209a93:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209a9a:	00 00 00 
  8004209a9d:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  8004209a9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209aa3:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004209aaa:	48 83 f8 0e          	cmp    $0xe,%rax
  8004209aae:	0f 85 9c 00 00 00    	jne    8004209b50 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  8004209ab4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209ab8:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8004209abf:	83 e0 01             	and    $0x1,%eax
		cprintf(" [%s, %s, %s]\n",
  8004209ac2:	48 85 c0             	test   %rax,%rax
  8004209ac5:	74 0c                	je     8004209ad3 <print_trapframe+0x191>
  8004209ac7:	48 b9 21 5c 21 04 80 	movabs $0x8004215c21,%rcx
  8004209ace:	00 00 00 
  8004209ad1:	eb 0a                	jmp    8004209add <print_trapframe+0x19b>
  8004209ad3:	48 b9 2c 5c 21 04 80 	movabs $0x8004215c2c,%rcx
  8004209ada:	00 00 00 
			tf->tf_err & 2 ? "write" : "read",
  8004209add:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209ae1:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8004209ae8:	83 e0 02             	and    $0x2,%eax
		cprintf(" [%s, %s, %s]\n",
  8004209aeb:	48 85 c0             	test   %rax,%rax
  8004209aee:	74 0c                	je     8004209afc <print_trapframe+0x1ba>
  8004209af0:	48 ba 38 5c 21 04 80 	movabs $0x8004215c38,%rdx
  8004209af7:	00 00 00 
  8004209afa:	eb 0a                	jmp    8004209b06 <print_trapframe+0x1c4>
  8004209afc:	48 ba 3e 5c 21 04 80 	movabs $0x8004215c3e,%rdx
  8004209b03:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  8004209b06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209b0a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8004209b11:	83 e0 04             	and    $0x4,%eax
		cprintf(" [%s, %s, %s]\n",
  8004209b14:	48 85 c0             	test   %rax,%rax
  8004209b17:	74 0c                	je     8004209b25 <print_trapframe+0x1e3>
  8004209b19:	48 b8 43 5c 21 04 80 	movabs $0x8004215c43,%rax
  8004209b20:	00 00 00 
  8004209b23:	eb 0a                	jmp    8004209b2f <print_trapframe+0x1ed>
  8004209b25:	48 b8 48 5c 21 04 80 	movabs $0x8004215c48,%rax
  8004209b2c:	00 00 00 
  8004209b2f:	48 89 c6             	mov    %rax,%rsi
  8004209b32:	48 bf 4f 5c 21 04 80 	movabs $0x8004215c4f,%rdi
  8004209b39:	00 00 00 
  8004209b3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209b41:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  8004209b48:	00 00 00 
  8004209b4b:	41 ff d0             	callq  *%r8
  8004209b4e:	eb 1b                	jmp    8004209b6b <print_trapframe+0x229>
	else
		cprintf("\n");
  8004209b50:	48 bf 5e 5c 21 04 80 	movabs $0x8004215c5e,%rdi
  8004209b57:	00 00 00 
  8004209b5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209b5f:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209b66:	00 00 00 
  8004209b69:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  8004209b6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209b6f:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8004209b76:	48 89 c6             	mov    %rax,%rsi
  8004209b79:	48 bf 60 5c 21 04 80 	movabs $0x8004215c60,%rdi
  8004209b80:	00 00 00 
  8004209b83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209b88:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209b8f:	00 00 00 
  8004209b92:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  8004209b94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209b98:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209b9f:	0f b7 c0             	movzwl %ax,%eax
  8004209ba2:	89 c6                	mov    %eax,%esi
  8004209ba4:	48 bf 6f 5c 21 04 80 	movabs $0x8004215c6f,%rdi
  8004209bab:	00 00 00 
  8004209bae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209bb3:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209bba:	00 00 00 
  8004209bbd:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  8004209bbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209bc3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004209bca:	48 89 c6             	mov    %rax,%rsi
  8004209bcd:	48 bf 82 5c 21 04 80 	movabs $0x8004215c82,%rdi
  8004209bd4:	00 00 00 
  8004209bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209bdc:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209be3:	00 00 00 
  8004209be6:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  8004209be8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209bec:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209bf3:	0f b7 c0             	movzwl %ax,%eax
  8004209bf6:	83 e0 03             	and    $0x3,%eax
  8004209bf9:	85 c0                	test   %eax,%eax
  8004209bfb:	74 54                	je     8004209c51 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  8004209bfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209c01:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  8004209c08:	48 89 c6             	mov    %rax,%rsi
  8004209c0b:	48 bf 91 5c 21 04 80 	movabs $0x8004215c91,%rdi
  8004209c12:	00 00 00 
  8004209c15:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c1a:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209c21:	00 00 00 
  8004209c24:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  8004209c26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209c2a:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  8004209c31:	0f b7 c0             	movzwl %ax,%eax
  8004209c34:	89 c6                	mov    %eax,%esi
  8004209c36:	48 bf a0 5c 21 04 80 	movabs $0x8004215ca0,%rdi
  8004209c3d:	00 00 00 
  8004209c40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c45:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209c4c:	00 00 00 
  8004209c4f:	ff d2                	callq  *%rdx
	}
}
  8004209c51:	c9                   	leaveq 
  8004209c52:	c3                   	retq   

0000008004209c53 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  8004209c53:	55                   	push   %rbp
  8004209c54:	48 89 e5             	mov    %rsp,%rbp
  8004209c57:	48 83 ec 10          	sub    $0x10,%rsp
  8004209c5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  8004209c5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209c63:	48 8b 00             	mov    (%rax),%rax
  8004209c66:	48 89 c6             	mov    %rax,%rsi
  8004209c69:	48 bf b3 5c 21 04 80 	movabs $0x8004215cb3,%rdi
  8004209c70:	00 00 00 
  8004209c73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c78:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209c7f:	00 00 00 
  8004209c82:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  8004209c84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209c88:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004209c8c:	48 89 c6             	mov    %rax,%rsi
  8004209c8f:	48 bf c2 5c 21 04 80 	movabs $0x8004215cc2,%rdi
  8004209c96:	00 00 00 
  8004209c99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c9e:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209ca5:	00 00 00 
  8004209ca8:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  8004209caa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209cae:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004209cb2:	48 89 c6             	mov    %rax,%rsi
  8004209cb5:	48 bf d1 5c 21 04 80 	movabs $0x8004215cd1,%rdi
  8004209cbc:	00 00 00 
  8004209cbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209cc4:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209ccb:	00 00 00 
  8004209cce:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  8004209cd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209cd4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004209cd8:	48 89 c6             	mov    %rax,%rsi
  8004209cdb:	48 bf e0 5c 21 04 80 	movabs $0x8004215ce0,%rdi
  8004209ce2:	00 00 00 
  8004209ce5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209cea:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209cf1:	00 00 00 
  8004209cf4:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  8004209cf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209cfa:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004209cfe:	48 89 c6             	mov    %rax,%rsi
  8004209d01:	48 bf ef 5c 21 04 80 	movabs $0x8004215cef,%rdi
  8004209d08:	00 00 00 
  8004209d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209d10:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209d17:	00 00 00 
  8004209d1a:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  8004209d1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209d20:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004209d24:	48 89 c6             	mov    %rax,%rsi
  8004209d27:	48 bf fe 5c 21 04 80 	movabs $0x8004215cfe,%rdi
  8004209d2e:	00 00 00 
  8004209d31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209d36:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209d3d:	00 00 00 
  8004209d40:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  8004209d42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209d46:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004209d4a:	48 89 c6             	mov    %rax,%rsi
  8004209d4d:	48 bf 0d 5d 21 04 80 	movabs $0x8004215d0d,%rdi
  8004209d54:	00 00 00 
  8004209d57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209d5c:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209d63:	00 00 00 
  8004209d66:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  8004209d68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209d6c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004209d70:	48 89 c6             	mov    %rax,%rsi
  8004209d73:	48 bf 1b 5d 21 04 80 	movabs $0x8004215d1b,%rdi
  8004209d7a:	00 00 00 
  8004209d7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209d82:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209d89:	00 00 00 
  8004209d8c:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  8004209d8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209d92:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004209d96:	48 89 c6             	mov    %rax,%rsi
  8004209d99:	48 bf 29 5d 21 04 80 	movabs $0x8004215d29,%rdi
  8004209da0:	00 00 00 
  8004209da3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209da8:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209daf:	00 00 00 
  8004209db2:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  8004209db4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209db8:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004209dbc:	48 89 c6             	mov    %rax,%rsi
  8004209dbf:	48 bf 38 5d 21 04 80 	movabs $0x8004215d38,%rdi
  8004209dc6:	00 00 00 
  8004209dc9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209dce:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209dd5:	00 00 00 
  8004209dd8:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  8004209dda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209dde:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004209de2:	48 89 c6             	mov    %rax,%rsi
  8004209de5:	48 bf 47 5d 21 04 80 	movabs $0x8004215d47,%rdi
  8004209dec:	00 00 00 
  8004209def:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209df4:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209dfb:	00 00 00 
  8004209dfe:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  8004209e00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209e04:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004209e08:	48 89 c6             	mov    %rax,%rsi
  8004209e0b:	48 bf 56 5d 21 04 80 	movabs $0x8004215d56,%rdi
  8004209e12:	00 00 00 
  8004209e15:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209e1a:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209e21:	00 00 00 
  8004209e24:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  8004209e26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209e2a:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004209e2e:	48 89 c6             	mov    %rax,%rsi
  8004209e31:	48 bf 65 5d 21 04 80 	movabs $0x8004215d65,%rdi
  8004209e38:	00 00 00 
  8004209e3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209e40:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209e47:	00 00 00 
  8004209e4a:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  8004209e4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209e50:	48 8b 40 60          	mov    0x60(%rax),%rax
  8004209e54:	48 89 c6             	mov    %rax,%rsi
  8004209e57:	48 bf 74 5d 21 04 80 	movabs $0x8004215d74,%rdi
  8004209e5e:	00 00 00 
  8004209e61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209e66:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209e6d:	00 00 00 
  8004209e70:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  8004209e72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209e76:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004209e7a:	48 89 c6             	mov    %rax,%rsi
  8004209e7d:	48 bf 83 5d 21 04 80 	movabs $0x8004215d83,%rdi
  8004209e84:	00 00 00 
  8004209e87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209e8c:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209e93:	00 00 00 
  8004209e96:	ff d2                	callq  *%rdx
}
  8004209e98:	c9                   	leaveq 
  8004209e99:	c3                   	retq   

0000008004209e9a <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  8004209e9a:	55                   	push   %rbp
  8004209e9b:	48 89 e5             	mov    %rsp,%rbp
  8004209e9e:	48 83 ec 10          	sub    $0x10,%rsp
  8004209ea2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 3: Your code here.

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  8004209ea6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209eaa:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004209eb1:	48 83 f8 27          	cmp    $0x27,%rax
  8004209eb5:	75 33                	jne    8004209eea <trap_dispatch+0x50>
		cprintf("Spurious interrupt on irq 7\n");
  8004209eb7:	48 bf 92 5d 21 04 80 	movabs $0x8004215d92,%rdi
  8004209ebe:	00 00 00 
  8004209ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209ec6:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004209ecd:	00 00 00 
  8004209ed0:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  8004209ed2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209ed6:	48 89 c7             	mov    %rax,%rdi
  8004209ed9:	48 b8 42 99 20 04 80 	movabs $0x8004209942,%rax
  8004209ee0:	00 00 00 
  8004209ee3:	ff d0                	callq  *%rax
		return;
  8004209ee5:	e9 8b 00 00 00       	jmpq   8004209f75 <trap_dispatch+0xdb>

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  8004209eea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209eee:	48 89 c7             	mov    %rax,%rdi
  8004209ef1:	48 b8 42 99 20 04 80 	movabs $0x8004209942,%rax
  8004209ef8:	00 00 00 
  8004209efb:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  8004209efd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209f01:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209f08:	66 83 f8 08          	cmp    $0x8,%ax
  8004209f0c:	75 2a                	jne    8004209f38 <trap_dispatch+0x9e>
		panic("unhandled trap in kernel");
  8004209f0e:	48 ba af 5d 21 04 80 	movabs $0x8004215daf,%rdx
  8004209f15:	00 00 00 
  8004209f18:	be d2 00 00 00       	mov    $0xd2,%esi
  8004209f1d:	48 bf c8 5d 21 04 80 	movabs $0x8004215dc8,%rdi
  8004209f24:	00 00 00 
  8004209f27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209f2c:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004209f33:	00 00 00 
  8004209f36:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  8004209f38:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004209f3f:	00 00 00 
  8004209f42:	ff d0                	callq  *%rax
  8004209f44:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004209f4b:	00 00 00 
  8004209f4e:	48 98                	cltq   
  8004209f50:	48 c1 e0 03          	shl    $0x3,%rax
  8004209f54:	48 89 c1             	mov    %rax,%rcx
  8004209f57:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209f5b:	48 01 c8             	add    %rcx,%rax
  8004209f5e:	48 01 d0             	add    %rdx,%rax
  8004209f61:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004209f65:	48 89 c7             	mov    %rax,%rdi
  8004209f68:	48 b8 4d 8e 20 04 80 	movabs $0x8004208e4d,%rax
  8004209f6f:	00 00 00 
  8004209f72:	ff d0                	callq  *%rax
		return;
  8004209f74:	90                   	nop
	}
}
  8004209f75:	c9                   	leaveq 
  8004209f76:	c3                   	retq   

0000008004209f77 <trap>:

void
trap(struct Trapframe *tf)
{
  8004209f77:	55                   	push   %rbp
  8004209f78:	48 89 e5             	mov    %rsp,%rbp
  8004209f7b:	48 83 ec 20          	sub    $0x20,%rsp
  8004209f7f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  8004209f83:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  8004209f84:	48 b8 b0 c7 57 04 80 	movabs $0x800457c7b0,%rax
  8004209f8b:	00 00 00 
  8004209f8e:	48 8b 00             	mov    (%rax),%rax
  8004209f91:	48 85 c0             	test   %rax,%rax
  8004209f94:	74 01                	je     8004209f97 <trap+0x20>
		asm volatile("hlt");
  8004209f96:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  8004209f97:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004209f9e:	00 00 00 
  8004209fa1:	ff d0                	callq  *%rax
  8004209fa3:	48 98                	cltq   
  8004209fa5:	48 c1 e0 03          	shl    $0x3,%rax
  8004209fa9:	48 89 c2             	mov    %rax,%rdx
  8004209fac:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209fb0:	48 01 d0             	add    %rdx,%rax
  8004209fb3:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004209fba:	00 00 00 
  8004209fbd:	48 01 d0             	add    %rdx,%rax
  8004209fc0:	48 83 c0 04          	add    $0x4,%rax
  8004209fc4:	be 01 00 00 00       	mov    $0x1,%esi
  8004209fc9:	48 89 c7             	mov    %rax,%rdi
  8004209fcc:	48 b8 22 96 20 04 80 	movabs $0x8004209622,%rax
  8004209fd3:	00 00 00 
  8004209fd6:	ff d0                	callq  *%rax
  8004209fd8:	83 f8 02             	cmp    $0x2,%eax
  8004209fdb:	75 0c                	jne    8004209fe9 <trap+0x72>
		lock_kernel();
  8004209fdd:	48 b8 47 96 20 04 80 	movabs $0x8004209647,%rax
  8004209fe4:	00 00 00 
  8004209fe7:	ff d0                	callq  *%rax
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  8004209fe9:	9c                   	pushfq 
  8004209fea:	58                   	pop    %rax
  8004209feb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  8004209fef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  8004209ff3:	25 00 02 00 00       	and    $0x200,%eax
  8004209ff8:	48 85 c0             	test   %rax,%rax
  8004209ffb:	74 35                	je     800420a032 <trap+0xbb>
  8004209ffd:	48 b9 d4 5d 21 04 80 	movabs $0x8004215dd4,%rcx
  800420a004:	00 00 00 
  800420a007:	48 ba ed 5d 21 04 80 	movabs $0x8004215ded,%rdx
  800420a00e:	00 00 00 
  800420a011:	be ed 00 00 00       	mov    $0xed,%esi
  800420a016:	48 bf c8 5d 21 04 80 	movabs $0x8004215dc8,%rdi
  800420a01d:	00 00 00 
  800420a020:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a025:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420a02c:	00 00 00 
  800420a02f:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420a032:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a036:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420a03d:	0f b7 c0             	movzwl %ax,%eax
  800420a040:	83 e0 03             	and    $0x3,%eax
  800420a043:	83 f8 03             	cmp    $0x3,%eax
  800420a046:	0f 85 8b 01 00 00    	jne    800420a1d7 <trap+0x260>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		assert(curenv);
  800420a04c:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a053:	00 00 00 
  800420a056:	ff d0                	callq  *%rax
  800420a058:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a05f:	00 00 00 
  800420a062:	48 98                	cltq   
  800420a064:	48 c1 e0 03          	shl    $0x3,%rax
  800420a068:	48 89 c1             	mov    %rax,%rcx
  800420a06b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a06f:	48 01 c8             	add    %rcx,%rax
  800420a072:	48 01 d0             	add    %rdx,%rax
  800420a075:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a079:	48 85 c0             	test   %rax,%rax
  800420a07c:	75 35                	jne    800420a0b3 <trap+0x13c>
  800420a07e:	48 b9 02 5e 21 04 80 	movabs $0x8004215e02,%rcx
  800420a085:	00 00 00 
  800420a088:	48 ba ed 5d 21 04 80 	movabs $0x8004215ded,%rdx
  800420a08f:	00 00 00 
  800420a092:	be f4 00 00 00       	mov    $0xf4,%esi
  800420a097:	48 bf c8 5d 21 04 80 	movabs $0x8004215dc8,%rdi
  800420a09e:	00 00 00 
  800420a0a1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a0a6:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420a0ad:	00 00 00 
  800420a0b0:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420a0b3:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a0ba:	00 00 00 
  800420a0bd:	ff d0                	callq  *%rax
  800420a0bf:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a0c6:	00 00 00 
  800420a0c9:	48 98                	cltq   
  800420a0cb:	48 c1 e0 03          	shl    $0x3,%rax
  800420a0cf:	48 89 c1             	mov    %rax,%rcx
  800420a0d2:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a0d6:	48 01 c8             	add    %rcx,%rax
  800420a0d9:	48 01 d0             	add    %rdx,%rax
  800420a0dc:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a0e0:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420a0e6:	83 f8 01             	cmp    $0x1,%eax
  800420a0e9:	75 79                	jne    800420a164 <trap+0x1ed>
			env_free(curenv);
  800420a0eb:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a0f2:	00 00 00 
  800420a0f5:	ff d0                	callq  *%rax
  800420a0f7:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a0fe:	00 00 00 
  800420a101:	48 98                	cltq   
  800420a103:	48 c1 e0 03          	shl    $0x3,%rax
  800420a107:	48 89 c1             	mov    %rax,%rcx
  800420a10a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a10e:	48 01 c8             	add    %rcx,%rax
  800420a111:	48 01 d0             	add    %rdx,%rax
  800420a114:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a118:	48 89 c7             	mov    %rax,%rdi
  800420a11b:	48 b8 a7 89 20 04 80 	movabs $0x80042089a7,%rax
  800420a122:	00 00 00 
  800420a125:	ff d0                	callq  *%rax
			curenv = NULL;
  800420a127:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a12e:	00 00 00 
  800420a131:	ff d0                	callq  *%rax
  800420a133:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a13a:	00 00 00 
  800420a13d:	48 98                	cltq   
  800420a13f:	48 c1 e0 03          	shl    $0x3,%rax
  800420a143:	48 89 c1             	mov    %rax,%rcx
  800420a146:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a14a:	48 01 c8             	add    %rcx,%rax
  800420a14d:	48 01 d0             	add    %rdx,%rax
  800420a150:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800420a157:	00 
			sched_yield();
  800420a158:	48 b8 c5 a3 20 04 80 	movabs $0x800420a3c5,%rax
  800420a15f:	00 00 00 
  800420a162:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420a164:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a16b:	00 00 00 
  800420a16e:	ff d0                	callq  *%rax
  800420a170:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a177:	00 00 00 
  800420a17a:	48 98                	cltq   
  800420a17c:	48 c1 e0 03          	shl    $0x3,%rax
  800420a180:	48 89 c1             	mov    %rax,%rcx
  800420a183:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a187:	48 01 c8             	add    %rcx,%rax
  800420a18a:	48 01 d0             	add    %rdx,%rax
  800420a18d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420a191:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a195:	48 89 c6             	mov    %rax,%rsi
  800420a198:	b8 18 00 00 00       	mov    $0x18,%eax
  800420a19d:	48 89 d7             	mov    %rdx,%rdi
  800420a1a0:	48 89 c1             	mov    %rax,%rcx
  800420a1a3:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420a1a6:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a1ad:	00 00 00 
  800420a1b0:	ff d0                	callq  *%rax
  800420a1b2:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a1b9:	00 00 00 
  800420a1bc:	48 98                	cltq   
  800420a1be:	48 c1 e0 03          	shl    $0x3,%rax
  800420a1c2:	48 89 c1             	mov    %rax,%rcx
  800420a1c5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a1c9:	48 01 c8             	add    %rcx,%rax
  800420a1cc:	48 01 d0             	add    %rdx,%rax
  800420a1cf:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a1d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420a1d7:	48 b8 d0 c2 57 04 80 	movabs $0x800457c2d0,%rax
  800420a1de:	00 00 00 
  800420a1e1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420a1e5:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420a1e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a1ec:	48 89 c7             	mov    %rax,%rdi
  800420a1ef:	48 b8 9a 9e 20 04 80 	movabs $0x8004209e9a,%rax
  800420a1f6:	00 00 00 
  800420a1f9:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420a1fb:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a202:	00 00 00 
  800420a205:	ff d0                	callq  *%rax
  800420a207:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a20e:	00 00 00 
  800420a211:	48 98                	cltq   
  800420a213:	48 c1 e0 03          	shl    $0x3,%rax
  800420a217:	48 89 c1             	mov    %rax,%rcx
  800420a21a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a21e:	48 01 c8             	add    %rcx,%rax
  800420a221:	48 01 d0             	add    %rdx,%rax
  800420a224:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a228:	48 85 c0             	test   %rax,%rax
  800420a22b:	74 74                	je     800420a2a1 <trap+0x32a>
  800420a22d:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a234:	00 00 00 
  800420a237:	ff d0                	callq  *%rax
  800420a239:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a240:	00 00 00 
  800420a243:	48 98                	cltq   
  800420a245:	48 c1 e0 03          	shl    $0x3,%rax
  800420a249:	48 89 c1             	mov    %rax,%rcx
  800420a24c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a250:	48 01 c8             	add    %rcx,%rax
  800420a253:	48 01 d0             	add    %rdx,%rax
  800420a256:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a25a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420a260:	83 f8 03             	cmp    $0x3,%eax
  800420a263:	75 3c                	jne    800420a2a1 <trap+0x32a>
		env_run(curenv);
  800420a265:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a26c:	00 00 00 
  800420a26f:	ff d0                	callq  *%rax
  800420a271:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a278:	00 00 00 
  800420a27b:	48 98                	cltq   
  800420a27d:	48 c1 e0 03          	shl    $0x3,%rax
  800420a281:	48 89 c1             	mov    %rax,%rcx
  800420a284:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a288:	48 01 c8             	add    %rcx,%rax
  800420a28b:	48 01 d0             	add    %rdx,%rax
  800420a28e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a292:	48 89 c7             	mov    %rax,%rdi
  800420a295:	48 b8 0c 90 20 04 80 	movabs $0x800420900c,%rax
  800420a29c:	00 00 00 
  800420a29f:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420a2a1:	48 b8 c5 a3 20 04 80 	movabs $0x800420a3c5,%rax
  800420a2a8:	00 00 00 
  800420a2ab:	ff d0                	callq  *%rax

000000800420a2ad <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420a2ad:	55                   	push   %rbp
  800420a2ae:	48 89 e5             	mov    %rsp,%rbp
  800420a2b1:	53                   	push   %rbx
  800420a2b2:	48 83 ec 28          	sub    $0x28,%rsp
  800420a2b6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420a2ba:	0f 20 d0             	mov    %cr2,%rax
  800420a2bd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	return val;
  800420a2c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420a2c5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420a2c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420a2cd:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
		curenv->env_id, fault_va, tf->tf_rip);
  800420a2d4:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a2db:	00 00 00 
  800420a2de:	ff d0                	callq  *%rax
  800420a2e0:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a2e7:	00 00 00 
  800420a2ea:	48 98                	cltq   
  800420a2ec:	48 c1 e0 03          	shl    $0x3,%rax
  800420a2f0:	48 89 c1             	mov    %rax,%rcx
  800420a2f3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a2f7:	48 01 c8             	add    %rcx,%rax
  800420a2fa:	48 01 d0             	add    %rdx,%rax
  800420a2fd:	48 8b 40 08          	mov    0x8(%rax),%rax
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420a301:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420a307:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420a30b:	48 89 d9             	mov    %rbx,%rcx
  800420a30e:	89 c6                	mov    %eax,%esi
  800420a310:	48 bf 10 5e 21 04 80 	movabs $0x8004215e10,%rdi
  800420a317:	00 00 00 
  800420a31a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a31f:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  800420a326:	00 00 00 
  800420a329:	41 ff d0             	callq  *%r8
	print_trapframe(tf);
  800420a32c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420a330:	48 89 c7             	mov    %rax,%rdi
  800420a333:	48 b8 42 99 20 04 80 	movabs $0x8004209942,%rax
  800420a33a:	00 00 00 
  800420a33d:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420a33f:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a346:	00 00 00 
  800420a349:	ff d0                	callq  *%rax
  800420a34b:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a352:	00 00 00 
  800420a355:	48 98                	cltq   
  800420a357:	48 c1 e0 03          	shl    $0x3,%rax
  800420a35b:	48 89 c1             	mov    %rax,%rcx
  800420a35e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a362:	48 01 c8             	add    %rcx,%rax
  800420a365:	48 01 d0             	add    %rdx,%rax
  800420a368:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a36c:	48 89 c7             	mov    %rax,%rdi
  800420a36f:	48 b8 4d 8e 20 04 80 	movabs $0x8004208e4d,%rax
  800420a376:	00 00 00 
  800420a379:	ff d0                	callq  *%rax
}
  800420a37b:	48 83 c4 28          	add    $0x28,%rsp
  800420a37f:	5b                   	pop    %rbx
  800420a380:	5d                   	pop    %rbp
  800420a381:	c3                   	retq   

000000800420a382 <xchg>:
xchg(volatile uint32_t *addr,uint32_t newval){
  800420a382:	55                   	push   %rbp
  800420a383:	48 89 e5             	mov    %rsp,%rbp
  800420a386:	48 83 ec 20          	sub    $0x20,%rsp
  800420a38a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420a38e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	__asm __volatile("lock; xchgl %0, %1":
  800420a391:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420a395:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420a398:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420a39c:	f0 87 02             	lock xchg %eax,(%rdx)
  800420a39f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return result;
  800420a3a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420a3a5:	c9                   	leaveq 
  800420a3a6:	c3                   	retq   

000000800420a3a7 <unlock_kernel>:
{
  800420a3a7:	55                   	push   %rbp
  800420a3a8:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420a3ab:	48 bf c0 87 22 04 80 	movabs $0x80042287c0,%rdi
  800420a3b2:	00 00 00 
  800420a3b5:	48 b8 5b 38 21 04 80 	movabs $0x800421385b,%rax
  800420a3bc:	00 00 00 
  800420a3bf:	ff d0                	callq  *%rax
	asm volatile("pause");
  800420a3c1:	f3 90                	pause  
}
  800420a3c3:	5d                   	pop    %rbp
  800420a3c4:	c3                   	retq   

000000800420a3c5 <sched_yield>:
#endif

// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420a3c5:	55                   	push   %rbp
  800420a3c6:	48 89 e5             	mov    %rsp,%rbp
  800420a3c9:	48 83 ec 10          	sub    $0x10,%rsp
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	// LAB 4: Your code here.
	// sched_halt never returns
	idle = thiscpu->cpu_env;
  800420a3cd:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a3d4:	00 00 00 
  800420a3d7:	ff d0                	callq  *%rax
  800420a3d9:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a3e0:	00 00 00 
  800420a3e3:	48 98                	cltq   
  800420a3e5:	48 c1 e0 03          	shl    $0x3,%rax
  800420a3e9:	48 89 c1             	mov    %rax,%rcx
  800420a3ec:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a3f0:	48 01 c8             	add    %rcx,%rax
  800420a3f3:	48 01 d0             	add    %rdx,%rax
  800420a3f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a3fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int i = 0;
  800420a3fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if(idle)
  800420a405:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420a40a:	74 3b                	je     800420a447 <sched_yield+0x82>
 		i = ENVX(thiscpu->cpu_env->env_id);
  800420a40c:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a413:	00 00 00 
  800420a416:	ff d0                	callq  *%rax
  800420a418:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a41f:	00 00 00 
  800420a422:	48 98                	cltq   
  800420a424:	48 c1 e0 03          	shl    $0x3,%rax
  800420a428:	48 89 c1             	mov    %rax,%rcx
  800420a42b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a42f:	48 01 c8             	add    %rcx,%rax
  800420a432:	48 01 d0             	add    %rdx,%rax
  800420a435:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a439:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420a43f:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420a444:	89 45 fc             	mov    %eax,-0x4(%rbp)
	int k = 0 ;
  800420a447:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while(k<NENV) {
  800420a44e:	eb 73                	jmp    800420a4c3 <sched_yield+0xfe>
		i = (i+1)%NENV;
  800420a450:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a453:	8d 50 01             	lea    0x1(%rax),%edx
  800420a456:	89 d0                	mov    %edx,%eax
  800420a458:	c1 f8 1f             	sar    $0x1f,%eax
  800420a45b:	c1 e8 16             	shr    $0x16,%eax
  800420a45e:	01 c2                	add    %eax,%edx
  800420a460:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420a466:	29 c2                	sub    %eax,%edx
  800420a468:	89 d0                	mov    %edx,%eax
  800420a46a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (envs[i].env_status == ENV_RUNNABLE) {
  800420a46d:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420a474:	00 00 00 
  800420a477:	48 8b 10             	mov    (%rax),%rdx
  800420a47a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a47d:	48 98                	cltq   
  800420a47f:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420a486:	48 01 d0             	add    %rdx,%rax
  800420a489:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420a48f:	83 f8 02             	cmp    $0x2,%eax
  800420a492:	75 2b                	jne    800420a4bf <sched_yield+0xfa>
		    		vmx_vmrun(&envs[i]);
				}
			}
			else {
#endif
				env_run(&envs[i]);
  800420a494:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420a49b:	00 00 00 
  800420a49e:	48 8b 10             	mov    (%rax),%rdx
  800420a4a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a4a4:	48 98                	cltq   
  800420a4a6:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420a4ad:	48 01 d0             	add    %rdx,%rax
  800420a4b0:	48 89 c7             	mov    %rax,%rdi
  800420a4b3:	48 b8 0c 90 20 04 80 	movabs $0x800420900c,%rax
  800420a4ba:	00 00 00 
  800420a4bd:	ff d0                	callq  *%rax
#ifndef VMM_GUEST
			}
#endif
			return;
		}
		k++;
  800420a4bf:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
	while(k<NENV) {
  800420a4c3:	81 7d f8 ff 03 00 00 	cmpl   $0x3ff,-0x8(%rbp)
  800420a4ca:	7e 84                	jle    800420a450 <sched_yield+0x8b>
	}
	// LAB 4: Your code here.

	// sched_halt never returns
	if(idle && idle->env_status == ENV_RUNNING)
  800420a4cc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420a4d1:	74 22                	je     800420a4f5 <sched_yield+0x130>
  800420a4d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420a4d7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420a4dd:	83 f8 03             	cmp    $0x3,%eax
  800420a4e0:	75 13                	jne    800420a4f5 <sched_yield+0x130>
				vmx_vmrun(idle);
			}
		}
		else {
#endif
			env_run(idle);
  800420a4e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420a4e6:	48 89 c7             	mov    %rax,%rdi
  800420a4e9:	48 b8 0c 90 20 04 80 	movabs $0x800420900c,%rax
  800420a4f0:	00 00 00 
  800420a4f3:	ff d0                	callq  *%rax
		}
#ifndef VMM_GUEST
	}
#endif
	sched_halt();
  800420a4f5:	48 b8 03 a5 20 04 80 	movabs $0x800420a503,%rax
  800420a4fc:	00 00 00 
  800420a4ff:	ff d0                	callq  *%rax
}
  800420a501:	c9                   	leaveq 
  800420a502:	c3                   	retq   

000000800420a503 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420a503:	55                   	push   %rbp
  800420a504:	48 89 e5             	mov    %rsp,%rbp
  800420a507:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420a50b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420a512:	eb 79                	jmp    800420a58d <sched_halt+0x8a>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420a514:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420a51b:	00 00 00 
  800420a51e:	48 8b 10             	mov    (%rax),%rdx
  800420a521:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a524:	48 98                	cltq   
  800420a526:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420a52d:	48 01 d0             	add    %rdx,%rax
  800420a530:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420a536:	83 f8 02             	cmp    $0x2,%eax
  800420a539:	74 5f                	je     800420a59a <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
  800420a53b:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420a542:	00 00 00 
  800420a545:	48 8b 10             	mov    (%rax),%rdx
  800420a548:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a54b:	48 98                	cltq   
  800420a54d:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420a554:	48 01 d0             	add    %rdx,%rax
  800420a557:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420a55d:	83 f8 03             	cmp    $0x3,%eax
  800420a560:	74 38                	je     800420a59a <sched_halt+0x97>
		     envs[i].env_status == ENV_DYING))
  800420a562:	48 b8 78 b2 57 04 80 	movabs $0x800457b278,%rax
  800420a569:	00 00 00 
  800420a56c:	48 8b 10             	mov    (%rax),%rdx
  800420a56f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a572:	48 98                	cltq   
  800420a574:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420a57b:	48 01 d0             	add    %rdx,%rax
  800420a57e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		     envs[i].env_status == ENV_RUNNING ||
  800420a584:	83 f8 01             	cmp    $0x1,%eax
  800420a587:	74 11                	je     800420a59a <sched_halt+0x97>
	for (i = 0; i < NENV; i++) {
  800420a589:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420a58d:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420a594:	0f 8e 7a ff ff ff    	jle    800420a514 <sched_halt+0x11>
			break;
	}
	if (i == NENV) {
  800420a59a:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420a5a1:	75 2e                	jne    800420a5d1 <sched_halt+0xce>
		cprintf("No runnable environments in the system!\n");
  800420a5a3:	48 bf 20 60 21 04 80 	movabs $0x8004216020,%rdi
  800420a5aa:	00 00 00 
  800420a5ad:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a5b2:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420a5b9:	00 00 00 
  800420a5bc:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420a5be:	bf 00 00 00 00       	mov    $0x0,%edi
  800420a5c3:	48 b8 60 1b 20 04 80 	movabs $0x8004201b60,%rax
  800420a5ca:	00 00 00 
  800420a5cd:	ff d0                	callq  *%rax
  800420a5cf:	eb ed                	jmp    800420a5be <sched_halt+0xbb>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420a5d1:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a5d8:	00 00 00 
  800420a5db:	ff d0                	callq  *%rax
  800420a5dd:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a5e4:	00 00 00 
  800420a5e7:	48 98                	cltq   
  800420a5e9:	48 c1 e0 03          	shl    $0x3,%rax
  800420a5ed:	48 89 c1             	mov    %rax,%rcx
  800420a5f0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a5f4:	48 01 c8             	add    %rcx,%rax
  800420a5f7:	48 01 d0             	add    %rdx,%rax
  800420a5fa:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800420a601:	00 
	lcr3(PADDR(boot_pml4e));
  800420a602:	48 b8 c8 c7 57 04 80 	movabs $0x800457c7c8,%rax
  800420a609:	00 00 00 
  800420a60c:	48 8b 00             	mov    (%rax),%rax
  800420a60f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420a613:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420a61a:	00 00 00 
  800420a61d:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420a621:	77 32                	ja     800420a655 <sched_halt+0x152>
  800420a623:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420a627:	48 89 c1             	mov    %rax,%rcx
  800420a62a:	48 ba 50 60 21 04 80 	movabs $0x8004216050,%rdx
  800420a631:	00 00 00 
  800420a634:	be 83 00 00 00       	mov    $0x83,%esi
  800420a639:	48 bf 74 60 21 04 80 	movabs $0x8004216074,%rdi
  800420a640:	00 00 00 
  800420a643:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a648:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420a64f:	00 00 00 
  800420a652:	41 ff d0             	callq  *%r8
  800420a655:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420a65c:	ff ff ff 
  800420a65f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420a663:	48 01 d0             	add    %rdx,%rax
  800420a666:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420a66a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a66e:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420a671:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a678:	00 00 00 
  800420a67b:	ff d0                	callq  *%rax
  800420a67d:	48 98                	cltq   
  800420a67f:	48 c1 e0 03          	shl    $0x3,%rax
  800420a683:	48 89 c2             	mov    %rax,%rdx
  800420a686:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a68a:	48 01 d0             	add    %rdx,%rax
  800420a68d:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a694:	00 00 00 
  800420a697:	48 01 d0             	add    %rdx,%rax
  800420a69a:	48 83 c0 04          	add    $0x4,%rax
  800420a69e:	be 02 00 00 00       	mov    $0x2,%esi
  800420a6a3:	48 89 c7             	mov    %rax,%rdi
  800420a6a6:	48 b8 82 a3 20 04 80 	movabs $0x800420a382,%rax
  800420a6ad:	00 00 00 
  800420a6b0:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420a6b2:	48 b8 a7 a3 20 04 80 	movabs $0x800420a3a7,%rax
  800420a6b9:	00 00 00 
  800420a6bc:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420a6be:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a6c5:	00 00 00 
  800420a6c8:	ff d0                	callq  *%rax
  800420a6ca:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a6d1:	00 00 00 
  800420a6d4:	48 98                	cltq   
  800420a6d6:	48 c1 e0 03          	shl    $0x3,%rax
  800420a6da:	48 89 c1             	mov    %rax,%rcx
  800420a6dd:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a6e1:	48 01 c8             	add    %rcx,%rax
  800420a6e4:	48 01 d0             	add    %rdx,%rax
  800420a6e7:	48 83 c0 10          	add    $0x10,%rax
  800420a6eb:	48 8b 40 04          	mov    0x4(%rax),%rax
	asm volatile (
  800420a6ef:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420a6f6:	48 89 c4             	mov    %rax,%rsp
  800420a6f9:	6a 00                	pushq  $0x0
  800420a6fb:	6a 00                	pushq  $0x0
  800420a6fd:	fb                   	sti    
  800420a6fe:	f4                   	hlt    
}
  800420a6ff:	c9                   	leaveq 
  800420a700:	c3                   	retq   

000000800420a701 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420a701:	55                   	push   %rbp
  800420a702:	48 89 e5             	mov    %rsp,%rbp
  800420a705:	48 83 ec 10          	sub    $0x10,%rsp
  800420a709:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420a70d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Destroy the environment if not.

	// LAB 3: Your code here.

	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420a711:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420a715:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420a719:	48 89 c6             	mov    %rax,%rsi
  800420a71c:	48 bf 88 60 21 04 80 	movabs $0x8004216088,%rdi
  800420a723:	00 00 00 
  800420a726:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a72b:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  800420a732:	00 00 00 
  800420a735:	ff d1                	callq  *%rcx
}
  800420a737:	c9                   	leaveq 
  800420a738:	c3                   	retq   

000000800420a739 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420a739:	55                   	push   %rbp
  800420a73a:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420a73d:	48 b8 b3 11 20 04 80 	movabs $0x80042011b3,%rax
  800420a744:	00 00 00 
  800420a747:	ff d0                	callq  *%rax
}
  800420a749:	5d                   	pop    %rbp
  800420a74a:	c3                   	retq   

000000800420a74b <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420a74b:	55                   	push   %rbp
  800420a74c:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420a74f:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420a756:	00 00 00 
  800420a759:	ff d0                	callq  *%rax
  800420a75b:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420a762:	00 00 00 
  800420a765:	48 98                	cltq   
  800420a767:	48 c1 e0 03          	shl    $0x3,%rax
  800420a76b:	48 89 c1             	mov    %rax,%rcx
  800420a76e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420a772:	48 01 c8             	add    %rcx,%rax
  800420a775:	48 01 d0             	add    %rdx,%rax
  800420a778:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a77c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420a782:	5d                   	pop    %rbp
  800420a783:	c3                   	retq   

000000800420a784 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420a784:	55                   	push   %rbp
  800420a785:	48 89 e5             	mov    %rsp,%rbp
  800420a788:	48 83 ec 20          	sub    $0x20,%rsp
  800420a78c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420a78f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420a793:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a796:	ba 01 00 00 00       	mov    $0x1,%edx
  800420a79b:	48 89 ce             	mov    %rcx,%rsi
  800420a79e:	89 c7                	mov    %eax,%edi
  800420a7a0:	48 b8 07 7f 20 04 80 	movabs $0x8004207f07,%rax
  800420a7a7:	00 00 00 
  800420a7aa:	ff d0                	callq  *%rax
  800420a7ac:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420a7af:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a7b3:	79 05                	jns    800420a7ba <sys_env_destroy+0x36>
		return r;
  800420a7b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a7b8:	eb 18                	jmp    800420a7d2 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420a7ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420a7be:	48 89 c7             	mov    %rax,%rdi
  800420a7c1:	48 b8 4d 8e 20 04 80 	movabs $0x8004208e4d,%rax
  800420a7c8:	00 00 00 
  800420a7cb:	ff d0                	callq  *%rax
	return 0;
  800420a7cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420a7d2:	c9                   	leaveq 
  800420a7d3:	c3                   	retq   

000000800420a7d4 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420a7d4:	55                   	push   %rbp
  800420a7d5:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420a7d8:	48 b8 c5 a3 20 04 80 	movabs $0x800420a3c5,%rax
  800420a7df:	00 00 00 
  800420a7e2:	ff d0                	callq  *%rax

000000800420a7e4 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420a7e4:	55                   	push   %rbp
  800420a7e5:	48 89 e5             	mov    %rsp,%rbp
	// status is set to ENV_NOT_RUNNABLE, and the register set is copied
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	panic("sys_exofork not implemented");
  800420a7e8:	48 ba 8d 60 21 04 80 	movabs $0x800421608d,%rdx
  800420a7ef:	00 00 00 
  800420a7f2:	be 5c 00 00 00       	mov    $0x5c,%esi
  800420a7f7:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a7fe:	00 00 00 
  800420a801:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a806:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a80d:	00 00 00 
  800420a810:	ff d1                	callq  *%rcx

000000800420a812 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420a812:	55                   	push   %rbp
  800420a813:	48 89 e5             	mov    %rsp,%rbp
  800420a816:	48 83 ec 10          	sub    $0x10,%rsp
  800420a81a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a81d:	89 75 f8             	mov    %esi,-0x8(%rbp)
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.
	panic("sys_env_set_status not implemented");
  800420a820:	48 ba b8 60 21 04 80 	movabs $0x80042160b8,%rdx
  800420a827:	00 00 00 
  800420a82a:	be 70 00 00 00       	mov    $0x70,%esi
  800420a82f:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a836:	00 00 00 
  800420a839:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a83e:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a845:	00 00 00 
  800420a848:	ff d1                	callq  *%rcx

000000800420a84a <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420a84a:	55                   	push   %rbp
  800420a84b:	48 89 e5             	mov    %rsp,%rbp
  800420a84e:	48 83 ec 10          	sub    $0x10,%rsp
  800420a852:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a855:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// LAB 5: Your code here.
	// Remember to check whether the user has supplied us with a good
	// address!
	panic("sys_env_set_trapframe not implemented");
  800420a859:	48 ba e0 60 21 04 80 	movabs $0x80042160e0,%rdx
  800420a860:	00 00 00 
  800420a863:	be 80 00 00 00       	mov    $0x80,%esi
  800420a868:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a86f:	00 00 00 
  800420a872:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a877:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a87e:	00 00 00 
  800420a881:	ff d1                	callq  *%rcx

000000800420a883 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420a883:	55                   	push   %rbp
  800420a884:	48 89 e5             	mov    %rsp,%rbp
  800420a887:	48 83 ec 10          	sub    $0x10,%rsp
  800420a88b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a88e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// LAB 4: Your code here.
	panic("sys_env_set_pgfault_upcall not implemented");
  800420a892:	48 ba 08 61 21 04 80 	movabs $0x8004216108,%rdx
  800420a899:	00 00 00 
  800420a89c:	be 8f 00 00 00       	mov    $0x8f,%esi
  800420a8a1:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a8a8:	00 00 00 
  800420a8ab:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a8b0:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a8b7:	00 00 00 
  800420a8ba:	ff d1                	callq  *%rcx

000000800420a8bc <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420a8bc:	55                   	push   %rbp
  800420a8bd:	48 89 e5             	mov    %rsp,%rbp
  800420a8c0:	48 83 ec 10          	sub    $0x10,%rsp
  800420a8c4:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a8c7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420a8cb:	89 55 f8             	mov    %edx,-0x8(%rbp)
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	panic("sys_page_alloc not implemented");
  800420a8ce:	48 ba 38 61 21 04 80 	movabs $0x8004216138,%rdx
  800420a8d5:	00 00 00 
  800420a8d8:	be b0 00 00 00       	mov    $0xb0,%esi
  800420a8dd:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a8e4:	00 00 00 
  800420a8e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a8ec:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a8f3:	00 00 00 
  800420a8f6:	ff d1                	callq  *%rcx

000000800420a8f8 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420a8f8:	55                   	push   %rbp
  800420a8f9:	48 89 e5             	mov    %rsp,%rbp
  800420a8fc:	48 83 ec 20          	sub    $0x20,%rsp
  800420a900:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a903:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420a907:	89 55 f8             	mov    %edx,-0x8(%rbp)
  800420a90a:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  800420a90e:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_page_map not implemented");
  800420a912:	48 ba 57 61 21 04 80 	movabs $0x8004216157,%rdx
  800420a919:	00 00 00 
  800420a91c:	be cf 00 00 00       	mov    $0xcf,%esi
  800420a921:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a928:	00 00 00 
  800420a92b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a930:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a937:	00 00 00 
  800420a93a:	ff d1                	callq  *%rcx

000000800420a93c <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420a93c:	55                   	push   %rbp
  800420a93d:	48 89 e5             	mov    %rsp,%rbp
  800420a940:	48 83 ec 10          	sub    $0x10,%rsp
  800420a944:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a947:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
  800420a94b:	48 ba 78 61 21 04 80 	movabs $0x8004216178,%rdx
  800420a952:	00 00 00 
  800420a955:	be df 00 00 00       	mov    $0xdf,%esi
  800420a95a:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a961:	00 00 00 
  800420a964:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a969:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a970:	00 00 00 
  800420a973:	ff d1                	callq  *%rcx

000000800420a975 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420a975:	55                   	push   %rbp
  800420a976:	48 89 e5             	mov    %rsp,%rbp
  800420a979:	48 83 ec 20          	sub    $0x20,%rsp
  800420a97d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420a980:	89 75 f8             	mov    %esi,-0x8(%rbp)
  800420a983:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800420a987:	89 4d ec             	mov    %ecx,-0x14(%rbp)
		// LAB 4: Your code here.
		panic("sys_ipc_try_send not implemented");
  800420a98a:	48 ba 98 61 21 04 80 	movabs $0x8004216198,%rdx
  800420a991:	00 00 00 
  800420a994:	be 11 01 00 00       	mov    $0x111,%esi
  800420a999:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a9a0:	00 00 00 
  800420a9a3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a9a8:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a9af:	00 00 00 
  800420a9b2:	ff d1                	callq  *%rcx

000000800420a9b4 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420a9b4:	55                   	push   %rbp
  800420a9b5:	48 89 e5             	mov    %rsp,%rbp
  800420a9b8:	48 83 ec 10          	sub    $0x10,%rsp
  800420a9bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	panic("sys_ipc_recv not implemented");
  800420a9c0:	48 ba b9 61 21 04 80 	movabs $0x80042161b9,%rdx
  800420a9c7:	00 00 00 
  800420a9ca:	be 23 01 00 00       	mov    $0x123,%esi
  800420a9cf:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420a9d6:	00 00 00 
  800420a9d9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a9de:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420a9e5:	00 00 00 
  800420a9e8:	ff d1                	callq  *%rcx

000000800420a9ea <sys_time_msec>:


// Return the current time.
static int
sys_time_msec(void)
{
  800420a9ea:	55                   	push   %rbp
  800420a9eb:	48 89 e5             	mov    %rsp,%rbp
	// LAB 6: Your code here.
	panic("sys_time_msec not implemented");
  800420a9ee:	48 ba d6 61 21 04 80 	movabs $0x80042161d6,%rdx
  800420a9f5:	00 00 00 
  800420a9f8:	be 2d 01 00 00       	mov    $0x12d,%esi
  800420a9fd:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420aa04:	00 00 00 
  800420aa07:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aa0c:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420aa13:	00 00 00 
  800420aa16:	ff d1                	callq  *%rcx

000000800420aa18 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420aa18:	55                   	push   %rbp
  800420aa19:	48 89 e5             	mov    %rsp,%rbp
  800420aa1c:	48 83 ec 30          	sub    $0x30,%rsp
  800420aa20:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420aa24:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420aa28:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420aa2c:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420aa30:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420aa34:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	panic("syscall not implemented");
  800420aa38:	48 ba f4 61 21 04 80 	movabs $0x80042161f4,%rdx
  800420aa3f:	00 00 00 
  800420aa42:	be aa 01 00 00       	mov    $0x1aa,%esi
  800420aa47:	48 bf a9 60 21 04 80 	movabs $0x80042160a9,%rdi
  800420aa4e:	00 00 00 
  800420aa51:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aa56:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800420aa5d:	00 00 00 
  800420aa60:	ff d1                	callq  *%rcx

000000800420aa62 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420aa62:	55                   	push   %rbp
  800420aa63:	48 89 e5             	mov    %rsp,%rbp
  800420aa66:	48 81 ec c0 61 00 00 	sub    $0x61c0,%rsp
  800420aa6d:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420aa74:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420aa7b:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420aa82:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420aa89:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420aa90:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420aa94:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420aa9b:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420aaa2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420aaa6:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420aaad:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420aab4:	48 89 d1             	mov    %rdx,%rcx
  800420aab7:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420aabc:	48 89 ce             	mov    %rcx,%rsi
  800420aabf:	48 89 c7             	mov    %rax,%rdi
  800420aac2:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420aac9:	00 00 00 
  800420aacc:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420aace:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420aad5:	00 
	uint64_t ret_offset=0;
  800420aad6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420aadd:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420aade:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420aae5:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420aae9:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420aaed:	74 0a                	je     800420aaf9 <list_func_die+0x97>
		return 0;
  800420aaef:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aaf4:	e9 8d 06 00 00       	jmpq   800420b186 <list_func_die+0x724>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420aaf9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420ab00:	ba 38 00 00 00       	mov    $0x38,%edx
  800420ab05:	be 00 00 00 00       	mov    $0x0,%esi
  800420ab0a:	48 89 c7             	mov    %rax,%rdi
  800420ab0d:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420ab14:	00 00 00 
  800420ab17:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420ab19:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ab20:	be 11 00 00 00       	mov    $0x11,%esi
  800420ab25:	48 89 c7             	mov    %rax,%rdi
  800420ab28:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420ab2f:	00 00 00 
  800420ab32:	ff d0                	callq  *%rax
  800420ab34:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420ab38:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ab3f:	be 12 00 00 00       	mov    $0x12,%esi
  800420ab44:	48 89 c7             	mov    %rax,%rdi
  800420ab47:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420ab4e:	00 00 00 
  800420ab51:	ff d0                	callq  *%rax
  800420ab53:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420ab57:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ab5c:	0f 84 1f 06 00 00    	je     800420b181 <list_func_die+0x71f>
  800420ab62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ab66:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ab6a:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420ab71:	0f 83 0a 06 00 00    	jae    800420b181 <list_func_die+0x71f>
  800420ab77:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420ab7c:	0f 84 ff 05 00 00    	je     800420b181 <list_func_die+0x71f>
  800420ab82:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ab86:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ab8a:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420ab91:	0f 86 ea 05 00 00    	jbe    800420b181 <list_func_die+0x71f>
	{
		info->rip_file = die->cu_die->die_name;
  800420ab97:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ab9e:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420aba5:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420abac:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420abb3:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420abb6:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420abbd:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420abc4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420abcb:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420abcf:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420abd6:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420abdd:	48 89 c7             	mov    %rax,%rdi
  800420abe0:	48 b8 e3 c1 20 04 80 	movabs $0x800420c1e3,%rax
  800420abe7:	00 00 00 
  800420abea:	ff d0                	callq  *%rax
  800420abec:	89 c2                	mov    %eax,%edx
  800420abee:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420abf5:	89 50 18             	mov    %edx,0x18(%rax)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420abf8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420abfc:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ac00:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ac07:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420ac0b:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ac12:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ac19:	48 85 c0             	test   %rax,%rax
  800420ac1c:	75 35                	jne    800420ac53 <list_func_die+0x1f1>
  800420ac1e:	48 b9 80 65 21 04 80 	movabs $0x8004216580,%rcx
  800420ac25:	00 00 00 
  800420ac28:	48 ba 8c 65 21 04 80 	movabs $0x800421658c,%rdx
  800420ac2f:	00 00 00 
  800420ac32:	be 91 00 00 00       	mov    $0x91,%esi
  800420ac37:	48 bf a1 65 21 04 80 	movabs $0x80042165a1,%rdi
  800420ac3e:	00 00 00 
  800420ac41:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ac46:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420ac4d:	00 00 00 
  800420ac50:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420ac53:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ac5a:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ac61:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420ac68:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420ac6f:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420ac74:	48 89 c7             	mov    %rax,%rdi
  800420ac77:	48 b8 52 19 21 04 80 	movabs $0x8004211952,%rax
  800420ac7e:	00 00 00 
  800420ac81:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420ac83:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ac8a:	89 c2                	mov    %eax,%edx
  800420ac8c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ac93:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420ac96:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ac9d:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420aca4:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420acab:	00 00 00 
  800420acae:	48 8b 00             	mov    (%rax),%rax
  800420acb1:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420acb8:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420acbf:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420acc3:	48 89 c7             	mov    %rax,%rdi
  800420acc6:	48 b8 51 e6 20 04 80 	movabs $0x800420e651,%rax
  800420accd:	00 00 00 
  800420acd0:	ff d0                	callq  *%rax
  800420acd2:	83 f8 04             	cmp    $0x4,%eax
  800420acd5:	0f 84 9f 04 00 00    	je     800420b17a <list_func_die+0x718>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420acdb:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420ace2:	48 83 f8 05          	cmp    $0x5,%rax
  800420ace6:	74 05                	je     800420aced <list_func_die+0x28b>
				goto last;
  800420ace8:	e9 8d 04 00 00       	jmpq   800420b17a <list_func_die+0x718>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420aced:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420acf4:	be 49 00 00 00       	mov    $0x49,%esi
  800420acf9:	48 89 c7             	mov    %rax,%rdi
  800420acfc:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420ad03:	00 00 00 
  800420ad06:	ff d0                	callq  *%rax
  800420ad08:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420ad0c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ad11:	0f 84 b6 00 00 00    	je     800420adcd <list_func_die+0x36b>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420ad17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ad1b:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420ad1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad23:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ad27:	48 01 d0             	add    %rdx,%rax
  800420ad2a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420ad2e:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420ad35:	00 00 00 
  800420ad38:	48 8b 08             	mov    (%rax),%rcx
  800420ad3b:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420ad42:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420ad46:	48 83 ec 08          	sub    $0x8,%rsp
  800420ad4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ad4e:	ff 70 30             	pushq  0x30(%rax)
  800420ad51:	ff 70 28             	pushq  0x28(%rax)
  800420ad54:	ff 70 20             	pushq  0x20(%rax)
  800420ad57:	ff 70 18             	pushq  0x18(%rax)
  800420ad5a:	ff 70 10             	pushq  0x10(%rax)
  800420ad5d:	ff 70 08             	pushq  0x8(%rax)
  800420ad60:	ff 30                	pushq  (%rax)
  800420ad62:	48 89 cf             	mov    %rcx,%rdi
  800420ad65:	48 b8 da e2 20 04 80 	movabs $0x800420e2da,%rax
  800420ad6c:	00 00 00 
  800420ad6f:	ff d0                	callq  *%rax
  800420ad71:	48 83 c4 40          	add    $0x40,%rsp
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420ad75:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420ad7c:	be 0b 00 00 00       	mov    $0xb,%esi
  800420ad81:	48 89 c7             	mov    %rax,%rdi
  800420ad84:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420ad8b:	00 00 00 
  800420ad8e:	ff d0                	callq  *%rax
  800420ad90:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420ad94:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ad99:	74 0e                	je     800420ada9 <list_func_die+0x347>
				{
					ret_val = attr->u[0].u64;
  800420ad9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad9f:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ada3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ada7:	eb 24                	jmp    800420adcd <list_func_die+0x36b>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420ada9:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420adb0:	be 49 00 00 00       	mov    $0x49,%esi
  800420adb5:	48 89 c7             	mov    %rax,%rdi
  800420adb8:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420adbf:	00 00 00 
  800420adc2:	ff d0                	callq  *%rax
  800420adc4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420adc8:	e9 3f ff ff ff       	jmpq   800420ad0c <list_func_die+0x2aa>
				}
			}

			ret_offset = 0;
  800420adcd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420add4:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420add5:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420addc:	be 02 00 00 00       	mov    $0x2,%esi
  800420ade1:	48 89 c7             	mov    %rax,%rdi
  800420ade4:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420adeb:	00 00 00 
  800420adee:	ff d0                	callq  *%rax
  800420adf0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420adf4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420adf9:	0f 84 a2 00 00 00    	je     800420aea1 <list_func_die+0x43f>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420adff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae03:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ae07:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420ae0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae0f:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420ae13:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420ae17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae1b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ae1f:	48 83 f8 03          	cmp    $0x3,%rax
  800420ae23:	72 7c                	jb     800420aea1 <list_func_die+0x43f>
  800420ae25:	48 83 f8 04          	cmp    $0x4,%rax
  800420ae29:	76 06                	jbe    800420ae31 <list_func_die+0x3cf>
  800420ae2b:	48 83 f8 0a          	cmp    $0xa,%rax
  800420ae2f:	75 70                	jne    800420aea1 <list_func_die+0x43f>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420ae31:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420ae38:	00 
						atom = *(loc_ptr++);
  800420ae39:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ae3d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ae41:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420ae45:	0f b6 00             	movzbl (%rax),%eax
  800420ae48:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420ae4b:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420ae50:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420ae54:	75 4a                	jne    800420aea0 <list_func_die+0x43e>
							uint8_t *p = loc_ptr;
  800420ae56:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ae5a:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420ae61:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420ae68:	48 89 c7             	mov    %rax,%rdi
  800420ae6b:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800420ae72:	00 00 00 
  800420ae75:	ff d0                	callq  *%rax
  800420ae77:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420ae7b:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420ae82:	48 89 c2             	mov    %rax,%rdx
  800420ae85:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ae89:	48 29 c2             	sub    %rax,%rdx
  800420ae8c:	48 89 d0             	mov    %rdx,%rax
  800420ae8f:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420ae93:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420ae9a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420ae9e:	eb 00                	jmp    800420aea0 <list_func_die+0x43e>
  800420aea0:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420aea1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420aea8:	8b 50 28             	mov    0x28(%rax),%edx
  800420aeab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420aeaf:	89 c1                	mov    %eax,%ecx
  800420aeb1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420aeb8:	48 63 d2             	movslq %edx,%rdx
  800420aebb:	48 83 c2 08          	add    $0x8,%rdx
  800420aebf:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420aec3:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420aeca:	8b 50 28             	mov    0x28(%rax),%edx
  800420aecd:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420aed4:	48 63 d2             	movslq %edx,%rdx
  800420aed7:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420aedb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420aedf:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420aee4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420aeeb:	8b 40 28             	mov    0x28(%rax),%eax
  800420aeee:	8d 50 01             	lea    0x1(%rax),%edx
  800420aef1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420aef8:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420aefb:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420af02:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420af09:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420af0e:	48 89 ce             	mov    %rcx,%rsi
  800420af11:	48 89 c7             	mov    %rax,%rdi
  800420af14:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420af1b:	00 00 00 
  800420af1e:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420af20:	e9 1f 02 00 00       	jmpq   800420b144 <list_func_die+0x6e2>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420af25:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420af2c:	48 83 f8 05          	cmp    $0x5,%rax
  800420af30:	74 05                	je     800420af37 <list_func_die+0x4d5>
					break;
  800420af32:	e9 43 02 00 00       	jmpq   800420b17a <list_func_die+0x718>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420af37:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420af3e:	be 49 00 00 00       	mov    $0x49,%esi
  800420af43:	48 89 c7             	mov    %rax,%rdi
  800420af46:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420af4d:	00 00 00 
  800420af50:	ff d0                	callq  *%rax
  800420af52:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420af56:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420af5b:	0f 84 90 00 00 00    	je     800420aff1 <list_func_die+0x58f>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420af61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420af65:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420af69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420af6d:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420af71:	48 01 d0             	add    %rdx,%rax
  800420af74:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420af78:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420af7f:	00 00 00 
  800420af82:	48 8b 08             	mov    (%rax),%rcx
  800420af85:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420af8c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420af90:	48 83 ec 08          	sub    $0x8,%rsp
  800420af94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420af98:	ff 70 30             	pushq  0x30(%rax)
  800420af9b:	ff 70 28             	pushq  0x28(%rax)
  800420af9e:	ff 70 20             	pushq  0x20(%rax)
  800420afa1:	ff 70 18             	pushq  0x18(%rax)
  800420afa4:	ff 70 10             	pushq  0x10(%rax)
  800420afa7:	ff 70 08             	pushq  0x8(%rax)
  800420afaa:	ff 30                	pushq  (%rax)
  800420afac:	48 89 cf             	mov    %rcx,%rdi
  800420afaf:	48 b8 da e2 20 04 80 	movabs $0x800420e2da,%rax
  800420afb6:	00 00 00 
  800420afb9:	ff d0                	callq  *%rax
  800420afbb:	48 83 c4 40          	add    $0x40,%rsp
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420afbf:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420afc6:	be 0b 00 00 00       	mov    $0xb,%esi
  800420afcb:	48 89 c7             	mov    %rax,%rdi
  800420afce:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420afd5:	00 00 00 
  800420afd8:	ff d0                	callq  *%rax
  800420afda:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420afde:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420afe3:	74 0c                	je     800420aff1 <list_func_die+0x58f>
					{
						ret_val = attr->u[0].u64;
  800420afe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420afe9:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420afed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420aff1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420aff8:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420aff9:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420b000:	be 02 00 00 00       	mov    $0x2,%esi
  800420b005:	48 89 c7             	mov    %rax,%rdi
  800420b008:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420b00f:	00 00 00 
  800420b012:	ff d0                	callq  *%rax
  800420b014:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420b018:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420b01d:	0f 84 a2 00 00 00    	je     800420b0c5 <list_func_die+0x663>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420b023:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b027:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420b02b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420b02f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b033:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b037:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420b03b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b03f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420b043:	48 83 f8 03          	cmp    $0x3,%rax
  800420b047:	72 7c                	jb     800420b0c5 <list_func_die+0x663>
  800420b049:	48 83 f8 04          	cmp    $0x4,%rax
  800420b04d:	76 06                	jbe    800420b055 <list_func_die+0x5f3>
  800420b04f:	48 83 f8 0a          	cmp    $0xa,%rax
  800420b053:	75 70                	jne    800420b0c5 <list_func_die+0x663>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420b055:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420b05c:	00 
							atom = *(loc_ptr++);
  800420b05d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b061:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420b065:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420b069:	0f b6 00             	movzbl (%rax),%eax
  800420b06c:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420b06f:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420b074:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420b078:	75 4a                	jne    800420b0c4 <list_func_die+0x662>
								uint8_t *p = loc_ptr;
  800420b07a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b07e:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420b085:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420b08c:	48 89 c7             	mov    %rax,%rdi
  800420b08f:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800420b096:	00 00 00 
  800420b099:	ff d0                	callq  *%rax
  800420b09b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420b09f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420b0a6:	48 89 c2             	mov    %rax,%rdx
  800420b0a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b0ad:	48 29 c2             	sub    %rax,%rdx
  800420b0b0:	48 89 d0             	mov    %rdx,%rax
  800420b0b3:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420b0b7:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420b0be:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420b0c2:	eb 00                	jmp    800420b0c4 <list_func_die+0x662>
  800420b0c4:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420b0c5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420b0cc:	8b 50 28             	mov    0x28(%rax),%edx
  800420b0cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0d3:	89 c1                	mov    %eax,%ecx
  800420b0d5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420b0dc:	48 63 d2             	movslq %edx,%rdx
  800420b0df:	48 83 c2 08          	add    $0x8,%rdx
  800420b0e3:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420b0e7:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420b0ee:	8b 50 28             	mov    0x28(%rax),%edx
  800420b0f1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420b0f8:	48 63 d2             	movslq %edx,%rdx
  800420b0fb:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420b0ff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420b103:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420b108:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420b10f:	8b 40 28             	mov    0x28(%rax),%eax
  800420b112:	8d 50 01             	lea    0x1(%rax),%edx
  800420b115:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420b11c:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420b11f:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420b126:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420b12d:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420b132:	48 89 ce             	mov    %rcx,%rsi
  800420b135:	48 89 c7             	mov    %rax,%rdi
  800420b138:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420b13f:	00 00 00 
  800420b142:	ff d0                	callq  *%rax
			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420b144:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b14b:	00 00 00 
  800420b14e:	48 8b 00             	mov    (%rax),%rax
  800420b151:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420b155:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420b15c:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420b163:	48 89 c7             	mov    %rax,%rdi
  800420b166:	48 b8 4f e4 20 04 80 	movabs $0x800420e44f,%rax
  800420b16d:	00 00 00 
  800420b170:	ff d0                	callq  *%rax
  800420b172:	85 c0                	test   %eax,%eax
  800420b174:	0f 84 ab fd ff ff    	je     800420af25 <list_func_die+0x4c3>
			}
		}
	last:	
		return 1;
  800420b17a:	b8 01 00 00 00       	mov    $0x1,%eax
  800420b17f:	eb 05                	jmp    800420b186 <list_func_die+0x724>
	}

	return 0;
  800420b181:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420b186:	c9                   	leaveq 
  800420b187:	c3                   	retq   

000000800420b188 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420b188:	55                   	push   %rbp
  800420b189:	48 89 e5             	mov    %rsp,%rbp
  800420b18c:	48 81 ec c0 91 00 00 	sub    $0x91c0,%rsp
  800420b193:	48 89 bd 48 6e ff ff 	mov    %rdi,-0x91b8(%rbp)
  800420b19a:	48 89 b5 40 6e ff ff 	mov    %rsi,-0x91c0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420b1a1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420b1a8:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420b1a9:	48 8b 85 48 6e ff ff 	mov    -0x91b8(%rbp),%rax
  800420b1b0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420b1b4:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b1bb:	48 bf af 65 21 04 80 	movabs $0x80042165af,%rdi
  800420b1c2:	00 00 00 
  800420b1c5:	48 89 38             	mov    %rdi,(%rax)
	info->rip_line = 0;
  800420b1c8:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b1cf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420b1d6:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b1dd:	48 bf af 65 21 04 80 	movabs $0x80042165af,%rdi
  800420b1e4:	00 00 00 
  800420b1e7:	48 89 78 10          	mov    %rdi,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420b1eb:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b1f2:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420b1f9:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b200:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420b207:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420b20b:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b212:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420b219:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420b220:	00 00 00 
  800420b223:	48 39 85 48 6e ff ff 	cmp    %rax,-0x91b8(%rbp)
  800420b22a:	76 13                	jbe    800420b23f <debuginfo_rip+0xb7>
		elf = (void *)0x10000 + KERNBASE;
  800420b22c:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420b233:	00 00 00 
  800420b236:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b23a:	e9 f4 00 00 00       	jmpq   800420b333 <debuginfo_rip+0x1ab>
	} else {
		if(curenv != lastenv) {
  800420b23f:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420b246:	00 00 00 
  800420b249:	ff d0                	callq  *%rax
  800420b24b:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420b252:	00 00 00 
  800420b255:	48 98                	cltq   
  800420b257:	48 c1 e0 03          	shl    $0x3,%rax
  800420b25b:	48 89 c1             	mov    %rax,%rcx
  800420b25e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b262:	48 01 c8             	add    %rcx,%rax
  800420b265:	48 01 d0             	add    %rdx,%rax
  800420b268:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420b26c:	48 b8 d8 c2 57 04 80 	movabs $0x800457c2d8,%rax
  800420b273:	00 00 00 
  800420b276:	48 8b 00             	mov    (%rax),%rax
  800420b279:	48 39 c2             	cmp    %rax,%rdx
  800420b27c:	74 7d                	je     800420b2fb <debuginfo_rip+0x173>
			find_debug_sections((uintptr_t)curenv->elf);
  800420b27e:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420b285:	00 00 00 
  800420b288:	ff d0                	callq  *%rax
  800420b28a:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420b291:	00 00 00 
  800420b294:	48 98                	cltq   
  800420b296:	48 c1 e0 03          	shl    $0x3,%rax
  800420b29a:	48 89 c1             	mov    %rax,%rcx
  800420b29d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b2a1:	48 01 c8             	add    %rcx,%rax
  800420b2a4:	48 01 d0             	add    %rdx,%rax
  800420b2a7:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b2ab:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420b2b2:	48 89 c7             	mov    %rax,%rdi
  800420b2b5:	48 b8 4d 1b 21 04 80 	movabs $0x8004211b4d,%rax
  800420b2bc:	00 00 00 
  800420b2bf:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420b2c1:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420b2c8:	00 00 00 
  800420b2cb:	ff d0                	callq  *%rax
  800420b2cd:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420b2d4:	00 00 00 
  800420b2d7:	48 98                	cltq   
  800420b2d9:	48 c1 e0 03          	shl    $0x3,%rax
  800420b2dd:	48 89 c1             	mov    %rax,%rcx
  800420b2e0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b2e4:	48 01 c8             	add    %rcx,%rax
  800420b2e7:	48 01 d0             	add    %rdx,%rax
  800420b2ea:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420b2ee:	48 b8 d8 c2 57 04 80 	movabs $0x800457c2d8,%rax
  800420b2f5:	00 00 00 
  800420b2f8:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420b2fb:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  800420b302:	00 00 00 
  800420b305:	ff d0                	callq  *%rax
  800420b307:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800420b30e:	00 00 00 
  800420b311:	48 98                	cltq   
  800420b313:	48 c1 e0 03          	shl    $0x3,%rax
  800420b317:	48 89 c1             	mov    %rax,%rcx
  800420b31a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b31e:	48 01 c8             	add    %rcx,%rax
  800420b321:	48 01 d0             	add    %rdx,%rax
  800420b324:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b328:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420b32f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420b333:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b33a:	00 00 00 
  800420b33d:	48 8b 00             	mov    (%rax),%rax
  800420b340:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420b344:	48 89 d6             	mov    %rdx,%rsi
  800420b347:	48 89 c7             	mov    %rax,%rdi
  800420b34a:	48 b8 28 d3 20 04 80 	movabs $0x800420d328,%rax
  800420b351:	00 00 00 
  800420b354:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420b356:	48 bf b9 65 21 04 80 	movabs $0x80042165b9,%rdi
  800420b35d:	00 00 00 
  800420b360:	48 b8 cd 1a 21 04 80 	movabs $0x8004211acd,%rax
  800420b367:	00 00 00 
  800420b36a:	ff d0                	callq  *%rax
  800420b36c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420b370:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b377:	00 00 00 
  800420b37a:	48 8b 00             	mov    (%rax),%rax
  800420b37d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b381:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420b385:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420b389:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b390:	00 00 00 
  800420b393:	48 8b 00             	mov    (%rax),%rax
  800420b396:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b39a:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420b39e:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420b3a2:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b3a9:	00 00 00 
  800420b3ac:	48 8b 00             	mov    (%rax),%rax
  800420b3af:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420b3b3:	48 85 c0             	test   %rax,%rax
  800420b3b6:	75 35                	jne    800420b3ed <debuginfo_rip+0x265>
  800420b3b8:	48 b9 c5 65 21 04 80 	movabs $0x80042165c5,%rcx
  800420b3bf:	00 00 00 
  800420b3c2:	48 ba 8c 65 21 04 80 	movabs $0x800421658c,%rdx
  800420b3c9:	00 00 00 
  800420b3cc:	be 37 01 00 00       	mov    $0x137,%esi
  800420b3d1:	48 bf a1 65 21 04 80 	movabs $0x80042165a1,%rdi
  800420b3d8:	00 00 00 
  800420b3db:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3e0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420b3e7:	00 00 00 
  800420b3ea:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420b3ed:	e9 6f 01 00 00       	jmpq   800420b561 <debuginfo_rip+0x3d9>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420b3f2:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b3f9:	00 00 00 
  800420b3fc:	48 8b 00             	mov    (%rax),%rax
  800420b3ff:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420b403:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420b40a:	be 00 00 00 00       	mov    $0x0,%esi
  800420b40f:	48 89 c7             	mov    %rax,%rdi
  800420b412:	48 b8 4f e4 20 04 80 	movabs $0x800420e44f,%rax
  800420b419:	00 00 00 
  800420b41c:	ff d0                	callq  *%rax
  800420b41e:	83 f8 04             	cmp    $0x4,%eax
  800420b421:	75 05                	jne    800420b428 <debuginfo_rip+0x2a0>
			continue;
  800420b423:	e9 39 01 00 00       	jmpq   800420b561 <debuginfo_rip+0x3d9>

		cudie.cu_header = &cu;
  800420b428:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420b42c:	48 89 85 20 a2 ff ff 	mov    %rax,-0x5de0(%rbp)
		cudie.cu_die = NULL;
  800420b433:	48 c7 85 28 a2 ff ff 	movq   $0x0,-0x5dd8(%rbp)
  800420b43a:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420b43e:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b445:	00 00 00 
  800420b448:	48 8b 00             	mov    (%rax),%rax
  800420b44b:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420b452:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420b459:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
  800420b45d:	48 89 c7             	mov    %rax,%rdi
  800420b460:	48 b8 51 e6 20 04 80 	movabs $0x800420e651,%rax
  800420b467:	00 00 00 
  800420b46a:	ff d0                	callq  *%rax
  800420b46c:	83 f8 04             	cmp    $0x4,%eax
  800420b46f:	75 05                	jne    800420b476 <debuginfo_rip+0x2ee>
			continue;
  800420b471:	e9 eb 00 00 00       	jmpq   800420b561 <debuginfo_rip+0x3d9>

		die.cu_header = &cu;
  800420b476:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420b47a:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
		die.cu_die = &cudie;
  800420b481:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420b488:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420b48f:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420b496:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420b49d:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b4a4:	48 89 ce             	mov    %rcx,%rsi
  800420b4a7:	48 89 c7             	mov    %rax,%rdi
  800420b4aa:	48 b8 62 aa 20 04 80 	movabs $0x800420aa62,%rax
  800420b4b1:	00 00 00 
  800420b4b4:	ff d0                	callq  *%rax
  800420b4b6:	85 c0                	test   %eax,%eax
  800420b4b8:	74 30                	je     800420b4ea <debuginfo_rip+0x362>
				goto find_done;
  800420b4ba:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420b4bb:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b4c2:	00 00 00 
  800420b4c5:	48 8b 00             	mov    (%rax),%rax
  800420b4c8:	be 00 00 00 00       	mov    $0x0,%esi
  800420b4cd:	48 89 c7             	mov    %rax,%rdi
  800420b4d0:	48 b8 4c 0d 21 04 80 	movabs $0x8004210d4c,%rax
  800420b4d7:	00 00 00 
  800420b4da:	ff d0                	callq  *%rax
  800420b4dc:	83 f8 01             	cmp    $0x1,%eax
  800420b4df:	0f 85 bb 00 00 00    	jne    800420b5a0 <debuginfo_rip+0x418>
  800420b4e5:	e9 ac 00 00 00       	jmpq   800420b596 <debuginfo_rip+0x40e>
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420b4ea:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b4f1:	00 00 00 
  800420b4f4:	48 8b 00             	mov    (%rax),%rax
  800420b4f7:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420b4fb:	48 8d 95 50 6e ff ff 	lea    -0x91b0(%rbp),%rdx
  800420b502:	48 8d b5 30 cf ff ff 	lea    -0x30d0(%rbp),%rsi
  800420b509:	48 89 c7             	mov    %rax,%rdi
  800420b50c:	48 b8 4f e4 20 04 80 	movabs $0x800420e44f,%rax
  800420b513:	00 00 00 
  800420b516:	ff d0                	callq  *%rax
  800420b518:	85 c0                	test   %eax,%eax
  800420b51a:	79 02                	jns    800420b51e <debuginfo_rip+0x396>
				break; 
  800420b51c:	eb 43                	jmp    800420b561 <debuginfo_rip+0x3d9>
			die = die2;
  800420b51e:	48 8d 85 30 cf ff ff 	lea    -0x30d0(%rbp),%rax
  800420b525:	48 8d 8d 50 6e ff ff 	lea    -0x91b0(%rbp),%rcx
  800420b52c:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420b531:	48 89 ce             	mov    %rcx,%rsi
  800420b534:	48 89 c7             	mov    %rax,%rdi
  800420b537:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420b53e:	00 00 00 
  800420b541:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420b543:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420b547:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
			die.cu_die = &cudie;
  800420b54e:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420b555:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		}
  800420b55c:	e9 2e ff ff ff       	jmpq   800420b48f <debuginfo_rip+0x307>
	while(_get_next_cu(dbg, &cu) == 0)
  800420b561:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b568:	00 00 00 
  800420b56b:	48 8b 00             	mov    (%rax),%rax
  800420b56e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420b572:	48 89 d6             	mov    %rdx,%rsi
  800420b575:	48 89 c7             	mov    %rax,%rdi
  800420b578:	48 b8 04 d4 20 04 80 	movabs $0x800420d404,%rax
  800420b57f:	00 00 00 
  800420b582:	ff d0                	callq  *%rax
  800420b584:	85 c0                	test   %eax,%eax
  800420b586:	0f 84 66 fe ff ff    	je     800420b3f2 <debuginfo_rip+0x26a>
	return -1;
  800420b58c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420b591:	e9 a0 00 00 00       	jmpq   800420b636 <debuginfo_rip+0x4ae>
		return -1;
  800420b596:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420b59b:	e9 96 00 00 00       	jmpq   800420b636 <debuginfo_rip+0x4ae>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420b5a0:	48 b8 c0 86 22 04 80 	movabs $0x80042286c0,%rax
  800420b5a7:	00 00 00 
  800420b5aa:	48 8b 08             	mov    (%rax),%rcx
  800420b5ad:	48 b8 b8 86 22 04 80 	movabs $0x80042286b8,%rax
  800420b5b4:	00 00 00 
  800420b5b7:	48 8b 10             	mov    (%rax),%rdx
  800420b5ba:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b5c1:	00 00 00 
  800420b5c4:	48 8b 00             	mov    (%rax),%rax
  800420b5c7:	48 8b b5 48 6e ff ff 	mov    -0x91b8(%rbp),%rsi
  800420b5ce:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420b5d4:	48 89 c7             	mov    %rax,%rdi
  800420b5d7:	48 b8 6e e8 20 04 80 	movabs $0x800420e86e,%rax
  800420b5de:	00 00 00 
  800420b5e1:	ff d0                	callq  *%rax
  800420b5e3:	85 c0                	test   %eax,%eax
  800420b5e5:	75 4a                	jne    800420b631 <debuginfo_rip+0x4a9>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420b5e7:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420b5ee:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420b5f5:	48 b8 b8 86 22 04 80 	movabs $0x80042286b8,%rax
  800420b5fc:	00 00 00 
  800420b5ff:	48 8b 30             	mov    (%rax),%rsi
  800420b602:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  800420b609:	00 00 00 
  800420b60c:	48 8b 00             	mov    (%rax),%rax
  800420b60f:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420b616:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420b61c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420b622:	48 89 c7             	mov    %rax,%rdi
  800420b625:	48 b8 58 fb 20 04 80 	movabs $0x800420fb58,%rax
  800420b62c:	00 00 00 
  800420b62f:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420b631:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420b636:	c9                   	leaveq 
  800420b637:	c3                   	retq   

000000800420b638 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420b638:	55                   	push   %rbp
  800420b639:	48 89 e5             	mov    %rsp,%rbp
  800420b63c:	48 83 ec 30          	sub    $0x30,%rsp
  800420b640:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420b644:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420b648:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420b64c:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  800420b64f:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  800420b653:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420b657:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420b65a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420b65e:	77 42                	ja     800420b6a2 <printnum+0x6a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420b660:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420b663:	8d 78 ff             	lea    -0x1(%rax),%edi
  800420b666:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  800420b669:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b66d:	ba 00 00 00 00       	mov    $0x0,%edx
  800420b672:	48 f7 f6             	div    %rsi
  800420b675:	49 89 c2             	mov    %rax,%r10
  800420b678:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  800420b67b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420b67e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420b682:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b686:	41 89 c9             	mov    %ecx,%r9d
  800420b689:	41 89 f8             	mov    %edi,%r8d
  800420b68c:	89 d1                	mov    %edx,%ecx
  800420b68e:	4c 89 d2             	mov    %r10,%rdx
  800420b691:	48 89 c7             	mov    %rax,%rdi
  800420b694:	48 b8 38 b6 20 04 80 	movabs $0x800420b638,%rax
  800420b69b:	00 00 00 
  800420b69e:	ff d0                	callq  *%rax
  800420b6a0:	eb 1e                	jmp    800420b6c0 <printnum+0x88>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420b6a2:	eb 12                	jmp    800420b6b6 <printnum+0x7e>
			putch(padc, putdat);
  800420b6a4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420b6a8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420b6ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6af:	48 89 ce             	mov    %rcx,%rsi
  800420b6b2:	89 d7                	mov    %edx,%edi
  800420b6b4:	ff d0                	callq  *%rax
		while (--width > 0)
  800420b6b6:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  800420b6ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  800420b6be:	7f e4                	jg     800420b6a4 <printnum+0x6c>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420b6c0:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420b6c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b6c7:	ba 00 00 00 00       	mov    $0x0,%edx
  800420b6cc:	48 f7 f1             	div    %rcx
  800420b6cf:	48 b8 f0 67 21 04 80 	movabs $0x80042167f0,%rax
  800420b6d6:	00 00 00 
  800420b6d9:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  800420b6dd:	0f be d0             	movsbl %al,%edx
  800420b6e0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420b6e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6e8:	48 89 ce             	mov    %rcx,%rsi
  800420b6eb:	89 d7                	mov    %edx,%edi
  800420b6ed:	ff d0                	callq  *%rax
}
  800420b6ef:	c9                   	leaveq 
  800420b6f0:	c3                   	retq   

000000800420b6f1 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420b6f1:	55                   	push   %rbp
  800420b6f2:	48 89 e5             	mov    %rsp,%rbp
  800420b6f5:	48 83 ec 20          	sub    $0x20,%rsp
  800420b6f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b6fd:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420b700:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420b704:	7e 4f                	jle    800420b755 <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  800420b706:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b70a:	8b 00                	mov    (%rax),%eax
  800420b70c:	83 f8 30             	cmp    $0x30,%eax
  800420b70f:	73 24                	jae    800420b735 <getuint+0x44>
  800420b711:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b715:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420b719:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b71d:	8b 00                	mov    (%rax),%eax
  800420b71f:	89 c0                	mov    %eax,%eax
  800420b721:	48 01 d0             	add    %rdx,%rax
  800420b724:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b728:	8b 12                	mov    (%rdx),%edx
  800420b72a:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420b72d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b731:	89 0a                	mov    %ecx,(%rdx)
  800420b733:	eb 14                	jmp    800420b749 <getuint+0x58>
  800420b735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b739:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b73d:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420b741:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b745:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420b749:	48 8b 00             	mov    (%rax),%rax
  800420b74c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b750:	e9 9d 00 00 00       	jmpq   800420b7f2 <getuint+0x101>
	else if (lflag)
  800420b755:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420b759:	74 4c                	je     800420b7a7 <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  800420b75b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b75f:	8b 00                	mov    (%rax),%eax
  800420b761:	83 f8 30             	cmp    $0x30,%eax
  800420b764:	73 24                	jae    800420b78a <getuint+0x99>
  800420b766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b76a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420b76e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b772:	8b 00                	mov    (%rax),%eax
  800420b774:	89 c0                	mov    %eax,%eax
  800420b776:	48 01 d0             	add    %rdx,%rax
  800420b779:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b77d:	8b 12                	mov    (%rdx),%edx
  800420b77f:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420b782:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b786:	89 0a                	mov    %ecx,(%rdx)
  800420b788:	eb 14                	jmp    800420b79e <getuint+0xad>
  800420b78a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b78e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b792:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420b796:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b79a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420b79e:	48 8b 00             	mov    (%rax),%rax
  800420b7a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b7a5:	eb 4b                	jmp    800420b7f2 <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  800420b7a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7ab:	8b 00                	mov    (%rax),%eax
  800420b7ad:	83 f8 30             	cmp    $0x30,%eax
  800420b7b0:	73 24                	jae    800420b7d6 <getuint+0xe5>
  800420b7b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7b6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420b7ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7be:	8b 00                	mov    (%rax),%eax
  800420b7c0:	89 c0                	mov    %eax,%eax
  800420b7c2:	48 01 d0             	add    %rdx,%rax
  800420b7c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b7c9:	8b 12                	mov    (%rdx),%edx
  800420b7cb:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420b7ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b7d2:	89 0a                	mov    %ecx,(%rdx)
  800420b7d4:	eb 14                	jmp    800420b7ea <getuint+0xf9>
  800420b7d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7da:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b7de:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420b7e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b7e6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420b7ea:	8b 00                	mov    (%rax),%eax
  800420b7ec:	89 c0                	mov    %eax,%eax
  800420b7ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420b7f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420b7f6:	c9                   	leaveq 
  800420b7f7:	c3                   	retq   

000000800420b7f8 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420b7f8:	55                   	push   %rbp
  800420b7f9:	48 89 e5             	mov    %rsp,%rbp
  800420b7fc:	48 83 ec 20          	sub    $0x20,%rsp
  800420b800:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b804:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420b807:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420b80b:	7e 4f                	jle    800420b85c <getint+0x64>
		x=va_arg(*ap, long long);
  800420b80d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b811:	8b 00                	mov    (%rax),%eax
  800420b813:	83 f8 30             	cmp    $0x30,%eax
  800420b816:	73 24                	jae    800420b83c <getint+0x44>
  800420b818:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b81c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420b820:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b824:	8b 00                	mov    (%rax),%eax
  800420b826:	89 c0                	mov    %eax,%eax
  800420b828:	48 01 d0             	add    %rdx,%rax
  800420b82b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b82f:	8b 12                	mov    (%rdx),%edx
  800420b831:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420b834:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b838:	89 0a                	mov    %ecx,(%rdx)
  800420b83a:	eb 14                	jmp    800420b850 <getint+0x58>
  800420b83c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b840:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b844:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420b848:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b84c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420b850:	48 8b 00             	mov    (%rax),%rax
  800420b853:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b857:	e9 9d 00 00 00       	jmpq   800420b8f9 <getint+0x101>
	else if (lflag)
  800420b85c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420b860:	74 4c                	je     800420b8ae <getint+0xb6>
		x=va_arg(*ap, long);
  800420b862:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b866:	8b 00                	mov    (%rax),%eax
  800420b868:	83 f8 30             	cmp    $0x30,%eax
  800420b86b:	73 24                	jae    800420b891 <getint+0x99>
  800420b86d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b871:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420b875:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b879:	8b 00                	mov    (%rax),%eax
  800420b87b:	89 c0                	mov    %eax,%eax
  800420b87d:	48 01 d0             	add    %rdx,%rax
  800420b880:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b884:	8b 12                	mov    (%rdx),%edx
  800420b886:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420b889:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b88d:	89 0a                	mov    %ecx,(%rdx)
  800420b88f:	eb 14                	jmp    800420b8a5 <getint+0xad>
  800420b891:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b895:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b899:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420b89d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b8a1:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420b8a5:	48 8b 00             	mov    (%rax),%rax
  800420b8a8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b8ac:	eb 4b                	jmp    800420b8f9 <getint+0x101>
	else
		x=va_arg(*ap, int);
  800420b8ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8b2:	8b 00                	mov    (%rax),%eax
  800420b8b4:	83 f8 30             	cmp    $0x30,%eax
  800420b8b7:	73 24                	jae    800420b8dd <getint+0xe5>
  800420b8b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8bd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420b8c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8c5:	8b 00                	mov    (%rax),%eax
  800420b8c7:	89 c0                	mov    %eax,%eax
  800420b8c9:	48 01 d0             	add    %rdx,%rax
  800420b8cc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b8d0:	8b 12                	mov    (%rdx),%edx
  800420b8d2:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420b8d5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b8d9:	89 0a                	mov    %ecx,(%rdx)
  800420b8db:	eb 14                	jmp    800420b8f1 <getint+0xf9>
  800420b8dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b8e5:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420b8e9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b8ed:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420b8f1:	8b 00                	mov    (%rax),%eax
  800420b8f3:	48 98                	cltq   
  800420b8f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420b8f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420b8fd:	c9                   	leaveq 
  800420b8fe:	c3                   	retq   

000000800420b8ff <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420b8ff:	55                   	push   %rbp
  800420b900:	48 89 e5             	mov    %rsp,%rbp
  800420b903:	41 54                	push   %r12
  800420b905:	53                   	push   %rbx
  800420b906:	48 83 ec 60          	sub    $0x60,%rsp
  800420b90a:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420b90e:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420b912:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420b916:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420b91a:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420b91e:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420b922:	48 8b 0a             	mov    (%rdx),%rcx
  800420b925:	48 89 08             	mov    %rcx,(%rax)
  800420b928:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420b92c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420b930:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420b934:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420b938:	eb 17                	jmp    800420b951 <vprintfmt+0x52>
			if (ch == '\0')
  800420b93a:	85 db                	test   %ebx,%ebx
  800420b93c:	0f 84 c5 04 00 00    	je     800420be07 <vprintfmt+0x508>
				return;
			putch(ch, putdat);
  800420b942:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b946:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b94a:	48 89 d6             	mov    %rdx,%rsi
  800420b94d:	89 df                	mov    %ebx,%edi
  800420b94f:	ff d0                	callq  *%rax
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420b951:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b955:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420b959:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420b95d:	0f b6 00             	movzbl (%rax),%eax
  800420b960:	0f b6 d8             	movzbl %al,%ebx
  800420b963:	83 fb 25             	cmp    $0x25,%ebx
  800420b966:	75 d2                	jne    800420b93a <vprintfmt+0x3b>
		}

		// Process a %-escape sequence
		padc = ' ';
  800420b968:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420b96c:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420b973:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420b97a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420b981:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420b988:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b98c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420b990:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420b994:	0f b6 00             	movzbl (%rax),%eax
  800420b997:	0f b6 d8             	movzbl %al,%ebx
  800420b99a:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420b99d:	83 f8 55             	cmp    $0x55,%eax
  800420b9a0:	0f 87 2e 04 00 00    	ja     800420bdd4 <vprintfmt+0x4d5>
  800420b9a6:	89 c0                	mov    %eax,%eax
  800420b9a8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b9af:	00 
  800420b9b0:	48 b8 18 68 21 04 80 	movabs $0x8004216818,%rax
  800420b9b7:	00 00 00 
  800420b9ba:	48 01 d0             	add    %rdx,%rax
  800420b9bd:	48 8b 00             	mov    (%rax),%rax
  800420b9c0:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420b9c2:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420b9c6:	eb c0                	jmp    800420b988 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420b9c8:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420b9cc:	eb ba                	jmp    800420b988 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420b9ce:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420b9d5:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420b9d8:	89 d0                	mov    %edx,%eax
  800420b9da:	c1 e0 02             	shl    $0x2,%eax
  800420b9dd:	01 d0                	add    %edx,%eax
  800420b9df:	01 c0                	add    %eax,%eax
  800420b9e1:	01 d8                	add    %ebx,%eax
  800420b9e3:	83 e8 30             	sub    $0x30,%eax
  800420b9e6:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420b9e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b9ed:	0f b6 00             	movzbl (%rax),%eax
  800420b9f0:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420b9f3:	83 fb 2f             	cmp    $0x2f,%ebx
  800420b9f6:	7e 0c                	jle    800420ba04 <vprintfmt+0x105>
  800420b9f8:	83 fb 39             	cmp    $0x39,%ebx
  800420b9fb:	7f 07                	jg     800420ba04 <vprintfmt+0x105>
			for (precision = 0; ; ++fmt) {
  800420b9fd:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
					break;
			}
  800420ba02:	eb d1                	jmp    800420b9d5 <vprintfmt+0xd6>
			goto process_precision;
  800420ba04:	eb 50                	jmp    800420ba56 <vprintfmt+0x157>

		case '*':
			precision = va_arg(aq, int);
  800420ba06:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ba09:	83 f8 30             	cmp    $0x30,%eax
  800420ba0c:	73 17                	jae    800420ba25 <vprintfmt+0x126>
  800420ba0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ba12:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ba15:	89 d2                	mov    %edx,%edx
  800420ba17:	48 01 d0             	add    %rdx,%rax
  800420ba1a:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ba1d:	83 c2 08             	add    $0x8,%edx
  800420ba20:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ba23:	eb 0c                	jmp    800420ba31 <vprintfmt+0x132>
  800420ba25:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ba29:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420ba2d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ba31:	8b 00                	mov    (%rax),%eax
  800420ba33:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420ba36:	eb 1e                	jmp    800420ba56 <vprintfmt+0x157>

		case '.':
			if (width < 0)
  800420ba38:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420ba3c:	79 07                	jns    800420ba45 <vprintfmt+0x146>
				width = 0;
  800420ba3e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420ba45:	e9 3e ff ff ff       	jmpq   800420b988 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420ba4a:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420ba51:	e9 32 ff ff ff       	jmpq   800420b988 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420ba56:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420ba5a:	79 0d                	jns    800420ba69 <vprintfmt+0x16a>
				width = precision, precision = -1;
  800420ba5c:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420ba5f:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420ba62:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420ba69:	e9 1a ff ff ff       	jmpq   800420b988 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420ba6e:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420ba72:	e9 11 ff ff ff       	jmpq   800420b988 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420ba77:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ba7a:	83 f8 30             	cmp    $0x30,%eax
  800420ba7d:	73 17                	jae    800420ba96 <vprintfmt+0x197>
  800420ba7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ba83:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ba86:	89 d2                	mov    %edx,%edx
  800420ba88:	48 01 d0             	add    %rdx,%rax
  800420ba8b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ba8e:	83 c2 08             	add    $0x8,%edx
  800420ba91:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ba94:	eb 0c                	jmp    800420baa2 <vprintfmt+0x1a3>
  800420ba96:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ba9a:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420ba9e:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420baa2:	8b 10                	mov    (%rax),%edx
  800420baa4:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420baa8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420baac:	48 89 ce             	mov    %rcx,%rsi
  800420baaf:	89 d7                	mov    %edx,%edi
  800420bab1:	ff d0                	callq  *%rax
			break;
  800420bab3:	e9 4a 03 00 00       	jmpq   800420be02 <vprintfmt+0x503>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420bab8:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420babb:	83 f8 30             	cmp    $0x30,%eax
  800420babe:	73 17                	jae    800420bad7 <vprintfmt+0x1d8>
  800420bac0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bac4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bac7:	89 d2                	mov    %edx,%edx
  800420bac9:	48 01 d0             	add    %rdx,%rax
  800420bacc:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bacf:	83 c2 08             	add    $0x8,%edx
  800420bad2:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420bad5:	eb 0c                	jmp    800420bae3 <vprintfmt+0x1e4>
  800420bad7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420badb:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420badf:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420bae3:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420bae5:	85 db                	test   %ebx,%ebx
  800420bae7:	79 02                	jns    800420baeb <vprintfmt+0x1ec>
				err = -err;
  800420bae9:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420baeb:	83 fb 15             	cmp    $0x15,%ebx
  800420baee:	7f 16                	jg     800420bb06 <vprintfmt+0x207>
  800420baf0:	48 b8 40 67 21 04 80 	movabs $0x8004216740,%rax
  800420baf7:	00 00 00 
  800420bafa:	48 63 d3             	movslq %ebx,%rdx
  800420bafd:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420bb01:	4d 85 e4             	test   %r12,%r12
  800420bb04:	75 2e                	jne    800420bb34 <vprintfmt+0x235>
				printfmt(putch, putdat, "error %d", err);
  800420bb06:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420bb0a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bb0e:	89 d9                	mov    %ebx,%ecx
  800420bb10:	48 ba 01 68 21 04 80 	movabs $0x8004216801,%rdx
  800420bb17:	00 00 00 
  800420bb1a:	48 89 c7             	mov    %rax,%rdi
  800420bb1d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bb22:	49 b8 10 be 20 04 80 	movabs $0x800420be10,%r8
  800420bb29:	00 00 00 
  800420bb2c:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420bb2f:	e9 ce 02 00 00       	jmpq   800420be02 <vprintfmt+0x503>
				printfmt(putch, putdat, "%s", p);
  800420bb34:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420bb38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bb3c:	4c 89 e1             	mov    %r12,%rcx
  800420bb3f:	48 ba 0a 68 21 04 80 	movabs $0x800421680a,%rdx
  800420bb46:	00 00 00 
  800420bb49:	48 89 c7             	mov    %rax,%rdi
  800420bb4c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bb51:	49 b8 10 be 20 04 80 	movabs $0x800420be10,%r8
  800420bb58:	00 00 00 
  800420bb5b:	41 ff d0             	callq  *%r8
			break;
  800420bb5e:	e9 9f 02 00 00       	jmpq   800420be02 <vprintfmt+0x503>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420bb63:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420bb66:	83 f8 30             	cmp    $0x30,%eax
  800420bb69:	73 17                	jae    800420bb82 <vprintfmt+0x283>
  800420bb6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bb6f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bb72:	89 d2                	mov    %edx,%edx
  800420bb74:	48 01 d0             	add    %rdx,%rax
  800420bb77:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bb7a:	83 c2 08             	add    $0x8,%edx
  800420bb7d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420bb80:	eb 0c                	jmp    800420bb8e <vprintfmt+0x28f>
  800420bb82:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420bb86:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420bb8a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420bb8e:	4c 8b 20             	mov    (%rax),%r12
  800420bb91:	4d 85 e4             	test   %r12,%r12
  800420bb94:	75 0a                	jne    800420bba0 <vprintfmt+0x2a1>
				p = "(null)";
  800420bb96:	49 bc 0d 68 21 04 80 	movabs $0x800421680d,%r12
  800420bb9d:	00 00 00 
			if (width > 0 && padc != '-')
  800420bba0:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420bba4:	7e 3f                	jle    800420bbe5 <vprintfmt+0x2e6>
  800420bba6:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420bbaa:	74 39                	je     800420bbe5 <vprintfmt+0x2e6>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420bbac:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420bbaf:	48 98                	cltq   
  800420bbb1:	48 89 c6             	mov    %rax,%rsi
  800420bbb4:	4c 89 e7             	mov    %r12,%rdi
  800420bbb7:	48 b8 11 c2 20 04 80 	movabs $0x800420c211,%rax
  800420bbbe:	00 00 00 
  800420bbc1:	ff d0                	callq  *%rax
  800420bbc3:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420bbc6:	eb 17                	jmp    800420bbdf <vprintfmt+0x2e0>
					putch(padc, putdat);
  800420bbc8:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420bbcc:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420bbd0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bbd4:	48 89 ce             	mov    %rcx,%rsi
  800420bbd7:	89 d7                	mov    %edx,%edi
  800420bbd9:	ff d0                	callq  *%rax
				for (width -= strnlen(p, precision); width > 0; width--)
  800420bbdb:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420bbdf:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420bbe3:	7f e3                	jg     800420bbc8 <vprintfmt+0x2c9>
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420bbe5:	eb 37                	jmp    800420bc1e <vprintfmt+0x31f>
				if (altflag && (ch < ' ' || ch > '~'))
  800420bbe7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420bbeb:	74 1e                	je     800420bc0b <vprintfmt+0x30c>
  800420bbed:	83 fb 1f             	cmp    $0x1f,%ebx
  800420bbf0:	7e 05                	jle    800420bbf7 <vprintfmt+0x2f8>
  800420bbf2:	83 fb 7e             	cmp    $0x7e,%ebx
  800420bbf5:	7e 14                	jle    800420bc0b <vprintfmt+0x30c>
					putch('?', putdat);
  800420bbf7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bbfb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bbff:	48 89 d6             	mov    %rdx,%rsi
  800420bc02:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420bc07:	ff d0                	callq  *%rax
  800420bc09:	eb 0f                	jmp    800420bc1a <vprintfmt+0x31b>
				else
					putch(ch, putdat);
  800420bc0b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bc0f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bc13:	48 89 d6             	mov    %rdx,%rsi
  800420bc16:	89 df                	mov    %ebx,%edi
  800420bc18:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420bc1a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420bc1e:	4c 89 e0             	mov    %r12,%rax
  800420bc21:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420bc25:	0f b6 00             	movzbl (%rax),%eax
  800420bc28:	0f be d8             	movsbl %al,%ebx
  800420bc2b:	85 db                	test   %ebx,%ebx
  800420bc2d:	74 10                	je     800420bc3f <vprintfmt+0x340>
  800420bc2f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420bc33:	78 b2                	js     800420bbe7 <vprintfmt+0x2e8>
  800420bc35:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420bc39:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420bc3d:	79 a8                	jns    800420bbe7 <vprintfmt+0x2e8>
			for (; width > 0; width--)
  800420bc3f:	eb 16                	jmp    800420bc57 <vprintfmt+0x358>
				putch(' ', putdat);
  800420bc41:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bc45:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bc49:	48 89 d6             	mov    %rdx,%rsi
  800420bc4c:	bf 20 00 00 00       	mov    $0x20,%edi
  800420bc51:	ff d0                	callq  *%rax
			for (; width > 0; width--)
  800420bc53:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420bc57:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420bc5b:	7f e4                	jg     800420bc41 <vprintfmt+0x342>
			break;
  800420bc5d:	e9 a0 01 00 00       	jmpq   800420be02 <vprintfmt+0x503>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420bc62:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420bc66:	be 03 00 00 00       	mov    $0x3,%esi
  800420bc6b:	48 89 c7             	mov    %rax,%rdi
  800420bc6e:	48 b8 f8 b7 20 04 80 	movabs $0x800420b7f8,%rax
  800420bc75:	00 00 00 
  800420bc78:	ff d0                	callq  *%rax
  800420bc7a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420bc7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bc82:	48 85 c0             	test   %rax,%rax
  800420bc85:	79 1d                	jns    800420bca4 <vprintfmt+0x3a5>
				putch('-', putdat);
  800420bc87:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bc8b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bc8f:	48 89 d6             	mov    %rdx,%rsi
  800420bc92:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420bc97:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420bc99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bc9d:	48 f7 d8             	neg    %rax
  800420bca0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420bca4:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420bcab:	e9 e5 00 00 00       	jmpq   800420bd95 <vprintfmt+0x496>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420bcb0:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420bcb4:	be 03 00 00 00       	mov    $0x3,%esi
  800420bcb9:	48 89 c7             	mov    %rax,%rdi
  800420bcbc:	48 b8 f1 b6 20 04 80 	movabs $0x800420b6f1,%rax
  800420bcc3:	00 00 00 
  800420bcc6:	ff d0                	callq  *%rax
  800420bcc8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420bccc:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420bcd3:	e9 bd 00 00 00       	jmpq   800420bd95 <vprintfmt+0x496>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  800420bcd8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bcdc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bce0:	48 89 d6             	mov    %rdx,%rsi
  800420bce3:	bf 58 00 00 00       	mov    $0x58,%edi
  800420bce8:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420bcea:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bcee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bcf2:	48 89 d6             	mov    %rdx,%rsi
  800420bcf5:	bf 58 00 00 00       	mov    $0x58,%edi
  800420bcfa:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420bcfc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bd00:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bd04:	48 89 d6             	mov    %rdx,%rsi
  800420bd07:	bf 58 00 00 00       	mov    $0x58,%edi
  800420bd0c:	ff d0                	callq  *%rax
			break;
  800420bd0e:	e9 ef 00 00 00       	jmpq   800420be02 <vprintfmt+0x503>

			// pointer
		case 'p':
			putch('0', putdat);
  800420bd13:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bd17:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bd1b:	48 89 d6             	mov    %rdx,%rsi
  800420bd1e:	bf 30 00 00 00       	mov    $0x30,%edi
  800420bd23:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420bd25:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bd29:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bd2d:	48 89 d6             	mov    %rdx,%rsi
  800420bd30:	bf 78 00 00 00       	mov    $0x78,%edi
  800420bd35:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420bd37:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420bd3a:	83 f8 30             	cmp    $0x30,%eax
  800420bd3d:	73 17                	jae    800420bd56 <vprintfmt+0x457>
  800420bd3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bd43:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bd46:	89 d2                	mov    %edx,%edx
  800420bd48:	48 01 d0             	add    %rdx,%rax
  800420bd4b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bd4e:	83 c2 08             	add    $0x8,%edx
  800420bd51:	89 55 b8             	mov    %edx,-0x48(%rbp)
			num = (unsigned long long)
  800420bd54:	eb 0c                	jmp    800420bd62 <vprintfmt+0x463>
				(uintptr_t) va_arg(aq, void *);
  800420bd56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420bd5a:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420bd5e:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420bd62:	48 8b 00             	mov    (%rax),%rax
			num = (unsigned long long)
  800420bd65:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420bd69:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420bd70:	eb 23                	jmp    800420bd95 <vprintfmt+0x496>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420bd72:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420bd76:	be 03 00 00 00       	mov    $0x3,%esi
  800420bd7b:	48 89 c7             	mov    %rax,%rdi
  800420bd7e:	48 b8 f1 b6 20 04 80 	movabs $0x800420b6f1,%rax
  800420bd85:	00 00 00 
  800420bd88:	ff d0                	callq  *%rax
  800420bd8a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420bd8e:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420bd95:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420bd9a:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420bd9d:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420bda0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bda4:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420bda8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bdac:	45 89 c1             	mov    %r8d,%r9d
  800420bdaf:	41 89 f8             	mov    %edi,%r8d
  800420bdb2:	48 89 c7             	mov    %rax,%rdi
  800420bdb5:	48 b8 38 b6 20 04 80 	movabs $0x800420b638,%rax
  800420bdbc:	00 00 00 
  800420bdbf:	ff d0                	callq  *%rax
			break;
  800420bdc1:	eb 3f                	jmp    800420be02 <vprintfmt+0x503>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420bdc3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bdc7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bdcb:	48 89 d6             	mov    %rdx,%rsi
  800420bdce:	89 df                	mov    %ebx,%edi
  800420bdd0:	ff d0                	callq  *%rax
			break;
  800420bdd2:	eb 2e                	jmp    800420be02 <vprintfmt+0x503>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420bdd4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420bdd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420bddc:	48 89 d6             	mov    %rdx,%rsi
  800420bddf:	bf 25 00 00 00       	mov    $0x25,%edi
  800420bde4:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420bde6:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420bdeb:	eb 05                	jmp    800420bdf2 <vprintfmt+0x4f3>
  800420bded:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420bdf2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420bdf6:	48 83 e8 01          	sub    $0x1,%rax
  800420bdfa:	0f b6 00             	movzbl (%rax),%eax
  800420bdfd:	3c 25                	cmp    $0x25,%al
  800420bdff:	75 ec                	jne    800420bded <vprintfmt+0x4ee>
				/* do nothing */;
			break;
  800420be01:	90                   	nop
		}
	}
  800420be02:	e9 31 fb ff ff       	jmpq   800420b938 <vprintfmt+0x39>
	va_end(aq);
}
  800420be07:	48 83 c4 60          	add    $0x60,%rsp
  800420be0b:	5b                   	pop    %rbx
  800420be0c:	41 5c                	pop    %r12
  800420be0e:	5d                   	pop    %rbp
  800420be0f:	c3                   	retq   

000000800420be10 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420be10:	55                   	push   %rbp
  800420be11:	48 89 e5             	mov    %rsp,%rbp
  800420be14:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420be1b:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420be22:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420be29:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420be30:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420be37:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420be3e:	84 c0                	test   %al,%al
  800420be40:	74 20                	je     800420be62 <printfmt+0x52>
  800420be42:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420be46:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420be4a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420be4e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420be52:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420be56:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420be5a:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420be5e:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420be62:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420be69:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420be70:	00 00 00 
  800420be73:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420be7a:	00 00 00 
  800420be7d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420be81:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420be88:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420be8f:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420be96:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420be9d:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420bea4:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420beab:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420beb2:	48 89 c7             	mov    %rax,%rdi
  800420beb5:	48 b8 ff b8 20 04 80 	movabs $0x800420b8ff,%rax
  800420bebc:	00 00 00 
  800420bebf:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420bec1:	c9                   	leaveq 
  800420bec2:	c3                   	retq   

000000800420bec3 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420bec3:	55                   	push   %rbp
  800420bec4:	48 89 e5             	mov    %rsp,%rbp
  800420bec7:	48 83 ec 10          	sub    $0x10,%rsp
  800420becb:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420bece:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420bed2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bed6:	8b 40 10             	mov    0x10(%rax),%eax
  800420bed9:	8d 50 01             	lea    0x1(%rax),%edx
  800420bedc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bee0:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420bee3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bee7:	48 8b 10             	mov    (%rax),%rdx
  800420beea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420beee:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420bef2:	48 39 c2             	cmp    %rax,%rdx
  800420bef5:	73 17                	jae    800420bf0e <sprintputch+0x4b>
		*b->buf++ = ch;
  800420bef7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420befb:	48 8b 00             	mov    (%rax),%rax
  800420befe:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420bf02:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420bf06:	48 89 0a             	mov    %rcx,(%rdx)
  800420bf09:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420bf0c:	88 10                	mov    %dl,(%rax)
}
  800420bf0e:	c9                   	leaveq 
  800420bf0f:	c3                   	retq   

000000800420bf10 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420bf10:	55                   	push   %rbp
  800420bf11:	48 89 e5             	mov    %rsp,%rbp
  800420bf14:	48 83 ec 50          	sub    $0x50,%rsp
  800420bf18:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420bf1c:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420bf1f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420bf23:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420bf27:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420bf2b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420bf2f:	48 8b 0a             	mov    (%rdx),%rcx
  800420bf32:	48 89 08             	mov    %rcx,(%rax)
  800420bf35:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420bf39:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420bf3d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420bf41:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420bf45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bf49:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420bf4d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420bf50:	48 98                	cltq   
  800420bf52:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420bf56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bf5a:	48 01 d0             	add    %rdx,%rax
  800420bf5d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420bf61:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420bf68:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420bf6d:	74 06                	je     800420bf75 <vsnprintf+0x65>
  800420bf6f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420bf73:	7f 07                	jg     800420bf7c <vsnprintf+0x6c>
		return -E_INVAL;
  800420bf75:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420bf7a:	eb 2f                	jmp    800420bfab <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420bf7c:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420bf80:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420bf84:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420bf88:	48 89 c6             	mov    %rax,%rsi
  800420bf8b:	48 bf c3 be 20 04 80 	movabs $0x800420bec3,%rdi
  800420bf92:	00 00 00 
  800420bf95:	48 b8 ff b8 20 04 80 	movabs $0x800420b8ff,%rax
  800420bf9c:	00 00 00 
  800420bf9f:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420bfa1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bfa5:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420bfa8:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420bfab:	c9                   	leaveq 
  800420bfac:	c3                   	retq   

000000800420bfad <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420bfad:	55                   	push   %rbp
  800420bfae:	48 89 e5             	mov    %rsp,%rbp
  800420bfb1:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420bfb8:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420bfbf:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420bfc5:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420bfcc:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420bfd3:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420bfda:	84 c0                	test   %al,%al
  800420bfdc:	74 20                	je     800420bffe <snprintf+0x51>
  800420bfde:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420bfe2:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420bfe6:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420bfea:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420bfee:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420bff2:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420bff6:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420bffa:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420bffe:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420c005:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420c00c:	00 00 00 
  800420c00f:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420c016:	00 00 00 
  800420c019:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420c01d:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420c024:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420c02b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420c032:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420c039:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420c040:	48 8b 0a             	mov    (%rdx),%rcx
  800420c043:	48 89 08             	mov    %rcx,(%rax)
  800420c046:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420c04a:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420c04e:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420c052:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420c056:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420c05d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420c064:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420c06a:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420c071:	48 89 c7             	mov    %rax,%rdi
  800420c074:	48 b8 10 bf 20 04 80 	movabs $0x800420bf10,%rax
  800420c07b:	00 00 00 
  800420c07e:	ff d0                	callq  *%rax
  800420c080:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420c086:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420c08c:	c9                   	leaveq 
  800420c08d:	c3                   	retq   

000000800420c08e <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420c08e:	55                   	push   %rbp
  800420c08f:	48 89 e5             	mov    %rsp,%rbp
  800420c092:	48 83 ec 20          	sub    $0x20,%rsp
  800420c096:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420c09a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c09f:	74 22                	je     800420c0c3 <readline+0x35>
		cprintf("%s", prompt);
  800420c0a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0a5:	48 89 c6             	mov    %rax,%rsi
  800420c0a8:	48 bf c8 6a 21 04 80 	movabs $0x8004216ac8,%rdi
  800420c0af:	00 00 00 
  800420c0b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0b7:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420c0be:	00 00 00 
  800420c0c1:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420c0c3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420c0ca:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c0cf:	48 b8 40 13 20 04 80 	movabs $0x8004201340,%rax
  800420c0d6:	00 00 00 
  800420c0d9:	ff d0                	callq  *%rax
  800420c0db:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420c0de:	48 b8 1e 13 20 04 80 	movabs $0x800420131e,%rax
  800420c0e5:	00 00 00 
  800420c0e8:	ff d0                	callq  *%rax
  800420c0ea:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420c0ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420c0f1:	79 30                	jns    800420c123 <readline+0x95>
			if (c != -E_EOF)
  800420c0f3:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420c0f7:	74 20                	je     800420c119 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420c0f9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c0fc:	89 c6                	mov    %eax,%esi
  800420c0fe:	48 bf cb 6a 21 04 80 	movabs $0x8004216acb,%rdi
  800420c105:	00 00 00 
  800420c108:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c10d:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800420c114:	00 00 00 
  800420c117:	ff d2                	callq  *%rdx
			return NULL;
  800420c119:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c11e:	e9 be 00 00 00       	jmpq   800420c1e1 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420c123:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420c127:	74 06                	je     800420c12f <readline+0xa1>
  800420c129:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420c12d:	75 26                	jne    800420c155 <readline+0xc7>
  800420c12f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c133:	7e 20                	jle    800420c155 <readline+0xc7>
			if (echoing)
  800420c135:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420c139:	74 11                	je     800420c14c <readline+0xbe>
				cputchar('\b');
  800420c13b:	bf 08 00 00 00       	mov    $0x8,%edi
  800420c140:	48 b8 00 13 20 04 80 	movabs $0x8004201300,%rax
  800420c147:	00 00 00 
  800420c14a:	ff d0                	callq  *%rax
			i--;
  800420c14c:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420c150:	e9 87 00 00 00       	jmpq   800420c1dc <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420c155:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420c159:	7e 3f                	jle    800420c19a <readline+0x10c>
  800420c15b:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420c162:	7f 36                	jg     800420c19a <readline+0x10c>
			if (echoing)
  800420c164:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420c168:	74 11                	je     800420c17b <readline+0xed>
				cputchar(c);
  800420c16a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c16d:	89 c7                	mov    %eax,%edi
  800420c16f:	48 b8 00 13 20 04 80 	movabs $0x8004201300,%rax
  800420c176:	00 00 00 
  800420c179:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420c17b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c17e:	8d 50 01             	lea    0x1(%rax),%edx
  800420c181:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420c184:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420c187:	89 d1                	mov    %edx,%ecx
  800420c189:	48 ba 00 c3 57 04 80 	movabs $0x800457c300,%rdx
  800420c190:	00 00 00 
  800420c193:	48 98                	cltq   
  800420c195:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420c198:	eb 42                	jmp    800420c1dc <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420c19a:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420c19e:	74 06                	je     800420c1a6 <readline+0x118>
  800420c1a0:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420c1a4:	75 36                	jne    800420c1dc <readline+0x14e>
			if (echoing)
  800420c1a6:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420c1aa:	74 11                	je     800420c1bd <readline+0x12f>
				cputchar('\n');
  800420c1ac:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420c1b1:	48 b8 00 13 20 04 80 	movabs $0x8004201300,%rax
  800420c1b8:	00 00 00 
  800420c1bb:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420c1bd:	48 ba 00 c3 57 04 80 	movabs $0x800457c300,%rdx
  800420c1c4:	00 00 00 
  800420c1c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c1ca:	48 98                	cltq   
  800420c1cc:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420c1d0:	48 b8 00 c3 57 04 80 	movabs $0x800457c300,%rax
  800420c1d7:	00 00 00 
  800420c1da:	eb 05                	jmp    800420c1e1 <readline+0x153>
		}
	}
  800420c1dc:	e9 fd fe ff ff       	jmpq   800420c0de <readline+0x50>
}
  800420c1e1:	c9                   	leaveq 
  800420c1e2:	c3                   	retq   

000000800420c1e3 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420c1e3:	55                   	push   %rbp
  800420c1e4:	48 89 e5             	mov    %rsp,%rbp
  800420c1e7:	48 83 ec 18          	sub    $0x18,%rsp
  800420c1eb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420c1ef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420c1f6:	eb 09                	jmp    800420c201 <strlen+0x1e>
		n++;
  800420c1f8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	for (n = 0; *s != '\0'; s++)
  800420c1fc:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420c201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c205:	0f b6 00             	movzbl (%rax),%eax
  800420c208:	84 c0                	test   %al,%al
  800420c20a:	75 ec                	jne    800420c1f8 <strlen+0x15>
	return n;
  800420c20c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420c20f:	c9                   	leaveq 
  800420c210:	c3                   	retq   

000000800420c211 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420c211:	55                   	push   %rbp
  800420c212:	48 89 e5             	mov    %rsp,%rbp
  800420c215:	48 83 ec 20          	sub    $0x20,%rsp
  800420c219:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c21d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420c221:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420c228:	eb 0e                	jmp    800420c238 <strnlen+0x27>
		n++;
  800420c22a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420c22e:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420c233:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420c238:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420c23d:	74 0b                	je     800420c24a <strnlen+0x39>
  800420c23f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c243:	0f b6 00             	movzbl (%rax),%eax
  800420c246:	84 c0                	test   %al,%al
  800420c248:	75 e0                	jne    800420c22a <strnlen+0x19>
	return n;
  800420c24a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420c24d:	c9                   	leaveq 
  800420c24e:	c3                   	retq   

000000800420c24f <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420c24f:	55                   	push   %rbp
  800420c250:	48 89 e5             	mov    %rsp,%rbp
  800420c253:	48 83 ec 20          	sub    $0x20,%rsp
  800420c257:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c25b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420c25f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c263:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420c267:	90                   	nop
  800420c268:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c26c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c270:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c274:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c278:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420c27c:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420c280:	0f b6 12             	movzbl (%rdx),%edx
  800420c283:	88 10                	mov    %dl,(%rax)
  800420c285:	0f b6 00             	movzbl (%rax),%eax
  800420c288:	84 c0                	test   %al,%al
  800420c28a:	75 dc                	jne    800420c268 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420c28c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c290:	c9                   	leaveq 
  800420c291:	c3                   	retq   

000000800420c292 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420c292:	55                   	push   %rbp
  800420c293:	48 89 e5             	mov    %rsp,%rbp
  800420c296:	48 83 ec 20          	sub    $0x20,%rsp
  800420c29a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c29e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420c2a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2a6:	48 89 c7             	mov    %rax,%rdi
  800420c2a9:	48 b8 e3 c1 20 04 80 	movabs $0x800420c1e3,%rax
  800420c2b0:	00 00 00 
  800420c2b3:	ff d0                	callq  *%rax
  800420c2b5:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420c2b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c2bb:	48 63 d0             	movslq %eax,%rdx
  800420c2be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2c2:	48 01 c2             	add    %rax,%rdx
  800420c2c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c2c9:	48 89 c6             	mov    %rax,%rsi
  800420c2cc:	48 89 d7             	mov    %rdx,%rdi
  800420c2cf:	48 b8 4f c2 20 04 80 	movabs $0x800420c24f,%rax
  800420c2d6:	00 00 00 
  800420c2d9:	ff d0                	callq  *%rax
	return dst;
  800420c2db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420c2df:	c9                   	leaveq 
  800420c2e0:	c3                   	retq   

000000800420c2e1 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420c2e1:	55                   	push   %rbp
  800420c2e2:	48 89 e5             	mov    %rsp,%rbp
  800420c2e5:	48 83 ec 28          	sub    $0x28,%rsp
  800420c2e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c2ed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c2f1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420c2f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420c2fd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c304:	00 
  800420c305:	eb 2a                	jmp    800420c331 <strncpy+0x50>
		*dst++ = *src;
  800420c307:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c30b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c30f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c313:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c317:	0f b6 12             	movzbl (%rdx),%edx
  800420c31a:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420c31c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c320:	0f b6 00             	movzbl (%rax),%eax
  800420c323:	84 c0                	test   %al,%al
  800420c325:	74 05                	je     800420c32c <strncpy+0x4b>
			src++;
  800420c327:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
	for (i = 0; i < size; i++) {
  800420c32c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420c331:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c335:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420c339:	72 cc                	jb     800420c307 <strncpy+0x26>
	}
	return ret;
  800420c33b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420c33f:	c9                   	leaveq 
  800420c340:	c3                   	retq   

000000800420c341 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420c341:	55                   	push   %rbp
  800420c342:	48 89 e5             	mov    %rsp,%rbp
  800420c345:	48 83 ec 28          	sub    $0x28,%rsp
  800420c349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c34d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c351:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420c355:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c359:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420c35d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420c362:	74 3d                	je     800420c3a1 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420c364:	eb 1d                	jmp    800420c383 <strlcpy+0x42>
			*dst++ = *src++;
  800420c366:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c36a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c36e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c372:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c376:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420c37a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420c37e:	0f b6 12             	movzbl (%rdx),%edx
  800420c381:	88 10                	mov    %dl,(%rax)
		while (--size > 0 && *src != '\0')
  800420c383:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420c388:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420c38d:	74 0b                	je     800420c39a <strlcpy+0x59>
  800420c38f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c393:	0f b6 00             	movzbl (%rax),%eax
  800420c396:	84 c0                	test   %al,%al
  800420c398:	75 cc                	jne    800420c366 <strlcpy+0x25>
		*dst = '\0';
  800420c39a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c39e:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420c3a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c3a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3a9:	48 29 c2             	sub    %rax,%rdx
  800420c3ac:	48 89 d0             	mov    %rdx,%rax
}
  800420c3af:	c9                   	leaveq 
  800420c3b0:	c3                   	retq   

000000800420c3b1 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420c3b1:	55                   	push   %rbp
  800420c3b2:	48 89 e5             	mov    %rsp,%rbp
  800420c3b5:	48 83 ec 10          	sub    $0x10,%rsp
  800420c3b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c3bd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420c3c1:	eb 0a                	jmp    800420c3cd <strcmp+0x1c>
		p++, q++;
  800420c3c3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420c3c8:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (*p && *p == *q)
  800420c3cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3d1:	0f b6 00             	movzbl (%rax),%eax
  800420c3d4:	84 c0                	test   %al,%al
  800420c3d6:	74 12                	je     800420c3ea <strcmp+0x39>
  800420c3d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3dc:	0f b6 10             	movzbl (%rax),%edx
  800420c3df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3e3:	0f b6 00             	movzbl (%rax),%eax
  800420c3e6:	38 c2                	cmp    %al,%dl
  800420c3e8:	74 d9                	je     800420c3c3 <strcmp+0x12>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420c3ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3ee:	0f b6 00             	movzbl (%rax),%eax
  800420c3f1:	0f b6 d0             	movzbl %al,%edx
  800420c3f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3f8:	0f b6 00             	movzbl (%rax),%eax
  800420c3fb:	0f b6 c0             	movzbl %al,%eax
  800420c3fe:	29 c2                	sub    %eax,%edx
  800420c400:	89 d0                	mov    %edx,%eax
}
  800420c402:	c9                   	leaveq 
  800420c403:	c3                   	retq   

000000800420c404 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420c404:	55                   	push   %rbp
  800420c405:	48 89 e5             	mov    %rsp,%rbp
  800420c408:	48 83 ec 18          	sub    $0x18,%rsp
  800420c40c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c410:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420c414:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420c418:	eb 0f                	jmp    800420c429 <strncmp+0x25>
		n--, p++, q++;
  800420c41a:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420c41f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420c424:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (n > 0 && *p && *p == *q)
  800420c429:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c42e:	74 1d                	je     800420c44d <strncmp+0x49>
  800420c430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c434:	0f b6 00             	movzbl (%rax),%eax
  800420c437:	84 c0                	test   %al,%al
  800420c439:	74 12                	je     800420c44d <strncmp+0x49>
  800420c43b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c43f:	0f b6 10             	movzbl (%rax),%edx
  800420c442:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c446:	0f b6 00             	movzbl (%rax),%eax
  800420c449:	38 c2                	cmp    %al,%dl
  800420c44b:	74 cd                	je     800420c41a <strncmp+0x16>
	if (n == 0)
  800420c44d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c452:	75 07                	jne    800420c45b <strncmp+0x57>
		return 0;
  800420c454:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c459:	eb 18                	jmp    800420c473 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420c45b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c45f:	0f b6 00             	movzbl (%rax),%eax
  800420c462:	0f b6 d0             	movzbl %al,%edx
  800420c465:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c469:	0f b6 00             	movzbl (%rax),%eax
  800420c46c:	0f b6 c0             	movzbl %al,%eax
  800420c46f:	29 c2                	sub    %eax,%edx
  800420c471:	89 d0                	mov    %edx,%eax
}
  800420c473:	c9                   	leaveq 
  800420c474:	c3                   	retq   

000000800420c475 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420c475:	55                   	push   %rbp
  800420c476:	48 89 e5             	mov    %rsp,%rbp
  800420c479:	48 83 ec 10          	sub    $0x10,%rsp
  800420c47d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c481:	89 f0                	mov    %esi,%eax
  800420c483:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420c486:	eb 17                	jmp    800420c49f <strchr+0x2a>
		if (*s == c)
  800420c488:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c48c:	0f b6 00             	movzbl (%rax),%eax
  800420c48f:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420c492:	75 06                	jne    800420c49a <strchr+0x25>
			return (char *) s;
  800420c494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c498:	eb 15                	jmp    800420c4af <strchr+0x3a>
	for (; *s; s++)
  800420c49a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420c49f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4a3:	0f b6 00             	movzbl (%rax),%eax
  800420c4a6:	84 c0                	test   %al,%al
  800420c4a8:	75 de                	jne    800420c488 <strchr+0x13>
	return 0;
  800420c4aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c4af:	c9                   	leaveq 
  800420c4b0:	c3                   	retq   

000000800420c4b1 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420c4b1:	55                   	push   %rbp
  800420c4b2:	48 89 e5             	mov    %rsp,%rbp
  800420c4b5:	48 83 ec 10          	sub    $0x10,%rsp
  800420c4b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c4bd:	89 f0                	mov    %esi,%eax
  800420c4bf:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420c4c2:	eb 13                	jmp    800420c4d7 <strfind+0x26>
		if (*s == c)
  800420c4c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4c8:	0f b6 00             	movzbl (%rax),%eax
  800420c4cb:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420c4ce:	75 02                	jne    800420c4d2 <strfind+0x21>
			break;
  800420c4d0:	eb 10                	jmp    800420c4e2 <strfind+0x31>
	for (; *s; s++)
  800420c4d2:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420c4d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4db:	0f b6 00             	movzbl (%rax),%eax
  800420c4de:	84 c0                	test   %al,%al
  800420c4e0:	75 e2                	jne    800420c4c4 <strfind+0x13>
	return (char *) s;
  800420c4e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c4e6:	c9                   	leaveq 
  800420c4e7:	c3                   	retq   

000000800420c4e8 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420c4e8:	55                   	push   %rbp
  800420c4e9:	48 89 e5             	mov    %rsp,%rbp
  800420c4ec:	48 83 ec 18          	sub    $0x18,%rsp
  800420c4f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c4f4:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420c4f7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420c4fb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c500:	75 06                	jne    800420c508 <memset+0x20>
		return v;
  800420c502:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c506:	eb 69                	jmp    800420c571 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420c508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c50c:	83 e0 03             	and    $0x3,%eax
  800420c50f:	48 85 c0             	test   %rax,%rax
  800420c512:	75 48                	jne    800420c55c <memset+0x74>
  800420c514:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c518:	83 e0 03             	and    $0x3,%eax
  800420c51b:	48 85 c0             	test   %rax,%rax
  800420c51e:	75 3c                	jne    800420c55c <memset+0x74>
		c &= 0xFF;
  800420c520:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420c527:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c52a:	c1 e0 18             	shl    $0x18,%eax
  800420c52d:	89 c2                	mov    %eax,%edx
  800420c52f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c532:	c1 e0 10             	shl    $0x10,%eax
  800420c535:	09 c2                	or     %eax,%edx
  800420c537:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c53a:	c1 e0 08             	shl    $0x8,%eax
  800420c53d:	09 d0                	or     %edx,%eax
  800420c53f:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420c542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c546:	48 c1 e8 02          	shr    $0x2,%rax
  800420c54a:	48 89 c1             	mov    %rax,%rcx
		asm volatile("cld; rep stosl\n"
  800420c54d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c551:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c554:	48 89 d7             	mov    %rdx,%rdi
  800420c557:	fc                   	cld    
  800420c558:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420c55a:	eb 11                	jmp    800420c56d <memset+0x85>
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420c55c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c560:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c563:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420c567:	48 89 d7             	mov    %rdx,%rdi
  800420c56a:	fc                   	cld    
  800420c56b:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420c56d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c571:	c9                   	leaveq 
  800420c572:	c3                   	retq   

000000800420c573 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420c573:	55                   	push   %rbp
  800420c574:	48 89 e5             	mov    %rsp,%rbp
  800420c577:	48 83 ec 28          	sub    $0x28,%rsp
  800420c57b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c57f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c583:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420c587:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c58b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420c58f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c593:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420c597:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c59b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420c59f:	0f 83 88 00 00 00    	jae    800420c62d <memmove+0xba>
  800420c5a5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c5a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c5ad:	48 01 d0             	add    %rdx,%rax
  800420c5b0:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420c5b4:	76 77                	jbe    800420c62d <memmove+0xba>
		s += n;
  800420c5b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c5ba:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420c5be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c5c2:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420c5c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5ca:	83 e0 03             	and    $0x3,%eax
  800420c5cd:	48 85 c0             	test   %rax,%rax
  800420c5d0:	75 3b                	jne    800420c60d <memmove+0x9a>
  800420c5d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c5d6:	83 e0 03             	and    $0x3,%eax
  800420c5d9:	48 85 c0             	test   %rax,%rax
  800420c5dc:	75 2f                	jne    800420c60d <memmove+0x9a>
  800420c5de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c5e2:	83 e0 03             	and    $0x3,%eax
  800420c5e5:	48 85 c0             	test   %rax,%rax
  800420c5e8:	75 23                	jne    800420c60d <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420c5ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c5ee:	48 83 e8 04          	sub    $0x4,%rax
  800420c5f2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c5f6:	48 83 ea 04          	sub    $0x4,%rdx
  800420c5fa:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420c5fe:	48 c1 e9 02          	shr    $0x2,%rcx
			asm volatile("std; rep movsl\n"
  800420c602:	48 89 c7             	mov    %rax,%rdi
  800420c605:	48 89 d6             	mov    %rdx,%rsi
  800420c608:	fd                   	std    
  800420c609:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420c60b:	eb 1d                	jmp    800420c62a <memmove+0xb7>
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420c60d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c611:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420c615:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c619:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
			asm volatile("std; rep movsb\n"
  800420c61d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c621:	48 89 d7             	mov    %rdx,%rdi
  800420c624:	48 89 c1             	mov    %rax,%rcx
  800420c627:	fd                   	std    
  800420c628:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420c62a:	fc                   	cld    
  800420c62b:	eb 57                	jmp    800420c684 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420c62d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c631:	83 e0 03             	and    $0x3,%eax
  800420c634:	48 85 c0             	test   %rax,%rax
  800420c637:	75 36                	jne    800420c66f <memmove+0xfc>
  800420c639:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c63d:	83 e0 03             	and    $0x3,%eax
  800420c640:	48 85 c0             	test   %rax,%rax
  800420c643:	75 2a                	jne    800420c66f <memmove+0xfc>
  800420c645:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c649:	83 e0 03             	and    $0x3,%eax
  800420c64c:	48 85 c0             	test   %rax,%rax
  800420c64f:	75 1e                	jne    800420c66f <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420c651:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c655:	48 c1 e8 02          	shr    $0x2,%rax
  800420c659:	48 89 c1             	mov    %rax,%rcx
			asm volatile("cld; rep movsl\n"
  800420c65c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c660:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c664:	48 89 c7             	mov    %rax,%rdi
  800420c667:	48 89 d6             	mov    %rdx,%rsi
  800420c66a:	fc                   	cld    
  800420c66b:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420c66d:	eb 15                	jmp    800420c684 <memmove+0x111>
		else
			asm volatile("cld; rep movsb\n"
  800420c66f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c673:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c677:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420c67b:	48 89 c7             	mov    %rax,%rdi
  800420c67e:	48 89 d6             	mov    %rdx,%rsi
  800420c681:	fc                   	cld    
  800420c682:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420c684:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420c688:	c9                   	leaveq 
  800420c689:	c3                   	retq   

000000800420c68a <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420c68a:	55                   	push   %rbp
  800420c68b:	48 89 e5             	mov    %rsp,%rbp
  800420c68e:	48 83 ec 18          	sub    $0x18,%rsp
  800420c692:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c696:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420c69a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420c69e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c6a2:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420c6a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6aa:	48 89 ce             	mov    %rcx,%rsi
  800420c6ad:	48 89 c7             	mov    %rax,%rdi
  800420c6b0:	48 b8 73 c5 20 04 80 	movabs $0x800420c573,%rax
  800420c6b7:	00 00 00 
  800420c6ba:	ff d0                	callq  *%rax
}
  800420c6bc:	c9                   	leaveq 
  800420c6bd:	c3                   	retq   

000000800420c6be <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420c6be:	55                   	push   %rbp
  800420c6bf:	48 89 e5             	mov    %rsp,%rbp
  800420c6c2:	48 83 ec 28          	sub    $0x28,%rsp
  800420c6c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c6ca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c6ce:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420c6d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c6d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420c6da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c6de:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420c6e2:	eb 36                	jmp    800420c71a <memcmp+0x5c>
		if (*s1 != *s2)
  800420c6e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6e8:	0f b6 10             	movzbl (%rax),%edx
  800420c6eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c6ef:	0f b6 00             	movzbl (%rax),%eax
  800420c6f2:	38 c2                	cmp    %al,%dl
  800420c6f4:	74 1a                	je     800420c710 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420c6f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6fa:	0f b6 00             	movzbl (%rax),%eax
  800420c6fd:	0f b6 d0             	movzbl %al,%edx
  800420c700:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c704:	0f b6 00             	movzbl (%rax),%eax
  800420c707:	0f b6 c0             	movzbl %al,%eax
  800420c70a:	29 c2                	sub    %eax,%edx
  800420c70c:	89 d0                	mov    %edx,%eax
  800420c70e:	eb 20                	jmp    800420c730 <memcmp+0x72>
		s1++, s2++;
  800420c710:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420c715:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
	while (n-- > 0) {
  800420c71a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c71e:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420c722:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420c726:	48 85 c0             	test   %rax,%rax
  800420c729:	75 b9                	jne    800420c6e4 <memcmp+0x26>
	}

	return 0;
  800420c72b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c730:	c9                   	leaveq 
  800420c731:	c3                   	retq   

000000800420c732 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420c732:	55                   	push   %rbp
  800420c733:	48 89 e5             	mov    %rsp,%rbp
  800420c736:	48 83 ec 28          	sub    $0x28,%rsp
  800420c73a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c73e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420c741:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420c745:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c749:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c74d:	48 01 d0             	add    %rdx,%rax
  800420c750:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420c754:	eb 15                	jmp    800420c76b <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420c756:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c75a:	0f b6 00             	movzbl (%rax),%eax
  800420c75d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420c760:	38 d0                	cmp    %dl,%al
  800420c762:	75 02                	jne    800420c766 <memfind+0x34>
			break;
  800420c764:	eb 0f                	jmp    800420c775 <memfind+0x43>
	for (; s < ends; s++)
  800420c766:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420c76b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c76f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420c773:	72 e1                	jb     800420c756 <memfind+0x24>
	return (void *) s;
  800420c775:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420c779:	c9                   	leaveq 
  800420c77a:	c3                   	retq   

000000800420c77b <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420c77b:	55                   	push   %rbp
  800420c77c:	48 89 e5             	mov    %rsp,%rbp
  800420c77f:	48 83 ec 38          	sub    $0x38,%rsp
  800420c783:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420c787:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c78b:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420c78e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420c795:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420c79c:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420c79d:	eb 05                	jmp    800420c7a4 <strtol+0x29>
		s++;
  800420c79f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	while (*s == ' ' || *s == '\t')
  800420c7a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7a8:	0f b6 00             	movzbl (%rax),%eax
  800420c7ab:	3c 20                	cmp    $0x20,%al
  800420c7ad:	74 f0                	je     800420c79f <strtol+0x24>
  800420c7af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7b3:	0f b6 00             	movzbl (%rax),%eax
  800420c7b6:	3c 09                	cmp    $0x9,%al
  800420c7b8:	74 e5                	je     800420c79f <strtol+0x24>

	// plus/minus sign
	if (*s == '+')
  800420c7ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7be:	0f b6 00             	movzbl (%rax),%eax
  800420c7c1:	3c 2b                	cmp    $0x2b,%al
  800420c7c3:	75 07                	jne    800420c7cc <strtol+0x51>
		s++;
  800420c7c5:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420c7ca:	eb 17                	jmp    800420c7e3 <strtol+0x68>
	else if (*s == '-')
  800420c7cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7d0:	0f b6 00             	movzbl (%rax),%eax
  800420c7d3:	3c 2d                	cmp    $0x2d,%al
  800420c7d5:	75 0c                	jne    800420c7e3 <strtol+0x68>
		s++, neg = 1;
  800420c7d7:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420c7dc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420c7e3:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420c7e7:	74 06                	je     800420c7ef <strtol+0x74>
  800420c7e9:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420c7ed:	75 28                	jne    800420c817 <strtol+0x9c>
  800420c7ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7f3:	0f b6 00             	movzbl (%rax),%eax
  800420c7f6:	3c 30                	cmp    $0x30,%al
  800420c7f8:	75 1d                	jne    800420c817 <strtol+0x9c>
  800420c7fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7fe:	48 83 c0 01          	add    $0x1,%rax
  800420c802:	0f b6 00             	movzbl (%rax),%eax
  800420c805:	3c 78                	cmp    $0x78,%al
  800420c807:	75 0e                	jne    800420c817 <strtol+0x9c>
		s += 2, base = 16;
  800420c809:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420c80e:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420c815:	eb 2c                	jmp    800420c843 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420c817:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420c81b:	75 19                	jne    800420c836 <strtol+0xbb>
  800420c81d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c821:	0f b6 00             	movzbl (%rax),%eax
  800420c824:	3c 30                	cmp    $0x30,%al
  800420c826:	75 0e                	jne    800420c836 <strtol+0xbb>
		s++, base = 8;
  800420c828:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420c82d:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420c834:	eb 0d                	jmp    800420c843 <strtol+0xc8>
	else if (base == 0)
  800420c836:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420c83a:	75 07                	jne    800420c843 <strtol+0xc8>
		base = 10;
  800420c83c:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420c843:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c847:	0f b6 00             	movzbl (%rax),%eax
  800420c84a:	3c 2f                	cmp    $0x2f,%al
  800420c84c:	7e 1d                	jle    800420c86b <strtol+0xf0>
  800420c84e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c852:	0f b6 00             	movzbl (%rax),%eax
  800420c855:	3c 39                	cmp    $0x39,%al
  800420c857:	7f 12                	jg     800420c86b <strtol+0xf0>
			dig = *s - '0';
  800420c859:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c85d:	0f b6 00             	movzbl (%rax),%eax
  800420c860:	0f be c0             	movsbl %al,%eax
  800420c863:	83 e8 30             	sub    $0x30,%eax
  800420c866:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c869:	eb 4e                	jmp    800420c8b9 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420c86b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c86f:	0f b6 00             	movzbl (%rax),%eax
  800420c872:	3c 60                	cmp    $0x60,%al
  800420c874:	7e 1d                	jle    800420c893 <strtol+0x118>
  800420c876:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c87a:	0f b6 00             	movzbl (%rax),%eax
  800420c87d:	3c 7a                	cmp    $0x7a,%al
  800420c87f:	7f 12                	jg     800420c893 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420c881:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c885:	0f b6 00             	movzbl (%rax),%eax
  800420c888:	0f be c0             	movsbl %al,%eax
  800420c88b:	83 e8 57             	sub    $0x57,%eax
  800420c88e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c891:	eb 26                	jmp    800420c8b9 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420c893:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c897:	0f b6 00             	movzbl (%rax),%eax
  800420c89a:	3c 40                	cmp    $0x40,%al
  800420c89c:	7e 48                	jle    800420c8e6 <strtol+0x16b>
  800420c89e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c8a2:	0f b6 00             	movzbl (%rax),%eax
  800420c8a5:	3c 5a                	cmp    $0x5a,%al
  800420c8a7:	7f 3d                	jg     800420c8e6 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420c8a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c8ad:	0f b6 00             	movzbl (%rax),%eax
  800420c8b0:	0f be c0             	movsbl %al,%eax
  800420c8b3:	83 e8 37             	sub    $0x37,%eax
  800420c8b6:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420c8b9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c8bc:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420c8bf:	7c 02                	jl     800420c8c3 <strtol+0x148>
			break;
  800420c8c1:	eb 23                	jmp    800420c8e6 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420c8c3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420c8c8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420c8cb:	48 98                	cltq   
  800420c8cd:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420c8d2:	48 89 c2             	mov    %rax,%rdx
  800420c8d5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c8d8:	48 98                	cltq   
  800420c8da:	48 01 d0             	add    %rdx,%rax
  800420c8dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420c8e1:	e9 5d ff ff ff       	jmpq   800420c843 <strtol+0xc8>

	if (endptr)
  800420c8e6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420c8eb:	74 0b                	je     800420c8f8 <strtol+0x17d>
		*endptr = (char *) s;
  800420c8ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c8f1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420c8f5:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420c8f8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c8fc:	74 09                	je     800420c907 <strtol+0x18c>
  800420c8fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c902:	48 f7 d8             	neg    %rax
  800420c905:	eb 04                	jmp    800420c90b <strtol+0x190>
  800420c907:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420c90b:	c9                   	leaveq 
  800420c90c:	c3                   	retq   

000000800420c90d <strstr>:

char * strstr(const char *in, const char *str)
{
  800420c90d:	55                   	push   %rbp
  800420c90e:	48 89 e5             	mov    %rsp,%rbp
  800420c911:	48 83 ec 30          	sub    $0x30,%rsp
  800420c915:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420c919:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420c91d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c921:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c925:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420c929:	0f b6 00             	movzbl (%rax),%eax
  800420c92c:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420c92f:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420c933:	75 06                	jne    800420c93b <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420c935:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c939:	eb 6b                	jmp    800420c9a6 <strstr+0x99>

	len = strlen(str);
  800420c93b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c93f:	48 89 c7             	mov    %rax,%rdi
  800420c942:	48 b8 e3 c1 20 04 80 	movabs $0x800420c1e3,%rax
  800420c949:	00 00 00 
  800420c94c:	ff d0                	callq  *%rax
  800420c94e:	48 98                	cltq   
  800420c950:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420c954:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c958:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c95c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420c960:	0f b6 00             	movzbl (%rax),%eax
  800420c963:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420c966:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420c96a:	75 07                	jne    800420c973 <strstr+0x66>
				return (char *) 0;
  800420c96c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c971:	eb 33                	jmp    800420c9a6 <strstr+0x99>
		} while (sc != c);
  800420c973:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420c977:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420c97a:	75 d8                	jne    800420c954 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420c97c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c980:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420c984:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c988:	48 89 ce             	mov    %rcx,%rsi
  800420c98b:	48 89 c7             	mov    %rax,%rdi
  800420c98e:	48 b8 04 c4 20 04 80 	movabs $0x800420c404,%rax
  800420c995:	00 00 00 
  800420c998:	ff d0                	callq  *%rax
  800420c99a:	85 c0                	test   %eax,%eax
  800420c99c:	75 b6                	jne    800420c954 <strstr+0x47>

	return (char *) (in - 1);
  800420c99e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c9a2:	48 83 e8 01          	sub    $0x1,%rax
}
  800420c9a6:	c9                   	leaveq 
  800420c9a7:	c3                   	retq   

000000800420c9a8 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420c9a8:	55                   	push   %rbp
  800420c9a9:	48 89 e5             	mov    %rsp,%rbp
  800420c9ac:	48 83 ec 28          	sub    $0x28,%rsp
  800420c9b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c9b4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c9b8:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420c9bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c9bf:	48 8b 10             	mov    (%rax),%rdx
  800420c9c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c9c6:	48 01 d0             	add    %rdx,%rax
  800420c9c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420c9cd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c9d4:	00 
	switch (bytes_to_read) {
  800420c9d5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c9d8:	83 f8 02             	cmp    $0x2,%eax
  800420c9db:	0f 84 ab 00 00 00    	je     800420ca8c <_dwarf_read_lsb+0xe4>
  800420c9e1:	83 f8 02             	cmp    $0x2,%eax
  800420c9e4:	7f 0e                	jg     800420c9f4 <_dwarf_read_lsb+0x4c>
  800420c9e6:	83 f8 01             	cmp    $0x1,%eax
  800420c9e9:	0f 84 b3 00 00 00    	je     800420caa2 <_dwarf_read_lsb+0xfa>
  800420c9ef:	e9 d9 00 00 00       	jmpq   800420cacd <_dwarf_read_lsb+0x125>
  800420c9f4:	83 f8 04             	cmp    $0x4,%eax
  800420c9f7:	74 65                	je     800420ca5e <_dwarf_read_lsb+0xb6>
  800420c9f9:	83 f8 08             	cmp    $0x8,%eax
  800420c9fc:	0f 85 cb 00 00 00    	jne    800420cacd <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420ca02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca06:	48 83 c0 04          	add    $0x4,%rax
  800420ca0a:	0f b6 00             	movzbl (%rax),%eax
  800420ca0d:	0f b6 c0             	movzbl %al,%eax
  800420ca10:	48 c1 e0 20          	shl    $0x20,%rax
  800420ca14:	48 89 c2             	mov    %rax,%rdx
  800420ca17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca1b:	48 83 c0 05          	add    $0x5,%rax
  800420ca1f:	0f b6 00             	movzbl (%rax),%eax
  800420ca22:	0f b6 c0             	movzbl %al,%eax
  800420ca25:	48 c1 e0 28          	shl    $0x28,%rax
  800420ca29:	48 09 d0             	or     %rdx,%rax
  800420ca2c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ca30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca34:	48 83 c0 06          	add    $0x6,%rax
  800420ca38:	0f b6 00             	movzbl (%rax),%eax
  800420ca3b:	0f b6 c0             	movzbl %al,%eax
  800420ca3e:	48 c1 e0 30          	shl    $0x30,%rax
  800420ca42:	48 89 c2             	mov    %rax,%rdx
  800420ca45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca49:	48 83 c0 07          	add    $0x7,%rax
  800420ca4d:	0f b6 00             	movzbl (%rax),%eax
  800420ca50:	0f b6 c0             	movzbl %al,%eax
  800420ca53:	48 c1 e0 38          	shl    $0x38,%rax
  800420ca57:	48 09 d0             	or     %rdx,%rax
  800420ca5a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ca5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca62:	48 83 c0 02          	add    $0x2,%rax
  800420ca66:	0f b6 00             	movzbl (%rax),%eax
  800420ca69:	0f b6 c0             	movzbl %al,%eax
  800420ca6c:	48 c1 e0 10          	shl    $0x10,%rax
  800420ca70:	48 89 c2             	mov    %rax,%rdx
  800420ca73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca77:	48 83 c0 03          	add    $0x3,%rax
  800420ca7b:	0f b6 00             	movzbl (%rax),%eax
  800420ca7e:	0f b6 c0             	movzbl %al,%eax
  800420ca81:	48 c1 e0 18          	shl    $0x18,%rax
  800420ca85:	48 09 d0             	or     %rdx,%rax
  800420ca88:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420ca8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca90:	48 83 c0 01          	add    $0x1,%rax
  800420ca94:	0f b6 00             	movzbl (%rax),%eax
  800420ca97:	0f b6 c0             	movzbl %al,%eax
  800420ca9a:	48 c1 e0 08          	shl    $0x8,%rax
  800420ca9e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420caa2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420caa6:	0f b6 00             	movzbl (%rax),%eax
  800420caa9:	0f b6 c0             	movzbl %al,%eax
  800420caac:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420cab0:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420cab1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cab5:	48 8b 10             	mov    (%rax),%rdx
  800420cab8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420cabb:	48 98                	cltq   
  800420cabd:	48 01 c2             	add    %rax,%rdx
  800420cac0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cac4:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420cac7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cacb:	eb 05                	jmp    800420cad2 <_dwarf_read_lsb+0x12a>
		return (0);
  800420cacd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cad2:	c9                   	leaveq 
  800420cad3:	c3                   	retq   

000000800420cad4 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420cad4:	55                   	push   %rbp
  800420cad5:	48 89 e5             	mov    %rsp,%rbp
  800420cad8:	48 83 ec 20          	sub    $0x20,%rsp
  800420cadc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420cae0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420cae3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cae7:	48 8b 00             	mov    (%rax),%rax
  800420caea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420caee:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420caf5:	00 
	switch (bytes_to_read) {
  800420caf6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420caf9:	83 f8 02             	cmp    $0x2,%eax
  800420cafc:	0f 84 ab 00 00 00    	je     800420cbad <_dwarf_decode_lsb+0xd9>
  800420cb02:	83 f8 02             	cmp    $0x2,%eax
  800420cb05:	7f 0e                	jg     800420cb15 <_dwarf_decode_lsb+0x41>
  800420cb07:	83 f8 01             	cmp    $0x1,%eax
  800420cb0a:	0f 84 b3 00 00 00    	je     800420cbc3 <_dwarf_decode_lsb+0xef>
  800420cb10:	e9 d9 00 00 00       	jmpq   800420cbee <_dwarf_decode_lsb+0x11a>
  800420cb15:	83 f8 04             	cmp    $0x4,%eax
  800420cb18:	74 65                	je     800420cb7f <_dwarf_decode_lsb+0xab>
  800420cb1a:	83 f8 08             	cmp    $0x8,%eax
  800420cb1d:	0f 85 cb 00 00 00    	jne    800420cbee <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420cb23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb27:	48 83 c0 04          	add    $0x4,%rax
  800420cb2b:	0f b6 00             	movzbl (%rax),%eax
  800420cb2e:	0f b6 c0             	movzbl %al,%eax
  800420cb31:	48 c1 e0 20          	shl    $0x20,%rax
  800420cb35:	48 89 c2             	mov    %rax,%rdx
  800420cb38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb3c:	48 83 c0 05          	add    $0x5,%rax
  800420cb40:	0f b6 00             	movzbl (%rax),%eax
  800420cb43:	0f b6 c0             	movzbl %al,%eax
  800420cb46:	48 c1 e0 28          	shl    $0x28,%rax
  800420cb4a:	48 09 d0             	or     %rdx,%rax
  800420cb4d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420cb51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb55:	48 83 c0 06          	add    $0x6,%rax
  800420cb59:	0f b6 00             	movzbl (%rax),%eax
  800420cb5c:	0f b6 c0             	movzbl %al,%eax
  800420cb5f:	48 c1 e0 30          	shl    $0x30,%rax
  800420cb63:	48 89 c2             	mov    %rax,%rdx
  800420cb66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb6a:	48 83 c0 07          	add    $0x7,%rax
  800420cb6e:	0f b6 00             	movzbl (%rax),%eax
  800420cb71:	0f b6 c0             	movzbl %al,%eax
  800420cb74:	48 c1 e0 38          	shl    $0x38,%rax
  800420cb78:	48 09 d0             	or     %rdx,%rax
  800420cb7b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420cb7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb83:	48 83 c0 02          	add    $0x2,%rax
  800420cb87:	0f b6 00             	movzbl (%rax),%eax
  800420cb8a:	0f b6 c0             	movzbl %al,%eax
  800420cb8d:	48 c1 e0 10          	shl    $0x10,%rax
  800420cb91:	48 89 c2             	mov    %rax,%rdx
  800420cb94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb98:	48 83 c0 03          	add    $0x3,%rax
  800420cb9c:	0f b6 00             	movzbl (%rax),%eax
  800420cb9f:	0f b6 c0             	movzbl %al,%eax
  800420cba2:	48 c1 e0 18          	shl    $0x18,%rax
  800420cba6:	48 09 d0             	or     %rdx,%rax
  800420cba9:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420cbad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cbb1:	48 83 c0 01          	add    $0x1,%rax
  800420cbb5:	0f b6 00             	movzbl (%rax),%eax
  800420cbb8:	0f b6 c0             	movzbl %al,%eax
  800420cbbb:	48 c1 e0 08          	shl    $0x8,%rax
  800420cbbf:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420cbc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cbc7:	0f b6 00             	movzbl (%rax),%eax
  800420cbca:	0f b6 c0             	movzbl %al,%eax
  800420cbcd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420cbd1:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420cbd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbd6:	48 8b 10             	mov    (%rax),%rdx
  800420cbd9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420cbdc:	48 98                	cltq   
  800420cbde:	48 01 c2             	add    %rax,%rdx
  800420cbe1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbe5:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420cbe8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbec:	eb 05                	jmp    800420cbf3 <_dwarf_decode_lsb+0x11f>
		return (0);
  800420cbee:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cbf3:	c9                   	leaveq 
  800420cbf4:	c3                   	retq   

000000800420cbf5 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420cbf5:	55                   	push   %rbp
  800420cbf6:	48 89 e5             	mov    %rsp,%rbp
  800420cbf9:	48 83 ec 28          	sub    $0x28,%rsp
  800420cbfd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420cc01:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420cc05:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420cc08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cc0c:	48 8b 10             	mov    (%rax),%rdx
  800420cc0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc13:	48 01 d0             	add    %rdx,%rax
  800420cc16:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420cc1a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420cc1d:	83 f8 02             	cmp    $0x2,%eax
  800420cc20:	74 35                	je     800420cc57 <_dwarf_read_msb+0x62>
  800420cc22:	83 f8 02             	cmp    $0x2,%eax
  800420cc25:	7f 0a                	jg     800420cc31 <_dwarf_read_msb+0x3c>
  800420cc27:	83 f8 01             	cmp    $0x1,%eax
  800420cc2a:	74 18                	je     800420cc44 <_dwarf_read_msb+0x4f>
  800420cc2c:	e9 53 01 00 00       	jmpq   800420cd84 <_dwarf_read_msb+0x18f>
  800420cc31:	83 f8 04             	cmp    $0x4,%eax
  800420cc34:	74 49                	je     800420cc7f <_dwarf_read_msb+0x8a>
  800420cc36:	83 f8 08             	cmp    $0x8,%eax
  800420cc39:	0f 84 96 00 00 00    	je     800420ccd5 <_dwarf_read_msb+0xe0>
  800420cc3f:	e9 40 01 00 00       	jmpq   800420cd84 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420cc44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc48:	0f b6 00             	movzbl (%rax),%eax
  800420cc4b:	0f b6 c0             	movzbl %al,%eax
  800420cc4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420cc52:	e9 34 01 00 00       	jmpq   800420cd8b <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420cc57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc5b:	48 83 c0 01          	add    $0x1,%rax
  800420cc5f:	0f b6 00             	movzbl (%rax),%eax
  800420cc62:	0f b6 d0             	movzbl %al,%edx
  800420cc65:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc69:	0f b6 00             	movzbl (%rax),%eax
  800420cc6c:	0f b6 c0             	movzbl %al,%eax
  800420cc6f:	48 c1 e0 08          	shl    $0x8,%rax
  800420cc73:	48 09 d0             	or     %rdx,%rax
  800420cc76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420cc7a:	e9 0c 01 00 00       	jmpq   800420cd8b <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420cc7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc83:	48 83 c0 03          	add    $0x3,%rax
  800420cc87:	0f b6 00             	movzbl (%rax),%eax
  800420cc8a:	0f b6 c0             	movzbl %al,%eax
  800420cc8d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420cc91:	48 83 c2 02          	add    $0x2,%rdx
  800420cc95:	0f b6 12             	movzbl (%rdx),%edx
  800420cc98:	0f b6 d2             	movzbl %dl,%edx
  800420cc9b:	48 c1 e2 08          	shl    $0x8,%rdx
  800420cc9f:	48 09 d0             	or     %rdx,%rax
  800420cca2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420cca6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ccaa:	48 83 c0 01          	add    $0x1,%rax
  800420ccae:	0f b6 00             	movzbl (%rax),%eax
  800420ccb1:	0f b6 c0             	movzbl %al,%eax
  800420ccb4:	48 c1 e0 10          	shl    $0x10,%rax
  800420ccb8:	48 89 c2             	mov    %rax,%rdx
  800420ccbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ccbf:	0f b6 00             	movzbl (%rax),%eax
  800420ccc2:	0f b6 c0             	movzbl %al,%eax
  800420ccc5:	48 c1 e0 18          	shl    $0x18,%rax
  800420ccc9:	48 09 d0             	or     %rdx,%rax
  800420cccc:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ccd0:	e9 b6 00 00 00       	jmpq   800420cd8b <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420ccd5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ccd9:	48 83 c0 07          	add    $0x7,%rax
  800420ccdd:	0f b6 00             	movzbl (%rax),%eax
  800420cce0:	0f b6 c0             	movzbl %al,%eax
  800420cce3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420cce7:	48 83 c2 06          	add    $0x6,%rdx
  800420cceb:	0f b6 12             	movzbl (%rdx),%edx
  800420ccee:	0f b6 d2             	movzbl %dl,%edx
  800420ccf1:	48 c1 e2 08          	shl    $0x8,%rdx
  800420ccf5:	48 09 d0             	or     %rdx,%rax
  800420ccf8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420ccfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd00:	48 83 c0 05          	add    $0x5,%rax
  800420cd04:	0f b6 00             	movzbl (%rax),%eax
  800420cd07:	0f b6 c0             	movzbl %al,%eax
  800420cd0a:	48 c1 e0 10          	shl    $0x10,%rax
  800420cd0e:	48 89 c2             	mov    %rax,%rdx
  800420cd11:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd15:	48 83 c0 04          	add    $0x4,%rax
  800420cd19:	0f b6 00             	movzbl (%rax),%eax
  800420cd1c:	0f b6 c0             	movzbl %al,%eax
  800420cd1f:	48 c1 e0 18          	shl    $0x18,%rax
  800420cd23:	48 09 d0             	or     %rdx,%rax
  800420cd26:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420cd2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd2e:	48 83 c0 03          	add    $0x3,%rax
  800420cd32:	0f b6 00             	movzbl (%rax),%eax
  800420cd35:	0f b6 c0             	movzbl %al,%eax
  800420cd38:	48 c1 e0 20          	shl    $0x20,%rax
  800420cd3c:	48 89 c2             	mov    %rax,%rdx
  800420cd3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd43:	48 83 c0 02          	add    $0x2,%rax
  800420cd47:	0f b6 00             	movzbl (%rax),%eax
  800420cd4a:	0f b6 c0             	movzbl %al,%eax
  800420cd4d:	48 c1 e0 28          	shl    $0x28,%rax
  800420cd51:	48 09 d0             	or     %rdx,%rax
  800420cd54:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420cd58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd5c:	48 83 c0 01          	add    $0x1,%rax
  800420cd60:	0f b6 00             	movzbl (%rax),%eax
  800420cd63:	0f b6 c0             	movzbl %al,%eax
  800420cd66:	48 c1 e0 30          	shl    $0x30,%rax
  800420cd6a:	48 89 c2             	mov    %rax,%rdx
  800420cd6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd71:	0f b6 00             	movzbl (%rax),%eax
  800420cd74:	0f b6 c0             	movzbl %al,%eax
  800420cd77:	48 c1 e0 38          	shl    $0x38,%rax
  800420cd7b:	48 09 d0             	or     %rdx,%rax
  800420cd7e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420cd82:	eb 07                	jmp    800420cd8b <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420cd84:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd89:	eb 1a                	jmp    800420cda5 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420cd8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cd8f:	48 8b 10             	mov    (%rax),%rdx
  800420cd92:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420cd95:	48 98                	cltq   
  800420cd97:	48 01 c2             	add    %rax,%rdx
  800420cd9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cd9e:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420cda1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420cda5:	c9                   	leaveq 
  800420cda6:	c3                   	retq   

000000800420cda7 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420cda7:	55                   	push   %rbp
  800420cda8:	48 89 e5             	mov    %rsp,%rbp
  800420cdab:	48 83 ec 20          	sub    $0x20,%rsp
  800420cdaf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420cdb3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420cdb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cdba:	48 8b 00             	mov    (%rax),%rax
  800420cdbd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420cdc1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420cdc8:	00 
	switch (bytes_to_read) {
  800420cdc9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420cdcc:	83 f8 02             	cmp    $0x2,%eax
  800420cdcf:	74 35                	je     800420ce06 <_dwarf_decode_msb+0x5f>
  800420cdd1:	83 f8 02             	cmp    $0x2,%eax
  800420cdd4:	7f 0a                	jg     800420cde0 <_dwarf_decode_msb+0x39>
  800420cdd6:	83 f8 01             	cmp    $0x1,%eax
  800420cdd9:	74 18                	je     800420cdf3 <_dwarf_decode_msb+0x4c>
  800420cddb:	e9 53 01 00 00       	jmpq   800420cf33 <_dwarf_decode_msb+0x18c>
  800420cde0:	83 f8 04             	cmp    $0x4,%eax
  800420cde3:	74 49                	je     800420ce2e <_dwarf_decode_msb+0x87>
  800420cde5:	83 f8 08             	cmp    $0x8,%eax
  800420cde8:	0f 84 96 00 00 00    	je     800420ce84 <_dwarf_decode_msb+0xdd>
  800420cdee:	e9 40 01 00 00       	jmpq   800420cf33 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420cdf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cdf7:	0f b6 00             	movzbl (%rax),%eax
  800420cdfa:	0f b6 c0             	movzbl %al,%eax
  800420cdfd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420ce01:	e9 34 01 00 00       	jmpq   800420cf3a <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420ce06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ce0a:	48 83 c0 01          	add    $0x1,%rax
  800420ce0e:	0f b6 00             	movzbl (%rax),%eax
  800420ce11:	0f b6 d0             	movzbl %al,%edx
  800420ce14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ce18:	0f b6 00             	movzbl (%rax),%eax
  800420ce1b:	0f b6 c0             	movzbl %al,%eax
  800420ce1e:	48 c1 e0 08          	shl    $0x8,%rax
  800420ce22:	48 09 d0             	or     %rdx,%rax
  800420ce25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420ce29:	e9 0c 01 00 00       	jmpq   800420cf3a <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420ce2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ce32:	48 83 c0 03          	add    $0x3,%rax
  800420ce36:	0f b6 00             	movzbl (%rax),%eax
  800420ce39:	0f b6 c0             	movzbl %al,%eax
  800420ce3c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ce40:	48 83 c2 02          	add    $0x2,%rdx
  800420ce44:	0f b6 12             	movzbl (%rdx),%edx
  800420ce47:	0f b6 d2             	movzbl %dl,%edx
  800420ce4a:	48 c1 e2 08          	shl    $0x8,%rdx
  800420ce4e:	48 09 d0             	or     %rdx,%rax
  800420ce51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420ce55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ce59:	48 83 c0 01          	add    $0x1,%rax
  800420ce5d:	0f b6 00             	movzbl (%rax),%eax
  800420ce60:	0f b6 c0             	movzbl %al,%eax
  800420ce63:	48 c1 e0 10          	shl    $0x10,%rax
  800420ce67:	48 89 c2             	mov    %rax,%rdx
  800420ce6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ce6e:	0f b6 00             	movzbl (%rax),%eax
  800420ce71:	0f b6 c0             	movzbl %al,%eax
  800420ce74:	48 c1 e0 18          	shl    $0x18,%rax
  800420ce78:	48 09 d0             	or     %rdx,%rax
  800420ce7b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ce7f:	e9 b6 00 00 00       	jmpq   800420cf3a <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420ce84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ce88:	48 83 c0 07          	add    $0x7,%rax
  800420ce8c:	0f b6 00             	movzbl (%rax),%eax
  800420ce8f:	0f b6 c0             	movzbl %al,%eax
  800420ce92:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ce96:	48 83 c2 06          	add    $0x6,%rdx
  800420ce9a:	0f b6 12             	movzbl (%rdx),%edx
  800420ce9d:	0f b6 d2             	movzbl %dl,%edx
  800420cea0:	48 c1 e2 08          	shl    $0x8,%rdx
  800420cea4:	48 09 d0             	or     %rdx,%rax
  800420cea7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420ceab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ceaf:	48 83 c0 05          	add    $0x5,%rax
  800420ceb3:	0f b6 00             	movzbl (%rax),%eax
  800420ceb6:	0f b6 c0             	movzbl %al,%eax
  800420ceb9:	48 c1 e0 10          	shl    $0x10,%rax
  800420cebd:	48 89 c2             	mov    %rax,%rdx
  800420cec0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cec4:	48 83 c0 04          	add    $0x4,%rax
  800420cec8:	0f b6 00             	movzbl (%rax),%eax
  800420cecb:	0f b6 c0             	movzbl %al,%eax
  800420cece:	48 c1 e0 18          	shl    $0x18,%rax
  800420ced2:	48 09 d0             	or     %rdx,%rax
  800420ced5:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420ced9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cedd:	48 83 c0 03          	add    $0x3,%rax
  800420cee1:	0f b6 00             	movzbl (%rax),%eax
  800420cee4:	0f b6 c0             	movzbl %al,%eax
  800420cee7:	48 c1 e0 20          	shl    $0x20,%rax
  800420ceeb:	48 89 c2             	mov    %rax,%rdx
  800420ceee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cef2:	48 83 c0 02          	add    $0x2,%rax
  800420cef6:	0f b6 00             	movzbl (%rax),%eax
  800420cef9:	0f b6 c0             	movzbl %al,%eax
  800420cefc:	48 c1 e0 28          	shl    $0x28,%rax
  800420cf00:	48 09 d0             	or     %rdx,%rax
  800420cf03:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420cf07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cf0b:	48 83 c0 01          	add    $0x1,%rax
  800420cf0f:	0f b6 00             	movzbl (%rax),%eax
  800420cf12:	0f b6 c0             	movzbl %al,%eax
  800420cf15:	48 c1 e0 30          	shl    $0x30,%rax
  800420cf19:	48 89 c2             	mov    %rax,%rdx
  800420cf1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cf20:	0f b6 00             	movzbl (%rax),%eax
  800420cf23:	0f b6 c0             	movzbl %al,%eax
  800420cf26:	48 c1 e0 38          	shl    $0x38,%rax
  800420cf2a:	48 09 d0             	or     %rdx,%rax
  800420cf2d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420cf31:	eb 07                	jmp    800420cf3a <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420cf33:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf38:	eb 1a                	jmp    800420cf54 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420cf3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf3e:	48 8b 10             	mov    (%rax),%rdx
  800420cf41:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420cf44:	48 98                	cltq   
  800420cf46:	48 01 c2             	add    %rax,%rdx
  800420cf49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf4d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420cf50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420cf54:	c9                   	leaveq 
  800420cf55:	c3                   	retq   

000000800420cf56 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420cf56:	55                   	push   %rbp
  800420cf57:	48 89 e5             	mov    %rsp,%rbp
  800420cf5a:	48 83 ec 30          	sub    $0x30,%rsp
  800420cf5e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420cf62:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420cf66:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420cf6d:	00 
	uint8_t b;
	int shift = 0;
  800420cf6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420cf75:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cf79:	48 8b 10             	mov    (%rax),%rdx
  800420cf7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cf80:	48 01 d0             	add    %rdx,%rax
  800420cf83:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420cf87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf8b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420cf8f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420cf93:	0f b6 00             	movzbl (%rax),%eax
  800420cf96:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420cf99:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420cf9d:	83 e0 7f             	and    $0x7f,%eax
  800420cfa0:	89 c2                	mov    %eax,%edx
  800420cfa2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420cfa5:	89 c1                	mov    %eax,%ecx
  800420cfa7:	d3 e2                	shl    %cl,%edx
  800420cfa9:	89 d0                	mov    %edx,%eax
  800420cfab:	48 98                	cltq   
  800420cfad:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420cfb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cfb5:	48 8b 00             	mov    (%rax),%rax
  800420cfb8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420cfbc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cfc0:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420cfc3:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420cfc7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420cfcb:	84 c0                	test   %al,%al
  800420cfcd:	78 b8                	js     800420cf87 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420cfcf:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420cfd3:	7f 1f                	jg     800420cff4 <_dwarf_read_sleb128+0x9e>
  800420cfd5:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420cfd9:	83 e0 40             	and    $0x40,%eax
  800420cfdc:	85 c0                	test   %eax,%eax
  800420cfde:	74 14                	je     800420cff4 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420cfe0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420cfe3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420cfe8:	89 c1                	mov    %eax,%ecx
  800420cfea:	d3 e2                	shl    %cl,%edx
  800420cfec:	89 d0                	mov    %edx,%eax
  800420cfee:	48 98                	cltq   
  800420cff0:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420cff4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420cff8:	c9                   	leaveq 
  800420cff9:	c3                   	retq   

000000800420cffa <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420cffa:	55                   	push   %rbp
  800420cffb:	48 89 e5             	mov    %rsp,%rbp
  800420cffe:	48 83 ec 30          	sub    $0x30,%rsp
  800420d002:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420d006:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420d00a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420d011:	00 
	uint8_t b;
	int shift = 0;
  800420d012:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420d019:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d01d:	48 8b 10             	mov    (%rax),%rdx
  800420d020:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d024:	48 01 d0             	add    %rdx,%rax
  800420d027:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420d02b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d02f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d033:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d037:	0f b6 00             	movzbl (%rax),%eax
  800420d03a:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420d03d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d041:	83 e0 7f             	and    $0x7f,%eax
  800420d044:	89 c2                	mov    %eax,%edx
  800420d046:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d049:	89 c1                	mov    %eax,%ecx
  800420d04b:	d3 e2                	shl    %cl,%edx
  800420d04d:	89 d0                	mov    %edx,%eax
  800420d04f:	48 98                	cltq   
  800420d051:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420d055:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d059:	48 8b 00             	mov    (%rax),%rax
  800420d05c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d060:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d064:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420d067:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420d06b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d06f:	84 c0                	test   %al,%al
  800420d071:	78 b8                	js     800420d02b <_dwarf_read_uleb128+0x31>

	return (ret);
  800420d073:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420d077:	c9                   	leaveq 
  800420d078:	c3                   	retq   

000000800420d079 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420d079:	55                   	push   %rbp
  800420d07a:	48 89 e5             	mov    %rsp,%rbp
  800420d07d:	48 83 ec 28          	sub    $0x28,%rsp
  800420d081:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420d085:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420d08c:	00 
	uint8_t b;
	int shift = 0;
  800420d08d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420d094:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d098:	48 8b 00             	mov    (%rax),%rax
  800420d09b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420d09f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d0a3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d0a7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d0ab:	0f b6 00             	movzbl (%rax),%eax
  800420d0ae:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420d0b1:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d0b5:	83 e0 7f             	and    $0x7f,%eax
  800420d0b8:	89 c2                	mov    %eax,%edx
  800420d0ba:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d0bd:	89 c1                	mov    %eax,%ecx
  800420d0bf:	d3 e2                	shl    %cl,%edx
  800420d0c1:	89 d0                	mov    %edx,%eax
  800420d0c3:	48 98                	cltq   
  800420d0c5:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420d0c9:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420d0cd:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d0d1:	84 c0                	test   %al,%al
  800420d0d3:	78 ca                	js     800420d09f <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420d0d5:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420d0d9:	7f 1f                	jg     800420d0fa <_dwarf_decode_sleb128+0x81>
  800420d0db:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d0df:	83 e0 40             	and    $0x40,%eax
  800420d0e2:	85 c0                	test   %eax,%eax
  800420d0e4:	74 14                	je     800420d0fa <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420d0e6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d0e9:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420d0ee:	89 c1                	mov    %eax,%ecx
  800420d0f0:	d3 e2                	shl    %cl,%edx
  800420d0f2:	89 d0                	mov    %edx,%eax
  800420d0f4:	48 98                	cltq   
  800420d0f6:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420d0fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d0fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d102:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420d105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420d109:	c9                   	leaveq 
  800420d10a:	c3                   	retq   

000000800420d10b <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420d10b:	55                   	push   %rbp
  800420d10c:	48 89 e5             	mov    %rsp,%rbp
  800420d10f:	48 83 ec 28          	sub    $0x28,%rsp
  800420d113:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420d117:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420d11e:	00 
	uint8_t b;
	int shift = 0;
  800420d11f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420d126:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d12a:	48 8b 00             	mov    (%rax),%rax
  800420d12d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420d131:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d135:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d139:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d13d:	0f b6 00             	movzbl (%rax),%eax
  800420d140:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420d143:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d147:	83 e0 7f             	and    $0x7f,%eax
  800420d14a:	89 c2                	mov    %eax,%edx
  800420d14c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d14f:	89 c1                	mov    %eax,%ecx
  800420d151:	d3 e2                	shl    %cl,%edx
  800420d153:	89 d0                	mov    %edx,%eax
  800420d155:	48 98                	cltq   
  800420d157:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420d15b:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420d15f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420d163:	84 c0                	test   %al,%al
  800420d165:	78 ca                	js     800420d131 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420d167:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d16b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d16f:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420d172:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420d176:	c9                   	leaveq 
  800420d177:	c3                   	retq   

000000800420d178 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420d178:	55                   	push   %rbp
  800420d179:	48 89 e5             	mov    %rsp,%rbp
  800420d17c:	48 83 ec 28          	sub    $0x28,%rsp
  800420d180:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d184:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420d188:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420d18c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d190:	48 8b 10             	mov    (%rax),%rdx
  800420d193:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d197:	48 01 d0             	add    %rdx,%rax
  800420d19a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d19e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d1a2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420d1a6:	eb 17                	jmp    800420d1bf <_dwarf_read_string+0x47>
		src++;
  800420d1a8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420d1ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d1b1:	48 8b 00             	mov    (%rax),%rax
  800420d1b4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d1b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d1bc:	48 89 10             	mov    %rdx,(%rax)
	while (*src != '\0' && *offsetp < size) {
  800420d1bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d1c3:	0f b6 00             	movzbl (%rax),%eax
  800420d1c6:	84 c0                	test   %al,%al
  800420d1c8:	74 0d                	je     800420d1d7 <_dwarf_read_string+0x5f>
  800420d1ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d1ce:	48 8b 00             	mov    (%rax),%rax
  800420d1d1:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420d1d5:	72 d1                	jb     800420d1a8 <_dwarf_read_string+0x30>
	}

	if (*src == '\0' && *offsetp < size)
  800420d1d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d1db:	0f b6 00             	movzbl (%rax),%eax
  800420d1de:	84 c0                	test   %al,%al
  800420d1e0:	75 1f                	jne    800420d201 <_dwarf_read_string+0x89>
  800420d1e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d1e6:	48 8b 00             	mov    (%rax),%rax
  800420d1e9:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420d1ed:	73 12                	jae    800420d201 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420d1ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d1f3:	48 8b 00             	mov    (%rax),%rax
  800420d1f6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d1fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d1fe:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420d201:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420d205:	c9                   	leaveq 
  800420d206:	c3                   	retq   

000000800420d207 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420d207:	55                   	push   %rbp
  800420d208:	48 89 e5             	mov    %rsp,%rbp
  800420d20b:	48 83 ec 28          	sub    $0x28,%rsp
  800420d20f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d213:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420d217:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420d21b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d21f:	48 8b 10             	mov    (%rax),%rdx
  800420d222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d226:	48 01 d0             	add    %rdx,%rax
  800420d229:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d22d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d231:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420d235:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d239:	48 8b 10             	mov    (%rax),%rdx
  800420d23c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d240:	48 01 c2             	add    %rax,%rdx
  800420d243:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d247:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420d24a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420d24e:	c9                   	leaveq 
  800420d24f:	c3                   	retq   

000000800420d250 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420d250:	55                   	push   %rbp
  800420d251:	48 89 e5             	mov    %rsp,%rbp
  800420d254:	48 83 ec 20          	sub    $0x20,%rsp
  800420d258:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420d25c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d260:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420d264:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420d269:	75 35                	jne    800420d2a0 <_dwarf_elf_get_byte_order+0x50>
  800420d26b:	48 b9 e0 6a 21 04 80 	movabs $0x8004216ae0,%rcx
  800420d272:	00 00 00 
  800420d275:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420d27c:	00 00 00 
  800420d27f:	be 29 01 00 00       	mov    $0x129,%esi
  800420d284:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420d28b:	00 00 00 
  800420d28e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d293:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420d29a:	00 00 00 
  800420d29d:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420d2a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d2a4:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420d2a8:	0f b6 c0             	movzbl %al,%eax
  800420d2ab:	83 f8 02             	cmp    $0x2,%eax
  800420d2ae:	75 07                	jne    800420d2b7 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420d2b0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2b5:	eb 05                	jmp    800420d2bc <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420d2b7:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420d2bc:	c9                   	leaveq 
  800420d2bd:	c3                   	retq   

000000800420d2be <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420d2be:	55                   	push   %rbp
  800420d2bf:	48 89 e5             	mov    %rsp,%rbp
  800420d2c2:	48 83 ec 20          	sub    $0x20,%rsp
  800420d2c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420d2ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420d2d2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420d2d7:	75 35                	jne    800420d30e <_dwarf_elf_get_pointer_size+0x50>
  800420d2d9:	48 b9 e0 6a 21 04 80 	movabs $0x8004216ae0,%rcx
  800420d2e0:	00 00 00 
  800420d2e3:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420d2ea:	00 00 00 
  800420d2ed:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420d2f2:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420d2f9:	00 00 00 
  800420d2fc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d301:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420d308:	00 00 00 
  800420d30b:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420d30e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d312:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420d316:	3c 01                	cmp    $0x1,%al
  800420d318:	75 07                	jne    800420d321 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420d31a:	b8 04 00 00 00       	mov    $0x4,%eax
  800420d31f:	eb 05                	jmp    800420d326 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420d321:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420d326:	c9                   	leaveq 
  800420d327:	c3                   	retq   

000000800420d328 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420d328:	55                   	push   %rbp
  800420d329:	48 89 e5             	mov    %rsp,%rbp
  800420d32c:	48 83 ec 10          	sub    $0x10,%rsp
  800420d330:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d334:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420d338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d33c:	ba 60 00 00 00       	mov    $0x60,%edx
  800420d341:	be 00 00 00 00       	mov    $0x0,%esi
  800420d346:	48 89 c7             	mov    %rax,%rdi
  800420d349:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420d350:	00 00 00 
  800420d353:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420d355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d359:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420d360:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d364:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420d36b:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420d36c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d370:	48 89 c7             	mov    %rax,%rdi
  800420d373:	48 b8 be d2 20 04 80 	movabs $0x800420d2be,%rax
  800420d37a:	00 00 00 
  800420d37d:	ff d0                	callq  *%rax
  800420d37f:	0f b6 d0             	movzbl %al,%edx
  800420d382:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d386:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420d389:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d38d:	48 89 c7             	mov    %rax,%rdi
  800420d390:	48 b8 50 d2 20 04 80 	movabs $0x800420d250,%rax
  800420d397:	00 00 00 
  800420d39a:	ff d0                	callq  *%rax
  800420d39c:	85 c0                	test   %eax,%eax
  800420d39e:	75 26                	jne    800420d3c6 <_dwarf_init+0x9e>
		dbg->read = _dwarf_read_msb;
  800420d3a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d3a4:	48 b9 f5 cb 20 04 80 	movabs $0x800420cbf5,%rcx
  800420d3ab:	00 00 00 
  800420d3ae:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420d3b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d3b6:	48 b9 a7 cd 20 04 80 	movabs $0x800420cda7,%rcx
  800420d3bd:	00 00 00 
  800420d3c0:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420d3c4:	eb 24                	jmp    800420d3ea <_dwarf_init+0xc2>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420d3c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d3ca:	48 be a8 c9 20 04 80 	movabs $0x800420c9a8,%rsi
  800420d3d1:	00 00 00 
  800420d3d4:	48 89 70 18          	mov    %rsi,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420d3d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d3dc:	48 ba d4 ca 20 04 80 	movabs $0x800420cad4,%rdx
  800420d3e3:	00 00 00 
  800420d3e6:	48 89 50 20          	mov    %rdx,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420d3ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d3ee:	48 89 c7             	mov    %rax,%rdi
  800420d3f1:	48 b8 2e e8 20 04 80 	movabs $0x800420e82e,%rax
  800420d3f8:	00 00 00 
  800420d3fb:	ff d0                	callq  *%rax
	return 0;
  800420d3fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d402:	c9                   	leaveq 
  800420d403:	c3                   	retq   

000000800420d404 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420d404:	55                   	push   %rbp
  800420d405:	48 89 e5             	mov    %rsp,%rbp
  800420d408:	48 83 ec 20          	sub    $0x20,%rsp
  800420d40c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d410:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420d414:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d418:	48 8b 10             	mov    (%rax),%rdx
  800420d41b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d41f:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420d423:	48 39 c2             	cmp    %rax,%rdx
  800420d426:	76 0a                	jbe    800420d432 <_get_next_cu+0x2e>
		return -1;
  800420d428:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420d42d:	e9 71 01 00 00       	jmpq   800420d5a3 <_get_next_cu+0x19f>

	offset = dbg->curr_off_dbginfo;
  800420d432:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d436:	48 8b 00             	mov    (%rax),%rax
  800420d439:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420d43d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d441:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d445:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420d449:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d44d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d451:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d455:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420d459:	48 89 d7             	mov    %rdx,%rdi
  800420d45c:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d460:	ba 04 00 00 00       	mov    $0x4,%edx
  800420d465:	48 89 ce             	mov    %rcx,%rsi
  800420d468:	ff d0                	callq  *%rax
  800420d46a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420d46d:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420d471:	75 2a                	jne    800420d49d <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420d473:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d477:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d47b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d47f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420d483:	48 89 d7             	mov    %rdx,%rdi
  800420d486:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d48a:	ba 08 00 00 00       	mov    $0x8,%edx
  800420d48f:	48 89 ce             	mov    %rcx,%rsi
  800420d492:	ff d0                	callq  *%rax
  800420d494:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420d497:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420d49b:	eb 04                	jmp    800420d4a1 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420d49d:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420d4a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d4a5:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420d4a9:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420d4ac:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420d4af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4b3:	48 01 c2             	add    %rax,%rdx
  800420d4b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d4ba:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420d4bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d4c1:	48 8b 10             	mov    (%rax),%rdx
  800420d4c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d4c8:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420d4cc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420d4cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d4d3:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420d4d6:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420d4da:	75 07                	jne    800420d4e3 <_get_next_cu+0xdf>
  800420d4dc:	ba 04 00 00 00       	mov    $0x4,%edx
  800420d4e1:	eb 05                	jmp    800420d4e8 <_get_next_cu+0xe4>
  800420d4e3:	ba 0c 00 00 00       	mov    $0xc,%edx
  800420d4e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d4ec:	88 50 18             	mov    %dl,0x18(%rax)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420d4ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d4f3:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d4f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d4fb:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420d4ff:	48 89 d7             	mov    %rdx,%rdi
  800420d502:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d506:	ba 02 00 00 00       	mov    $0x2,%edx
  800420d50b:	48 89 ce             	mov    %rcx,%rsi
  800420d50e:	ff d0                	callq  *%rax
  800420d510:	89 c2                	mov    %eax,%edx
  800420d512:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d516:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420d51a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d51e:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d522:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420d526:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d52a:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420d52e:	48 89 cf             	mov    %rcx,%rdi
  800420d531:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d535:	48 89 ce             	mov    %rcx,%rsi
  800420d538:	ff d0                	callq  *%rax
  800420d53a:	48 89 c2             	mov    %rax,%rdx
  800420d53d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d541:	48 89 50 10          	mov    %rdx,0x10(%rax)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420d545:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d549:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d54d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d551:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420d555:	48 89 d7             	mov    %rdx,%rdi
  800420d558:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d55c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d561:	48 89 ce             	mov    %rcx,%rsi
  800420d564:	ff d0                	callq  *%rax
  800420d566:	89 c2                	mov    %eax,%edx
  800420d568:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d56c:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420d56f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d573:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420d577:	66 83 f8 01          	cmp    $0x1,%ax
  800420d57b:	76 0e                	jbe    800420d58b <_get_next_cu+0x187>
  800420d57d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d581:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420d585:	66 83 f8 04          	cmp    $0x4,%ax
  800420d589:	76 07                	jbe    800420d592 <_get_next_cu+0x18e>
		return -1;
  800420d58b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420d590:	eb 11                	jmp    800420d5a3 <_get_next_cu+0x19f>
	}

	cu->cu_die_offset = offset;
  800420d592:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d596:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d59a:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420d59e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d5a3:	c9                   	leaveq 
  800420d5a4:	c3                   	retq   

000000800420d5a5 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420d5a5:	55                   	push   %rbp
  800420d5a6:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420d5a9:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420d5ad:	0f b6 c8             	movzbl %al,%ecx
  800420d5b0:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420d5b4:	0f b7 d0             	movzwl %ax,%edx
  800420d5b7:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420d5bb:	48 89 c6             	mov    %rax,%rsi
  800420d5be:	48 bf 12 6b 21 04 80 	movabs $0x8004216b12,%rdi
  800420d5c5:	00 00 00 
  800420d5c8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d5cd:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  800420d5d4:	00 00 00 
  800420d5d7:	41 ff d0             	callq  *%r8
}
  800420d5da:	5d                   	pop    %rbp
  800420d5db:	c3                   	retq   

000000800420d5dc <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420d5dc:	55                   	push   %rbp
  800420d5dd:	48 89 e5             	mov    %rsp,%rbp
  800420d5e0:	48 83 ec 60          	sub    $0x60,%rsp
  800420d5e4:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420d5e8:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420d5ec:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420d5f0:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420d5f4:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420d5f9:	75 35                	jne    800420d630 <_dwarf_abbrev_parse+0x54>
  800420d5fb:	48 b9 21 6b 21 04 80 	movabs $0x8004216b21,%rcx
  800420d602:	00 00 00 
  800420d605:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420d60c:	00 00 00 
  800420d60f:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420d614:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420d61b:	00 00 00 
  800420d61e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d623:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420d62a:	00 00 00 
  800420d62d:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420d630:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420d635:	75 35                	jne    800420d66c <_dwarf_abbrev_parse+0x90>
  800420d637:	48 b9 2d 6b 21 04 80 	movabs $0x8004216b2d,%rcx
  800420d63e:	00 00 00 
  800420d641:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420d648:	00 00 00 
  800420d64b:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420d650:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420d657:	00 00 00 
  800420d65a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d65f:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420d666:	00 00 00 
  800420d669:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420d66c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d670:	48 8b 10             	mov    (%rax),%rdx
  800420d673:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420d677:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d67b:	48 39 c2             	cmp    %rax,%rdx
  800420d67e:	72 0a                	jb     800420d68a <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420d680:	b8 04 00 00 00       	mov    $0x4,%eax
  800420d685:	e9 d4 01 00 00       	jmpq   800420d85e <_dwarf_abbrev_parse+0x282>

	aboff = *offset;
  800420d68a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d68e:	48 8b 00             	mov    (%rax),%rax
  800420d691:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420d695:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420d699:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d69d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420d6a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d6a5:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420d6a9:	48 89 d6             	mov    %rdx,%rsi
  800420d6ac:	48 89 c7             	mov    %rax,%rdi
  800420d6af:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420d6b6:	00 00 00 
  800420d6b9:	ff d0                	callq  *%rax
  800420d6bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  800420d6bf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d6c4:	75 15                	jne    800420d6db <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800420d6c6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d6ca:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800420d6d1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d6d6:	e9 83 01 00 00       	jmpq   800420d85e <_dwarf_abbrev_parse+0x282>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420d6db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d6df:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420d6e3:	48 89 d6             	mov    %rdx,%rsi
  800420d6e6:	48 89 c7             	mov    %rax,%rdi
  800420d6e9:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420d6f0:	00 00 00 
  800420d6f3:	ff d0                	callq  *%rax
  800420d6f5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420d6f9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420d6fd:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d701:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420d705:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420d709:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d70e:	48 89 cf             	mov    %rcx,%rdi
  800420d711:	ff d0                	callq  *%rax
  800420d713:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800420d716:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d71a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d71e:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  800420d721:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d725:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d729:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  800420d72d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d731:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420d735:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  800420d738:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d73c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d740:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  800420d744:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d748:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420d74f:	00 
	abp->ab_atnum    = 0;
  800420d750:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d754:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420d75b:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  800420d75c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d760:	48 8b 00             	mov    (%rax),%rax
  800420d763:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420d767:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d76b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420d76f:	48 89 d6             	mov    %rdx,%rsi
  800420d772:	48 89 c7             	mov    %rax,%rdi
  800420d775:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420d77c:	00 00 00 
  800420d77f:	ff d0                	callq  *%rax
  800420d781:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420d785:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d789:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420d78d:	48 89 d6             	mov    %rdx,%rsi
  800420d790:	48 89 c7             	mov    %rax,%rdi
  800420d793:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420d79a:	00 00 00 
  800420d79d:	ff d0                	callq  *%rax
  800420d79f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800420d7a3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d7a8:	0f 84 8a 00 00 00    	je     800420d838 <_dwarf_abbrev_parse+0x25c>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420d7ae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d7b2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d7b6:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420d7ba:	48 89 d0             	mov    %rdx,%rax
  800420d7bd:	48 01 c0             	add    %rax,%rax
  800420d7c0:	48 01 d0             	add    %rdx,%rax
  800420d7c3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7c7:	48 01 c8             	add    %rcx,%rax
  800420d7ca:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420d7ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d7d2:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420d7d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d7d9:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d7dd:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420d7e1:	48 89 d0             	mov    %rdx,%rax
  800420d7e4:	48 01 c0             	add    %rax,%rax
  800420d7e7:	48 01 d0             	add    %rdx,%rax
  800420d7ea:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7ee:	48 01 c8             	add    %rcx,%rax
  800420d7f1:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420d7f5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420d7f9:	48 89 42 08          	mov    %rax,0x8(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420d7fd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d801:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d805:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420d809:	48 89 d0             	mov    %rdx,%rax
  800420d80c:	48 01 c0             	add    %rax,%rax
  800420d80f:	48 01 d0             	add    %rdx,%rax
  800420d812:	48 c1 e0 03          	shl    $0x3,%rax
  800420d816:	48 01 c8             	add    %rcx,%rax
  800420d819:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420d81d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d821:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800420d824:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d828:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d82c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d830:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d834:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800420d838:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d83d:	0f 85 19 ff ff ff    	jne    800420d75c <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800420d843:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d847:	48 8b 00             	mov    (%rax),%rax
  800420d84a:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420d84e:	48 89 c2             	mov    %rax,%rdx
  800420d851:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d855:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  800420d859:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d85e:	c9                   	leaveq 
  800420d85f:	c3                   	retq   

000000800420d860 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420d860:	55                   	push   %rbp
  800420d861:	48 89 e5             	mov    %rsp,%rbp
  800420d864:	48 83 ec 40          	sub    $0x40,%rsp
  800420d868:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420d86c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420d870:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800420d874:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420d879:	75 0a                	jne    800420d885 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  800420d87b:	b8 04 00 00 00       	mov    $0x4,%eax
  800420d880:	e9 e2 00 00 00       	jmpq   800420d967 <_dwarf_abbrev_find+0x107>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800420d885:	48 bf 38 6b 21 04 80 	movabs $0x8004216b38,%rdi
  800420d88c:	00 00 00 
  800420d88f:	48 b8 cd 1a 21 04 80 	movabs $0x8004211acd,%rax
  800420d896:	00 00 00 
  800420d899:	ff d0                	callq  *%rax
  800420d89b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  800420d89f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420d8a4:	75 35                	jne    800420d8db <_dwarf_abbrev_find+0x7b>
  800420d8a6:	48 b9 2d 6b 21 04 80 	movabs $0x8004216b2d,%rcx
  800420d8ad:	00 00 00 
  800420d8b0:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420d8b7:	00 00 00 
  800420d8ba:	be e5 01 00 00       	mov    $0x1e5,%esi
  800420d8bf:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420d8c6:	00 00 00 
  800420d8c9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d8ce:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420d8d5:	00 00 00 
  800420d8d8:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  800420d8db:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420d8df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  800420d8e3:	eb 6c                	jmp    800420d951 <_dwarf_abbrev_find+0xf1>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800420d8e5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420d8e9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d8ed:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800420d8f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d8f5:	48 83 ec 08          	sub    $0x8,%rsp
  800420d8f9:	ff 75 40             	pushq  0x40(%rbp)
  800420d8fc:	ff 75 38             	pushq  0x38(%rbp)
  800420d8ff:	ff 75 30             	pushq  0x30(%rbp)
  800420d902:	ff 75 28             	pushq  0x28(%rbp)
  800420d905:	ff 75 20             	pushq  0x20(%rbp)
  800420d908:	ff 75 18             	pushq  0x18(%rbp)
  800420d90b:	ff 75 10             	pushq  0x10(%rbp)
  800420d90e:	48 89 c7             	mov    %rax,%rdi
  800420d911:	48 b8 dc d5 20 04 80 	movabs $0x800420d5dc,%rax
  800420d918:	00 00 00 
  800420d91b:	ff d0                	callq  *%rax
  800420d91d:	48 83 c4 40          	add    $0x40,%rsp
  800420d921:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  800420d924:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420d928:	74 05                	je     800420d92f <_dwarf_abbrev_find+0xcf>
			return (ret);
  800420d92a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d92d:	eb 38                	jmp    800420d967 <_dwarf_abbrev_find+0x107>
		if (abp->ab_entry == entry) {
  800420d92f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d933:	48 8b 00             	mov    (%rax),%rax
  800420d936:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420d93a:	75 07                	jne    800420d943 <_dwarf_abbrev_find+0xe3>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  800420d93c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d941:	eb 24                	jmp    800420d967 <_dwarf_abbrev_find+0x107>
		}
		if (abp->ab_entry == 0) {
  800420d943:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d947:	48 8b 00             	mov    (%rax),%rax
  800420d94a:	48 85 c0             	test   %rax,%rax
  800420d94d:	75 02                	jne    800420d951 <_dwarf_abbrev_find+0xf1>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  800420d94f:	eb 11                	jmp    800420d962 <_dwarf_abbrev_find+0x102>
	while (offset < ds->ds_size) {
  800420d951:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d955:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420d959:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d95d:	48 39 c2             	cmp    %rax,%rdx
  800420d960:	77 83                	ja     800420d8e5 <_dwarf_abbrev_find+0x85>
		}
	}

	return DW_DLE_NO_ENTRY;
  800420d962:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420d967:	c9                   	leaveq 
  800420d968:	c3                   	retq   

000000800420d969 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  800420d969:	55                   	push   %rbp
  800420d96a:	48 89 e5             	mov    %rsp,%rbp
  800420d96d:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
  800420d974:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420d97b:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800420d982:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800420d989:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800420d990:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800420d997:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800420d99e:	48 bf 46 6b 21 04 80 	movabs $0x8004216b46,%rdi
  800420d9a5:	00 00 00 
  800420d9a8:	48 b8 cd 1a 21 04 80 	movabs $0x8004211acd,%rax
  800420d9af:	00 00 00 
  800420d9b2:	ff d0                	callq  *%rax
  800420d9b4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  800420d9b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d9bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d9c0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800420d9c4:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420d9cb:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800420d9cf:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  800420d9d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  800420d9d9:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800420d9e0:	ba 60 00 00 00       	mov    $0x60,%edx
  800420d9e5:	be 00 00 00 00       	mov    $0x0,%esi
  800420d9ea:	48 89 c7             	mov    %rax,%rdi
  800420d9ed:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420d9f4:	00 00 00 
  800420d9f7:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  800420d9f9:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420da00:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  800420da07:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420da0e:	48 8b 00             	mov    (%rax),%rax
  800420da11:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  800420da15:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420da1c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420da20:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  800420da24:	8b 45 10             	mov    0x10(%rbp),%eax
  800420da27:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  800420da2a:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420da31:	00 

	switch (form) {
  800420da32:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800420da39:	20 
  800420da3a:	0f 87 85 04 00 00    	ja     800420dec5 <_dwarf_attr_init+0x55c>
  800420da40:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800420da47:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420da4e:	00 
  800420da4f:	48 b8 70 6b 21 04 80 	movabs $0x8004216b70,%rax
  800420da56:	00 00 00 
  800420da59:	48 01 d0             	add    %rdx,%rax
  800420da5c:	48 8b 00             	mov    (%rax),%rax
  800420da5f:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420da61:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420da68:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420da6c:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420da73:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420da77:	0f b6 d2             	movzbl %dl,%edx
  800420da7a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420da81:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420da85:	48 89 cf             	mov    %rcx,%rdi
  800420da88:	ff d0                	callq  *%rax
  800420da8a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420da8e:	e9 3a 04 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420da93:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420da9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da9e:	48 89 d6             	mov    %rdx,%rsi
  800420daa1:	48 89 c7             	mov    %rax,%rdi
  800420daa4:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420daab:	00 00 00 
  800420daae:	ff d0                	callq  *%rax
  800420dab0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420dab4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420dab8:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420dabf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dac3:	48 89 ce             	mov    %rcx,%rsi
  800420dac6:	48 89 c7             	mov    %rax,%rdi
  800420dac9:	48 b8 07 d2 20 04 80 	movabs $0x800420d207,%rax
  800420dad0:	00 00 00 
  800420dad3:	ff d0                	callq  *%rax
  800420dad5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420dad9:	e9 ef 03 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420dade:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dae5:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dae9:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420daf0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420daf4:	ba 01 00 00 00       	mov    $0x1,%edx
  800420daf9:	48 89 cf             	mov    %rcx,%rdi
  800420dafc:	ff d0                	callq  *%rax
  800420dafe:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420db02:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420db06:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420db0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db11:	48 89 ce             	mov    %rcx,%rsi
  800420db14:	48 89 c7             	mov    %rax,%rdi
  800420db17:	48 b8 07 d2 20 04 80 	movabs $0x800420d207,%rax
  800420db1e:	00 00 00 
  800420db21:	ff d0                	callq  *%rax
  800420db23:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420db27:	e9 a1 03 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420db2c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420db33:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420db37:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420db3e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420db42:	ba 02 00 00 00       	mov    $0x2,%edx
  800420db47:	48 89 cf             	mov    %rcx,%rdi
  800420db4a:	ff d0                	callq  *%rax
  800420db4c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420db50:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420db54:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420db5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db5f:	48 89 ce             	mov    %rcx,%rsi
  800420db62:	48 89 c7             	mov    %rax,%rdi
  800420db65:	48 b8 07 d2 20 04 80 	movabs $0x800420d207,%rax
  800420db6c:	00 00 00 
  800420db6f:	ff d0                	callq  *%rax
  800420db71:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420db75:	e9 53 03 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420db7a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420db81:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420db85:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420db8c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420db90:	ba 04 00 00 00       	mov    $0x4,%edx
  800420db95:	48 89 cf             	mov    %rcx,%rdi
  800420db98:	ff d0                	callq  *%rax
  800420db9a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420db9e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420dba2:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420dba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbad:	48 89 ce             	mov    %rcx,%rsi
  800420dbb0:	48 89 c7             	mov    %rax,%rdi
  800420dbb3:	48 b8 07 d2 20 04 80 	movabs $0x800420d207,%rax
  800420dbba:	00 00 00 
  800420dbbd:	ff d0                	callq  *%rax
  800420dbbf:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420dbc3:	e9 05 03 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420dbc8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dbcf:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dbd3:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dbda:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420dbde:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dbe3:	48 89 cf             	mov    %rcx,%rdi
  800420dbe6:	ff d0                	callq  *%rax
  800420dbe8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dbec:	e9 dc 02 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420dbf1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dbf8:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dbfc:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dc03:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420dc07:	ba 02 00 00 00       	mov    $0x2,%edx
  800420dc0c:	48 89 cf             	mov    %rcx,%rdi
  800420dc0f:	ff d0                	callq  *%rax
  800420dc11:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dc15:	e9 b3 02 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420dc1a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dc21:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dc25:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dc2c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420dc30:	ba 04 00 00 00       	mov    $0x4,%edx
  800420dc35:	48 89 cf             	mov    %rcx,%rdi
  800420dc38:	ff d0                	callq  *%rax
  800420dc3a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dc3e:	e9 8a 02 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800420dc43:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dc4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dc4e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dc55:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420dc59:	ba 08 00 00 00       	mov    $0x8,%edx
  800420dc5e:	48 89 cf             	mov    %rcx,%rdi
  800420dc61:	ff d0                	callq  *%rax
  800420dc63:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dc67:	e9 61 02 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  800420dc6c:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420dc73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc77:	48 89 d6             	mov    %rdx,%rsi
  800420dc7a:	48 89 c7             	mov    %rax,%rdi
  800420dc7d:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420dc84:	00 00 00 
  800420dc87:	ff d0                	callq  *%rax
  800420dc89:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800420dc90:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800420dc97:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  800420dc9e:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420dca5:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420dcac:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dcb3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dcba:	48 83 ec 08          	sub    $0x8,%rsp
  800420dcbe:	6a 01                	pushq  $0x1
  800420dcc0:	4d 89 c1             	mov    %r8,%r9
  800420dcc3:	49 89 f8             	mov    %rdi,%r8
  800420dcc6:	48 89 c7             	mov    %rax,%rdi
  800420dcc9:	48 b8 69 d9 20 04 80 	movabs $0x800420d969,%rax
  800420dcd0:	00 00 00 
  800420dcd3:	ff d0                	callq  *%rax
  800420dcd5:	48 83 c4 10          	add    $0x10,%rsp
  800420dcd9:	e9 1d 03 00 00       	jmpq   800420dffb <_dwarf_attr_init+0x692>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  800420dcde:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420dce5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420dce9:	66 83 f8 02          	cmp    $0x2,%ax
  800420dced:	75 2f                	jne    800420dd1e <_dwarf_attr_init+0x3b5>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420dcef:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dcf6:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dcfa:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420dd01:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420dd05:	0f b6 d2             	movzbl %dl,%edx
  800420dd08:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dd0f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420dd13:	48 89 cf             	mov    %rcx,%rdi
  800420dd16:	ff d0                	callq  *%rax
  800420dd18:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800420dd1c:	eb 39                	jmp    800420dd57 <_dwarf_attr_init+0x3ee>
		else if (cu->version == 3)
  800420dd1e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420dd25:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420dd29:	66 83 f8 03          	cmp    $0x3,%ax
  800420dd2d:	75 28                	jne    800420dd57 <_dwarf_attr_init+0x3ee>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420dd2f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dd36:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dd3a:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420dd3e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420dd45:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420dd49:	48 89 cf             	mov    %rcx,%rdi
  800420dd4c:	ff d0                	callq  *%rax
  800420dd4e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dd52:	e9 76 01 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
  800420dd57:	e9 71 01 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420dd5c:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420dd63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd67:	48 89 d6             	mov    %rdx,%rsi
  800420dd6a:	48 89 c7             	mov    %rax,%rdi
  800420dd6d:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420dd74:	00 00 00 
  800420dd77:	ff d0                	callq  *%rax
  800420dd79:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dd7d:	e9 4b 01 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800420dd82:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420dd89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd8d:	48 89 d6             	mov    %rdx,%rsi
  800420dd90:	48 89 c7             	mov    %rax,%rdi
  800420dd93:	48 b8 56 cf 20 04 80 	movabs $0x800420cf56,%rax
  800420dd9a:	00 00 00 
  800420dd9d:	ff d0                	callq  *%rax
  800420dd9f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420dda3:	e9 25 01 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420dda8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ddaf:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ddb3:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420ddb7:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420ddbe:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ddc2:	48 89 cf             	mov    %rcx,%rdi
  800420ddc5:	ff d0                	callq  *%rax
  800420ddc7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420ddcb:	e9 fd 00 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  800420ddd0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ddd4:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420ddd8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420dddf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dde3:	48 89 ce             	mov    %rcx,%rsi
  800420dde6:	48 89 c7             	mov    %rax,%rdi
  800420dde9:	48 b8 78 d1 20 04 80 	movabs $0x800420d178,%rax
  800420ddf0:	00 00 00 
  800420ddf3:	ff d0                	callq  *%rax
  800420ddf5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420ddf9:	e9 cf 00 00 00       	jmpq   800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420ddfe:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420de05:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420de09:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420de0d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420de14:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420de18:	48 89 cf             	mov    %rcx,%rdi
  800420de1b:	ff d0                	callq  *%rax
  800420de1d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  800420de21:	48 bf 52 6b 21 04 80 	movabs $0x8004216b52,%rdi
  800420de28:	00 00 00 
  800420de2b:	48 b8 cd 1a 21 04 80 	movabs $0x8004211acd,%rax
  800420de32:	00 00 00 
  800420de35:	ff d0                	callq  *%rax
  800420de37:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  800420de3b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420de40:	75 35                	jne    800420de77 <_dwarf_attr_init+0x50e>
  800420de42:	48 b9 5d 6b 21 04 80 	movabs $0x8004216b5d,%rcx
  800420de49:	00 00 00 
  800420de4c:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420de53:	00 00 00 
  800420de56:	be 51 02 00 00       	mov    $0x251,%esi
  800420de5b:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420de62:	00 00 00 
  800420de65:	b8 00 00 00 00       	mov    $0x0,%eax
  800420de6a:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420de71:	00 00 00 
  800420de74:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800420de77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de7b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420de7f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420de83:	48 01 d0             	add    %rdx,%rax
  800420de86:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420de8a:	eb 41                	jmp    800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  800420de8c:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800420de93:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800420de94:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420de98:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420de9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dea3:	48 89 ce             	mov    %rcx,%rsi
  800420dea6:	48 89 c7             	mov    %rax,%rdi
  800420dea9:	48 b8 07 d2 20 04 80 	movabs $0x800420d207,%rax
  800420deb0:	00 00 00 
  800420deb3:	ff d0                	callq  *%rax
  800420deb5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420deb9:	eb 12                	jmp    800420decd <_dwarf_attr_init+0x564>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  800420debb:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800420dec2:	00 
		break;
  800420dec3:	eb 08                	jmp    800420decd <_dwarf_attr_init+0x564>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800420dec5:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  800420decc:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  800420decd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ded1:	0f 85 21 01 00 00    	jne    800420dff8 <_dwarf_attr_init+0x68f>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  800420ded7:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  800420dede:	09 
  800420dedf:	74 1e                	je     800420deff <_dwarf_attr_init+0x596>
  800420dee1:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  800420dee8:	0a 
  800420dee9:	74 14                	je     800420deff <_dwarf_attr_init+0x596>
  800420deeb:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  800420def2:	03 
  800420def3:	74 0a                	je     800420deff <_dwarf_attr_init+0x596>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  800420def5:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  800420defc:	04 
  800420defd:	75 10                	jne    800420df0f <_dwarf_attr_init+0x5a6>
			atref.at_block.bl_len = atref.u[0].u64;
  800420deff:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420df03:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  800420df07:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420df0b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  800420df0f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420df13:	48 83 f8 03          	cmp    $0x3,%rax
  800420df17:	75 39                	jne    800420df52 <_dwarf_attr_init+0x5e9>
			switch (atref.at_form) {
  800420df19:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420df1d:	48 83 f8 08          	cmp    $0x8,%rax
  800420df21:	74 1c                	je     800420df3f <_dwarf_attr_init+0x5d6>
  800420df23:	48 83 f8 0e          	cmp    $0xe,%rax
  800420df27:	74 02                	je     800420df2b <_dwarf_attr_init+0x5c2>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  800420df29:	eb 27                	jmp    800420df52 <_dwarf_attr_init+0x5e9>
				ret_die->die_name = atref.u[1].s;
  800420df2b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420df2f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420df36:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800420df3d:	eb 13                	jmp    800420df52 <_dwarf_attr_init+0x5e9>
				ret_die->die_name = atref.u[0].s;
  800420df3f:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420df43:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420df4a:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800420df51:	90                   	nop
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800420df52:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420df59:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800420df60:	8d 48 01             	lea    0x1(%rax),%ecx
  800420df63:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800420df6a:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  800420df70:	0f b6 c0             	movzbl %al,%eax
  800420df73:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420df7a:	48 63 d0             	movslq %eax,%rdx
  800420df7d:	48 89 d0             	mov    %rdx,%rax
  800420df80:	48 01 c0             	add    %rax,%rax
  800420df83:	48 01 d0             	add    %rdx,%rax
  800420df86:	48 c1 e0 05          	shl    $0x5,%rax
  800420df8a:	48 01 c8             	add    %rcx,%rax
  800420df8d:	48 05 70 03 00 00    	add    $0x370,%rax
  800420df93:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420df9a:	48 89 10             	mov    %rdx,(%rax)
  800420df9d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420dfa4:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800420dfa8:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800420dfac:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800420dfb0:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800420dfb4:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800420dfb8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420dfbc:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800420dfc0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420dfc4:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800420dfc8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dfcc:	48 89 50 30          	mov    %rdx,0x30(%rax)
  800420dfd0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420dfd4:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800420dfd8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420dfdc:	48 89 50 40          	mov    %rdx,0x40(%rax)
  800420dfe0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420dfe4:	48 89 50 48          	mov    %rdx,0x48(%rax)
  800420dfe8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420dfec:	48 89 50 50          	mov    %rdx,0x50(%rax)
  800420dff0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dff4:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  800420dff8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420dffb:	c9                   	leaveq 
  800420dffc:	c3                   	retq   

000000800420dffd <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  800420dffd:	55                   	push   %rbp
  800420dffe:	48 89 e5             	mov    %rsp,%rbp
  800420e001:	48 81 ec 90 03 00 00 	sub    $0x390,%rsp
  800420e008:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  800420e00f:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  800420e016:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  800420e01d:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  800420e023:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  800420e02a:	00 
  800420e02b:	75 35                	jne    800420e062 <dwarf_search_die_within_cu+0x65>
  800420e02d:	48 b9 78 6c 21 04 80 	movabs $0x8004216c78,%rcx
  800420e034:	00 00 00 
  800420e037:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e03e:	00 00 00 
  800420e041:	be 86 02 00 00       	mov    $0x286,%esi
  800420e046:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e04d:	00 00 00 
  800420e050:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e055:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e05c:	00 00 00 
  800420e05f:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  800420e062:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  800420e069:	00 
  800420e06a:	75 35                	jne    800420e0a1 <dwarf_search_die_within_cu+0xa4>
  800420e06c:	48 b9 7c 6c 21 04 80 	movabs $0x8004216c7c,%rcx
  800420e073:	00 00 00 
  800420e076:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e07d:	00 00 00 
  800420e080:	be 88 02 00 00       	mov    $0x288,%esi
  800420e085:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e08c:	00 00 00 
  800420e08f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e094:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e09b:	00 00 00 
  800420e09e:	41 ff d0             	callq  *%r8

	level = 1;
  800420e0a1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800420e0a8:	e9 fb 01 00 00       	jmpq   800420e2a8 <dwarf_search_die_within_cu+0x2ab>

		die_offset = offset;
  800420e0ad:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420e0b4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  800420e0b8:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420e0bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e0c3:	48 89 c2             	mov    %rax,%rdx
  800420e0c6:	48 8d 85 80 fc ff ff 	lea    -0x380(%rbp),%rax
  800420e0cd:	48 89 c6             	mov    %rax,%rsi
  800420e0d0:	48 89 d7             	mov    %rdx,%rdi
  800420e0d3:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420e0da:	00 00 00 
  800420e0dd:	ff d0                	callq  *%rax
  800420e0df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  800420e0e3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e0e8:	75 22                	jne    800420e10c <dwarf_search_die_within_cu+0x10f>
			if (level == 0 || !search_sibling) {
  800420e0ea:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e0ee:	74 09                	je     800420e0f9 <dwarf_search_die_within_cu+0xfc>
  800420e0f0:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800420e0f7:	75 0a                	jne    800420e103 <dwarf_search_die_within_cu+0x106>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  800420e0f9:	b8 04 00 00 00       	mov    $0x4,%eax
  800420e0fe:	e9 d5 01 00 00       	jmpq   800420e2d8 <dwarf_search_die_within_cu+0x2db>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  800420e103:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  800420e107:	e9 9c 01 00 00       	jmpq   800420e2a8 <dwarf_search_die_within_cu+0x2ab>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  800420e10c:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800420e113:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e117:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420e11e:	48 83 ec 08          	sub    $0x8,%rsp
  800420e122:	ff 75 40             	pushq  0x40(%rbp)
  800420e125:	ff 75 38             	pushq  0x38(%rbp)
  800420e128:	ff 75 30             	pushq  0x30(%rbp)
  800420e12b:	ff 75 28             	pushq  0x28(%rbp)
  800420e12e:	ff 75 20             	pushq  0x20(%rbp)
  800420e131:	ff 75 18             	pushq  0x18(%rbp)
  800420e134:	ff 75 10             	pushq  0x10(%rbp)
  800420e137:	48 89 ce             	mov    %rcx,%rsi
  800420e13a:	48 89 c7             	mov    %rax,%rdi
  800420e13d:	48 b8 60 d8 20 04 80 	movabs $0x800420d860,%rax
  800420e144:	00 00 00 
  800420e147:	ff d0                	callq  *%rax
  800420e149:	48 83 c4 40          	add    $0x40,%rsp
  800420e14d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420e150:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e154:	74 08                	je     800420e15e <dwarf_search_die_within_cu+0x161>
			return (ret);
  800420e156:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e159:	e9 7a 01 00 00       	jmpq   800420e2d8 <dwarf_search_die_within_cu+0x2db>
		ret_die->die_offset = die_offset;
  800420e15e:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420e165:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e169:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800420e16c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420e173:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e177:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  800420e17b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420e182:	48 8d 50 20          	lea    0x20(%rax),%rdx
  800420e186:	48 8d 85 b0 fc ff ff 	lea    -0x350(%rbp),%rax
  800420e18d:	b9 66 00 00 00       	mov    $0x66,%ecx
  800420e192:	48 89 d7             	mov    %rdx,%rdi
  800420e195:	48 89 c6             	mov    %rax,%rsi
  800420e198:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  800420e19b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420e1a2:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  800420e1a9:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800420e1b0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420e1b7:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800420e1bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420e1c2:	e9 92 00 00 00       	jmpq   800420e259 <dwarf_search_die_within_cu+0x25c>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  800420e1c7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420e1ca:	48 63 d0             	movslq %eax,%rdx
  800420e1cd:	48 89 d0             	mov    %rdx,%rax
  800420e1d0:	48 01 c0             	add    %rax,%rax
  800420e1d3:	48 01 d0             	add    %rdx,%rax
  800420e1d6:	48 c1 e0 03          	shl    $0x3,%rax
  800420e1da:	48 01 e8             	add    %rbp,%rax
  800420e1dd:	48 2d 20 03 00 00    	sub    $0x320,%rax
  800420e1e3:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420e1e7:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  800420e1ee:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420e1f1:	48 63 d0             	movslq %eax,%rdx
  800420e1f4:	48 89 d0             	mov    %rdx,%rax
  800420e1f7:	48 01 c0             	add    %rax,%rax
  800420e1fa:	48 01 d0             	add    %rdx,%rax
  800420e1fd:	48 c1 e0 03          	shl    $0x3,%rax
  800420e201:	48 83 c0 30          	add    $0x30,%rax
  800420e205:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  800420e209:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  800420e210:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  800420e217:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420e21e:	48 83 ec 08          	sub    $0x8,%rsp
  800420e222:	6a 00                	pushq  $0x0
  800420e224:	49 89 c9             	mov    %rcx,%r9
  800420e227:	49 89 f8             	mov    %rdi,%r8
  800420e22a:	48 89 d1             	mov    %rdx,%rcx
  800420e22d:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  800420e231:	48 89 c7             	mov    %rax,%rdi
  800420e234:	48 b8 69 d9 20 04 80 	movabs $0x800420d969,%rax
  800420e23b:	00 00 00 
  800420e23e:	ff d0                	callq  *%rax
  800420e240:	48 83 c4 10          	add    $0x10,%rsp
  800420e244:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420e247:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e24b:	74 08                	je     800420e255 <dwarf_search_die_within_cu+0x258>
				return (ret);
  800420e24d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e250:	e9 83 00 00 00       	jmpq   800420e2d8 <dwarf_search_die_within_cu+0x2db>
		for(i=0; i < ab.ab_atnum; i++)
  800420e255:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420e259:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420e25c:	48 63 d0             	movslq %eax,%rdx
  800420e25f:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  800420e266:	48 39 c2             	cmp    %rax,%rdx
  800420e269:	0f 82 58 ff ff ff    	jb     800420e1c7 <dwarf_search_die_within_cu+0x1ca>
		}

		ret_die->die_next_off = offset;
  800420e26f:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  800420e276:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420e27d:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  800420e281:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800420e288:	74 17                	je     800420e2a1 <dwarf_search_die_within_cu+0x2a4>
  800420e28a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e28e:	7e 11                	jle    800420e2a1 <dwarf_search_die_within_cu+0x2a4>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800420e290:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  800420e297:	3c 01                	cmp    $0x1,%al
  800420e299:	75 04                	jne    800420e29f <dwarf_search_die_within_cu+0x2a2>
				/* Advance to next DIE level. */
				level++;
  800420e29b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
			if (ab.ab_children == DW_CHILDREN_yes) {
  800420e29f:	eb 07                	jmp    800420e2a8 <dwarf_search_die_within_cu+0x2ab>
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  800420e2a1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e2a6:	eb 30                	jmp    800420e2d8 <dwarf_search_die_within_cu+0x2db>
	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800420e2a8:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  800420e2ac:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420e2b3:	48 39 c2             	cmp    %rax,%rdx
  800420e2b6:	76 1b                	jbe    800420e2d3 <dwarf_search_die_within_cu+0x2d6>
  800420e2b8:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420e2bf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e2c3:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420e2ca:	48 39 c2             	cmp    %rax,%rdx
  800420e2cd:	0f 87 da fd ff ff    	ja     800420e0ad <dwarf_search_die_within_cu+0xb0>
		}
	}

	return (DW_DLE_NO_ENTRY);
  800420e2d3:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420e2d8:	c9                   	leaveq 
  800420e2d9:	c3                   	retq   

000000800420e2da <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  800420e2da:	55                   	push   %rbp
  800420e2db:	48 89 e5             	mov    %rsp,%rbp
  800420e2de:	48 83 ec 30          	sub    $0x30,%rsp
  800420e2e2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e2e6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e2ea:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  800420e2ee:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e2f3:	75 35                	jne    800420e32a <dwarf_offdie+0x50>
  800420e2f5:	48 b9 78 6c 21 04 80 	movabs $0x8004216c78,%rcx
  800420e2fc:	00 00 00 
  800420e2ff:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e306:	00 00 00 
  800420e309:	be c4 02 00 00       	mov    $0x2c4,%esi
  800420e30e:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e315:	00 00 00 
  800420e318:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e31d:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e324:	00 00 00 
  800420e327:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420e32a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e32f:	75 35                	jne    800420e366 <dwarf_offdie+0x8c>
  800420e331:	48 b9 7c 6c 21 04 80 	movabs $0x8004216c7c,%rcx
  800420e338:	00 00 00 
  800420e33b:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e342:	00 00 00 
  800420e345:	be c5 02 00 00       	mov    $0x2c5,%esi
  800420e34a:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e351:	00 00 00 
  800420e354:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e359:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e360:	00 00 00 
  800420e363:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  800420e366:	48 8b 45 30          	mov    0x30(%rbp),%rax
  800420e36a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420e36e:	76 45                	jbe    800420e3b5 <dwarf_offdie+0xdb>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800420e370:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420e374:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e378:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e37c:	48 83 ec 08          	sub    $0x8,%rsp
  800420e380:	ff 75 40             	pushq  0x40(%rbp)
  800420e383:	ff 75 38             	pushq  0x38(%rbp)
  800420e386:	ff 75 30             	pushq  0x30(%rbp)
  800420e389:	ff 75 28             	pushq  0x28(%rbp)
  800420e38c:	ff 75 20             	pushq  0x20(%rbp)
  800420e38f:	ff 75 18             	pushq  0x18(%rbp)
  800420e392:	ff 75 10             	pushq  0x10(%rbp)
  800420e395:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e39a:	48 89 c7             	mov    %rax,%rdi
  800420e39d:	48 b8 fd df 20 04 80 	movabs $0x800420dffd,%rax
  800420e3a4:	00 00 00 
  800420e3a7:	ff d0                	callq  *%rax
  800420e3a9:	48 83 c4 40          	add    $0x40,%rsp
  800420e3ad:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  800420e3b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e3b3:	eb 05                	jmp    800420e3ba <dwarf_offdie+0xe0>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  800420e3b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e3ba:	c9                   	leaveq 
  800420e3bb:	c3                   	retq   

000000800420e3bc <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  800420e3bc:	55                   	push   %rbp
  800420e3bd:	48 89 e5             	mov    %rsp,%rbp
  800420e3c0:	48 83 ec 20          	sub    $0x20,%rsp
  800420e3c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e3c8:	89 f0                	mov    %esi,%eax
  800420e3ca:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  800420e3ce:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e3d5:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800420e3d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800420e3dd:	eb 57                	jmp    800420e436 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  800420e3df:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e3e3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e3e6:	48 63 d0             	movslq %eax,%rdx
  800420e3e9:	48 89 d0             	mov    %rdx,%rax
  800420e3ec:	48 01 c0             	add    %rax,%rax
  800420e3ef:	48 01 d0             	add    %rdx,%rax
  800420e3f2:	48 c1 e0 05          	shl    $0x5,%rax
  800420e3f6:	48 01 c8             	add    %rcx,%rax
  800420e3f9:	48 05 80 03 00 00    	add    $0x380,%rax
  800420e3ff:	48 8b 10             	mov    (%rax),%rdx
  800420e402:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  800420e406:	48 39 c2             	cmp    %rax,%rdx
  800420e409:	75 27                	jne    800420e432 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  800420e40b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e40e:	48 63 d0             	movslq %eax,%rdx
  800420e411:	48 89 d0             	mov    %rdx,%rax
  800420e414:	48 01 c0             	add    %rax,%rax
  800420e417:	48 01 d0             	add    %rdx,%rax
  800420e41a:	48 c1 e0 05          	shl    $0x5,%rax
  800420e41e:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  800420e425:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e429:	48 01 d0             	add    %rdx,%rax
  800420e42c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420e430:	eb 17                	jmp    800420e449 <_dwarf_attr_find+0x8d>
	for(i=0; i < die->die_attr_count; i++)
  800420e432:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420e436:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e43a:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800420e441:	0f b6 c0             	movzbl %al,%eax
  800420e444:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800420e447:	7f 96                	jg     800420e3df <_dwarf_attr_find+0x23>
		}
	}

	return myat;
  800420e449:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e44d:	c9                   	leaveq 
  800420e44e:	c3                   	retq   

000000800420e44f <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  800420e44f:	55                   	push   %rbp
  800420e450:	48 89 e5             	mov    %rsp,%rbp
  800420e453:	48 83 ec 40          	sub    $0x40,%rsp
  800420e457:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420e45b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420e45f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420e463:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  800420e467:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e46c:	75 35                	jne    800420e4a3 <dwarf_siblingof+0x54>
  800420e46e:	48 b9 78 6c 21 04 80 	movabs $0x8004216c78,%rcx
  800420e475:	00 00 00 
  800420e478:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e47f:	00 00 00 
  800420e482:	be ec 02 00 00       	mov    $0x2ec,%esi
  800420e487:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e48e:	00 00 00 
  800420e491:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e496:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e49d:	00 00 00 
  800420e4a0:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420e4a3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e4a8:	75 35                	jne    800420e4df <dwarf_siblingof+0x90>
  800420e4aa:	48 b9 7c 6c 21 04 80 	movabs $0x8004216c7c,%rcx
  800420e4b1:	00 00 00 
  800420e4b4:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e4bb:	00 00 00 
  800420e4be:	be ed 02 00 00       	mov    $0x2ed,%esi
  800420e4c3:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e4ca:	00 00 00 
  800420e4cd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e4d2:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e4d9:	00 00 00 
  800420e4dc:	41 ff d0             	callq  *%r8
	assert(cu);
  800420e4df:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420e4e4:	75 35                	jne    800420e51b <dwarf_siblingof+0xcc>
  800420e4e6:	48 b9 84 6c 21 04 80 	movabs $0x8004216c84,%rcx
  800420e4ed:	00 00 00 
  800420e4f0:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e4f7:	00 00 00 
  800420e4fa:	be ee 02 00 00       	mov    $0x2ee,%esi
  800420e4ff:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e506:	00 00 00 
  800420e509:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e50e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e515:	00 00 00 
  800420e518:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  800420e51b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420e520:	75 44                	jne    800420e566 <dwarf_siblingof+0x117>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  800420e522:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e526:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800420e52a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e52e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e532:	48 83 ec 08          	sub    $0x8,%rsp
  800420e536:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e53a:	ff 70 30             	pushq  0x30(%rax)
  800420e53d:	ff 70 28             	pushq  0x28(%rax)
  800420e540:	ff 70 20             	pushq  0x20(%rax)
  800420e543:	ff 70 18             	pushq  0x18(%rax)
  800420e546:	ff 70 10             	pushq  0x10(%rax)
  800420e549:	ff 70 08             	pushq  0x8(%rax)
  800420e54c:	ff 30                	pushq  (%rax)
  800420e54e:	48 89 cf             	mov    %rcx,%rdi
  800420e551:	48 b8 da e2 20 04 80 	movabs $0x800420e2da,%rax
  800420e558:	00 00 00 
  800420e55b:	ff d0                	callq  *%rax
  800420e55d:	48 83 c4 40          	add    $0x40,%rsp
  800420e561:	e9 e9 00 00 00       	jmpq   800420e64f <dwarf_siblingof+0x200>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  800420e566:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800420e56d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e571:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800420e575:	84 c0                	test   %al,%al
  800420e577:	75 0e                	jne    800420e587 <dwarf_siblingof+0x138>
		offset = die->die_next_off;
  800420e579:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e57d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e581:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e585:	eb 6b                	jmp    800420e5f2 <dwarf_siblingof+0x1a3>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  800420e587:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e58b:	be 01 00 00 00       	mov    $0x1,%esi
  800420e590:	48 89 c7             	mov    %rax,%rdi
  800420e593:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420e59a:	00 00 00 
  800420e59d:	ff d0                	callq  *%rax
  800420e59f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e5a3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e5a8:	74 35                	je     800420e5df <dwarf_siblingof+0x190>
			if (at->at_form != DW_FORM_ref_addr)
  800420e5aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5ae:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e5b2:	48 83 f8 10          	cmp    $0x10,%rax
  800420e5b6:	74 19                	je     800420e5d1 <dwarf_siblingof+0x182>
				offset = at->u[0].u64 + cu->cu_offset;
  800420e5b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5bc:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420e5c0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e5c4:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e5c8:	48 01 d0             	add    %rdx,%rax
  800420e5cb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e5cf:	eb 21                	jmp    800420e5f2 <dwarf_siblingof+0x1a3>
			else
				offset = at->u[0].u64;
  800420e5d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5d5:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e5d9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e5dd:	eb 13                	jmp    800420e5f2 <dwarf_siblingof+0x1a3>
		} else {
			offset = die->die_next_off;
  800420e5df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e5e3:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e5e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  800420e5eb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  800420e5f2:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800420e5f5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e5f9:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420e5fd:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800420e601:	48 83 ec 08          	sub    $0x8,%rsp
  800420e605:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e609:	ff 70 30             	pushq  0x30(%rax)
  800420e60c:	ff 70 28             	pushq  0x28(%rax)
  800420e60f:	ff 70 20             	pushq  0x20(%rax)
  800420e612:	ff 70 18             	pushq  0x18(%rax)
  800420e615:	ff 70 10             	pushq  0x10(%rax)
  800420e618:	ff 70 08             	pushq  0x8(%rax)
  800420e61b:	ff 30                	pushq  (%rax)
  800420e61d:	48 b8 fd df 20 04 80 	movabs $0x800420dffd,%rax
  800420e624:	00 00 00 
  800420e627:	ff d0                	callq  *%rax
  800420e629:	48 83 c4 40          	add    $0x40,%rsp
  800420e62d:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  800420e630:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  800420e634:	75 07                	jne    800420e63d <dwarf_siblingof+0x1ee>
		return (DW_DLV_NO_ENTRY);
  800420e636:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420e63b:	eb 12                	jmp    800420e64f <dwarf_siblingof+0x200>
	} else if (ret != DW_DLE_NONE)
  800420e63d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e641:	74 07                	je     800420e64a <dwarf_siblingof+0x1fb>
		return (DW_DLV_ERROR);
  800420e643:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e648:	eb 05                	jmp    800420e64f <dwarf_siblingof+0x200>


	return (DW_DLV_OK);
  800420e64a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e64f:	c9                   	leaveq 
  800420e650:	c3                   	retq   

000000800420e651 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800420e651:	55                   	push   %rbp
  800420e652:	48 89 e5             	mov    %rsp,%rbp
  800420e655:	48 83 ec 30          	sub    $0x30,%rsp
  800420e659:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e65d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e661:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420e665:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  800420e669:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e66e:	75 35                	jne    800420e6a5 <dwarf_child+0x54>
  800420e670:	48 b9 87 6c 21 04 80 	movabs $0x8004216c87,%rcx
  800420e677:	00 00 00 
  800420e67a:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e681:	00 00 00 
  800420e684:	be 1c 03 00 00       	mov    $0x31c,%esi
  800420e689:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e690:	00 00 00 
  800420e693:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e698:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e69f:	00 00 00 
  800420e6a2:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420e6a5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420e6aa:	75 35                	jne    800420e6e1 <dwarf_child+0x90>
  800420e6ac:	48 b9 7c 6c 21 04 80 	movabs $0x8004216c7c,%rcx
  800420e6b3:	00 00 00 
  800420e6b6:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e6bd:	00 00 00 
  800420e6c0:	be 1d 03 00 00       	mov    $0x31d,%esi
  800420e6c5:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e6cc:	00 00 00 
  800420e6cf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e6d4:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e6db:	00 00 00 
  800420e6de:	41 ff d0             	callq  *%r8
	assert(dbg);
  800420e6e1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e6e6:	75 35                	jne    800420e71d <dwarf_child+0xcc>
  800420e6e8:	48 b9 78 6c 21 04 80 	movabs $0x8004216c78,%rcx
  800420e6ef:	00 00 00 
  800420e6f2:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e6f9:	00 00 00 
  800420e6fc:	be 1e 03 00 00       	mov    $0x31e,%esi
  800420e701:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e708:	00 00 00 
  800420e70b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e710:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e717:	00 00 00 
  800420e71a:	41 ff d0             	callq  *%r8
	assert(cu);
  800420e71d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e722:	75 35                	jne    800420e759 <dwarf_child+0x108>
  800420e724:	48 b9 84 6c 21 04 80 	movabs $0x8004216c84,%rcx
  800420e72b:	00 00 00 
  800420e72e:	48 ba ea 6a 21 04 80 	movabs $0x8004216aea,%rdx
  800420e735:	00 00 00 
  800420e738:	be 1f 03 00 00       	mov    $0x31f,%esi
  800420e73d:	48 bf ff 6a 21 04 80 	movabs $0x8004216aff,%rdi
  800420e744:	00 00 00 
  800420e747:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e74c:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e753:	00 00 00 
  800420e756:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800420e759:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e75d:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800420e761:	84 c0                	test   %al,%al
  800420e763:	75 07                	jne    800420e76c <dwarf_child+0x11b>
		return (DW_DLE_NO_ENTRY);
  800420e765:	b8 04 00 00 00       	mov    $0x4,%eax
  800420e76a:	eb 63                	jmp    800420e7cf <dwarf_child+0x17e>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  800420e76c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e770:	48 8b 70 08          	mov    0x8(%rax),%rsi
  800420e774:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e778:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  800420e77c:	48 83 ec 08          	sub    $0x8,%rsp
  800420e780:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e784:	ff 70 30             	pushq  0x30(%rax)
  800420e787:	ff 70 28             	pushq  0x28(%rax)
  800420e78a:	ff 70 20             	pushq  0x20(%rax)
  800420e78d:	ff 70 18             	pushq  0x18(%rax)
  800420e790:	ff 70 10             	pushq  0x10(%rax)
  800420e793:	ff 70 08             	pushq  0x8(%rax)
  800420e796:	ff 30                	pushq  (%rax)
  800420e798:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e79d:	48 b8 fd df 20 04 80 	movabs $0x800420dffd,%rax
  800420e7a4:	00 00 00 
  800420e7a7:	ff d0                	callq  *%rax
  800420e7a9:	48 83 c4 40          	add    $0x40,%rsp
  800420e7ad:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  800420e7b0:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800420e7b4:	75 07                	jne    800420e7bd <dwarf_child+0x16c>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800420e7b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420e7bb:	eb 12                	jmp    800420e7cf <dwarf_child+0x17e>
	} else if (ret != DW_DLE_NONE)
  800420e7bd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e7c1:	74 07                	je     800420e7ca <dwarf_child+0x179>
		return (DW_DLV_ERROR);
  800420e7c3:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e7c8:	eb 05                	jmp    800420e7cf <dwarf_child+0x17e>

	return (DW_DLV_OK);
  800420e7ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e7cf:	c9                   	leaveq 
  800420e7d0:	c3                   	retq   

000000800420e7d1 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  800420e7d1:	55                   	push   %rbp
  800420e7d2:	48 89 e5             	mov    %rsp,%rbp
  800420e7d5:	48 83 ec 20          	sub    $0x20,%rsp
  800420e7d9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  800420e7dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e7e1:	48 8b 00             	mov    (%rax),%rax
  800420e7e4:	48 89 c7             	mov    %rax,%rdi
  800420e7e7:	48 b8 cd 1a 21 04 80 	movabs $0x8004211acd,%rax
  800420e7ee:	00 00 00 
  800420e7f1:	ff d0                	callq  *%rax
  800420e7f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  800420e7f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7fb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e7ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e803:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  800420e807:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e80b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e80f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e813:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  800420e817:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e81b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420e81f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e823:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  800420e827:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e82c:	c9                   	leaveq 
  800420e82d:	c3                   	retq   

000000800420e82e <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  800420e82e:	55                   	push   %rbp
  800420e82f:	48 89 e5             	mov    %rsp,%rbp
  800420e832:	48 83 ec 08          	sub    $0x8,%rsp
  800420e836:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  800420e83a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e83e:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  800420e844:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e848:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  800420e84e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e852:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  800420e858:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e85c:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800420e862:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e866:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  800420e86c:	c9                   	leaveq 
  800420e86d:	c3                   	retq   

000000800420e86e <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  800420e86e:	55                   	push   %rbp
  800420e86f:	48 89 e5             	mov    %rsp,%rbp
  800420e872:	48 83 ec 40          	sub    $0x40,%rsp
  800420e876:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e87a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e87e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420e882:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420e886:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  800420e88a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e88e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  800420e892:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e896:	ba 80 00 00 00       	mov    $0x80,%edx
  800420e89b:	be 00 00 00 00       	mov    $0x0,%esi
  800420e8a0:	48 89 c7             	mov    %rax,%rdi
  800420e8a3:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420e8aa:	00 00 00 
  800420e8ad:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800420e8af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8b3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e8b7:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  800420e8bb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e8c0:	75 07                	jne    800420e8c9 <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  800420e8c2:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e8c7:	eb 75                	jmp    800420e93e <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800420e8c9:	eb 59                	jmp    800420e924 <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  800420e8cb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420e8cf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e8d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e8d7:	be 01 00 00 00       	mov    $0x1,%esi
  800420e8dc:	48 89 c7             	mov    %rax,%rdi
  800420e8df:	48 b8 c4 0a 21 04 80 	movabs $0x8004210ac4,%rax
  800420e8e6:	00 00 00 
  800420e8e9:	ff d0                	callq  *%rax
  800420e8eb:	85 c0                	test   %eax,%eax
  800420e8ed:	79 07                	jns    800420e8f6 <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  800420e8ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420e8f4:	eb 48                	jmp    800420e93e <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800420e8f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8fa:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e8fe:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420e902:	77 20                	ja     800420e924 <dwarf_get_fde_at_pc+0xb6>
  800420e904:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e908:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  800420e90c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e910:	48 8b 40 38          	mov    0x38(%rax),%rax
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800420e914:	48 01 d0             	add    %rdx,%rax
  800420e917:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420e91b:	76 07                	jbe    800420e924 <dwarf_get_fde_at_pc+0xb6>
			return (DW_DLV_OK);
  800420e91d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e922:	eb 1a                	jmp    800420e93e <dwarf_get_fde_at_pc+0xd0>
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800420e924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e928:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e92c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e930:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e934:	48 39 c2             	cmp    %rax,%rdx
  800420e937:	72 92                	jb     800420e8cb <dwarf_get_fde_at_pc+0x5d>
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  800420e939:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800420e93e:	c9                   	leaveq 
  800420e93f:	c3                   	retq   

000000800420e940 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  800420e940:	55                   	push   %rbp
  800420e941:	48 89 e5             	mov    %rsp,%rbp
  800420e944:	48 83 ec 30          	sub    $0x30,%rsp
  800420e948:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e94c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e950:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420e954:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int i;

	assert(dest != NULL);
  800420e958:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e95d:	75 35                	jne    800420e994 <_dwarf_frame_regtable_copy+0x54>
  800420e95f:	48 b9 9a 6c 21 04 80 	movabs $0x8004216c9a,%rcx
  800420e966:	00 00 00 
  800420e969:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  800420e970:	00 00 00 
  800420e973:	be 57 00 00 00       	mov    $0x57,%esi
  800420e978:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  800420e97f:	00 00 00 
  800420e982:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e987:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e98e:	00 00 00 
  800420e991:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  800420e994:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e999:	75 35                	jne    800420e9d0 <_dwarf_frame_regtable_copy+0x90>
  800420e99b:	48 b9 d2 6c 21 04 80 	movabs $0x8004216cd2,%rcx
  800420e9a2:	00 00 00 
  800420e9a5:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  800420e9ac:	00 00 00 
  800420e9af:	be 58 00 00 00       	mov    $0x58,%esi
  800420e9b4:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  800420e9bb:	00 00 00 
  800420e9be:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e9c3:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420e9ca:	00 00 00 
  800420e9cd:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  800420e9d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e9d4:	48 8b 00             	mov    (%rax),%rax
  800420e9d7:	48 85 c0             	test   %rax,%rax
  800420e9da:	75 39                	jne    800420ea15 <_dwarf_frame_regtable_copy+0xd5>
		*dest = &global_rt_table_shadow;
  800420e9dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e9e0:	48 bf 40 c7 57 04 80 	movabs $0x800457c740,%rdi
  800420e9e7:	00 00 00 
  800420e9ea:	48 89 38             	mov    %rdi,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  800420e9ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e9f1:	48 8b 00             	mov    (%rax),%rax
  800420e9f4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420e9f8:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  800420e9fc:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  800420ea00:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea04:	48 8b 00             	mov    (%rax),%rax
  800420ea07:	48 be 00 ca 57 04 80 	movabs $0x800457ca00,%rsi
  800420ea0e:	00 00 00 
  800420ea11:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  800420ea15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea19:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ea1d:	48 8b 12             	mov    (%rdx),%rdx
  800420ea20:	48 89 d1             	mov    %rdx,%rcx
  800420ea23:	ba 18 00 00 00       	mov    $0x18,%edx
  800420ea28:	48 89 c6             	mov    %rax,%rsi
  800420ea2b:	48 89 cf             	mov    %rcx,%rdi
  800420ea2e:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420ea35:	00 00 00 
  800420ea38:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800420ea3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420ea41:	eb 5a                	jmp    800420ea9d <_dwarf_frame_regtable_copy+0x15d>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  800420ea43:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea47:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ea4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ea4e:	48 63 d0             	movslq %eax,%rdx
  800420ea51:	48 89 d0             	mov    %rdx,%rax
  800420ea54:	48 01 c0             	add    %rax,%rax
  800420ea57:	48 01 d0             	add    %rdx,%rax
  800420ea5a:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea5e:	48 01 c1             	add    %rax,%rcx
  800420ea61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea65:	48 8b 00             	mov    (%rax),%rax
  800420ea68:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420ea6c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ea6f:	48 63 d0             	movslq %eax,%rdx
  800420ea72:	48 89 d0             	mov    %rdx,%rax
  800420ea75:	48 01 c0             	add    %rax,%rax
  800420ea78:	48 01 d0             	add    %rdx,%rax
  800420ea7b:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea7f:	48 01 f0             	add    %rsi,%rax
  800420ea82:	ba 18 00 00 00       	mov    $0x18,%edx
  800420ea87:	48 89 ce             	mov    %rcx,%rsi
  800420ea8a:	48 89 c7             	mov    %rax,%rdi
  800420ea8d:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420ea94:	00 00 00 
  800420ea97:	ff d0                	callq  *%rax
		     i < src->rt3_reg_table_size; i++)
  800420ea99:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800420ea9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eaa1:	48 8b 00             	mov    (%rax),%rax
  800420eaa4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420eaa8:	0f b7 c0             	movzwl %ax,%eax
  800420eaab:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420eaae:	7e 10                	jle    800420eac0 <_dwarf_frame_regtable_copy+0x180>
		     i < src->rt3_reg_table_size; i++)
  800420eab0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eab4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420eab8:	0f b7 c0             	movzwl %ax,%eax
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800420eabb:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420eabe:	7f 83                	jg     800420ea43 <_dwarf_frame_regtable_copy+0x103>
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800420eac0:	eb 32                	jmp    800420eaf4 <_dwarf_frame_regtable_copy+0x1b4>
		(*dest)->rt3_rules[i].dw_regnum =
  800420eac2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eac6:	48 8b 00             	mov    (%rax),%rax
  800420eac9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eacd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ead0:	48 63 d0             	movslq %eax,%rdx
  800420ead3:	48 89 d0             	mov    %rdx,%rax
  800420ead6:	48 01 c0             	add    %rax,%rax
  800420ead9:	48 01 d0             	add    %rdx,%rax
  800420eadc:	48 c1 e0 03          	shl    $0x3,%rax
  800420eae0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  800420eae4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eae8:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		(*dest)->rt3_rules[i].dw_regnum =
  800420eaec:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (; i < (*dest)->rt3_reg_table_size; i++)
  800420eaf0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420eaf4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eaf8:	48 8b 00             	mov    (%rax),%rax
  800420eafb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420eaff:	0f b7 c0             	movzwl %ax,%eax
  800420eb02:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420eb05:	7f bb                	jg     800420eac2 <_dwarf_frame_regtable_copy+0x182>

	return (DW_DLE_NONE);
  800420eb07:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eb0c:	c9                   	leaveq 
  800420eb0d:	c3                   	retq   

000000800420eb0e <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  800420eb0e:	55                   	push   %rbp
  800420eb0f:	48 89 e5             	mov    %rsp,%rbp
  800420eb12:	53                   	push   %rbx
  800420eb13:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  800420eb1a:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  800420eb1e:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  800420eb22:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  800420eb26:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  800420eb2a:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  800420eb31:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  800420eb38:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  800420eb3f:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800420eb46:	00 
  800420eb47:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420eb4b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  800420eb4f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420eb53:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420eb57:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  800420eb5a:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420eb5e:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420eb62:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  800420eb66:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420eb6a:	48 89 c7             	mov    %rax,%rdi
  800420eb6d:	48 b8 40 e9 20 04 80 	movabs $0x800420e940,%rax
  800420eb74:	00 00 00 
  800420eb77:	ff d0                	callq  *%rax
	p = insts;
  800420eb79:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420eb7d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  800420eb81:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420eb85:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420eb89:	48 01 d0             	add    %rdx,%rax
  800420eb8c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  800420eb90:	e9 3c 0d 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		if (*p == DW_CFA_nop) {
  800420eb95:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420eb99:	0f b6 00             	movzbl (%rax),%eax
  800420eb9c:	84 c0                	test   %al,%al
  800420eb9e:	75 11                	jne    800420ebb1 <_dwarf_frame_run_inst+0xa3>
			p++;
  800420eba0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420eba4:	48 83 c0 01          	add    $0x1,%rax
  800420eba8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  800420ebac:	e9 20 0d 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		}

		high2 = *p & 0xc0;
  800420ebb1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ebb5:	0f b6 00             	movzbl (%rax),%eax
  800420ebb8:	83 e0 c0             	and    $0xffffffc0,%eax
  800420ebbb:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  800420ebbe:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ebc2:	0f b6 00             	movzbl (%rax),%eax
  800420ebc5:	83 e0 3f             	and    $0x3f,%eax
  800420ebc8:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  800420ebcb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ebcf:	48 83 c0 01          	add    $0x1,%rax
  800420ebd3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  800420ebd7:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800420ebdb:	0f 84 a4 01 00 00    	je     800420ed85 <_dwarf_frame_run_inst+0x277>
			switch (high2) {
  800420ebe1:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420ebe5:	3d 80 00 00 00       	cmp    $0x80,%eax
  800420ebea:	74 38                	je     800420ec24 <_dwarf_frame_run_inst+0x116>
  800420ebec:	3d c0 00 00 00       	cmp    $0xc0,%eax
  800420ebf1:	0f 84 04 01 00 00    	je     800420ecfb <_dwarf_frame_run_inst+0x1ed>
  800420ebf7:	83 f8 40             	cmp    $0x40,%eax
  800420ebfa:	0f 85 74 01 00 00    	jne    800420ed74 <_dwarf_frame_run_inst+0x266>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  800420ec00:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800420ec04:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420ec0b:	ff 
  800420ec0c:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  800420ec10:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420ec14:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420ec18:	73 05                	jae    800420ec1f <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  800420ec1a:	e9 c0 0c 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			        break;
  800420ec1f:	e9 5c 01 00 00       	jmpq   800420ed80 <_dwarf_frame_run_inst+0x272>
			case DW_CFA_offset:
			        *row_pc = pc;
  800420ec24:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ec28:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ec2c:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800420ec2f:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ec33:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec37:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420ec3b:	66 39 c2             	cmp    %ax,%dx
  800420ec3e:	72 0c                	jb     800420ec4c <_dwarf_frame_run_inst+0x13e>
  800420ec40:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420ec47:	e9 93 0c 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			        RL[low6].dw_offset_relevant = 1;
  800420ec4c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec50:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ec54:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ec58:	48 89 d0             	mov    %rdx,%rax
  800420ec5b:	48 01 c0             	add    %rax,%rax
  800420ec5e:	48 01 d0             	add    %rdx,%rax
  800420ec61:	48 c1 e0 03          	shl    $0x3,%rax
  800420ec65:	48 01 c8             	add    %rcx,%rax
  800420ec68:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  800420ec6b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec6f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ec73:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ec77:	48 89 d0             	mov    %rdx,%rax
  800420ec7a:	48 01 c0             	add    %rax,%rax
  800420ec7d:	48 01 d0             	add    %rdx,%rax
  800420ec80:	48 c1 e0 03          	shl    $0x3,%rax
  800420ec84:	48 01 c8             	add    %rcx,%rax
  800420ec87:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  800420ec8b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec8f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ec93:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ec97:	48 89 d0             	mov    %rdx,%rax
  800420ec9a:	48 01 c0             	add    %rax,%rax
  800420ec9d:	48 01 d0             	add    %rdx,%rax
  800420eca0:	48 c1 e0 03          	shl    $0x3,%rax
  800420eca4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420eca8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ecac:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420ecb0:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800420ecb4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ecb8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ecbc:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ecc0:	48 89 d0             	mov    %rdx,%rax
  800420ecc3:	48 01 c0             	add    %rax,%rax
  800420ecc6:	48 01 d0             	add    %rdx,%rax
  800420ecc9:	48 c1 e0 03          	shl    $0x3,%rax
  800420eccd:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  800420ecd1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ecd5:	48 89 c7             	mov    %rax,%rdi
  800420ecd8:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420ecdf:	00 00 00 
  800420ece2:	ff d0                	callq  *%rax
  800420ece4:	48 89 c2             	mov    %rax,%rdx
  800420ece7:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420ecee:	48 0f af c2          	imul   %rdx,%rax
			        RL[low6].dw_offset_or_block_len =
  800420ecf2:	48 89 43 08          	mov    %rax,0x8(%rbx)
			        break;
  800420ecf6:	e9 85 00 00 00       	jmpq   800420ed80 <_dwarf_frame_run_inst+0x272>
			case DW_CFA_restore:
			        *row_pc = pc;
  800420ecfb:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ecff:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ed03:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800420ed06:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ed0a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ed0e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420ed12:	66 39 c2             	cmp    %ax,%dx
  800420ed15:	72 0c                	jb     800420ed23 <_dwarf_frame_run_inst+0x215>
  800420ed17:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420ed1e:	e9 bc 0b 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			        memcpy(&RL[low6], &INITRL[low6],
  800420ed23:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ed27:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ed2b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ed2f:	48 89 d0             	mov    %rdx,%rax
  800420ed32:	48 01 c0             	add    %rax,%rax
  800420ed35:	48 01 d0             	add    %rdx,%rax
  800420ed38:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed3c:	48 01 c1             	add    %rax,%rcx
  800420ed3f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ed43:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420ed47:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420ed4b:	48 89 d0             	mov    %rdx,%rax
  800420ed4e:	48 01 c0             	add    %rax,%rax
  800420ed51:	48 01 d0             	add    %rdx,%rax
  800420ed54:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed58:	48 01 f0             	add    %rsi,%rax
  800420ed5b:	ba 18 00 00 00       	mov    $0x18,%edx
  800420ed60:	48 89 ce             	mov    %rcx,%rsi
  800420ed63:	48 89 c7             	mov    %rax,%rdi
  800420ed66:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420ed6d:	00 00 00 
  800420ed70:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  800420ed72:	eb 0c                	jmp    800420ed80 <_dwarf_frame_run_inst+0x272>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800420ed74:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  800420ed7b:	e9 5f 0b 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			}

			continue;
  800420ed80:	e9 4c 0b 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		}

		switch (low6) {
  800420ed85:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800420ed89:	83 f8 16             	cmp    $0x16,%eax
  800420ed8c:	0f 87 36 0b 00 00    	ja     800420f8c8 <_dwarf_frame_run_inst+0xdba>
  800420ed92:	89 c0                	mov    %eax,%eax
  800420ed94:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ed9b:	00 
  800420ed9c:	48 b8 e0 6c 21 04 80 	movabs $0x8004216ce0,%rax
  800420eda3:	00 00 00 
  800420eda6:	48 01 d0             	add    %rdx,%rax
  800420eda9:	48 8b 00             	mov    (%rax),%rax
  800420edac:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  800420edae:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420edb2:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420edb6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420edba:	8b 4a 28             	mov    0x28(%rdx),%ecx
  800420edbd:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420edc1:	89 ce                	mov    %ecx,%esi
  800420edc3:	48 89 d7             	mov    %rdx,%rdi
  800420edc6:	ff d0                	callq  *%rax
  800420edc8:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420edcc:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420edd0:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420edd4:	73 05                	jae    800420eddb <_dwarf_frame_run_inst+0x2cd>
			        goto program_done;
  800420edd6:	e9 04 0b 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			break;
  800420eddb:	e9 f1 0a 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  800420ede0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ede4:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420ede8:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420edec:	be 01 00 00 00       	mov    $0x1,%esi
  800420edf1:	48 89 d7             	mov    %rdx,%rdi
  800420edf4:	ff d0                	callq  *%rax
  800420edf6:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420edfd:	ff 
  800420edfe:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420ee02:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420ee06:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420ee0a:	73 05                	jae    800420ee11 <_dwarf_frame_run_inst+0x303>
			        goto program_done;
  800420ee0c:	e9 ce 0a 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			break;
  800420ee11:	e9 bb 0a 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  800420ee16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ee1a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420ee1e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420ee22:	be 02 00 00 00       	mov    $0x2,%esi
  800420ee27:	48 89 d7             	mov    %rdx,%rdi
  800420ee2a:	ff d0                	callq  *%rax
  800420ee2c:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420ee33:	ff 
  800420ee34:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420ee38:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420ee3c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420ee40:	73 05                	jae    800420ee47 <_dwarf_frame_run_inst+0x339>
			        goto program_done;
  800420ee42:	e9 98 0a 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			break;
  800420ee47:	e9 85 0a 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  800420ee4c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ee50:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420ee54:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420ee58:	be 04 00 00 00       	mov    $0x4,%esi
  800420ee5d:	48 89 d7             	mov    %rdx,%rdi
  800420ee60:	ff d0                	callq  *%rax
  800420ee62:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420ee69:	ff 
  800420ee6a:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420ee6e:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420ee72:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420ee76:	73 05                	jae    800420ee7d <_dwarf_frame_run_inst+0x36f>
			        goto program_done;
  800420ee78:	e9 62 0a 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			break;
  800420ee7d:	e9 4f 0a 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  800420ee82:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ee86:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ee8a:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420ee8d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ee91:	48 89 c7             	mov    %rax,%rdi
  800420ee94:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420ee9b:	00 00 00 
  800420ee9e:	ff d0                	callq  *%rax
  800420eea0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800420eea4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420eea8:	48 89 c7             	mov    %rax,%rdi
  800420eeab:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420eeb2:	00 00 00 
  800420eeb5:	ff d0                	callq  *%rax
  800420eeb7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420eebb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eebf:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420eec3:	0f b7 c0             	movzwl %ax,%eax
  800420eec6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420eeca:	77 0c                	ja     800420eed8 <_dwarf_frame_run_inst+0x3ca>
  800420eecc:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420eed3:	e9 07 0a 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 1;
  800420eed8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eedc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eee0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eee4:	48 89 d0             	mov    %rdx,%rax
  800420eee7:	48 01 c0             	add    %rax,%rax
  800420eeea:	48 01 d0             	add    %rdx,%rax
  800420eeed:	48 c1 e0 03          	shl    $0x3,%rax
  800420eef1:	48 01 c8             	add    %rcx,%rax
  800420eef4:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800420eef7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eefb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eeff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ef03:	48 89 d0             	mov    %rdx,%rax
  800420ef06:	48 01 c0             	add    %rax,%rax
  800420ef09:	48 01 d0             	add    %rdx,%rax
  800420ef0c:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef10:	48 01 c8             	add    %rcx,%rax
  800420ef13:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420ef17:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ef1b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ef1f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ef23:	48 89 d0             	mov    %rdx,%rax
  800420ef26:	48 01 c0             	add    %rax,%rax
  800420ef29:	48 01 d0             	add    %rdx,%rax
  800420ef2c:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef30:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ef34:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef38:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420ef3c:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800420ef40:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ef44:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ef48:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ef4c:	48 89 d0             	mov    %rdx,%rax
  800420ef4f:	48 01 c0             	add    %rax,%rax
  800420ef52:	48 01 d0             	add    %rdx,%rax
  800420ef55:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef59:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ef5d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420ef64:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800420ef69:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420ef6d:	e9 5f 09 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  800420ef72:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ef76:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ef7a:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420ef7d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ef81:	48 89 c7             	mov    %rax,%rdi
  800420ef84:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420ef8b:	00 00 00 
  800420ef8e:	ff d0                	callq  *%rax
  800420ef90:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420ef94:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ef98:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420ef9c:	0f b7 c0             	movzwl %ax,%eax
  800420ef9f:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420efa3:	77 0c                	ja     800420efb1 <_dwarf_frame_run_inst+0x4a3>
  800420efa5:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420efac:	e9 2e 09 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			memcpy(&RL[reg], &INITRL[reg],
  800420efb1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420efb5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420efb9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420efbd:	48 89 d0             	mov    %rdx,%rax
  800420efc0:	48 01 c0             	add    %rax,%rax
  800420efc3:	48 01 d0             	add    %rdx,%rax
  800420efc6:	48 c1 e0 03          	shl    $0x3,%rax
  800420efca:	48 01 c1             	add    %rax,%rcx
  800420efcd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420efd1:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420efd5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420efd9:	48 89 d0             	mov    %rdx,%rax
  800420efdc:	48 01 c0             	add    %rax,%rax
  800420efdf:	48 01 d0             	add    %rdx,%rax
  800420efe2:	48 c1 e0 03          	shl    $0x3,%rax
  800420efe6:	48 01 f0             	add    %rsi,%rax
  800420efe9:	ba 18 00 00 00       	mov    $0x18,%edx
  800420efee:	48 89 ce             	mov    %rcx,%rsi
  800420eff1:	48 89 c7             	mov    %rax,%rdi
  800420eff4:	48 b8 8a c6 20 04 80 	movabs $0x800420c68a,%rax
  800420effb:	00 00 00 
  800420effe:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  800420f000:	e9 cc 08 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_undefined:
			*row_pc = pc;
  800420f005:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f009:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f00d:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f010:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f014:	48 89 c7             	mov    %rax,%rdi
  800420f017:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f01e:	00 00 00 
  800420f021:	ff d0                	callq  *%rax
  800420f023:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f027:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f02b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f02f:	0f b7 c0             	movzwl %ax,%eax
  800420f032:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f036:	77 0c                	ja     800420f044 <_dwarf_frame_run_inst+0x536>
  800420f038:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f03f:	e9 9b 08 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 0;
  800420f044:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f048:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f04c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f050:	48 89 d0             	mov    %rdx,%rax
  800420f053:	48 01 c0             	add    %rax,%rax
  800420f056:	48 01 d0             	add    %rdx,%rax
  800420f059:	48 c1 e0 03          	shl    $0x3,%rax
  800420f05d:	48 01 c8             	add    %rcx,%rax
  800420f060:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  800420f063:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f067:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f06b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f06f:	48 89 d0             	mov    %rdx,%rax
  800420f072:	48 01 c0             	add    %rax,%rax
  800420f075:	48 01 d0             	add    %rdx,%rax
  800420f078:	48 c1 e0 03          	shl    $0x3,%rax
  800420f07c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f080:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f084:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  800420f088:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800420f08c:	e9 40 08 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  800420f091:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f095:	48 89 c7             	mov    %rax,%rdi
  800420f098:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f09f:	00 00 00 
  800420f0a2:	ff d0                	callq  *%rax
  800420f0a4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f0a8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f0ac:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f0b0:	0f b7 c0             	movzwl %ax,%eax
  800420f0b3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f0b7:	77 0c                	ja     800420f0c5 <_dwarf_frame_run_inst+0x5b7>
  800420f0b9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f0c0:	e9 1a 08 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 0;
  800420f0c5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f0c9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f0cd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f0d1:	48 89 d0             	mov    %rdx,%rax
  800420f0d4:	48 01 c0             	add    %rax,%rax
  800420f0d7:	48 01 d0             	add    %rdx,%rax
  800420f0da:	48 c1 e0 03          	shl    $0x3,%rax
  800420f0de:	48 01 c8             	add    %rcx,%rax
  800420f0e1:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  800420f0e4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f0e8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f0ec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f0f0:	48 89 d0             	mov    %rdx,%rax
  800420f0f3:	48 01 c0             	add    %rax,%rax
  800420f0f6:	48 01 d0             	add    %rdx,%rax
  800420f0f9:	48 c1 e0 03          	shl    $0x3,%rax
  800420f0fd:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f101:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f105:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  800420f109:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800420f10d:	e9 bf 07 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_register:
			*row_pc = pc;
  800420f112:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f116:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f11a:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f11d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f121:	48 89 c7             	mov    %rax,%rdi
  800420f124:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f12b:	00 00 00 
  800420f12e:	ff d0                	callq  *%rax
  800420f130:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  800420f134:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f138:	48 89 c7             	mov    %rax,%rdi
  800420f13b:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f142:	00 00 00 
  800420f145:	ff d0                	callq  *%rax
  800420f147:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f14b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f14f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f153:	0f b7 c0             	movzwl %ax,%eax
  800420f156:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f15a:	77 0c                	ja     800420f168 <_dwarf_frame_run_inst+0x65a>
  800420f15c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f163:	e9 77 07 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 0;
  800420f168:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f16c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f170:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f174:	48 89 d0             	mov    %rdx,%rax
  800420f177:	48 01 c0             	add    %rax,%rax
  800420f17a:	48 01 d0             	add    %rdx,%rax
  800420f17d:	48 c1 e0 03          	shl    $0x3,%rax
  800420f181:	48 01 c8             	add    %rcx,%rax
  800420f184:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  800420f187:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f18b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f18f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f193:	48 89 d0             	mov    %rdx,%rax
  800420f196:	48 01 c0             	add    %rax,%rax
  800420f199:	48 01 d0             	add    %rdx,%rax
  800420f19c:	48 c1 e0 03          	shl    $0x3,%rax
  800420f1a0:	48 01 c8             	add    %rcx,%rax
  800420f1a3:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f1a7:	66 89 50 02          	mov    %dx,0x2(%rax)
			break;
  800420f1ab:	e9 21 07 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  800420f1b0:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420f1b4:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420f1b8:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  800420f1bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f1c0:	48 89 c7             	mov    %rax,%rdi
  800420f1c3:	48 b8 40 e9 20 04 80 	movabs $0x800420e940,%rax
  800420f1ca:	00 00 00 
  800420f1cd:	ff d0                	callq  *%rax
			break;
  800420f1cf:	e9 fd 06 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_restore_state:
			*row_pc = pc;
  800420f1d4:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f1d8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f1dc:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  800420f1df:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420f1e3:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420f1e7:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420f1eb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f1ef:	48 89 c7             	mov    %rax,%rdi
  800420f1f2:	48 b8 40 e9 20 04 80 	movabs $0x800420e940,%rax
  800420f1f9:	00 00 00 
  800420f1fc:	ff d0                	callq  *%rax
			break;
  800420f1fe:	e9 ce 06 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  800420f203:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f207:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f20b:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f20e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f212:	48 89 c7             	mov    %rax,%rdi
  800420f215:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f21c:	00 00 00 
  800420f21f:	ff d0                	callq  *%rax
  800420f221:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800420f225:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f229:	48 89 c7             	mov    %rax,%rdi
  800420f22c:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f233:	00 00 00 
  800420f236:	ff d0                	callq  *%rax
  800420f238:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  800420f23c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f240:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420f243:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f247:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  800420f24b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f24f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f253:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800420f257:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f25b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f25f:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420f263:	e9 69 06 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  800420f268:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f26c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f270:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f273:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f277:	48 89 c7             	mov    %rax,%rdi
  800420f27a:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f281:	00 00 00 
  800420f284:	ff d0                	callq  *%rax
  800420f286:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  800420f28a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f28e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f292:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  800420f296:	e9 36 06 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  800420f29b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f29f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f2a3:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  800420f2a6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f2aa:	48 89 c7             	mov    %rax,%rdi
  800420f2ad:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f2b4:	00 00 00 
  800420f2b7:	ff d0                	callq  *%rax
  800420f2b9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  800420f2bd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f2c1:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420f2c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f2c8:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800420f2cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f2d0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f2d4:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420f2d8:	e9 f4 05 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  800420f2dd:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f2e1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f2e5:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  800420f2e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f2ec:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  800420f2ef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f2f3:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  800420f2f7:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  800420f2fb:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f2ff:	48 89 c7             	mov    %rax,%rdi
  800420f302:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f309:	00 00 00 
  800420f30c:	ff d0                	callq  *%rax
  800420f30e:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  800420f312:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f316:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f31a:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  800420f31e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f322:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f326:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f32a:	48 01 d0             	add    %rdx,%rax
  800420f32d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800420f331:	e9 9b 05 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_expression:
			*row_pc = pc;
  800420f336:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f33a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f33e:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f341:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f345:	48 89 c7             	mov    %rax,%rdi
  800420f348:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f34f:	00 00 00 
  800420f352:	ff d0                	callq  *%rax
  800420f354:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f358:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f35c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f360:	0f b7 c0             	movzwl %ax,%eax
  800420f363:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f367:	77 0c                	ja     800420f375 <_dwarf_frame_run_inst+0x867>
  800420f369:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f370:	e9 6a 05 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 0;
  800420f375:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f379:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f37d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f381:	48 89 d0             	mov    %rdx,%rax
  800420f384:	48 01 c0             	add    %rax,%rax
  800420f387:	48 01 d0             	add    %rdx,%rax
  800420f38a:	48 c1 e0 03          	shl    $0x3,%rax
  800420f38e:	48 01 c8             	add    %rcx,%rax
  800420f391:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  800420f394:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f398:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f39c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f3a0:	48 89 d0             	mov    %rdx,%rax
  800420f3a3:	48 01 c0             	add    %rax,%rax
  800420f3a6:	48 01 d0             	add    %rdx,%rax
  800420f3a9:	48 c1 e0 03          	shl    $0x3,%rax
  800420f3ad:	48 01 c8             	add    %rcx,%rax
  800420f3b0:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800420f3b4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f3b8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f3bc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f3c0:	48 89 d0             	mov    %rdx,%rax
  800420f3c3:	48 01 c0             	add    %rax,%rax
  800420f3c6:	48 01 d0             	add    %rdx,%rax
  800420f3c9:	48 c1 e0 03          	shl    $0x3,%rax
  800420f3cd:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  800420f3d1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f3d5:	48 89 c7             	mov    %rax,%rdi
  800420f3d8:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f3df:	00 00 00 
  800420f3e2:	ff d0                	callq  *%rax
			RL[reg].dw_offset_or_block_len =
  800420f3e4:	48 89 43 08          	mov    %rax,0x8(%rbx)
			RL[reg].dw_block_ptr = p;
  800420f3e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f3ec:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f3f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f3f4:	48 89 d0             	mov    %rdx,%rax
  800420f3f7:	48 01 c0             	add    %rax,%rax
  800420f3fa:	48 01 d0             	add    %rdx,%rax
  800420f3fd:	48 c1 e0 03          	shl    $0x3,%rax
  800420f401:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f405:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f409:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  800420f40d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f411:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f415:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420f419:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f41d:	48 89 d0             	mov    %rdx,%rax
  800420f420:	48 01 c0             	add    %rax,%rax
  800420f423:	48 01 d0             	add    %rdx,%rax
  800420f426:	48 c1 e0 03          	shl    $0x3,%rax
  800420f42a:	48 01 f0             	add    %rsi,%rax
  800420f42d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f431:	48 01 c8             	add    %rcx,%rax
  800420f434:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800420f438:	e9 94 04 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  800420f43d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f441:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f445:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f448:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f44c:	48 89 c7             	mov    %rax,%rdi
  800420f44f:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f456:	00 00 00 
  800420f459:	ff d0                	callq  *%rax
  800420f45b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800420f45f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f463:	48 89 c7             	mov    %rax,%rdi
  800420f466:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800420f46d:	00 00 00 
  800420f470:	ff d0                	callq  *%rax
  800420f472:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f476:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f47a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f47e:	0f b7 c0             	movzwl %ax,%eax
  800420f481:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f485:	77 0c                	ja     800420f493 <_dwarf_frame_run_inst+0x985>
  800420f487:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f48e:	e9 4c 04 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 1;
  800420f493:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f497:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f49b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f49f:	48 89 d0             	mov    %rdx,%rax
  800420f4a2:	48 01 c0             	add    %rax,%rax
  800420f4a5:	48 01 d0             	add    %rdx,%rax
  800420f4a8:	48 c1 e0 03          	shl    $0x3,%rax
  800420f4ac:	48 01 c8             	add    %rcx,%rax
  800420f4af:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800420f4b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f4b6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f4ba:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f4be:	48 89 d0             	mov    %rdx,%rax
  800420f4c1:	48 01 c0             	add    %rax,%rax
  800420f4c4:	48 01 d0             	add    %rdx,%rax
  800420f4c7:	48 c1 e0 03          	shl    $0x3,%rax
  800420f4cb:	48 01 c8             	add    %rcx,%rax
  800420f4ce:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420f4d2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f4d6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f4da:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f4de:	48 89 d0             	mov    %rdx,%rax
  800420f4e1:	48 01 c0             	add    %rax,%rax
  800420f4e4:	48 01 d0             	add    %rdx,%rax
  800420f4e7:	48 c1 e0 03          	shl    $0x3,%rax
  800420f4eb:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f4ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f4f3:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420f4f7:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  800420f4fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f4ff:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f503:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f507:	48 89 d0             	mov    %rdx,%rax
  800420f50a:	48 01 c0             	add    %rax,%rax
  800420f50d:	48 01 d0             	add    %rdx,%rax
  800420f510:	48 c1 e0 03          	shl    $0x3,%rax
  800420f514:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f518:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420f51f:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  800420f524:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420f528:	e9 a4 03 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  800420f52d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f531:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f535:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f538:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f53c:	48 89 c7             	mov    %rax,%rdi
  800420f53f:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f546:	00 00 00 
  800420f549:	ff d0                	callq  *%rax
  800420f54b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800420f54f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f553:	48 89 c7             	mov    %rax,%rdi
  800420f556:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800420f55d:	00 00 00 
  800420f560:	ff d0                	callq  *%rax
  800420f562:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800420f566:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f56a:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420f56d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f571:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  800420f575:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f579:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f57d:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  800420f581:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f585:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420f58c:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  800420f591:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420f595:	e9 37 03 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  800420f59a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f59e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f5a2:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  800420f5a5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f5a9:	48 89 c7             	mov    %rax,%rdi
  800420f5ac:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800420f5b3:	00 00 00 
  800420f5b6:	ff d0                	callq  *%rax
  800420f5b8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800420f5bc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f5c0:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420f5c3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f5c7:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  800420f5cb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f5cf:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420f5d6:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  800420f5db:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420f5df:	e9 ed 02 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_val_offset:
			*row_pc = pc;
  800420f5e4:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f5e8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f5ec:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f5ef:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f5f3:	48 89 c7             	mov    %rax,%rdi
  800420f5f6:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f5fd:	00 00 00 
  800420f600:	ff d0                	callq  *%rax
  800420f602:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800420f606:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f60a:	48 89 c7             	mov    %rax,%rdi
  800420f60d:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f614:	00 00 00 
  800420f617:	ff d0                	callq  *%rax
  800420f619:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f61d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f621:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f625:	0f b7 c0             	movzwl %ax,%eax
  800420f628:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f62c:	77 0c                	ja     800420f63a <_dwarf_frame_run_inst+0xb2c>
  800420f62e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f635:	e9 a5 02 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 1;
  800420f63a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f63e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f642:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f646:	48 89 d0             	mov    %rdx,%rax
  800420f649:	48 01 c0             	add    %rax,%rax
  800420f64c:	48 01 d0             	add    %rdx,%rax
  800420f64f:	48 c1 e0 03          	shl    $0x3,%rax
  800420f653:	48 01 c8             	add    %rcx,%rax
  800420f656:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800420f659:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f65d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f661:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f665:	48 89 d0             	mov    %rdx,%rax
  800420f668:	48 01 c0             	add    %rax,%rax
  800420f66b:	48 01 d0             	add    %rdx,%rax
  800420f66e:	48 c1 e0 03          	shl    $0x3,%rax
  800420f672:	48 01 c8             	add    %rcx,%rax
  800420f675:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420f679:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f67d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f681:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f685:	48 89 d0             	mov    %rdx,%rax
  800420f688:	48 01 c0             	add    %rax,%rax
  800420f68b:	48 01 d0             	add    %rdx,%rax
  800420f68e:	48 c1 e0 03          	shl    $0x3,%rax
  800420f692:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f696:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f69a:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420f69e:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800420f6a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f6a6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f6aa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f6ae:	48 89 d0             	mov    %rdx,%rax
  800420f6b1:	48 01 c0             	add    %rax,%rax
  800420f6b4:	48 01 d0             	add    %rdx,%rax
  800420f6b7:	48 c1 e0 03          	shl    $0x3,%rax
  800420f6bb:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f6bf:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420f6c6:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800420f6cb:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420f6cf:	e9 fd 01 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  800420f6d4:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f6d8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f6dc:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f6df:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f6e3:	48 89 c7             	mov    %rax,%rdi
  800420f6e6:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f6ed:	00 00 00 
  800420f6f0:	ff d0                	callq  *%rax
  800420f6f2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800420f6f6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f6fa:	48 89 c7             	mov    %rax,%rdi
  800420f6fd:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800420f704:	00 00 00 
  800420f707:	ff d0                	callq  *%rax
  800420f709:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f70d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f711:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f715:	0f b7 c0             	movzwl %ax,%eax
  800420f718:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f71c:	77 0c                	ja     800420f72a <_dwarf_frame_run_inst+0xc1c>
  800420f71e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f725:	e9 b5 01 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 1;
  800420f72a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f72e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f732:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f736:	48 89 d0             	mov    %rdx,%rax
  800420f739:	48 01 c0             	add    %rax,%rax
  800420f73c:	48 01 d0             	add    %rdx,%rax
  800420f73f:	48 c1 e0 03          	shl    $0x3,%rax
  800420f743:	48 01 c8             	add    %rcx,%rax
  800420f746:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800420f749:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f74d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f751:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f755:	48 89 d0             	mov    %rdx,%rax
  800420f758:	48 01 c0             	add    %rax,%rax
  800420f75b:	48 01 d0             	add    %rdx,%rax
  800420f75e:	48 c1 e0 03          	shl    $0x3,%rax
  800420f762:	48 01 c8             	add    %rcx,%rax
  800420f765:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420f769:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f76d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f771:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f775:	48 89 d0             	mov    %rdx,%rax
  800420f778:	48 01 c0             	add    %rax,%rax
  800420f77b:	48 01 d0             	add    %rdx,%rax
  800420f77e:	48 c1 e0 03          	shl    $0x3,%rax
  800420f782:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f786:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f78a:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420f78e:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  800420f792:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f796:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f79a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f79e:	48 89 d0             	mov    %rdx,%rax
  800420f7a1:	48 01 c0             	add    %rax,%rax
  800420f7a4:	48 01 d0             	add    %rdx,%rax
  800420f7a7:	48 c1 e0 03          	shl    $0x3,%rax
  800420f7ab:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f7af:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420f7b6:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  800420f7bb:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420f7bf:	e9 0d 01 00 00       	jmpq   800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		case DW_CFA_val_expression:
			*row_pc = pc;
  800420f7c4:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420f7c8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420f7cc:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420f7cf:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f7d3:	48 89 c7             	mov    %rax,%rdi
  800420f7d6:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f7dd:	00 00 00 
  800420f7e0:	ff d0                	callq  *%rax
  800420f7e2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420f7e6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f7ea:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f7ee:	0f b7 c0             	movzwl %ax,%eax
  800420f7f1:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420f7f5:	77 0c                	ja     800420f803 <_dwarf_frame_run_inst+0xcf5>
  800420f7f7:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420f7fe:	e9 dc 00 00 00       	jmpq   800420f8df <_dwarf_frame_run_inst+0xdd1>
			RL[reg].dw_offset_relevant = 0;
  800420f803:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f807:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f80b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f80f:	48 89 d0             	mov    %rdx,%rax
  800420f812:	48 01 c0             	add    %rax,%rax
  800420f815:	48 01 d0             	add    %rdx,%rax
  800420f818:	48 c1 e0 03          	shl    $0x3,%rax
  800420f81c:	48 01 c8             	add    %rcx,%rax
  800420f81f:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  800420f822:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f826:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f82a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f82e:	48 89 d0             	mov    %rdx,%rax
  800420f831:	48 01 c0             	add    %rax,%rax
  800420f834:	48 01 d0             	add    %rdx,%rax
  800420f837:	48 c1 e0 03          	shl    $0x3,%rax
  800420f83b:	48 01 c8             	add    %rcx,%rax
  800420f83e:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800420f842:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f846:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f84a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f84e:	48 89 d0             	mov    %rdx,%rax
  800420f851:	48 01 c0             	add    %rax,%rax
  800420f854:	48 01 d0             	add    %rdx,%rax
  800420f857:	48 c1 e0 03          	shl    $0x3,%rax
  800420f85b:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  800420f85f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f863:	48 89 c7             	mov    %rax,%rdi
  800420f866:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800420f86d:	00 00 00 
  800420f870:	ff d0                	callq  *%rax
			RL[reg].dw_offset_or_block_len =
  800420f872:	48 89 43 08          	mov    %rax,0x8(%rbx)
			RL[reg].dw_block_ptr = p;
  800420f876:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f87a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f87e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f882:	48 89 d0             	mov    %rdx,%rax
  800420f885:	48 01 c0             	add    %rax,%rax
  800420f888:	48 01 d0             	add    %rdx,%rax
  800420f88b:	48 c1 e0 03          	shl    $0x3,%rax
  800420f88f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f893:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f897:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  800420f89b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f89f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420f8a3:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420f8a7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f8ab:	48 89 d0             	mov    %rdx,%rax
  800420f8ae:	48 01 c0             	add    %rax,%rax
  800420f8b1:	48 01 d0             	add    %rdx,%rax
  800420f8b4:	48 c1 e0 03          	shl    $0x3,%rax
  800420f8b8:	48 01 f0             	add    %rsi,%rax
  800420f8bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f8bf:	48 01 c8             	add    %rcx,%rax
  800420f8c2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800420f8c6:	eb 09                	jmp    800420f8d1 <_dwarf_frame_run_inst+0xdc3>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800420f8c8:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  800420f8cf:	eb 0e                	jmp    800420f8df <_dwarf_frame_run_inst+0xdd1>
	while (p < pe) {
  800420f8d1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f8d5:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f8d9:	0f 82 b6 f2 ff ff    	jb     800420eb95 <_dwarf_frame_run_inst+0x87>
		}
	}

program_done:
	return (ret);
  800420f8df:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  800420f8e2:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  800420f8e9:	5b                   	pop    %rbx
  800420f8ea:	5d                   	pop    %rbp
  800420f8eb:	c3                   	retq   

000000800420f8ec <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  800420f8ec:	55                   	push   %rbp
  800420f8ed:	48 89 e5             	mov    %rsp,%rbp
  800420f8f0:	48 83 ec 60          	sub    $0x60,%rsp
  800420f8f4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f8f8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420f8fc:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f900:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800420f904:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  800420f908:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  800420f90c:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  800420f911:	75 35                	jne    800420f948 <_dwarf_frame_get_internal_table+0x5c>
  800420f913:	48 b9 98 6d 21 04 80 	movabs $0x8004216d98,%rcx
  800420f91a:	00 00 00 
  800420f91d:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  800420f924:	00 00 00 
  800420f927:	be 83 01 00 00       	mov    $0x183,%esi
  800420f92c:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  800420f933:	00 00 00 
  800420f936:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f93b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420f942:	00 00 00 
  800420f945:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  800420f948:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f94d:	75 35                	jne    800420f984 <_dwarf_frame_get_internal_table+0x98>
  800420f94f:	48 b9 a7 6d 21 04 80 	movabs $0x8004216da7,%rcx
  800420f956:	00 00 00 
  800420f959:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  800420f960:	00 00 00 
  800420f963:	be 86 01 00 00       	mov    $0x186,%esi
  800420f968:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  800420f96f:	00 00 00 
  800420f972:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f977:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420f97e:	00 00 00 
  800420f981:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  800420f984:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f988:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420f98c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  800420f990:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f994:	ba 18 00 00 00       	mov    $0x18,%edx
  800420f999:	be 00 00 00 00       	mov    $0x0,%esi
  800420f99e:	48 89 c7             	mov    %rax,%rdi
  800420f9a1:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420f9a8:	00 00 00 
  800420f9ab:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800420f9ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9b1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f9b5:	0f b7 d0             	movzwl %ax,%edx
  800420f9b8:	48 89 d0             	mov    %rdx,%rax
  800420f9bb:	48 01 c0             	add    %rax,%rax
  800420f9be:	48 01 d0             	add    %rdx,%rax
  800420f9c1:	48 c1 e0 03          	shl    $0x3,%rax
  800420f9c5:	48 89 c2             	mov    %rax,%rdx
  800420f9c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9cc:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420f9d0:	be 00 00 00 00       	mov    $0x0,%esi
  800420f9d5:	48 89 c7             	mov    %rax,%rdi
  800420f9d8:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800420f9df:	00 00 00 
  800420f9e2:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  800420f9e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f9eb:	eb 2f                	jmp    800420fa1c <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  800420f9ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9f1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f9f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f9f8:	48 63 d0             	movslq %eax,%rdx
  800420f9fb:	48 89 d0             	mov    %rdx,%rax
  800420f9fe:	48 01 c0             	add    %rax,%rax
  800420fa01:	48 01 d0             	add    %rdx,%rax
  800420fa04:	48 c1 e0 03          	shl    $0x3,%rax
  800420fa08:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420fa0c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fa10:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  800420fa14:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  800420fa18:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420fa1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fa20:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420fa24:	0f b7 c0             	movzwl %ax,%eax
  800420fa27:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420fa2a:	7f c1                	jg     800420f9ed <_dwarf_frame_get_internal_table+0x101>

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  800420fa2c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fa30:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fa34:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  800420fa38:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fa3d:	75 35                	jne    800420fa74 <_dwarf_frame_get_internal_table+0x188>
  800420fa3f:	48 b9 b3 6d 21 04 80 	movabs $0x8004216db3,%rcx
  800420fa46:	00 00 00 
  800420fa49:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  800420fa50:	00 00 00 
  800420fa53:	be 95 01 00 00       	mov    $0x195,%esi
  800420fa58:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  800420fa5f:	00 00 00 
  800420fa62:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa67:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420fa6e:	00 00 00 
  800420fa71:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  800420fa74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa78:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800420fa7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa80:	4c 8b 40 38          	mov    0x38(%rax),%r8
  800420fa84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa88:	48 8b 48 70          	mov    0x70(%rax),%rcx
  800420fa8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa90:	48 8b 50 68          	mov    0x68(%rax),%rdx
  800420fa94:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420fa98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fa9c:	ff 75 a0             	pushq  -0x60(%rbp)
  800420fa9f:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800420faa3:	57                   	push   %rdi
  800420faa4:	6a ff                	pushq  $0xffffffffffffffff
  800420faa6:	6a 00                	pushq  $0x0
  800420faa8:	48 89 c7             	mov    %rax,%rdi
  800420faab:	48 b8 0e eb 20 04 80 	movabs $0x800420eb0e,%rax
  800420fab2:	00 00 00 
  800420fab5:	ff d0                	callq  *%rax
  800420fab7:	48 83 c4 20          	add    $0x20,%rsp
  800420fabb:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  800420fabe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420fac2:	74 08                	je     800420facc <_dwarf_frame_get_internal_table+0x1e0>
		return (ret);
  800420fac4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fac7:	e9 8a 00 00 00       	jmpq   800420fb56 <_dwarf_frame_get_internal_table+0x26a>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  800420facc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fad0:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420fad4:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420fad8:	77 61                	ja     800420fb3b <_dwarf_frame_get_internal_table+0x24f>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800420fada:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fade:	48 8b 78 30          	mov    0x30(%rax),%rdi
  800420fae2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fae6:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800420faea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faee:	4c 8b 50 38          	mov    0x38(%rax),%r10
  800420faf2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420faf6:	48 8b 48 58          	mov    0x58(%rax),%rcx
  800420fafa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fafe:	48 8b 50 50          	mov    0x50(%rax),%rdx
  800420fb02:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420fb06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fb0a:	ff 75 a0             	pushq  -0x60(%rbp)
  800420fb0d:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  800420fb11:	41 50                	push   %r8
  800420fb13:	ff 75 b8             	pushq  -0x48(%rbp)
  800420fb16:	57                   	push   %rdi
  800420fb17:	4d 89 d0             	mov    %r10,%r8
  800420fb1a:	48 89 c7             	mov    %rax,%rdi
  800420fb1d:	48 b8 0e eb 20 04 80 	movabs $0x800420eb0e,%rax
  800420fb24:	00 00 00 
  800420fb27:	ff d0                	callq  *%rax
  800420fb29:	48 83 c4 20          	add    $0x20,%rsp
  800420fb2d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  800420fb30:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420fb34:	74 05                	je     800420fb3b <_dwarf_frame_get_internal_table+0x24f>
			return (ret);
  800420fb36:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fb39:	eb 1b                	jmp    800420fb56 <_dwarf_frame_get_internal_table+0x26a>
	}

	*ret_rt = rt;
  800420fb3b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fb3f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fb43:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  800420fb46:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420fb4a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb4e:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  800420fb51:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fb56:	c9                   	leaveq 
  800420fb57:	c3                   	retq   

000000800420fb58 <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  800420fb58:	55                   	push   %rbp
  800420fb59:	48 89 e5             	mov    %rsp,%rbp
  800420fb5c:	48 83 ec 50          	sub    $0x50,%rsp
  800420fb60:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fb64:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fb68:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420fb6c:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800420fb70:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  800420fb74:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  800420fb78:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fb7d:	74 07                	je     800420fb86 <dwarf_get_fde_info_for_all_regs+0x2e>
  800420fb7f:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420fb84:	75 0a                	jne    800420fb90 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800420fb86:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fb8b:	e9 e5 02 00 00       	jmpq   800420fe75 <dwarf_get_fde_info_for_all_regs+0x31d>
	}

	assert(dbg != NULL);
  800420fb90:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420fb95:	75 35                	jne    800420fbcc <dwarf_get_fde_info_for_all_regs+0x74>
  800420fb97:	48 b9 a7 6d 21 04 80 	movabs $0x8004216da7,%rcx
  800420fb9e:	00 00 00 
  800420fba1:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  800420fba8:	00 00 00 
  800420fbab:	be bf 01 00 00       	mov    $0x1bf,%esi
  800420fbb0:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  800420fbb7:	00 00 00 
  800420fbba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fbbf:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800420fbc6:	00 00 00 
  800420fbc9:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  800420fbcc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fbd0:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420fbd4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420fbd8:	77 19                	ja     800420fbf3 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800420fbda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fbde:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420fbe2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fbe6:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fbea:	48 01 d0             	add    %rdx,%rax
	if (pc_requested < fde->fde_initloc ||
  800420fbed:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420fbf1:	77 0a                	ja     800420fbfd <dwarf_get_fde_info_for_all_regs+0xa5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  800420fbf3:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fbf8:	e9 78 02 00 00       	jmpq   800420fe75 <dwarf_get_fde_info_for_all_regs+0x31d>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  800420fbfd:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  800420fc01:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  800420fc05:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420fc09:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fc0d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420fc11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc15:	4d 89 c1             	mov    %r8,%r9
  800420fc18:	49 89 f8             	mov    %rdi,%r8
  800420fc1b:	48 89 c7             	mov    %rax,%rdi
  800420fc1e:	48 b8 ec f8 20 04 80 	movabs $0x800420f8ec,%rax
  800420fc25:	00 00 00 
  800420fc28:	ff d0                	callq  *%rax
  800420fc2a:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  800420fc2d:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420fc31:	74 0a                	je     800420fc3d <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  800420fc33:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fc38:	e9 38 02 00 00       	jmpq   800420fe75 <dwarf_get_fde_info_for_all_regs+0x31d>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  800420fc3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc41:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420fc45:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  800420fc49:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  800420fc4e:	0f 87 ae 00 00 00    	ja     800420fd02 <dwarf_get_fde_info_for_all_regs+0x1aa>
		reg_table->rules[cfa].dw_offset_relevant =
  800420fc54:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  800420fc58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc5c:	0f b6 00             	movzbl (%rax),%eax
		reg_table->rules[cfa].dw_offset_relevant =
  800420fc5f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fc63:	48 63 c9             	movslq %ecx,%rcx
  800420fc66:	48 83 c1 01          	add    $0x1,%rcx
  800420fc6a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fc6e:	48 01 ca             	add    %rcx,%rdx
  800420fc71:	88 02                	mov    %al,(%rdx)
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  800420fc73:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800420fc77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc7b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800420fc7f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fc83:	48 63 c9             	movslq %ecx,%rcx
  800420fc86:	48 83 c1 01          	add    $0x1,%rcx
  800420fc8a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fc8e:	48 01 ca             	add    %rcx,%rdx
  800420fc91:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  800420fc94:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800420fc98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc9c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800420fca0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fca4:	48 63 c9             	movslq %ecx,%rcx
  800420fca7:	48 83 c1 01          	add    $0x1,%rcx
  800420fcab:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fcaf:	48 01 ca             	add    %rcx,%rdx
  800420fcb2:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800420fcb6:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800420fcba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcbe:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fcc2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fcc6:	48 63 c9             	movslq %ecx,%rcx
  800420fcc9:	48 83 c1 01          	add    $0x1,%rcx
  800420fccd:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fcd1:	48 01 ca             	add    %rcx,%rdx
  800420fcd4:	48 89 42 08          	mov    %rax,0x8(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  800420fcd8:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  800420fcdc:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420fce0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fce4:	48 63 d2             	movslq %edx,%rdx
  800420fce7:	48 83 c2 01          	add    $0x1,%rdx
  800420fceb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420fcef:	48 01 d0             	add    %rdx,%rax
  800420fcf2:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fcf6:	48 8b 00             	mov    (%rax),%rax
  800420fcf9:	48 89 01             	mov    %rax,(%rcx)
  800420fcfc:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  800420fd00:	eb 3c                	jmp    800420fd3e <dwarf_get_fde_info_for_all_regs+0x1e6>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  800420fd02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd06:	0f b6 10             	movzbl (%rax),%edx
		reg_table->cfa_rule.dw_offset_relevant =
  800420fd09:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fd0d:	88 10                	mov    %dl,(%rax)
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  800420fd0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd13:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  800420fd17:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fd1b:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  800420fd1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd22:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  800420fd26:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fd2a:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  800420fd2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd32:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fd36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fd3a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800420fd3e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420fd45:	e9 fa 00 00 00       	jmpq   800420fe44 <dwarf_get_fde_info_for_all_regs+0x2ec>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  800420fd4a:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  800420fd4e:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420fd51:	75 05                	jne    800420fd58 <dwarf_get_fde_info_for_all_regs+0x200>
			continue;
  800420fd53:	e9 e8 00 00 00       	jmpq   800420fe40 <dwarf_get_fde_info_for_all_regs+0x2e8>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  800420fd58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd5c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420fd60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420fd63:	48 63 d0             	movslq %eax,%rdx
  800420fd66:	48 89 d0             	mov    %rdx,%rax
  800420fd69:	48 01 c0             	add    %rax,%rax
  800420fd6c:	48 01 d0             	add    %rdx,%rax
  800420fd6f:	48 c1 e0 03          	shl    $0x3,%rax
  800420fd73:	48 01 c8             	add    %rcx,%rax
  800420fd76:	0f b6 00             	movzbl (%rax),%eax
		reg_table->rules[i].dw_offset_relevant =
  800420fd79:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fd7d:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420fd80:	48 63 c9             	movslq %ecx,%rcx
  800420fd83:	48 83 c1 01          	add    $0x1,%rcx
  800420fd87:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fd8b:	48 01 ca             	add    %rcx,%rdx
  800420fd8e:	88 02                	mov    %al,(%rdx)
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  800420fd90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd94:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420fd98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420fd9b:	48 63 d0             	movslq %eax,%rdx
  800420fd9e:	48 89 d0             	mov    %rdx,%rax
  800420fda1:	48 01 c0             	add    %rax,%rax
  800420fda4:	48 01 d0             	add    %rdx,%rax
  800420fda7:	48 c1 e0 03          	shl    $0x3,%rax
  800420fdab:	48 01 c8             	add    %rcx,%rax
  800420fdae:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		reg_table->rules[i].dw_value_type =
  800420fdb2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fdb6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420fdb9:	48 63 c9             	movslq %ecx,%rcx
  800420fdbc:	48 83 c1 01          	add    $0x1,%rcx
  800420fdc0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fdc4:	48 01 ca             	add    %rcx,%rdx
  800420fdc7:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  800420fdca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdce:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420fdd2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420fdd5:	48 63 d0             	movslq %eax,%rdx
  800420fdd8:	48 89 d0             	mov    %rdx,%rax
  800420fddb:	48 01 c0             	add    %rax,%rax
  800420fdde:	48 01 d0             	add    %rdx,%rax
  800420fde1:	48 c1 e0 03          	shl    $0x3,%rax
  800420fde5:	48 01 c8             	add    %rcx,%rax
  800420fde8:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800420fdec:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fdf0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420fdf3:	48 63 c9             	movslq %ecx,%rcx
  800420fdf6:	48 83 c1 01          	add    $0x1,%rcx
  800420fdfa:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fdfe:	48 01 ca             	add    %rcx,%rdx
  800420fe01:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  800420fe05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe09:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420fe0d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420fe10:	48 63 d0             	movslq %eax,%rdx
  800420fe13:	48 89 d0             	mov    %rdx,%rax
  800420fe16:	48 01 c0             	add    %rax,%rax
  800420fe19:	48 01 d0             	add    %rdx,%rax
  800420fe1c:	48 c1 e0 03          	shl    $0x3,%rax
  800420fe20:	48 01 c8             	add    %rcx,%rax
  800420fe23:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset =
  800420fe27:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fe2b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420fe2e:	48 63 c9             	movslq %ecx,%rcx
  800420fe31:	48 83 c1 01          	add    $0x1,%rcx
  800420fe35:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fe39:	48 01 ca             	add    %rcx,%rdx
  800420fe3c:	48 89 42 08          	mov    %rax,0x8(%rdx)
	     i++) {
  800420fe40:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800420fe44:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800420fe48:	7f 14                	jg     800420fe5e <dwarf_get_fde_info_for_all_regs+0x306>
  800420fe4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe4e:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  800420fe52:	0f b7 c0             	movzwl %ax,%eax
  800420fe55:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420fe58:	0f 8f ec fe ff ff    	jg     800420fd4a <dwarf_get_fde_info_for_all_regs+0x1f2>
	}

	if (row_pc) *row_pc = pc;
  800420fe5e:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420fe63:	74 0b                	je     800420fe70 <dwarf_get_fde_info_for_all_regs+0x318>
  800420fe65:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fe69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fe6d:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  800420fe70:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fe75:	c9                   	leaveq 
  800420fe76:	c3                   	retq   

000000800420fe77 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800420fe77:	55                   	push   %rbp
  800420fe78:	48 89 e5             	mov    %rsp,%rbp
  800420fe7b:	48 83 ec 40          	sub    $0x40,%rsp
  800420fe7f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fe83:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fe87:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fe8b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420fe8f:	44 89 c0             	mov    %r8d,%eax
  800420fe92:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800420fe96:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  800420fe99:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  800420fe9d:	75 0a                	jne    800420fea9 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  800420fe9f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fea4:	e9 f8 01 00 00       	jmpq   80042100a1 <_dwarf_frame_read_lsb_encoded+0x22a>

	application = encode & 0xf0;
  800420fea9:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800420fead:	83 e0 f0             	and    $0xfffffff0,%eax
  800420feb0:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800420feb3:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800420feb7:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800420febb:	83 f8 0c             	cmp    $0xc,%eax
  800420febe:	0f 87 84 01 00 00    	ja     8004210048 <_dwarf_frame_read_lsb_encoded+0x1d1>
  800420fec4:	89 c0                	mov    %eax,%eax
  800420fec6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420fecd:	00 
  800420fece:	48 b8 c0 6d 21 04 80 	movabs $0x8004216dc0,%rax
  800420fed5:	00 00 00 
  800420fed8:	48 01 d0             	add    %rdx,%rax
  800420fedb:	48 8b 00             	mov    (%rax),%rax
  800420fede:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  800420fee0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fee4:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fee8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420feec:	8b 52 28             	mov    0x28(%rdx),%edx
  800420feef:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420fef3:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fef7:	48 89 cf             	mov    %rcx,%rdi
  800420fefa:	ff d0                	callq  *%rax
  800420fefc:	48 89 c2             	mov    %rax,%rdx
  800420feff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff03:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420ff06:	e9 44 01 00 00       	jmpq   800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  800420ff0b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ff0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff13:	48 89 d6             	mov    %rdx,%rsi
  800420ff16:	48 89 c7             	mov    %rax,%rdi
  800420ff19:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420ff20:	00 00 00 
  800420ff23:	ff d0                	callq  *%rax
  800420ff25:	48 89 c2             	mov    %rax,%rdx
  800420ff28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff2c:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420ff2f:	e9 1b 01 00 00       	jmpq   800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  800420ff34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff38:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff3c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420ff40:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ff44:	ba 02 00 00 00       	mov    $0x2,%edx
  800420ff49:	48 89 cf             	mov    %rcx,%rdi
  800420ff4c:	ff d0                	callq  *%rax
  800420ff4e:	48 89 c2             	mov    %rax,%rdx
  800420ff51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff55:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420ff58:	e9 f2 00 00 00       	jmpq   800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  800420ff5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff61:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff65:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420ff69:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ff6d:	ba 04 00 00 00       	mov    $0x4,%edx
  800420ff72:	48 89 cf             	mov    %rcx,%rdi
  800420ff75:	ff d0                	callq  *%rax
  800420ff77:	48 89 c2             	mov    %rax,%rdx
  800420ff7a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff7e:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420ff81:	e9 c9 00 00 00       	jmpq   800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  800420ff86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff8a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff8e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420ff92:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ff96:	ba 08 00 00 00       	mov    $0x8,%edx
  800420ff9b:	48 89 cf             	mov    %rcx,%rdi
  800420ff9e:	ff d0                	callq  *%rax
  800420ffa0:	48 89 c2             	mov    %rax,%rdx
  800420ffa3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ffa7:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420ffaa:	e9 a0 00 00 00       	jmpq   800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  800420ffaf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ffb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ffb7:	48 89 d6             	mov    %rdx,%rsi
  800420ffba:	48 89 c7             	mov    %rax,%rdi
  800420ffbd:	48 b8 56 cf 20 04 80 	movabs $0x800420cf56,%rax
  800420ffc4:	00 00 00 
  800420ffc7:	ff d0                	callq  *%rax
  800420ffc9:	48 89 c2             	mov    %rax,%rdx
  800420ffcc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ffd0:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420ffd3:	eb 7a                	jmp    800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  800420ffd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffd9:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ffdd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420ffe1:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ffe5:	ba 02 00 00 00       	mov    $0x2,%edx
  800420ffea:	48 89 cf             	mov    %rcx,%rdi
  800420ffed:	ff d0                	callq  *%rax
  800420ffef:	48 0f bf d0          	movswq %ax,%rdx
  800420fff3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fff7:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420fffa:	eb 53                	jmp    800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  800420fffc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210000:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210004:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004210008:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421000c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210011:	48 89 cf             	mov    %rcx,%rdi
  8004210014:	ff d0                	callq  *%rax
  8004210016:	48 63 d0             	movslq %eax,%rdx
  8004210019:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421001d:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004210020:	eb 2d                	jmp    800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004210022:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210026:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421002a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421002e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210032:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210037:	48 89 cf             	mov    %rcx,%rdi
  800421003a:	ff d0                	callq  *%rax
  800421003c:	48 89 c2             	mov    %rax,%rdx
  800421003f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210043:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004210046:	eb 07                	jmp    800421004f <_dwarf_frame_read_lsb_encoded+0x1d8>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004210048:	b8 14 00 00 00       	mov    $0x14,%eax
  800421004d:	eb 52                	jmp    80042100a1 <_dwarf_frame_read_lsb_encoded+0x22a>
	}

	if (application == DW_EH_PE_pcrel) {
  800421004f:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004210053:	75 47                	jne    800421009c <_dwarf_frame_read_lsb_encoded+0x225>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004210055:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004210059:	83 f8 01             	cmp    $0x1,%eax
  800421005c:	7c 3d                	jl     800421009b <_dwarf_frame_read_lsb_encoded+0x224>
  800421005e:	83 f8 04             	cmp    $0x4,%eax
  8004210061:	7e 0a                	jle    800421006d <_dwarf_frame_read_lsb_encoded+0x1f6>
  8004210063:	83 e8 09             	sub    $0x9,%eax
  8004210066:	83 f8 03             	cmp    $0x3,%eax
  8004210069:	77 30                	ja     800421009b <_dwarf_frame_read_lsb_encoded+0x224>
  800421006b:	eb 17                	jmp    8004210084 <_dwarf_frame_read_lsb_encoded+0x20d>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  800421006d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210071:	48 8b 10             	mov    (%rax),%rdx
  8004210074:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210078:	48 01 c2             	add    %rax,%rdx
  800421007b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421007f:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004210082:	eb 18                	jmp    800421009c <_dwarf_frame_read_lsb_encoded+0x225>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004210084:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210088:	48 8b 10             	mov    (%rax),%rdx
  800421008b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421008f:	48 01 c2             	add    %rax,%rdx
  8004210092:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210096:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004210099:	eb 01                	jmp    800421009c <_dwarf_frame_read_lsb_encoded+0x225>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  800421009b:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  800421009c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042100a1:	c9                   	leaveq 
  80042100a2:	c3                   	retq   

00000080042100a3 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  80042100a3:	55                   	push   %rbp
  80042100a4:	48 89 e5             	mov    %rsp,%rbp
  80042100a7:	48 83 ec 50          	sub    $0x50,%rsp
  80042100ab:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042100af:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042100b3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  80042100b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042100bb:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042100bf:	48 85 c0             	test   %rax,%rax
  80042100c2:	74 0f                	je     80042100d3 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  80042100c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042100c8:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042100cc:	0f b6 00             	movzbl (%rax),%eax
  80042100cf:	3c 7a                	cmp    $0x7a,%al
  80042100d1:	74 35                	je     8004210108 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  80042100d3:	48 b9 28 6e 21 04 80 	movabs $0x8004216e28,%rcx
  80042100da:	00 00 00 
  80042100dd:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  80042100e4:	00 00 00 
  80042100e7:	be 4a 02 00 00       	mov    $0x24a,%esi
  80042100ec:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  80042100f3:	00 00 00 
  80042100f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042100fb:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004210102:	00 00 00 
  8004210105:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004210108:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421010c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210110:	48 83 c0 01          	add    $0x1,%rax
  8004210114:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004210118:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421011c:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004210120:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  8004210124:	e9 b4 00 00 00       	jmpq   80042101dd <_dwarf_frame_parse_lsb_cie_augment+0x13a>
		switch (*aug_p) {
  8004210129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421012d:	0f b6 00             	movzbl (%rax),%eax
  8004210130:	0f b6 c0             	movzbl %al,%eax
  8004210133:	83 f8 50             	cmp    $0x50,%eax
  8004210136:	74 18                	je     8004210150 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004210138:	83 f8 52             	cmp    $0x52,%eax
  800421013b:	74 7c                	je     80042101b9 <_dwarf_frame_parse_lsb_cie_augment+0x116>
  800421013d:	83 f8 4c             	cmp    $0x4c,%eax
  8004210140:	0f 85 8b 00 00 00    	jne    80042101d1 <_dwarf_frame_parse_lsb_cie_augment+0x12e>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004210146:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  800421014b:	e9 88 00 00 00       	jmpq   80042101d8 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004210150:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210154:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210158:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421015c:	0f b6 00             	movzbl (%rax),%eax
  800421015f:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004210162:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004210169:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421016a:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  800421016e:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004210172:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210176:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  800421017a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421017e:	48 83 ec 08          	sub    $0x8,%rsp
  8004210182:	ff 75 b8             	pushq  -0x48(%rbp)
  8004210185:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421018b:	41 89 f8             	mov    %edi,%r8d
  800421018e:	48 89 c7             	mov    %rax,%rdi
  8004210191:	48 b8 77 fe 20 04 80 	movabs $0x800420fe77,%rax
  8004210198:	00 00 00 
  800421019b:	ff d0                	callq  *%rax
  800421019d:	48 83 c4 10          	add    $0x10,%rsp
  80042101a1:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  80042101a4:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80042101a8:	74 05                	je     80042101af <_dwarf_frame_parse_lsb_cie_augment+0x10c>
				return (ret);
  80042101aa:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042101ad:	eb 42                	jmp    80042101f1 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
			augdata_p += offset;
  80042101af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042101b3:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  80042101b7:	eb 1f                	jmp    80042101d8 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  80042101b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101bd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042101c1:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042101c5:	0f b6 10             	movzbl (%rax),%edx
  80042101c8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042101cc:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  80042101cf:	eb 07                	jmp    80042101d8 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042101d1:	b8 14 00 00 00       	mov    $0x14,%eax
  80042101d6:	eb 19                	jmp    80042101f1 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
		}
		aug_p++;
  80042101d8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	while (*aug_p != '\0') {
  80042101dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042101e1:	0f b6 00             	movzbl (%rax),%eax
  80042101e4:	84 c0                	test   %al,%al
  80042101e6:	0f 85 3d ff ff ff    	jne    8004210129 <_dwarf_frame_parse_lsb_cie_augment+0x86>
	}

	return (DW_DLE_NONE);
  80042101ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042101f1:	c9                   	leaveq 
  80042101f2:	c3                   	retq   

00000080042101f3 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042101f3:	55                   	push   %rbp
  80042101f4:	48 89 e5             	mov    %rsp,%rbp
  80042101f7:	48 83 ec 60          	sub    $0x60,%rsp
  80042101fb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042101ff:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004210203:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004210207:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421020b:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  800421020f:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004210214:	75 35                	jne    800421024b <_dwarf_frame_set_cie+0x58>
  8004210216:	48 b9 5d 6e 21 04 80 	movabs $0x8004216e5d,%rcx
  800421021d:	00 00 00 
  8004210220:	48 ba a7 6c 21 04 80 	movabs $0x8004216ca7,%rdx
  8004210227:	00 00 00 
  800421022a:	be 7b 02 00 00       	mov    $0x27b,%esi
  800421022f:	48 bf bc 6c 21 04 80 	movabs $0x8004216cbc,%rdi
  8004210236:	00 00 00 
  8004210239:	b8 00 00 00 00       	mov    $0x0,%eax
  800421023e:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004210245:	00 00 00 
  8004210248:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  800421024b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421024f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004210253:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210257:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421025b:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  800421025e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210262:	48 8b 10             	mov    (%rax),%rdx
  8004210265:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210269:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800421026d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210271:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210275:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210279:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421027d:	48 89 d7             	mov    %rdx,%rdi
  8004210280:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004210284:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210289:	48 89 ce             	mov    %rcx,%rsi
  800421028c:	ff d0                	callq  *%rax
  800421028e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004210292:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210297:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421029b:	75 2e                	jne    80042102cb <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  800421029d:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  80042102a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102a8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042102ac:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042102b0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042102b4:	48 89 d7             	mov    %rdx,%rdi
  80042102b7:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042102bb:	ba 08 00 00 00       	mov    $0x8,%edx
  80042102c0:	48 89 ce             	mov    %rcx,%rsi
  80042102c3:	ff d0                	callq  *%rax
  80042102c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042102c9:	eb 07                	jmp    80042102d2 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  80042102cb:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  80042102d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102d6:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042102da:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042102de:	48 8b 00             	mov    (%rax),%rax
  80042102e1:	48 29 c2             	sub    %rax,%rdx
  80042102e4:	48 89 d0             	mov    %rdx,%rax
  80042102e7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042102eb:	73 0a                	jae    80042102f7 <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042102ed:	b8 12 00 00 00       	mov    $0x12,%eax
  80042102f2:	e9 7e 03 00 00       	jmpq   8004210675 <_dwarf_frame_set_cie+0x482>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  80042102f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102fb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042102ff:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210303:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210307:	48 89 d7             	mov    %rdx,%rdi
  800421030a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421030d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004210311:	48 89 ce             	mov    %rcx,%rsi
  8004210314:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004210316:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421031a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421031e:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004210322:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210326:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421032a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421032e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210332:	48 89 d7             	mov    %rdx,%rdi
  8004210335:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004210339:	ba 01 00 00 00       	mov    $0x1,%edx
  800421033e:	48 89 ce             	mov    %rcx,%rsi
  8004210341:	ff d0                	callq  *%rax
  8004210343:	89 c2                	mov    %eax,%edx
  8004210345:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210349:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  800421034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210351:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004210355:	66 83 f8 01          	cmp    $0x1,%ax
  8004210359:	74 26                	je     8004210381 <_dwarf_frame_set_cie+0x18e>
  800421035b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421035f:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004210363:	66 83 f8 03          	cmp    $0x3,%ax
  8004210367:	74 18                	je     8004210381 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004210369:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421036d:	0f b7 40 20          	movzwl 0x20(%rax),%eax
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004210371:	66 83 f8 04          	cmp    $0x4,%ax
  8004210375:	74 0a                	je     8004210381 <_dwarf_frame_set_cie+0x18e>
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004210377:	b8 16 00 00 00       	mov    $0x16,%eax
  800421037c:	e9 f4 02 00 00       	jmpq   8004210675 <_dwarf_frame_set_cie+0x482>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004210381:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210385:	48 8b 10             	mov    (%rax),%rdx
  8004210388:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421038c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004210390:	48 01 d0             	add    %rdx,%rax
  8004210393:	48 89 c2             	mov    %rax,%rdx
  8004210396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421039a:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  800421039e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042103a2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042103a6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  80042103aa:	90                   	nop
  80042103ab:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042103af:	48 8b 00             	mov    (%rax),%rax
  80042103b2:	48 8d 48 01          	lea    0x1(%rax),%rcx
  80042103b6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042103ba:	48 89 0a             	mov    %rcx,(%rdx)
  80042103bd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042103c1:	48 01 d0             	add    %rdx,%rax
  80042103c4:	0f b6 00             	movzbl (%rax),%eax
  80042103c7:	84 c0                	test   %al,%al
  80042103c9:	75 e0                	jne    80042103ab <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  80042103cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103cf:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042103d3:	0f b6 00             	movzbl (%rax),%eax
  80042103d6:	84 c0                	test   %al,%al
  80042103d8:	74 48                	je     8004210422 <_dwarf_frame_set_cie+0x22f>
  80042103da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103de:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042103e2:	0f b6 00             	movzbl (%rax),%eax
  80042103e5:	3c 7a                	cmp    $0x7a,%al
  80042103e7:	74 39                	je     8004210422 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042103e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103ed:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042103f1:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042103f5:	75 07                	jne    80042103fe <_dwarf_frame_set_cie+0x20b>
  80042103f7:	ba 04 00 00 00       	mov    $0x4,%edx
  80042103fc:	eb 05                	jmp    8004210403 <_dwarf_frame_set_cie+0x210>
  80042103fe:	ba 0c 00 00 00       	mov    $0xc,%edx
  8004210403:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004210406:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421040a:	48 8b 40 18          	mov    0x18(%rax),%rax
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  800421040e:	48 01 c2             	add    %rax,%rdx
  8004210411:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210415:	48 89 10             	mov    %rdx,(%rax)
		return (DW_DLE_NONE);
  8004210418:	b8 00 00 00 00       	mov    $0x0,%eax
  800421041d:	e9 53 02 00 00       	jmpq   8004210675 <_dwarf_frame_set_cie+0x482>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004210422:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210426:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421042a:	48 be 65 6e 21 04 80 	movabs $0x8004216e65,%rsi
  8004210431:	00 00 00 
  8004210434:	48 89 c7             	mov    %rax,%rdi
  8004210437:	48 b8 0d c9 20 04 80 	movabs $0x800420c90d,%rax
  800421043e:	00 00 00 
  8004210441:	ff d0                	callq  *%rax
  8004210443:	48 85 c0             	test   %rax,%rax
  8004210446:	74 2e                	je     8004210476 <_dwarf_frame_set_cie+0x283>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004210448:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421044c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210450:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210454:	8b 52 28             	mov    0x28(%rdx),%edx
  8004210457:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421045b:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800421045f:	48 89 cf             	mov    %rcx,%rdi
  8004210462:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004210466:	48 89 ce             	mov    %rcx,%rsi
  8004210469:	ff d0                	callq  *%rax
  800421046b:	48 89 c2             	mov    %rax,%rdx
  800421046e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210472:	48 89 50 30          	mov    %rdx,0x30(%rax)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004210476:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421047a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421047e:	48 89 c2             	mov    %rax,%rdx
  8004210481:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210485:	48 89 c6             	mov    %rax,%rsi
  8004210488:	48 89 d7             	mov    %rdx,%rdi
  800421048b:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  8004210492:	00 00 00 
  8004210495:	ff d0                	callq  *%rax
  8004210497:	48 89 c2             	mov    %rax,%rdx
  800421049a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421049e:	48 89 50 38          	mov    %rdx,0x38(%rax)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042104a2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042104a6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042104aa:	48 89 c2             	mov    %rax,%rdx
  80042104ad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042104b1:	48 89 c6             	mov    %rax,%rsi
  80042104b4:	48 89 d7             	mov    %rdx,%rdi
  80042104b7:	48 b8 56 cf 20 04 80 	movabs $0x800420cf56,%rax
  80042104be:	00 00 00 
  80042104c1:	ff d0                	callq  *%rax
  80042104c3:	48 89 c2             	mov    %rax,%rdx
  80042104c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104ca:	48 89 50 40          	mov    %rdx,0x40(%rax)

	/* Return address register. */
	if (cie->cie_version == 1)
  80042104ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104d2:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042104d6:	66 83 f8 01          	cmp    $0x1,%ax
  80042104da:	75 2e                	jne    800421050a <_dwarf_frame_set_cie+0x317>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  80042104dc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042104e0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042104e4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042104e8:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042104ec:	48 89 d7             	mov    %rdx,%rdi
  80042104ef:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042104f3:	ba 01 00 00 00       	mov    $0x1,%edx
  80042104f8:	48 89 ce             	mov    %rcx,%rsi
  80042104fb:	ff d0                	callq  *%rax
  80042104fd:	48 89 c2             	mov    %rax,%rdx
  8004210500:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210504:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004210508:	eb 2c                	jmp    8004210536 <_dwarf_frame_set_cie+0x343>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421050a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421050e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004210512:	48 89 c2             	mov    %rax,%rdx
  8004210515:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210519:	48 89 c6             	mov    %rax,%rsi
  800421051c:	48 89 d7             	mov    %rdx,%rdi
  800421051f:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  8004210526:	00 00 00 
  8004210529:	ff d0                	callq  *%rax
  800421052b:	48 89 c2             	mov    %rax,%rdx
  800421052e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210532:	48 89 50 48          	mov    %rdx,0x48(%rax)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004210536:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421053a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421053e:	0f b6 00             	movzbl (%rax),%eax
  8004210541:	3c 7a                	cmp    $0x7a,%al
  8004210543:	0f 85 99 00 00 00    	jne    80042105e2 <_dwarf_frame_set_cie+0x3ef>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004210549:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421054d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004210551:	48 89 c2             	mov    %rax,%rdx
  8004210554:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210558:	48 89 c6             	mov    %rax,%rsi
  800421055b:	48 89 d7             	mov    %rdx,%rdi
  800421055e:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  8004210565:	00 00 00 
  8004210568:	ff d0                	callq  *%rax
  800421056a:	48 89 c2             	mov    %rax,%rdx
  800421056d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210571:	48 89 50 50          	mov    %rdx,0x50(%rax)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004210575:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210579:	48 8b 10             	mov    (%rax),%rdx
  800421057c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210580:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004210584:	48 01 d0             	add    %rdx,%rax
  8004210587:	48 89 c2             	mov    %rax,%rdx
  800421058a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421058e:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004210592:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210596:	48 8b 10             	mov    (%rax),%rdx
  8004210599:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421059d:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042105a1:	48 01 c2             	add    %rax,%rdx
  80042105a4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042105a8:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  80042105ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105af:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  80042105b3:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042105b7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042105bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042105bf:	48 89 ce             	mov    %rcx,%rsi
  80042105c2:	48 89 c7             	mov    %rax,%rdi
  80042105c5:	48 b8 a3 00 21 04 80 	movabs $0x80042100a3,%rax
  80042105cc:	00 00 00 
  80042105cf:	ff d0                	callq  *%rax
  80042105d1:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  80042105d4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042105d8:	74 08                	je     80042105e2 <_dwarf_frame_set_cie+0x3ef>
			return (ret);
  80042105da:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042105dd:	e9 93 00 00 00       	jmpq   8004210675 <_dwarf_frame_set_cie+0x482>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042105e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042105e6:	48 8b 10             	mov    (%rax),%rdx
  80042105e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042105ed:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042105f1:	48 01 d0             	add    %rdx,%rax
  80042105f4:	48 89 c2             	mov    %rax,%rdx
  80042105f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105fb:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  80042105ff:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004210603:	75 2a                	jne    800421062f <_dwarf_frame_set_cie+0x43c>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004210605:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210609:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421060d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210611:	48 01 c2             	add    %rax,%rdx
  8004210614:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210618:	48 8b 00             	mov    (%rax),%rax
  800421061b:	48 29 c2             	sub    %rax,%rdx
  800421061e:	48 89 d0             	mov    %rdx,%rax
  8004210621:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004210625:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210629:	48 89 50 70          	mov    %rdx,0x70(%rax)
  800421062d:	eb 28                	jmp    8004210657 <_dwarf_frame_set_cie+0x464>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  800421062f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210633:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421063b:	48 01 c2             	add    %rax,%rdx
  800421063e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210642:	48 8b 00             	mov    (%rax),%rax
  8004210645:	48 29 c2             	sub    %rax,%rdx
  8004210648:	48 89 d0             	mov    %rdx,%rax
  800421064b:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  800421064f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210653:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004210657:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421065b:	48 8b 10             	mov    (%rax),%rdx
  800421065e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210662:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004210666:	48 01 c2             	add    %rax,%rdx
  8004210669:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421066d:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004210670:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210675:	c9                   	leaveq 
  8004210676:	c3                   	retq   

0000008004210677 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004210677:	55                   	push   %rbp
  8004210678:	48 89 e5             	mov    %rsp,%rbp
  800421067b:	48 83 ec 60          	sub    $0x60,%rsp
  800421067f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004210683:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004210687:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421068b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421068f:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004210693:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004210697:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421069b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  800421069f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106a3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042106a7:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042106aa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042106ae:	48 8b 10             	mov    (%rax),%rdx
  80042106b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042106b5:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042106b9:	48 01 d0             	add    %rdx,%rax
  80042106bc:	48 89 c2             	mov    %rax,%rdx
  80042106bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106c3:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  80042106c7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042106cb:	48 8b 10             	mov    (%rax),%rdx
  80042106ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106d2:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042106d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042106da:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042106de:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042106e2:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042106e6:	48 89 d7             	mov    %rdx,%rdi
  80042106e9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042106ed:	ba 04 00 00 00       	mov    $0x4,%edx
  80042106f2:	48 89 ce             	mov    %rcx,%rsi
  80042106f5:	ff d0                	callq  *%rax
  80042106f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  80042106fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210700:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004210704:	75 2e                	jne    8004210734 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004210706:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  800421070d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210711:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210715:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210719:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421071d:	48 89 d7             	mov    %rdx,%rdi
  8004210720:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004210724:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210729:	48 89 ce             	mov    %rcx,%rsi
  800421072c:	ff d0                	callq  *%rax
  800421072e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210732:	eb 07                	jmp    800421073b <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004210734:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  800421073b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421073f:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004210743:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210747:	48 8b 00             	mov    (%rax),%rax
  800421074a:	48 29 c2             	sub    %rax,%rdx
  800421074d:	48 89 d0             	mov    %rdx,%rax
  8004210750:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004210754:	73 0a                	jae    8004210760 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004210756:	b8 12 00 00 00       	mov    $0x12,%eax
  800421075b:	e9 fb 02 00 00       	jmpq   8004210a5b <_dwarf_frame_set_fde+0x3e4>
	}

	fde->fde_length = length;
  8004210760:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210764:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210768:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  800421076c:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004210770:	74 61                	je     80042107d3 <_dwarf_frame_set_fde+0x15c>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004210772:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210776:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421077a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421077e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210782:	48 89 d7             	mov    %rdx,%rdi
  8004210785:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004210789:	ba 04 00 00 00       	mov    $0x4,%edx
  800421078e:	48 89 ce             	mov    %rcx,%rsi
  8004210791:	ff d0                	callq  *%rax
  8004210793:	48 89 c2             	mov    %rax,%rdx
  8004210796:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421079a:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = *off - (4 + fde->fde_cieoff);
  800421079e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042107a2:	48 8b 10             	mov    (%rax),%rdx
  80042107a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107a9:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042107ad:	48 29 c2             	sub    %rax,%rdx
  80042107b0:	48 89 d0             	mov    %rdx,%rax
  80042107b3:	48 83 e8 04          	sub    $0x4,%rax
  80042107b7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  80042107bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107bf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042107c3:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042107c7:	75 40                	jne    8004210809 <_dwarf_frame_set_fde+0x192>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  80042107c9:	b8 13 00 00 00       	mov    $0x13,%eax
  80042107ce:	e9 88 02 00 00       	jmpq   8004210a5b <_dwarf_frame_set_fde+0x3e4>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  80042107d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042107d7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042107db:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042107df:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042107e3:	48 89 d7             	mov    %rdx,%rdi
  80042107e6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042107e9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042107ed:	48 89 ce             	mov    %rcx,%rsi
  80042107f0:	ff d0                	callq  *%rax
  80042107f2:	48 89 c2             	mov    %rax,%rdx
  80042107f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107f9:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = fde->fde_cieoff;
  80042107fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210801:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210805:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004210809:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800421080d:	0f 84 e2 00 00 00    	je     80042108f5 <_dwarf_frame_set_fde+0x27e>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004210813:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210817:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421081b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421081f:	48 8b 00             	mov    (%rax),%rax
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004210822:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004210826:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421082a:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421082e:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  8004210831:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210835:	48 8b 40 38          	mov    0x38(%rax),%rax
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004210839:	49 89 c2             	mov    %rax,%r10
  800421083c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210840:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004210844:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210848:	48 83 ec 08          	sub    $0x8,%rsp
  800421084c:	ff 75 10             	pushq  0x10(%rbp)
  800421084f:	49 89 f9             	mov    %rdi,%r9
  8004210852:	41 89 c8             	mov    %ecx,%r8d
  8004210855:	48 89 d1             	mov    %rdx,%rcx
  8004210858:	4c 89 d2             	mov    %r10,%rdx
  800421085b:	48 89 c7             	mov    %rax,%rdi
  800421085e:	48 b8 77 fe 20 04 80 	movabs $0x800420fe77,%rax
  8004210865:	00 00 00 
  8004210868:	ff d0                	callq  *%rax
  800421086a:	48 83 c4 10          	add    $0x10,%rsp
  800421086e:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004210871:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210875:	74 08                	je     800421087f <_dwarf_frame_set_fde+0x208>
			return (ret);
  8004210877:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421087a:	e9 dc 01 00 00       	jmpq   8004210a5b <_dwarf_frame_set_fde+0x3e4>
		fde->fde_initloc = val;
  800421087f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210883:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210887:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  800421088b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421088f:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004210893:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  8004210896:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421089a:	48 8b 40 38          	mov    0x38(%rax),%rax
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421089e:	48 89 c7             	mov    %rax,%rdi
  80042108a1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042108a5:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80042108a9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042108ad:	48 83 ec 08          	sub    $0x8,%rsp
  80042108b1:	ff 75 10             	pushq  0x10(%rbp)
  80042108b4:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042108ba:	41 89 c8             	mov    %ecx,%r8d
  80042108bd:	48 89 d1             	mov    %rdx,%rcx
  80042108c0:	48 89 fa             	mov    %rdi,%rdx
  80042108c3:	48 89 c7             	mov    %rax,%rdi
  80042108c6:	48 b8 77 fe 20 04 80 	movabs $0x800420fe77,%rax
  80042108cd:	00 00 00 
  80042108d0:	ff d0                	callq  *%rax
  80042108d2:	48 83 c4 10          	add    $0x10,%rsp
  80042108d6:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  80042108d9:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042108dd:	74 08                	je     80042108e7 <_dwarf_frame_set_fde+0x270>
			return (ret);
  80042108df:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042108e2:	e9 74 01 00 00       	jmpq   8004210a5b <_dwarf_frame_set_fde+0x3e4>
		fde->fde_adrange = val;
  80042108e7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042108eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108ef:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042108f3:	eb 5c                	jmp    8004210951 <_dwarf_frame_set_fde+0x2da>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042108f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042108f9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042108fd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210901:	8b 52 28             	mov    0x28(%rdx),%edx
  8004210904:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004210908:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800421090c:	48 89 cf             	mov    %rcx,%rdi
  800421090f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004210913:	48 89 ce             	mov    %rcx,%rsi
  8004210916:	ff d0                	callq  *%rax
  8004210918:	48 89 c2             	mov    %rax,%rdx
  800421091b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421091f:	48 89 50 30          	mov    %rdx,0x30(%rax)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004210923:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210927:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421092b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421092f:	8b 52 28             	mov    0x28(%rdx),%edx
  8004210932:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004210936:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800421093a:	48 89 cf             	mov    %rcx,%rdi
  800421093d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004210941:	48 89 ce             	mov    %rcx,%rsi
  8004210944:	ff d0                	callq  *%rax
  8004210946:	48 89 c2             	mov    %rax,%rdx
  8004210949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421094d:	48 89 50 38          	mov    %rdx,0x38(%rax)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004210951:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004210955:	74 71                	je     80042109c8 <_dwarf_frame_set_fde+0x351>
  8004210957:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421095b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421095f:	0f b6 00             	movzbl (%rax),%eax
  8004210962:	3c 7a                	cmp    $0x7a,%al
  8004210964:	75 62                	jne    80042109c8 <_dwarf_frame_set_fde+0x351>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004210966:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421096a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421096e:	48 89 c2             	mov    %rax,%rdx
  8004210971:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210975:	48 89 c6             	mov    %rax,%rsi
  8004210978:	48 89 d7             	mov    %rdx,%rdi
  800421097b:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  8004210982:	00 00 00 
  8004210985:	ff d0                	callq  *%rax
  8004210987:	48 89 c2             	mov    %rax,%rdx
  800421098a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421098e:	48 89 50 40          	mov    %rdx,0x40(%rax)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004210992:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210996:	48 8b 10             	mov    (%rax),%rdx
  8004210999:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421099d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042109a1:	48 01 d0             	add    %rdx,%rax
  80042109a4:	48 89 c2             	mov    %rax,%rdx
  80042109a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109ab:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  80042109af:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042109b3:	48 8b 10             	mov    (%rax),%rdx
  80042109b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109ba:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042109be:	48 01 c2             	add    %rax,%rdx
  80042109c1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042109c5:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042109c8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042109cc:	48 8b 10             	mov    (%rax),%rdx
  80042109cf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042109d3:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042109d7:	48 01 d0             	add    %rdx,%rax
  80042109da:	48 89 c2             	mov    %rax,%rdx
  80042109dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109e1:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  80042109e5:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042109e9:	75 2a                	jne    8004210a15 <_dwarf_frame_set_fde+0x39e>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  80042109eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109ef:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042109f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042109f7:	48 01 c2             	add    %rax,%rdx
  80042109fa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042109fe:	48 8b 00             	mov    (%rax),%rax
  8004210a01:	48 29 c2             	sub    %rax,%rdx
  8004210a04:	48 89 d0             	mov    %rdx,%rax
  8004210a07:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004210a0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a0f:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004210a13:	eb 28                	jmp    8004210a3d <_dwarf_frame_set_fde+0x3c6>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004210a15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a19:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210a1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a21:	48 01 c2             	add    %rax,%rdx
  8004210a24:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210a28:	48 8b 00             	mov    (%rax),%rax
  8004210a2b:	48 29 c2             	sub    %rax,%rdx
  8004210a2e:	48 89 d0             	mov    %rdx,%rax
  8004210a31:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004210a35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a39:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004210a3d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210a41:	48 8b 10             	mov    (%rax),%rdx
  8004210a44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a48:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004210a4c:	48 01 c2             	add    %rax,%rdx
  8004210a4f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210a53:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004210a56:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210a5b:	c9                   	leaveq 
  8004210a5c:	c3                   	retq   

0000008004210a5d <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004210a5d:	55                   	push   %rbp
  8004210a5e:	48 89 e5             	mov    %rsp,%rbp
  8004210a61:	48 83 ec 20          	sub    $0x20,%rsp
  8004210a65:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210a69:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004210a6d:	48 b8 00 c7 57 04 80 	movabs $0x800457c700,%rax
  8004210a74:	00 00 00 
  8004210a77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  8004210a7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a7f:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004210a83:	48 85 c0             	test   %rax,%rax
  8004210a86:	74 07                	je     8004210a8f <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  8004210a88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a8d:	eb 33                	jmp    8004210ac2 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004210a8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a93:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004210a97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a9b:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004210a9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210aa3:	48 b9 40 d0 57 04 80 	movabs $0x800457d040,%rcx
  8004210aaa:	00 00 00 
  8004210aad:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  8004210ab1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ab5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210ab9:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004210abd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210ac2:	c9                   	leaveq 
  8004210ac3:	c3                   	retq   

0000008004210ac4 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004210ac4:	55                   	push   %rbp
  8004210ac5:	48 89 e5             	mov    %rsp,%rbp
  8004210ac8:	48 83 ec 50          	sub    $0x50,%rsp
  8004210acc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004210ad0:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004210ad3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004210ad7:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004210adb:	48 b8 e0 86 22 04 80 	movabs $0x80042286e0,%rax
  8004210ae2:	00 00 00 
  8004210ae5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004210ae9:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004210af0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210af4:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210af8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004210afc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210b00:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004210b04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210b08:	48 39 c2             	cmp    %rax,%rdx
  8004210b0b:	0f 86 04 02 00 00    	jbe    8004210d15 <_dwarf_get_next_fde+0x251>
		entry_off = offset;
  8004210b11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210b15:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004210b19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210b1d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210b21:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210b25:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210b29:	48 89 d7             	mov    %rdx,%rdi
  8004210b2c:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004210b30:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210b35:	48 89 ce             	mov    %rcx,%rsi
  8004210b38:	ff d0                	callq  *%rax
  8004210b3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004210b3e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210b43:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004210b47:	75 2e                	jne    8004210b77 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004210b49:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004210b50:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210b54:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210b58:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210b5c:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210b60:	48 89 d7             	mov    %rdx,%rdi
  8004210b63:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004210b67:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210b6c:	48 89 ce             	mov    %rcx,%rsi
  8004210b6f:	ff d0                	callq  *%rax
  8004210b71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210b75:	eb 07                	jmp    8004210b7e <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  8004210b77:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004210b7e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210b82:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004210b86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210b8a:	48 29 c2             	sub    %rax,%rdx
  8004210b8d:	48 89 d0             	mov    %rdx,%rax
  8004210b90:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004210b94:	72 0d                	jb     8004210ba3 <_dwarf_get_next_fde+0xdf>
  8004210b96:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210b9b:	75 10                	jne    8004210bad <_dwarf_get_next_fde+0xe9>
  8004210b9d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004210ba1:	75 0a                	jne    8004210bad <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004210ba3:	b8 12 00 00 00       	mov    $0x12,%eax
  8004210ba8:	e9 6d 01 00 00       	jmpq   8004210d1a <_dwarf_get_next_fde+0x256>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004210bad:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004210bb1:	74 11                	je     8004210bc4 <_dwarf_get_next_fde+0x100>
  8004210bb3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210bb8:	75 0a                	jne    8004210bc4 <_dwarf_get_next_fde+0x100>
			return(-1);
  8004210bba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210bbf:	e9 56 01 00 00       	jmpq   8004210d1a <_dwarf_get_next_fde+0x256>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  8004210bc4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210bc8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210bcc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210bd0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210bd4:	48 89 d7             	mov    %rdx,%rdi
  8004210bd7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004210bda:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004210bde:	48 89 ce             	mov    %rcx,%rsi
  8004210be1:	ff d0                	callq  *%rax
  8004210be3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004210be7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004210beb:	74 7c                	je     8004210c69 <_dwarf_get_next_fde+0x1a5>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004210bed:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210bf2:	75 32                	jne    8004210c26 <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004210bf4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210bf8:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004210bfc:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004210c00:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004210c04:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004210c08:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210c0c:	49 89 f8             	mov    %rdi,%r8
  8004210c0f:	48 89 c7             	mov    %rax,%rdi
  8004210c12:	48 b8 f3 01 21 04 80 	movabs $0x80042101f3,%rax
  8004210c19:	00 00 00 
  8004210c1c:	ff d0                	callq  *%rax
  8004210c1e:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004210c21:	e9 ce 00 00 00       	jmpq   8004210cf4 <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004210c26:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210c2a:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210c2e:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004210c32:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210c36:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210c3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210c3e:	48 83 ec 08          	sub    $0x8,%rsp
  8004210c42:	ff 75 b8             	pushq  -0x48(%rbp)
  8004210c45:	49 89 f9             	mov    %rdi,%r9
  8004210c48:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004210c4e:	48 89 c7             	mov    %rax,%rdi
  8004210c51:	48 b8 77 06 21 04 80 	movabs $0x8004210677,%rax
  8004210c58:	00 00 00 
  8004210c5b:	ff d0                	callq  *%rax
  8004210c5d:	48 83 c4 10          	add    $0x10,%rsp
  8004210c61:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004210c64:	e9 8b 00 00 00       	jmpq   8004210cf4 <_dwarf_get_next_fde+0x230>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004210c69:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004210c6d:	75 0b                	jne    8004210c7a <_dwarf_get_next_fde+0x1b6>
  8004210c6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210c74:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004210c78:	74 0d                	je     8004210c87 <_dwarf_get_next_fde+0x1c3>
  8004210c7a:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004210c7e:	75 36                	jne    8004210cb6 <_dwarf_get_next_fde+0x1f2>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004210c80:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004210c85:	75 2f                	jne    8004210cb6 <_dwarf_get_next_fde+0x1f2>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004210c87:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210c8b:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004210c8f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004210c93:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004210c97:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004210c9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210c9f:	49 89 f8             	mov    %rdi,%r8
  8004210ca2:	48 89 c7             	mov    %rax,%rdi
  8004210ca5:	48 b8 f3 01 21 04 80 	movabs $0x80042101f3,%rax
  8004210cac:	00 00 00 
  8004210caf:	ff d0                	callq  *%rax
  8004210cb1:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004210cb4:	eb 3e                	jmp    8004210cf4 <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004210cb6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210cba:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210cbe:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004210cc2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210cc6:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210cca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210cce:	48 83 ec 08          	sub    $0x8,%rsp
  8004210cd2:	ff 75 b8             	pushq  -0x48(%rbp)
  8004210cd5:	49 89 f9             	mov    %rdi,%r9
  8004210cd8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004210cde:	48 89 c7             	mov    %rax,%rdi
  8004210ce1:	48 b8 77 06 21 04 80 	movabs $0x8004210677,%rax
  8004210ce8:	00 00 00 
  8004210ceb:	ff d0                	callq  *%rax
  8004210ced:	48 83 c4 10          	add    $0x10,%rsp
  8004210cf1:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004210cf4:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004210cf8:	74 07                	je     8004210d01 <_dwarf_get_next_fde+0x23d>
			return(-1);
  8004210cfa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210cff:	eb 19                	jmp    8004210d1a <_dwarf_get_next_fde+0x256>

		offset = entry_off;
  8004210d01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d05:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  8004210d09:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210d0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210d11:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004210d15:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210d1a:	c9                   	leaveq 
  8004210d1b:	c3                   	retq   

0000008004210d1c <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004210d1c:	55                   	push   %rbp
  8004210d1d:	48 89 e5             	mov    %rsp,%rbp
  8004210d20:	48 83 ec 20          	sub    $0x20,%rsp
  8004210d24:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d28:	89 f0                	mov    %esi,%eax
  8004210d2a:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  8004210d2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d32:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210d36:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  8004210d3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d3e:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004210d42:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004210d46:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004210d4a:	c9                   	leaveq 
  8004210d4b:	c3                   	retq   

0000008004210d4c <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004210d4c:	55                   	push   %rbp
  8004210d4d:	48 89 e5             	mov    %rsp,%rbp
  8004210d50:	48 83 ec 10          	sub    $0x10,%rsp
  8004210d54:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210d58:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004210d5c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210d61:	75 0a                	jne    8004210d6d <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004210d63:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210d68:	e9 85 00 00 00       	jmpq   8004210df2 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004210d6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d71:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004210d75:	48 85 c0             	test   %rax,%rax
  8004210d78:	75 25                	jne    8004210d9f <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004210d7a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210d7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d82:	48 89 d6             	mov    %rdx,%rsi
  8004210d85:	48 89 c7             	mov    %rax,%rdi
  8004210d88:	48 b8 5d 0a 21 04 80 	movabs $0x8004210a5d,%rax
  8004210d8f:	00 00 00 
  8004210d92:	ff d0                	callq  *%rax
  8004210d94:	85 c0                	test   %eax,%eax
  8004210d96:	74 07                	je     8004210d9f <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  8004210d98:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210d9d:	eb 53                	jmp    8004210df2 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004210d9f:	48 bf e0 86 22 04 80 	movabs $0x80042286e0,%rdi
  8004210da6:	00 00 00 
  8004210da9:	48 b8 d1 e7 20 04 80 	movabs $0x800420e7d1,%rax
  8004210db0:	00 00 00 
  8004210db3:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  8004210db5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210db9:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004210dc0:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004210dc1:	48 b8 e0 86 22 04 80 	movabs $0x80042286e0,%rax
  8004210dc8:	00 00 00 
  8004210dcb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210dcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210dd3:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004210dd7:	48 b8 e0 86 22 04 80 	movabs $0x80042286e0,%rax
  8004210dde:	00 00 00 
  8004210de1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210de5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210de9:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004210ded:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210df2:	c9                   	leaveq 
  8004210df3:	c3                   	retq   

0000008004210df4 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004210df4:	55                   	push   %rbp
  8004210df5:	48 89 e5             	mov    %rsp,%rbp
  8004210df8:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004210dff:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004210e03:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004210e07:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004210e0b:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004210e0f:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004210e16:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004210e1d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210e21:	48 83 c0 48          	add    $0x48,%rax
  8004210e25:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004210e29:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210e30:	00 
  8004210e31:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004210e38:	00 
  8004210e39:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004210e40:	00 
  8004210e41:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004210e48:	00 
  8004210e49:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210e4d:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210e51:	0f b6 c0             	movzbl %al,%eax
  8004210e54:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004210e57:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004210e5e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004210e65:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004210e6c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004210e73:	e9 b1 04 00 00       	jmpq   8004211329 <_dwarf_lineno_run_program+0x535>
		if (*p == 0) {
  8004210e78:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210e7c:	0f b6 00             	movzbl (%rax),%eax
  8004210e7f:	84 c0                	test   %al,%al
  8004210e81:	0f 85 49 01 00 00    	jne    8004210fd0 <_dwarf_lineno_run_program+0x1dc>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004210e87:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210e8b:	48 83 c0 01          	add    $0x1,%rax
  8004210e8f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004210e93:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004210e97:	48 89 c7             	mov    %rax,%rdi
  8004210e9a:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  8004210ea1:	00 00 00 
  8004210ea4:	ff d0                	callq  *%rax
  8004210ea6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			switch (*p) {
  8004210eaa:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210eae:	0f b6 00             	movzbl (%rax),%eax
  8004210eb1:	0f b6 c0             	movzbl %al,%eax
  8004210eb4:	83 f8 02             	cmp    $0x2,%eax
  8004210eb7:	74 74                	je     8004210f2d <_dwarf_lineno_run_program+0x139>
  8004210eb9:	83 f8 03             	cmp    $0x3,%eax
  8004210ebc:	0f 84 a4 00 00 00    	je     8004210f66 <_dwarf_lineno_run_program+0x172>
  8004210ec2:	83 f8 01             	cmp    $0x1,%eax
  8004210ec5:	0f 85 f1 00 00 00    	jne    8004210fbc <_dwarf_lineno_run_program+0x1c8>
			case DW_LNE_end_sequence:
				p++;
  8004210ecb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210ecf:	48 83 c0 01          	add    $0x1,%rax
  8004210ed3:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				end_sequence = 1;
  8004210ed7:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
				RESET_REGISTERS;
  8004210ede:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210ee5:	00 
  8004210ee6:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004210eed:	00 
  8004210eee:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004210ef5:	00 
  8004210ef6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004210efd:	00 
  8004210efe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f02:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210f06:	0f b6 c0             	movzbl %al,%eax
  8004210f09:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004210f0c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004210f13:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004210f1a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004210f21:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  8004210f28:	e9 9e 00 00 00       	jmpq   8004210fcb <_dwarf_lineno_run_program+0x1d7>
			case DW_LNE_set_address:
				p++;
  8004210f2d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210f31:	48 83 c0 01          	add    $0x1,%rax
  8004210f35:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004210f39:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004210f40:	00 00 00 
  8004210f43:	48 8b 00             	mov    (%rax),%rax
  8004210f46:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004210f4a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210f4e:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210f52:	0f b6 ca             	movzbl %dl,%ecx
  8004210f55:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  8004210f59:	89 ce                	mov    %ecx,%esi
  8004210f5b:	48 89 d7             	mov    %rdx,%rdi
  8004210f5e:	ff d0                	callq  *%rax
  8004210f60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				break;
  8004210f64:	eb 65                	jmp    8004210fcb <_dwarf_lineno_run_program+0x1d7>
			case DW_LNE_define_file:
				p++;
  8004210f66:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210f6a:	48 83 c0 01          	add    $0x1,%rax
  8004210f6e:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004210f72:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004210f79:	00 00 00 
  8004210f7c:	48 8b 08             	mov    (%rax),%rcx
  8004210f7f:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210f86:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  8004210f8a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f8e:	49 89 c8             	mov    %rcx,%r8
  8004210f91:	48 89 d1             	mov    %rdx,%rcx
  8004210f94:	ba 00 00 00 00       	mov    $0x0,%edx
  8004210f99:	48 89 c7             	mov    %rax,%rdi
  8004210f9c:	48 b8 3e 13 21 04 80 	movabs $0x800421133e,%rax
  8004210fa3:	00 00 00 
  8004210fa6:	ff d0                	callq  *%rax
  8004210fa8:	89 45 b4             	mov    %eax,-0x4c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004210fab:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004210faf:	74 09                	je     8004210fba <_dwarf_lineno_run_program+0x1c6>
					goto prog_fail;
  8004210fb1:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  8004210fb2:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004210fb5:	e9 82 03 00 00       	jmpq   800421133c <_dwarf_lineno_run_program+0x548>
				break;
  8004210fba:	eb 0f                	jmp    8004210fcb <_dwarf_lineno_run_program+0x1d7>
				p += opsize;
  8004210fbc:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004210fc0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210fc4:	48 01 d0             	add    %rdx,%rax
  8004210fc7:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004210fcb:	e9 59 03 00 00       	jmpq   8004211329 <_dwarf_lineno_run_program+0x535>
		} else if (*p > 0 && *p < li->li_opbase) {
  8004210fd0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210fd4:	0f b6 00             	movzbl (%rax),%eax
  8004210fd7:	84 c0                	test   %al,%al
  8004210fd9:	0f 84 24 02 00 00    	je     8004211203 <_dwarf_lineno_run_program+0x40f>
  8004210fdf:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210fe3:	0f b6 10             	movzbl (%rax),%edx
  8004210fe6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210fea:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004210fee:	38 c2                	cmp    %al,%dl
  8004210ff0:	0f 83 0d 02 00 00    	jae    8004211203 <_dwarf_lineno_run_program+0x40f>
			switch (*p++) {
  8004210ff6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210ffa:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210ffe:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004211002:	0f b6 00             	movzbl (%rax),%eax
  8004211005:	0f b6 c0             	movzbl %al,%eax
  8004211008:	83 f8 0c             	cmp    $0xc,%eax
  800421100b:	0f 87 ec 01 00 00    	ja     80042111fd <_dwarf_lineno_run_program+0x409>
  8004211011:	89 c0                	mov    %eax,%eax
  8004211013:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421101a:	00 
  800421101b:	48 b8 68 6e 21 04 80 	movabs $0x8004216e68,%rax
  8004211022:	00 00 00 
  8004211025:	48 01 d0             	add    %rdx,%rax
  8004211028:	48 8b 00             	mov    (%rax),%rax
  800421102b:	ff e0                	jmpq   *%rax
				APPEND_ROW;
  800421102d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004211034:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004211038:	73 0a                	jae    8004211044 <_dwarf_lineno_run_program+0x250>
  800421103a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421103f:	e9 f8 02 00 00       	jmpq   800421133c <_dwarf_lineno_run_program+0x548>
  8004211044:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211048:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421104c:	48 89 10             	mov    %rdx,(%rax)
  800421104f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211053:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800421105a:	00 
  800421105b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421105f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211063:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211067:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421106b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421106f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004211073:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211077:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421107b:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421107f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211083:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004211086:	89 50 28             	mov    %edx,0x28(%rax)
  8004211089:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421108d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004211090:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004211093:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211097:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800421109a:	89 50 30             	mov    %edx,0x30(%rax)
  800421109d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042110a1:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042110a8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042110ac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042110b0:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  80042110b7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				prologue_end = 0;
  80042110be:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
				epilogue_begin = 0;
  80042110c5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  80042110cc:	e9 2d 01 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				address += _dwarf_decode_uleb128(&p) *
  80042110d1:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042110d5:	48 89 c7             	mov    %rax,%rdi
  80042110d8:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  80042110df:	00 00 00 
  80042110e2:	ff d0                	callq  *%rax
  80042110e4:	48 89 c2             	mov    %rax,%rdx
					li->li_minlen;
  80042110e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042110eb:	0f b6 40 18          	movzbl 0x18(%rax),%eax
				address += _dwarf_decode_uleb128(&p) *
  80042110ef:	0f b6 c0             	movzbl %al,%eax
  80042110f2:	48 0f af c2          	imul   %rdx,%rax
  80042110f6:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  80042110fa:	e9 ff 00 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				line += _dwarf_decode_sleb128(&p);
  80042110ff:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004211103:	48 89 c7             	mov    %rax,%rdi
  8004211106:	48 b8 79 d0 20 04 80 	movabs $0x800420d079,%rax
  800421110d:	00 00 00 
  8004211110:	ff d0                	callq  *%rax
  8004211112:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004211116:	e9 e3 00 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				file = _dwarf_decode_uleb128(&p);
  800421111b:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421111f:	48 89 c7             	mov    %rax,%rdi
  8004211122:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  8004211129:	00 00 00 
  800421112c:	ff d0                	callq  *%rax
  800421112e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
				break;
  8004211132:	e9 c7 00 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				column = _dwarf_decode_uleb128(&p);
  8004211137:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421113b:	48 89 c7             	mov    %rax,%rdi
  800421113e:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  8004211145:	00 00 00 
  8004211148:	ff d0                	callq  *%rax
  800421114a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  800421114e:	e9 ab 00 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				is_stmt = !is_stmt;
  8004211153:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004211157:	0f 94 c0             	sete   %al
  800421115a:	0f b6 c0             	movzbl %al,%eax
  800421115d:	89 45 dc             	mov    %eax,-0x24(%rbp)
				break;
  8004211160:	e9 99 00 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				basic_block = 1;
  8004211165:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
				break;
  800421116c:	e9 8d 00 00 00       	jmpq   80042111fe <_dwarf_lineno_run_program+0x40a>
				address += ADDRESS(255);
  8004211171:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211175:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004211179:	0f b6 c0             	movzbl %al,%eax
  800421117c:	ba ff 00 00 00       	mov    $0xff,%edx
  8004211181:	89 d1                	mov    %edx,%ecx
  8004211183:	29 c1                	sub    %eax,%ecx
  8004211185:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211189:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  800421118d:	0f b6 f0             	movzbl %al,%esi
  8004211190:	89 c8                	mov    %ecx,%eax
  8004211192:	99                   	cltd   
  8004211193:	f7 fe                	idiv   %esi
  8004211195:	89 c2                	mov    %eax,%edx
  8004211197:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421119b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421119f:	0f b6 c0             	movzbl %al,%eax
  80042111a2:	0f af c2             	imul   %edx,%eax
  80042111a5:	48 98                	cltq   
  80042111a7:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  80042111ab:	eb 51                	jmp    80042111fe <_dwarf_lineno_run_program+0x40a>
				address += dbg->decode(&p, 2);
  80042111ad:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  80042111b4:	00 00 00 
  80042111b7:	48 8b 00             	mov    (%rax),%rax
  80042111ba:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042111be:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  80042111c2:	be 02 00 00 00       	mov    $0x2,%esi
  80042111c7:	48 89 d7             	mov    %rdx,%rdi
  80042111ca:	ff d0                	callq  *%rax
  80042111cc:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  80042111d0:	eb 2c                	jmp    80042111fe <_dwarf_lineno_run_program+0x40a>
				prologue_end = 1;
  80042111d2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				break;
  80042111d9:	eb 23                	jmp    80042111fe <_dwarf_lineno_run_program+0x40a>
				epilogue_begin = 1;
  80042111db:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%rbp)
				break;
  80042111e2:	eb 1a                	jmp    80042111fe <_dwarf_lineno_run_program+0x40a>
				isa = _dwarf_decode_uleb128(&p);
  80042111e4:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042111e8:	48 89 c7             	mov    %rax,%rdi
  80042111eb:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  80042111f2:	00 00 00 
  80042111f5:	ff d0                	callq  *%rax
  80042111f7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				break;
  80042111fb:	eb 01                	jmp    80042111fe <_dwarf_lineno_run_program+0x40a>
				break;
  80042111fd:	90                   	nop
		} else {
  80042111fe:	e9 26 01 00 00       	jmpq   8004211329 <_dwarf_lineno_run_program+0x535>
			line += LINE(*p);
  8004211203:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211207:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  800421120b:	0f be c8             	movsbl %al,%ecx
  800421120e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211212:	0f b6 00             	movzbl (%rax),%eax
  8004211215:	0f b6 d0             	movzbl %al,%edx
  8004211218:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421121c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004211220:	0f b6 c0             	movzbl %al,%eax
  8004211223:	29 c2                	sub    %eax,%edx
  8004211225:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211229:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  800421122d:	0f b6 f0             	movzbl %al,%esi
  8004211230:	89 d0                	mov    %edx,%eax
  8004211232:	99                   	cltd   
  8004211233:	f7 fe                	idiv   %esi
  8004211235:	89 d0                	mov    %edx,%eax
  8004211237:	01 c8                	add    %ecx,%eax
  8004211239:	48 98                	cltq   
  800421123b:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			address += ADDRESS(*p);
  800421123f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211243:	0f b6 00             	movzbl (%rax),%eax
  8004211246:	0f b6 d0             	movzbl %al,%edx
  8004211249:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421124d:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004211251:	0f b6 c0             	movzbl %al,%eax
  8004211254:	89 d1                	mov    %edx,%ecx
  8004211256:	29 c1                	sub    %eax,%ecx
  8004211258:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421125c:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004211260:	0f b6 f0             	movzbl %al,%esi
  8004211263:	89 c8                	mov    %ecx,%eax
  8004211265:	99                   	cltd   
  8004211266:	f7 fe                	idiv   %esi
  8004211268:	89 c2                	mov    %eax,%edx
  800421126a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421126e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004211272:	0f b6 c0             	movzbl %al,%eax
  8004211275:	0f af c2             	imul   %edx,%eax
  8004211278:	48 98                	cltq   
  800421127a:	48 01 45 f8          	add    %rax,-0x8(%rbp)
			APPEND_ROW;
  800421127e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004211285:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004211289:	73 0a                	jae    8004211295 <_dwarf_lineno_run_program+0x4a1>
  800421128b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211290:	e9 a7 00 00 00       	jmpq   800421133c <_dwarf_lineno_run_program+0x548>
  8004211295:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211299:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421129d:	48 89 10             	mov    %rdx,(%rax)
  80042112a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112a4:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042112ab:	00 
  80042112ac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112b0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042112b4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042112b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042112c0:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042112c4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042112c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112cc:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042112d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112d4:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80042112d7:	89 50 28             	mov    %edx,0x28(%rax)
  80042112da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112de:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042112e1:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042112e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112e8:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042112eb:	89 50 30             	mov    %edx,0x30(%rax)
  80042112ee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042112f2:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042112f9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042112fd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211301:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004211308:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
			prologue_end = 0;
  800421130f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
			epilogue_begin = 0;
  8004211316:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
			p++;
  800421131d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211321:	48 83 c0 01          	add    $0x1,%rax
  8004211325:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	while (p < pe) {
  8004211329:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421132d:	48 3b 45 80          	cmp    -0x80(%rbp),%rax
  8004211331:	0f 82 41 fb ff ff    	jb     8004210e78 <_dwarf_lineno_run_program+0x84>
	return (DW_DLE_NONE);
  8004211337:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  800421133c:	c9                   	leaveq 
  800421133d:	c3                   	retq   

000000800421133e <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  800421133e:	55                   	push   %rbp
  800421133f:	48 89 e5             	mov    %rsp,%rbp
  8004211342:	48 83 ec 40          	sub    $0x40,%rsp
  8004211346:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421134a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421134e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211352:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211356:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  800421135a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421135e:	48 8b 00             	mov    (%rax),%rax
  8004211361:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004211365:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211369:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	src += strlen(fname) + 1;
  800421136d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211371:	48 89 c7             	mov    %rax,%rdi
  8004211374:	48 b8 e3 c1 20 04 80 	movabs $0x800420c1e3,%rax
  800421137b:	00 00 00 
  800421137e:	ff d0                	callq  *%rax
  8004211380:	83 c0 01             	add    $0x1,%eax
  8004211383:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211387:	48 98                	cltq   
  8004211389:	48 01 d0             	add    %rdx,%rax
  800421138c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	_dwarf_decode_uleb128(&src);
  8004211390:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004211394:	48 89 c7             	mov    %rax,%rdi
  8004211397:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  800421139e:	00 00 00 
  80042113a1:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  80042113a3:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80042113a7:	48 89 c7             	mov    %rax,%rdi
  80042113aa:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  80042113b1:	00 00 00 
  80042113b4:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  80042113b6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80042113ba:	48 89 c7             	mov    %rax,%rdi
  80042113bd:	48 b8 0b d1 20 04 80 	movabs $0x800420d10b,%rax
  80042113c4:	00 00 00 
  80042113c7:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  80042113c9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042113cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113d1:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042113d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042113d9:	c9                   	leaveq 
  80042113da:	c3                   	retq   

00000080042113db <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  80042113db:	55                   	push   %rbp
  80042113dc:	48 89 e5             	mov    %rsp,%rbp
  80042113df:	53                   	push   %rbx
  80042113e0:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  80042113e7:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80042113ee:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  80042113f5:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  80042113fc:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004211403:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  800421140a:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004211411:	00 
  8004211412:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004211419:	00 
  800421141a:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004211421:	00 
  8004211422:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004211429:	00 
  800421142a:	48 b8 d0 6e 21 04 80 	movabs $0x8004216ed0,%rax
  8004211431:	00 00 00 
  8004211434:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004211438:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800421143c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004211440:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004211447:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800421144e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004211452:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211457:	75 35                	jne    800421148e <_dwarf_lineno_init+0xb3>
  8004211459:	48 b9 dc 6e 21 04 80 	movabs $0x8004216edc,%rcx
  8004211460:	00 00 00 
  8004211463:	48 ba e7 6e 21 04 80 	movabs $0x8004216ee7,%rdx
  800421146a:	00 00 00 
  800421146d:	be 13 01 00 00       	mov    $0x113,%esi
  8004211472:	48 bf fc 6e 21 04 80 	movabs $0x8004216efc,%rdi
  8004211479:	00 00 00 
  800421147c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211481:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004211488:	00 00 00 
  800421148b:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  800421148e:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211495:	00 00 00 
  8004211498:	48 8b 00             	mov    (%rax),%rax
  800421149b:	48 85 c0             	test   %rax,%rax
  800421149e:	75 35                	jne    80042114d5 <_dwarf_lineno_init+0xfa>
  80042114a0:	48 b9 13 6f 21 04 80 	movabs $0x8004216f13,%rcx
  80042114a7:	00 00 00 
  80042114aa:	48 ba e7 6e 21 04 80 	movabs $0x8004216ee7,%rdx
  80042114b1:	00 00 00 
  80042114b4:	be 14 01 00 00       	mov    $0x114,%esi
  80042114b9:	48 bf fc 6e 21 04 80 	movabs $0x8004216efc,%rdi
  80042114c0:	00 00 00 
  80042114c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042114c8:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042114cf:	00 00 00 
  80042114d2:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  80042114d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042114d9:	48 89 c7             	mov    %rax,%rdi
  80042114dc:	48 b8 d1 e7 20 04 80 	movabs $0x800420e7d1,%rax
  80042114e3:	00 00 00 
  80042114e6:	ff d0                	callq  *%rax
  80042114e8:	85 c0                	test   %eax,%eax
  80042114ea:	74 0a                	je     80042114f6 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  80042114ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042114f1:	e9 52 04 00 00       	jmpq   8004211948 <_dwarf_lineno_init+0x56d>

	li = linfo;
  80042114f6:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042114fd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004211501:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211508:	00 00 00 
  800421150b:	48 8b 00             	mov    (%rax),%rax
  800421150e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211512:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211516:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421151a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004211521:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211526:	48 89 cf             	mov    %rcx,%rdi
  8004211529:	ff d0                	callq  *%rax
  800421152b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  800421152f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211534:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004211538:	75 37                	jne    8004211571 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  800421153a:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004211541:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211548:	00 00 00 
  800421154b:	48 8b 00             	mov    (%rax),%rax
  800421154e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211552:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211556:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421155a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004211561:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211566:	48 89 cf             	mov    %rcx,%rdi
  8004211569:	ff d0                	callq  *%rax
  800421156b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421156f:	eb 07                	jmp    8004211578 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004211571:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004211578:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421157c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211580:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004211587:	48 29 c2             	sub    %rax,%rdx
  800421158a:	48 89 d0             	mov    %rdx,%rax
  800421158d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004211591:	73 0a                	jae    800421159d <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004211593:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004211598:	e9 ab 03 00 00       	jmpq   8004211948 <_dwarf_lineno_init+0x56d>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  800421159d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042115a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042115a5:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  80042115a8:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  80042115af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042115b3:	48 01 d0             	add    %rdx,%rax
  80042115b6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  80042115ba:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  80042115c1:	00 00 00 
  80042115c4:	48 8b 00             	mov    (%rax),%rax
  80042115c7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042115cb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042115cf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042115d3:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042115da:	ba 02 00 00 00       	mov    $0x2,%edx
  80042115df:	48 89 cf             	mov    %rcx,%rdi
  80042115e2:	ff d0                	callq  *%rax
  80042115e4:	89 c2                	mov    %eax,%edx
  80042115e6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042115ea:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  80042115ee:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  80042115f5:	00 00 00 
  80042115f8:	48 8b 00             	mov    (%rax),%rax
  80042115fb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042115ff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211603:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004211607:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421160a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004211611:	48 89 cf             	mov    %rcx,%rdi
  8004211614:	ff d0                	callq  *%rax
  8004211616:	48 89 c2             	mov    %rax,%rdx
  8004211619:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421161d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	hdroff = offset;
  8004211621:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004211628:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  800421162c:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211633:	00 00 00 
  8004211636:	48 8b 00             	mov    (%rax),%rax
  8004211639:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421163d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211641:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004211645:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421164c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211651:	48 89 cf             	mov    %rcx,%rdi
  8004211654:	ff d0                	callq  *%rax
  8004211656:	89 c2                	mov    %eax,%edx
  8004211658:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421165c:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  800421165f:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211666:	00 00 00 
  8004211669:	48 8b 00             	mov    (%rax),%rax
  800421166c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211670:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211674:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004211678:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421167f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211684:	48 89 cf             	mov    %rcx,%rdi
  8004211687:	ff d0                	callq  *%rax
  8004211689:	89 c2                	mov    %eax,%edx
  800421168b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421168f:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004211692:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211699:	00 00 00 
  800421169c:	48 8b 00             	mov    (%rax),%rax
  800421169f:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042116a3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116a7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042116ab:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042116b2:	ba 01 00 00 00       	mov    $0x1,%edx
  80042116b7:	48 89 cf             	mov    %rcx,%rdi
  80042116ba:	ff d0                	callq  *%rax
  80042116bc:	89 c2                	mov    %eax,%edx
  80042116be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042116c2:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  80042116c5:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  80042116cc:	00 00 00 
  80042116cf:	48 8b 00             	mov    (%rax),%rax
  80042116d2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042116d6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116da:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042116de:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042116e5:	ba 01 00 00 00       	mov    $0x1,%edx
  80042116ea:	48 89 cf             	mov    %rcx,%rdi
  80042116ed:	ff d0                	callq  *%rax
  80042116ef:	89 c2                	mov    %eax,%edx
  80042116f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042116f5:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042116f8:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  80042116ff:	00 00 00 
  8004211702:	48 8b 00             	mov    (%rax),%rax
  8004211705:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211709:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421170d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004211711:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004211718:	ba 01 00 00 00       	mov    $0x1,%edx
  800421171d:	48 89 cf             	mov    %rcx,%rdi
  8004211720:	ff d0                	callq  *%rax
  8004211722:	89 c2                	mov    %eax,%edx
  8004211724:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211728:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  800421172b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421172f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211733:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004211736:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421173a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421173e:	0f b6 c0             	movzbl %al,%eax
  8004211741:	83 e8 01             	sub    $0x1,%eax
  8004211744:	39 c2                	cmp    %eax,%edx
  8004211746:	7d 0c                	jge    8004211754 <_dwarf_lineno_init+0x379>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004211748:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421174f:	e9 f1 01 00 00       	jmpq   8004211945 <_dwarf_lineno_init+0x56a>
	}

	li->li_oplen = global_std_op;
  8004211754:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211758:	48 bb 80 d6 57 04 80 	movabs $0x800457d680,%rbx
  800421175f:	00 00 00 
  8004211762:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004211766:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  800421176d:	eb 41                	jmp    80042117b0 <_dwarf_lineno_init+0x3d5>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  800421176f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211773:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211777:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421177a:	48 98                	cltq   
  800421177c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004211780:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211787:	00 00 00 
  800421178a:	48 8b 00             	mov    (%rax),%rax
  800421178d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211791:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211795:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004211799:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042117a0:	ba 01 00 00 00       	mov    $0x1,%edx
  80042117a5:	48 89 cf             	mov    %rcx,%rdi
  80042117a8:	ff d0                	callq  *%rax
  80042117aa:	88 03                	mov    %al,(%rbx)
	for (i = 1; i < li->li_opbase; i++)
  80042117ac:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  80042117b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042117b4:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042117b8:	0f b6 c0             	movzbl %al,%eax
  80042117bb:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  80042117be:	7f af                	jg     800421176f <_dwarf_lineno_init+0x394>

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  80042117c0:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042117c7:	00 
	p = ds->ds_data + offset;
  80042117c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042117cc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042117d0:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042117d7:	48 01 d0             	add    %rdx,%rax
  80042117da:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  80042117e1:	eb 1f                	jmp    8004211802 <_dwarf_lineno_init+0x427>
		while (*p++ != '\0')
  80042117e3:	90                   	nop
  80042117e4:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042117eb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042117ef:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  80042117f6:	0f b6 00             	movzbl (%rax),%eax
  80042117f9:	84 c0                	test   %al,%al
  80042117fb:	75 e7                	jne    80042117e4 <_dwarf_lineno_init+0x409>
			;
		length++;
  80042117fd:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	while (*p != '\0') {
  8004211802:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004211809:	0f b6 00             	movzbl (%rax),%eax
  800421180c:	84 c0                	test   %al,%al
  800421180e:	75 d3                	jne    80042117e3 <_dwarf_lineno_init+0x408>
	}
	li->li_inclen = length;
  8004211810:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211814:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211818:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  800421181c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004211823:	48 89 c2             	mov    %rax,%rdx
  8004211826:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421182a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421182e:	48 29 c2             	sub    %rax,%rdx
  8004211831:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211835:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211839:	48 98                	cltq   
  800421183b:	48 39 c2             	cmp    %rax,%rdx
  800421183e:	7e 0c                	jle    800421184c <_dwarf_lineno_init+0x471>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004211840:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004211847:	e9 f9 00 00 00       	jmpq   8004211945 <_dwarf_lineno_init+0x56a>
	}
	p++;
  800421184c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004211853:	48 83 c0 01          	add    $0x1,%rax
  8004211857:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421185e:	eb 3c                	jmp    800421189c <_dwarf_lineno_init+0x4c1>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004211860:	48 b8 c8 86 22 04 80 	movabs $0x80042286c8,%rax
  8004211867:	00 00 00 
  800421186a:	48 8b 08             	mov    (%rax),%rcx
  800421186d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004211874:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  800421187b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421187f:	49 89 c8             	mov    %rcx,%r8
  8004211882:	48 89 d1             	mov    %rdx,%rcx
  8004211885:	ba 00 00 00 00       	mov    $0x0,%edx
  800421188a:	48 89 c7             	mov    %rax,%rdi
  800421188d:	48 b8 3e 13 21 04 80 	movabs $0x800421133e,%rax
  8004211894:	00 00 00 
  8004211897:	ff d0                	callq  *%rax
  8004211899:	89 45 dc             	mov    %eax,-0x24(%rbp)
	while (*p != '\0') {
  800421189c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042118a3:	0f b6 00             	movzbl (%rax),%eax
  80042118a6:	84 c0                	test   %al,%al
  80042118a8:	75 b6                	jne    8004211860 <_dwarf_lineno_init+0x485>
		//p++;
	}

	p++;
  80042118aa:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042118b1:	48 83 c0 01          	add    $0x1,%rax
  80042118b5:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  80042118bc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042118c3:	48 89 c2             	mov    %rax,%rdx
  80042118c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042118ca:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042118ce:	48 29 c2             	sub    %rax,%rdx
  80042118d1:	48 89 d0             	mov    %rdx,%rax
  80042118d4:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  80042118d8:	48 89 c2             	mov    %rax,%rdx
  80042118db:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042118df:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042118e3:	48 39 c2             	cmp    %rax,%rdx
  80042118e6:	74 09                	je     80042118f1 <_dwarf_lineno_init+0x516>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042118e8:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042118ef:	eb 54                	jmp    8004211945 <_dwarf_lineno_init+0x56a>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042118f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042118f5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042118f9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042118fd:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004211901:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004211908:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  800421190f:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004211916:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800421191a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421191e:	4d 89 c1             	mov    %r8,%r9
  8004211921:	49 89 f8             	mov    %rdi,%r8
  8004211924:	48 89 c7             	mov    %rax,%rdi
  8004211927:	48 b8 f4 0d 21 04 80 	movabs $0x8004210df4,%rax
  800421192e:	00 00 00 
  8004211931:	ff d0                	callq  *%rax
  8004211933:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004211936:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421193a:	74 02                	je     800421193e <_dwarf_lineno_init+0x563>
		goto fail_cleanup;
  800421193c:	eb 07                	jmp    8004211945 <_dwarf_lineno_init+0x56a>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  800421193e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211943:	eb 03                	jmp    8004211948 <_dwarf_lineno_init+0x56d>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004211945:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004211948:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421194f:	5b                   	pop    %rbx
  8004211950:	5d                   	pop    %rbp
  8004211951:	c3                   	retq   

0000008004211952 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004211952:	55                   	push   %rbp
  8004211953:	48 89 e5             	mov    %rsp,%rbp
  8004211956:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800421195d:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004211964:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421196b:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004211972:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004211979:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004211980:	00 
  8004211981:	75 35                	jne    80042119b8 <dwarf_srclines+0x66>
  8004211983:	48 b9 1f 6f 21 04 80 	movabs $0x8004216f1f,%rcx
  800421198a:	00 00 00 
  800421198d:	48 ba e7 6e 21 04 80 	movabs $0x8004216ee7,%rdx
  8004211994:	00 00 00 
  8004211997:	be 9a 01 00 00       	mov    $0x19a,%esi
  800421199c:	48 bf fc 6e 21 04 80 	movabs $0x8004216efc,%rdi
  80042119a3:	00 00 00 
  80042119a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042119ab:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042119b2:	00 00 00 
  80042119b5:	41 ff d0             	callq  *%r8
	assert(linebuf);
  80042119b8:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042119bf:	00 
  80042119c0:	75 35                	jne    80042119f7 <dwarf_srclines+0xa5>
  80042119c2:	48 b9 23 6f 21 04 80 	movabs $0x8004216f23,%rcx
  80042119c9:	00 00 00 
  80042119cc:	48 ba e7 6e 21 04 80 	movabs $0x8004216ee7,%rdx
  80042119d3:	00 00 00 
  80042119d6:	be 9b 01 00 00       	mov    $0x19b,%esi
  80042119db:	48 bf fc 6e 21 04 80 	movabs $0x8004216efc,%rdi
  80042119e2:	00 00 00 
  80042119e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042119ea:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042119f1:	00 00 00 
  80042119f4:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042119f7:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042119fe:	ba 88 00 00 00       	mov    $0x88,%edx
  8004211a03:	be 00 00 00 00       	mov    $0x0,%esi
  8004211a08:	48 89 c7             	mov    %rax,%rdi
  8004211a0b:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004211a12:	00 00 00 
  8004211a15:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004211a17:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a1e:	be 10 00 00 00       	mov    $0x10,%esi
  8004211a23:	48 89 c7             	mov    %rax,%rdi
  8004211a26:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  8004211a2d:	00 00 00 
  8004211a30:	ff d0                	callq  *%rax
  8004211a32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211a36:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211a3b:	75 0a                	jne    8004211a47 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004211a3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211a42:	e9 84 00 00 00       	jmpq   8004211acb <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004211a47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211a4b:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004211a4f:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004211a56:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004211a5d:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004211a64:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a6b:	49 89 f8             	mov    %rdi,%r8
  8004211a6e:	48 89 c7             	mov    %rax,%rdi
  8004211a71:	48 b8 db 13 21 04 80 	movabs $0x80042113db,%rax
  8004211a78:	00 00 00 
  8004211a7b:	ff d0                	callq  *%rax
  8004211a7d:	85 c0                	test   %eax,%eax
  8004211a7f:	74 07                	je     8004211a88 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004211a81:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211a86:	eb 43                	jmp    8004211acb <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004211a88:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004211a8f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211a93:	48 89 10             	mov    %rdx,(%rax)
  8004211a96:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004211a9a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004211a9e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211aa2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211aa6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211aaa:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004211aae:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211ab2:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211ab6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211aba:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004211abe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211ac2:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004211ac6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211acb:	c9                   	leaveq 
  8004211acc:	c3                   	retq   

0000008004211acd <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004211acd:	55                   	push   %rbp
  8004211ace:	48 89 e5             	mov    %rsp,%rbp
  8004211ad1:	48 83 ec 20          	sub    $0x20,%rsp
  8004211ad5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004211ad9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211ae0:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004211ae1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004211ae8:	eb 57                	jmp    8004211b41 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  8004211aea:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211af1:	00 00 00 
  8004211af4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004211af7:	48 63 d2             	movslq %edx,%rdx
  8004211afa:	48 c1 e2 05          	shl    $0x5,%rdx
  8004211afe:	48 01 d0             	add    %rdx,%rax
  8004211b01:	48 8b 00             	mov    (%rax),%rax
  8004211b04:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211b08:	48 89 d6             	mov    %rdx,%rsi
  8004211b0b:	48 89 c7             	mov    %rax,%rdi
  8004211b0e:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004211b15:	00 00 00 
  8004211b18:	ff d0                	callq  *%rax
  8004211b1a:	85 c0                	test   %eax,%eax
  8004211b1c:	75 1f                	jne    8004211b3d <_dwarf_find_section+0x70>
			ret = (section_info + i);
  8004211b1e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b21:	48 98                	cltq   
  8004211b23:	48 c1 e0 05          	shl    $0x5,%rax
  8004211b27:	48 89 c2             	mov    %rax,%rdx
  8004211b2a:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211b31:	00 00 00 
  8004211b34:	48 01 d0             	add    %rdx,%rax
  8004211b37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004211b3b:	eb 0a                	jmp    8004211b47 <_dwarf_find_section+0x7a>
	for(i=0; i < NDEBUG_SECT; i++) {
  8004211b3d:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211b41:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004211b45:	7e a3                	jle    8004211aea <_dwarf_find_section+0x1d>
		}
	}

	return ret;
  8004211b47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211b4b:	c9                   	leaveq 
  8004211b4c:	c3                   	retq   

0000008004211b4d <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004211b4d:	55                   	push   %rbp
  8004211b4e:	48 89 e5             	mov    %rsp,%rbp
  8004211b51:	48 83 ec 40          	sub    $0x40,%rsp
  8004211b55:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004211b59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211b5d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004211b61:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004211b68:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004211b69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b6d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211b71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b75:	48 01 d0             	add    %rdx,%rax
  8004211b78:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004211b7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b80:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004211b84:	0f b7 c0             	movzwl %ax,%eax
  8004211b87:	48 c1 e0 06          	shl    $0x6,%rax
  8004211b8b:	48 89 c2             	mov    %rax,%rdx
  8004211b8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b92:	48 01 d0             	add    %rdx,%rax
  8004211b95:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004211b99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b9d:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004211ba1:	0f b7 c0             	movzwl %ax,%eax
  8004211ba4:	48 c1 e0 06          	shl    $0x6,%rax
  8004211ba8:	48 89 c2             	mov    %rax,%rdx
  8004211bab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211baf:	48 01 d0             	add    %rdx,%rax
  8004211bb2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004211bb6:	e9 4b 02 00 00       	jmpq   8004211e06 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004211bbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211bbf:	8b 00                	mov    (%rax),%eax
  8004211bc1:	89 c1                	mov    %eax,%ecx
  8004211bc3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211bc7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211bcb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211bcf:	48 01 d0             	add    %rdx,%rax
  8004211bd2:	48 01 c8             	add    %rcx,%rax
  8004211bd5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004211bd9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211bdd:	48 be 2b 6f 21 04 80 	movabs $0x8004216f2b,%rsi
  8004211be4:	00 00 00 
  8004211be7:	48 89 c7             	mov    %rax,%rdi
  8004211bea:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004211bf1:	00 00 00 
  8004211bf4:	ff d0                	callq  *%rax
  8004211bf6:	85 c0                	test   %eax,%eax
  8004211bf8:	75 4b                	jne    8004211c45 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004211bfa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211bfe:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211c05:	00 00 00 
  8004211c08:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004211c0c:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211c13:	00 00 00 
  8004211c16:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211c1a:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004211c1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211c22:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211c26:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211c2d:	00 00 00 
  8004211c30:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004211c34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211c38:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211c3c:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004211c40:	e9 bc 01 00 00       	jmpq   8004211e01 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004211c45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211c49:	48 be 37 6f 21 04 80 	movabs $0x8004216f37,%rsi
  8004211c50:	00 00 00 
  8004211c53:	48 89 c7             	mov    %rax,%rdi
  8004211c56:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004211c5d:	00 00 00 
  8004211c60:	ff d0                	callq  *%rax
  8004211c62:	85 c0                	test   %eax,%eax
  8004211c64:	75 4b                	jne    8004211cb1 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004211c66:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211c6a:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211c71:	00 00 00 
  8004211c74:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004211c78:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211c7f:	00 00 00 
  8004211c82:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211c86:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004211c8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211c8e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211c92:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211c99:	00 00 00 
  8004211c9c:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004211ca0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211ca4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211ca8:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004211cac:	e9 50 01 00 00       	jmpq   8004211e01 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004211cb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211cb5:	48 be 4f 6f 21 04 80 	movabs $0x8004216f4f,%rsi
  8004211cbc:	00 00 00 
  8004211cbf:	48 89 c7             	mov    %rax,%rdi
  8004211cc2:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004211cc9:	00 00 00 
  8004211ccc:	ff d0                	callq  *%rax
  8004211cce:	85 c0                	test   %eax,%eax
  8004211cd0:	75 4b                	jne    8004211d1d <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004211cd2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211cd6:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211cdd:	00 00 00 
  8004211ce0:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004211ce4:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211ceb:	00 00 00 
  8004211cee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211cf2:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004211cf6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211cfa:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211cfe:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211d05:	00 00 00 
  8004211d08:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  8004211d0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d10:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211d14:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004211d18:	e9 e4 00 00 00       	jmpq   8004211e01 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  8004211d1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d21:	48 be 45 6f 21 04 80 	movabs $0x8004216f45,%rsi
  8004211d28:	00 00 00 
  8004211d2b:	48 89 c7             	mov    %rax,%rdi
  8004211d2e:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004211d35:	00 00 00 
  8004211d38:	ff d0                	callq  *%rax
  8004211d3a:	85 c0                	test   %eax,%eax
  8004211d3c:	75 53                	jne    8004211d91 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004211d3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d42:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211d46:	48 89 c2             	mov    %rax,%rdx
  8004211d49:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211d50:	00 00 00 
  8004211d53:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004211d57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d5b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211d5f:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211d66:	00 00 00 
  8004211d69:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004211d6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d71:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211d75:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211d7c:	00 00 00 
  8004211d7f:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004211d83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d87:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211d8b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004211d8f:	eb 70                	jmp    8004211e01 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004211d91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d95:	48 be 5b 6f 21 04 80 	movabs $0x8004216f5b,%rsi
  8004211d9c:	00 00 00 
  8004211d9f:	48 89 c7             	mov    %rax,%rdi
  8004211da2:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004211da9:	00 00 00 
  8004211dac:	ff d0                	callq  *%rax
  8004211dae:	85 c0                	test   %eax,%eax
  8004211db0:	75 4f                	jne    8004211e01 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004211db2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211db6:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211dbd:	00 00 00 
  8004211dc0:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004211dc7:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211dce:	00 00 00 
  8004211dd1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211dd5:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004211ddc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211de0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211de4:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004211deb:	00 00 00 
  8004211dee:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004211df5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211df9:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211dfd:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	for(;sh < esh; sh++) {
  8004211e01:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004211e06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e0a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004211e0e:	0f 82 a7 fd ff ff    	jb     8004211bbb <find_debug_sections+0x6e>
		}
	}

}
  8004211e14:	c9                   	leaveq 
  8004211e15:	c3                   	retq   

0000008004211e16 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004211e16:	55                   	push   %rbp
  8004211e17:	48 89 e5             	mov    %rsp,%rbp
  8004211e1a:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004211e21:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004211e28:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004211e2f:	48 8d 95 c0 fe ff ff 	lea    -0x140(%rbp),%rdx
  8004211e36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e3b:	b9 14 00 00 00       	mov    $0x14,%ecx
  8004211e40:	48 89 d7             	mov    %rdx,%rdi
  8004211e43:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004211e46:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004211e4d:	00 
  8004211e4e:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004211e55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e59:	48 01 d0             	add    %rdx,%rax
  8004211e5c:	48 83 e8 01          	sub    $0x1,%rax
  8004211e60:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004211e64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211e68:	ba 00 00 00 00       	mov    $0x0,%edx
  8004211e6d:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004211e71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211e75:	48 29 d0             	sub    %rdx,%rax
  8004211e78:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004211e7c:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004211e83:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004211e87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211e8b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004211e8f:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004211e96:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004211e97:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004211e9e:	00 00 00 
  8004211ea1:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004211ea8:	75 11                	jne    8004211ebb <read_section_headers+0xa5>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004211eaa:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211eb1:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211eb5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211eb9:	eb 26                	jmp    8004211ee1 <read_section_headers+0xcb>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004211ebb:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211ec2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211ec6:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211ecd:	48 01 c2             	add    %rax,%rdx
  8004211ed0:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004211ed7:	ff ff ff 
  8004211eda:	48 01 d0             	add    %rdx,%rax
  8004211edd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004211ee1:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211ee8:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004211eec:	0f b7 c0             	movzwl %ax,%eax
  8004211eef:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004211ef2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211ef9:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004211efd:	0f b7 c0             	movzwl %ax,%eax
  8004211f00:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004211f03:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211f0a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004211f0e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004211f11:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004211f15:	48 63 f0             	movslq %eax,%rsi
  8004211f18:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f1c:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004211f23:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211f27:	48 89 c7             	mov    %rax,%rdi
  8004211f2a:	48 b8 5b 25 21 04 80 	movabs $0x800421255b,%rax
  8004211f31:	00 00 00 
  8004211f34:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004211f36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f3a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004211f3e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211f42:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004211f48:	48 89 c2             	mov    %rax,%rdx
  8004211f4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f4f:	48 29 d0             	sub    %rdx,%rax
  8004211f52:	48 89 c2             	mov    %rax,%rdx
  8004211f55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f59:	48 01 d0             	add    %rdx,%rax
  8004211f5c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004211f60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004211f67:	eb 24                	jmp    8004211f8d <read_section_headers+0x177>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004211f69:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211f6c:	48 98                	cltq   
  8004211f6e:	48 c1 e0 06          	shl    $0x6,%rax
  8004211f72:	48 89 c2             	mov    %rax,%rdx
  8004211f75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f79:	48 01 c2             	add    %rax,%rdx
  8004211f7c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211f7f:	48 98                	cltq   
  8004211f81:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004211f88:	ff 
	for (i = 0; i < numSectionHeaders; i++)
  8004211f89:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211f8d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211f90:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004211f93:	7c d4                	jl     8004211f69 <read_section_headers+0x153>
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004211f95:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211f99:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004211f9d:	0f b7 c0             	movzwl %ax,%eax
  8004211fa0:	48 98                	cltq   
  8004211fa2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211fa9:	ff 
  8004211faa:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004211fae:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004211fb5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004211fb9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211fbd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211fc1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211fc5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211fc9:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004211fd0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211fd4:	48 01 f1             	add    %rsi,%rcx
  8004211fd7:	48 89 cf             	mov    %rcx,%rdi
  8004211fda:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004211fe1:	48 89 c6             	mov    %rax,%rsi
  8004211fe4:	48 b8 5b 25 21 04 80 	movabs $0x800421255b,%rax
  8004211feb:	00 00 00 
  8004211fee:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004211ff0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211ff4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211ff8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211ffc:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212000:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004212004:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212008:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421200e:	48 29 c2             	sub    %rax,%rdx
  8004212011:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212015:	48 01 c2             	add    %rax,%rdx
  8004212018:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421201c:	48 01 d0             	add    %rdx,%rax
  800421201f:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004212023:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421202a:	e9 10 05 00 00       	jmpq   800421253f <read_section_headers+0x729>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  800421202f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212032:	48 98                	cltq   
  8004212034:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421203b:	ff 
  800421203c:	8b 00                	mov    (%rax),%eax
  800421203e:	89 c2                	mov    %eax,%edx
  8004212040:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212044:	48 01 d0             	add    %rdx,%rax
  8004212047:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  800421204b:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004212052:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004212057:	48 85 c0             	test   %rax,%rax
  800421205a:	74 35                	je     8004212091 <read_section_headers+0x27b>
  800421205c:	48 b9 66 6f 21 04 80 	movabs $0x8004216f66,%rcx
  8004212063:	00 00 00 
  8004212066:	48 ba 7f 6f 21 04 80 	movabs $0x8004216f7f,%rdx
  800421206d:	00 00 00 
  8004212070:	be 86 00 00 00       	mov    $0x86,%esi
  8004212075:	48 bf 94 6f 21 04 80 	movabs $0x8004216f94,%rdi
  800421207c:	00 00 00 
  800421207f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212084:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  800421208b:	00 00 00 
  800421208e:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004212091:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004212098:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  800421209c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042120a0:	48 be 2b 6f 21 04 80 	movabs $0x8004216f2b,%rsi
  80042120a7:	00 00 00 
  80042120aa:	48 89 c7             	mov    %rax,%rdi
  80042120ad:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042120b4:	00 00 00 
  80042120b7:	ff d0                	callq  *%rax
  80042120b9:	85 c0                	test   %eax,%eax
  80042120bb:	0f 85 db 00 00 00    	jne    800421219c <read_section_headers+0x386>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042120c1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042120c4:	48 98                	cltq   
  80042120c6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042120cd:	ff 
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042120ce:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042120d2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042120d5:	48 98                	cltq   
  80042120d7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042120de:	ff 
  80042120df:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042120e3:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  80042120ea:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042120ee:	48 01 f1             	add    %rsi,%rcx
  80042120f1:	48 89 cf             	mov    %rcx,%rdi
  80042120f4:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042120fb:	48 89 c6             	mov    %rax,%rsi
  80042120fe:	48 b8 5b 25 21 04 80 	movabs $0x800421255b,%rax
  8004212105:	00 00 00 
  8004212108:	ff d0                	callq  *%rax
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421210a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421210d:	48 98                	cltq   
  800421210f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212116:	ff 
  8004212117:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421211b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421211e:	48 98                	cltq   
  8004212120:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212127:	ff 
  8004212128:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421212c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004212130:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212134:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421213a:	48 29 c2             	sub    %rax,%rdx
  800421213d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212141:	48 01 c2             	add    %rax,%rdx
  8004212144:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212148:	48 01 c2             	add    %rax,%rdx
  800421214b:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212152:	00 00 00 
  8004212155:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004212159:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212160:	00 00 00 
  8004212163:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212167:	48 89 c2             	mov    %rax,%rdx
  800421216a:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212171:	00 00 00 
  8004212174:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004212178:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421217b:	48 98                	cltq   
  800421217d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212184:	ff 
  8004212185:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004212189:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212190:	00 00 00 
  8004212193:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004212197:	e9 9f 03 00 00       	jmpq   800421253b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  800421219c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042121a0:	48 be 37 6f 21 04 80 	movabs $0x8004216f37,%rsi
  80042121a7:	00 00 00 
  80042121aa:	48 89 c7             	mov    %rax,%rdi
  80042121ad:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042121b4:	00 00 00 
  80042121b7:	ff d0                	callq  *%rax
  80042121b9:	85 c0                	test   %eax,%eax
  80042121bb:	0f 85 e1 00 00 00    	jne    80042122a2 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042121c1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042121c4:	48 98                	cltq   
  80042121c6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042121cd:	ff 
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042121ce:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042121d2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042121d5:	48 98                	cltq   
  80042121d7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042121de:	ff 
  80042121df:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042121e3:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  80042121ea:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042121ee:	48 01 f1             	add    %rsi,%rcx
  80042121f1:	48 89 cf             	mov    %rcx,%rdi
  80042121f4:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042121fb:	48 89 c6             	mov    %rax,%rsi
  80042121fe:	48 b8 5b 25 21 04 80 	movabs $0x800421255b,%rax
  8004212205:	00 00 00 
  8004212208:	ff d0                	callq  *%rax
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421220a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421220d:	48 98                	cltq   
  800421220f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212216:	ff 
  8004212217:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421221b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421221e:	48 98                	cltq   
  8004212220:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212227:	ff 
  8004212228:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421222c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004212233:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421223a:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004212240:	48 29 c2             	sub    %rax,%rdx
  8004212243:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212247:	48 01 c2             	add    %rax,%rdx
  800421224a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421224e:	48 01 c2             	add    %rax,%rdx
  8004212251:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212258:	00 00 00 
  800421225b:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  800421225f:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212266:	00 00 00 
  8004212269:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421226d:	48 89 c2             	mov    %rax,%rdx
  8004212270:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212277:	00 00 00 
  800421227a:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  800421227e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212281:	48 98                	cltq   
  8004212283:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421228a:	ff 
  800421228b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421228f:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212296:	00 00 00 
  8004212299:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421229d:	e9 99 02 00 00       	jmpq   800421253b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_line"))
  80042122a2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042122a6:	48 be 4f 6f 21 04 80 	movabs $0x8004216f4f,%rsi
  80042122ad:	00 00 00 
  80042122b0:	48 89 c7             	mov    %rax,%rdi
  80042122b3:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042122ba:	00 00 00 
  80042122bd:	ff d0                	callq  *%rax
  80042122bf:	85 c0                	test   %eax,%eax
  80042122c1:	0f 85 e1 00 00 00    	jne    80042123a8 <read_section_headers+0x592>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042122c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042122ca:	48 98                	cltq   
  80042122cc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042122d3:	ff 
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042122d4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042122d8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042122db:	48 98                	cltq   
  80042122dd:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042122e4:	ff 
  80042122e5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042122e9:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  80042122f0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042122f4:	48 01 f1             	add    %rsi,%rcx
  80042122f7:	48 89 cf             	mov    %rcx,%rdi
  80042122fa:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004212301:	48 89 c6             	mov    %rax,%rsi
  8004212304:	48 b8 5b 25 21 04 80 	movabs $0x800421255b,%rax
  800421230b:	00 00 00 
  800421230e:	ff d0                	callq  *%rax
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004212310:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212313:	48 98                	cltq   
  8004212315:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421231c:	ff 
  800421231d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212321:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212324:	48 98                	cltq   
  8004212326:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421232d:	ff 
  800421232e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212332:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004212339:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212340:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004212346:	48 29 c2             	sub    %rax,%rdx
  8004212349:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421234d:	48 01 c2             	add    %rax,%rdx
  8004212350:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212354:	48 01 c2             	add    %rax,%rdx
  8004212357:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  800421235e:	00 00 00 
  8004212361:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004212365:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  800421236c:	00 00 00 
  800421236f:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004212373:	48 89 c2             	mov    %rax,%rdx
  8004212376:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  800421237d:	00 00 00 
  8004212380:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004212384:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212387:	48 98                	cltq   
  8004212389:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212390:	ff 
  8004212391:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004212395:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  800421239c:	00 00 00 
  800421239f:	48 89 50 78          	mov    %rdx,0x78(%rax)
  80042123a3:	e9 93 01 00 00       	jmpq   800421253b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".eh_frame"))
  80042123a8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042123ac:	48 be 45 6f 21 04 80 	movabs $0x8004216f45,%rsi
  80042123b3:	00 00 00 
  80042123b6:	48 89 c7             	mov    %rax,%rdi
  80042123b9:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  80042123c0:	00 00 00 
  80042123c3:	ff d0                	callq  *%rax
  80042123c5:	85 c0                	test   %eax,%eax
  80042123c7:	75 65                	jne    800421242e <read_section_headers+0x618>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  80042123c9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042123cc:	48 98                	cltq   
  80042123ce:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042123d5:	ff 
  80042123d6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042123da:	48 89 c2             	mov    %rax,%rdx
  80042123dd:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  80042123e4:	00 00 00 
  80042123e7:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  80042123eb:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  80042123f2:	00 00 00 
  80042123f5:	48 8b 40 48          	mov    0x48(%rax),%rax
  80042123f9:	48 89 c2             	mov    %rax,%rdx
  80042123fc:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212403:	00 00 00 
  8004212406:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  800421240a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421240d:	48 98                	cltq   
  800421240f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212416:	ff 
  8004212417:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421241b:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212422:	00 00 00 
  8004212425:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004212429:	e9 0d 01 00 00       	jmpq   800421253b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_str"))
  800421242e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004212432:	48 be 5b 6f 21 04 80 	movabs $0x8004216f5b,%rsi
  8004212439:	00 00 00 
  800421243c:	48 89 c7             	mov    %rax,%rdi
  800421243f:	48 b8 b1 c3 20 04 80 	movabs $0x800420c3b1,%rax
  8004212446:	00 00 00 
  8004212449:	ff d0                	callq  *%rax
  800421244b:	85 c0                	test   %eax,%eax
  800421244d:	0f 85 e8 00 00 00    	jne    800421253b <read_section_headers+0x725>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004212453:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212456:	48 98                	cltq   
  8004212458:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421245f:	ff 
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004212460:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212464:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212467:	48 98                	cltq   
  8004212469:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212470:	ff 
  8004212471:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212475:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  800421247c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212480:	48 01 f1             	add    %rsi,%rcx
  8004212483:	48 89 cf             	mov    %rcx,%rdi
  8004212486:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421248d:	48 89 c6             	mov    %rax,%rsi
  8004212490:	48 b8 5b 25 21 04 80 	movabs $0x800421255b,%rax
  8004212497:	00 00 00 
  800421249a:	ff d0                	callq  *%rax
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421249c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421249f:	48 98                	cltq   
  80042124a1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042124a8:	ff 
  80042124a9:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042124ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042124b0:	48 98                	cltq   
  80042124b2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042124b9:	ff 
  80042124ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042124be:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042124c5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042124cc:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042124d2:	48 29 c2             	sub    %rax,%rdx
  80042124d5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042124d9:	48 01 c2             	add    %rax,%rdx
  80042124dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042124e0:	48 01 c2             	add    %rax,%rdx
  80042124e3:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  80042124ea:	00 00 00 
  80042124ed:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  80042124f4:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  80042124fb:	00 00 00 
  80042124fe:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004212505:	48 89 c2             	mov    %rax,%rdx
  8004212508:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  800421250f:	00 00 00 
  8004212512:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004212519:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421251c:	48 98                	cltq   
  800421251e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004212525:	ff 
  8004212526:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421252a:	48 b8 00 87 22 04 80 	movabs $0x8004228700,%rax
  8004212531:	00 00 00 
  8004212534:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	for (i = 0; i < numSectionHeaders; i++)
  800421253b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421253f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212542:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004212545:	0f 8c e4 fa ff ff    	jl     800421202f <read_section_headers+0x219>
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  800421254b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421254f:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004212556:	48 01 d0             	add    %rdx,%rax
}
  8004212559:	c9                   	leaveq 
  800421255a:	c3                   	retq   

000000800421255b <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  800421255b:	55                   	push   %rbp
  800421255c:	48 89 e5             	mov    %rsp,%rbp
  800421255f:	48 83 ec 30          	sub    $0x30,%rsp
  8004212563:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212567:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421256b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421256f:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004212573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212577:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  800421257b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421257f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212583:	48 01 d0             	add    %rdx,%rax
  8004212586:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  800421258a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421258e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004212593:	48 85 c0             	test   %rax,%rax
  8004212596:	74 35                	je     80042125cd <readseg+0x72>
  8004212598:	48 b9 a2 6f 21 04 80 	movabs $0x8004216fa2,%rcx
  800421259f:	00 00 00 
  80042125a2:	48 ba 7f 6f 21 04 80 	movabs $0x8004216f7f,%rdx
  80042125a9:	00 00 00 
  80042125ac:	be c0 00 00 00       	mov    $0xc0,%esi
  80042125b1:	48 bf 94 6f 21 04 80 	movabs $0x8004216f94,%rdi
  80042125b8:	00 00 00 
  80042125bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042125c0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042125c7:	00 00 00 
  80042125ca:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  80042125cd:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  80042125d4:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  80042125d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042125d9:	48 c1 e8 09          	shr    $0x9,%rax
  80042125dd:	48 83 c0 01          	add    $0x1,%rax
  80042125e1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042125e5:	eb 3c                	jmp    8004212623 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  80042125e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042125eb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042125ef:	48 89 d6             	mov    %rdx,%rsi
  80042125f2:	48 89 c7             	mov    %rax,%rdi
  80042125f5:	48 b8 eb 26 21 04 80 	movabs $0x80042126eb,%rax
  80042125fc:	00 00 00 
  80042125ff:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004212601:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004212608:	00 
		*kvoffset += SECTSIZE;
  8004212609:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421260d:	48 8b 00             	mov    (%rax),%rax
  8004212610:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004212617:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421261b:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  800421261e:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	while (pa < end_pa) {
  8004212623:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212627:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800421262b:	72 ba                	jb     80042125e7 <readseg+0x8c>
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  800421262d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212631:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004212636:	48 89 c2             	mov    %rax,%rdx
  8004212639:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421263d:	48 01 d0             	add    %rdx,%rax
  8004212640:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004212646:	76 2f                	jbe    8004212677 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004212648:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421264c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212650:	48 89 d6             	mov    %rdx,%rsi
  8004212653:	48 89 c7             	mov    %rax,%rdi
  8004212656:	48 b8 eb 26 21 04 80 	movabs $0x80042126eb,%rax
  800421265d:	00 00 00 
  8004212660:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004212662:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212666:	48 8b 00             	mov    (%rax),%rax
  8004212669:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004212670:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212674:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004212677:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421267b:	48 8b 00             	mov    (%rax),%rax
  800421267e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004212683:	48 85 c0             	test   %rax,%rax
  8004212686:	74 35                	je     80042126bd <readseg+0x162>
  8004212688:	48 b9 b5 6f 21 04 80 	movabs $0x8004216fb5,%rcx
  800421268f:	00 00 00 
  8004212692:	48 ba 7f 6f 21 04 80 	movabs $0x8004216f7f,%rdx
  8004212699:	00 00 00 
  800421269c:	be d6 00 00 00       	mov    $0xd6,%esi
  80042126a1:	48 bf 94 6f 21 04 80 	movabs $0x8004216f94,%rdi
  80042126a8:	00 00 00 
  80042126ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042126b0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042126b7:	00 00 00 
  80042126ba:	41 ff d0             	callq  *%r8
}
  80042126bd:	c9                   	leaveq 
  80042126be:	c3                   	retq   

00000080042126bf <waitdisk>:

void
waitdisk(void)
{
  80042126bf:	55                   	push   %rbp
  80042126c0:	48 89 e5             	mov    %rsp,%rbp
  80042126c3:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  80042126c7:	90                   	nop
  80042126c8:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042126cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042126d2:	89 c2                	mov    %eax,%edx
  80042126d4:	ec                   	in     (%dx),%al
  80042126d5:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042126d8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042126dc:	0f b6 c0             	movzbl %al,%eax
  80042126df:	25 c0 00 00 00       	and    $0xc0,%eax
  80042126e4:	83 f8 40             	cmp    $0x40,%eax
  80042126e7:	75 df                	jne    80042126c8 <waitdisk+0x9>
		/* do nothing */;
}
  80042126e9:	c9                   	leaveq 
  80042126ea:	c3                   	retq   

00000080042126eb <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042126eb:	55                   	push   %rbp
  80042126ec:	48 89 e5             	mov    %rsp,%rbp
  80042126ef:	48 83 ec 60          	sub    $0x60,%rsp
  80042126f3:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042126f7:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042126fb:	48 b8 bf 26 21 04 80 	movabs $0x80042126bf,%rax
  8004212702:	00 00 00 
  8004212705:	ff d0                	callq  *%rax
  8004212707:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  800421270e:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004212712:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004212716:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004212719:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  800421271a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421271e:	0f b6 c0             	movzbl %al,%eax
  8004212721:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004212728:	88 45 f3             	mov    %al,-0xd(%rbp)
  800421272b:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800421272f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212732:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004212733:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212737:	48 c1 e8 08          	shr    $0x8,%rax
  800421273b:	0f b6 c0             	movzbl %al,%eax
  800421273e:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004212745:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004212748:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800421274c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421274f:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004212750:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212754:	48 c1 e8 10          	shr    $0x10,%rax
  8004212758:	0f b6 c0             	movzbl %al,%eax
  800421275b:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004212762:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004212765:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004212769:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421276c:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  800421276d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212771:	48 c1 e8 18          	shr    $0x18,%rax
  8004212775:	83 c8 e0             	or     $0xffffffe0,%eax
  8004212778:	0f b6 c0             	movzbl %al,%eax
  800421277b:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004212782:	88 45 db             	mov    %al,-0x25(%rbp)
  8004212785:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004212789:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421278c:	ee                   	out    %al,(%dx)
  800421278d:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004212794:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004212798:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800421279c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800421279f:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  80042127a0:	48 b8 bf 26 21 04 80 	movabs $0x80042126bf,%rax
  80042127a7:	00 00 00 
  80042127aa:	ff d0                	callq  *%rax
  80042127ac:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  80042127b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042127b7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042127bb:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  80042127c2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042127c5:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042127c9:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042127cc:	48 89 ce             	mov    %rcx,%rsi
  80042127cf:	48 89 f7             	mov    %rsi,%rdi
  80042127d2:	89 c1                	mov    %eax,%ecx
  80042127d4:	fc                   	cld    
  80042127d5:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  80042127d7:	89 c8                	mov    %ecx,%eax
  80042127d9:	48 89 fe             	mov    %rdi,%rsi
  80042127dc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042127e0:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  80042127e3:	c9                   	leaveq 
  80042127e4:	c3                   	retq   
  80042127e5:	0f 1f 00             	nopl   (%rax)

00000080042127e8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  80042127e8:	fa                   	cli    
	xorw    %ax, %ax
  80042127e9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  80042127eb:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042127ed:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042127ef:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  80042127f1:	0f 01 16             	lgdt   (%rsi)
  80042127f4:	e0 70                	loopne 8004212866 <start64+0x10>
	movl    %cr0, %eax
  80042127f6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042127f9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  80042127fd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004212800:	ea                   	(bad)  
  8004212801:	1d                   	.byte 0x1d
  8004212802:	70 08                	jo     800421280c <start32+0x7>
	...

0000008004212805 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004212805:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004212809:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421280b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421280d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  800421280f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004212813:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004212815:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
	movl $CR4_PAE,%eax
#else
	movl $(CR4_PAE|CR4_VMXE),%eax
  8004212817:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif

	movl %eax,%cr4
  800421281c:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  800421281f:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 80042198e6 <bootstack+0x18e6>
	movl    %cr0, %eax
  8004212826:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004212829:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  800421282c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  800421282f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004212834:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004212837:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421283c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421283e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004212842:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004212844:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004212847:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421284c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421284f:	ea                   	(bad)  
  8004212850:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004212851:	70 00                	jo     8004212853 <start32+0x4e>
  8004212853:	00 08                	add    %cl,(%rax)
	...

0000008004212856 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004212856:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  800421285a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421285c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421285e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004212860:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004212864:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004212866:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004212868:	48 a1 b8 c7 57 04 80 	movabs 0x800457c7b8,%rax
  800421286f:	00 00 00 
	movq    %rax,%rsp
  8004212872:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004212875:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421287c:	48 b8 f6 04 20 04 80 	movabs $0x80042004f6,%rax
  8004212883:	00 00 00 
	call    *%rax
  8004212886:	ff d0                	callq  *%rax

0000008004212888 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004212888:	eb fe                	jmp    8004212888 <spin>
  800421288a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004212890 <gdt>:
	...
  8004212898:	ff                   	(bad)  
  8004212899:	ff 00                	incl   (%rax)
  800421289b:	00 00                	add    %al,(%rax)
  800421289d:	9a                   	(bad)  
  800421289e:	af                   	scas   %es:(%rdi),%eax
  800421289f:	00 ff                	add    %bh,%bh
  80042128a1:	ff 00                	incl   (%rax)
  80042128a3:	00 00                	add    %al,(%rax)
  80042128a5:	92                   	xchg   %eax,%edx
  80042128a6:	af                   	scas   %es:(%rdi),%eax
	...

00000080042128a8 <gdtdesc>:
  80042128a8:	17                   	(bad)  
  80042128a9:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  80042128af:	90                   	nop

00000080042128b0 <gdt32>:
	...
  80042128b8:	ff                   	(bad)  
  80042128b9:	ff 00                	incl   (%rax)
  80042128bb:	00 00                	add    %al,(%rax)
  80042128bd:	9a                   	(bad)  
  80042128be:	cf                   	iret   
  80042128bf:	00 ff                	add    %bh,%bh
  80042128c1:	ff 00                	incl   (%rax)
  80042128c3:	00 00                	add    %al,(%rax)
  80042128c5:	92                   	xchg   %eax,%edx
  80042128c6:	cf                   	iret   
	...

00000080042128c8 <gdt32desc>:
  80042128c8:	17                   	(bad)  
  80042128c9:	00 c8                	add    %cl,%al
  80042128cb:	70 00                	jo     80042128cd <gdt32desc+0x5>
	...

00000080042128ce <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  80042128ce:	90                   	nop

00000080042128cf <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  80042128cf:	55                   	push   %rbp
  80042128d0:	48 89 e5             	mov    %rsp,%rbp
  80042128d3:	48 83 ec 20          	sub    $0x20,%rsp
  80042128d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042128db:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042128de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042128e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042128ec:	eb 1a                	jmp    8004212908 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042128ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042128f1:	48 63 d0             	movslq %eax,%rdx
  80042128f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128f8:	48 01 d0             	add    %rdx,%rax
  80042128fb:	0f b6 00             	movzbl (%rax),%eax
  80042128fe:	0f b6 c0             	movzbl %al,%eax
  8004212901:	01 45 f8             	add    %eax,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004212904:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004212908:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421290b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  800421290e:	7c de                	jl     80042128ee <sum+0x1f>
	return sum;
  8004212910:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004212913:	c9                   	leaveq 
  8004212914:	c3                   	retq   

0000008004212915 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004212915:	55                   	push   %rbp
  8004212916:	48 89 e5             	mov    %rsp,%rbp
  8004212919:	48 83 ec 40          	sub    $0x40,%rsp
  800421291d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212921:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004212924:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212928:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421292c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212930:	48 c1 e8 0c          	shr    $0xc,%rax
  8004212934:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004212937:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421293a:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004212941:	00 00 00 
  8004212944:	48 8b 00             	mov    (%rax),%rax
  8004212947:	48 39 c2             	cmp    %rax,%rdx
  800421294a:	72 32                	jb     800421297e <mpsearch1+0x69>
  800421294c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212950:	48 89 c1             	mov    %rax,%rcx
  8004212953:	48 ba d0 6f 21 04 80 	movabs $0x8004216fd0,%rdx
  800421295a:	00 00 00 
  800421295d:	be 58 00 00 00       	mov    $0x58,%esi
  8004212962:	48 bf f3 6f 21 04 80 	movabs $0x8004216ff3,%rdi
  8004212969:	00 00 00 
  800421296c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212971:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004212978:	00 00 00 
  800421297b:	41 ff d0             	callq  *%r8
  800421297e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004212985:	00 00 00 
  8004212988:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421298c:	48 01 d0             	add    %rdx,%rax
  800421298f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212993:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004212996:	48 63 d0             	movslq %eax,%rdx
  8004212999:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421299d:	48 01 d0             	add    %rdx,%rax
  80042129a0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042129a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129a8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042129ac:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042129af:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042129b2:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042129b9:	00 00 00 
  80042129bc:	48 8b 00             	mov    (%rax),%rax
  80042129bf:	48 39 c2             	cmp    %rax,%rdx
  80042129c2:	72 32                	jb     80042129f6 <mpsearch1+0xe1>
  80042129c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129c8:	48 89 c1             	mov    %rax,%rcx
  80042129cb:	48 ba d0 6f 21 04 80 	movabs $0x8004216fd0,%rdx
  80042129d2:	00 00 00 
  80042129d5:	be 58 00 00 00       	mov    $0x58,%esi
  80042129da:	48 bf f3 6f 21 04 80 	movabs $0x8004216ff3,%rdi
  80042129e1:	00 00 00 
  80042129e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042129e9:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042129f0:	00 00 00 
  80042129f3:	41 ff d0             	callq  *%r8
  80042129f6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042129fd:	00 00 00 
  8004212a00:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a04:	48 01 d0             	add    %rdx,%rax
  8004212a07:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004212a0b:	eb 4d                	jmp    8004212a5a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004212a0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a11:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212a16:	48 be 03 70 21 04 80 	movabs $0x8004217003,%rsi
  8004212a1d:	00 00 00 
  8004212a20:	48 89 c7             	mov    %rax,%rdi
  8004212a23:	48 b8 be c6 20 04 80 	movabs $0x800420c6be,%rax
  8004212a2a:	00 00 00 
  8004212a2d:	ff d0                	callq  *%rax
  8004212a2f:	85 c0                	test   %eax,%eax
  8004212a31:	75 22                	jne    8004212a55 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004212a33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a37:	be 10 00 00 00       	mov    $0x10,%esi
  8004212a3c:	48 89 c7             	mov    %rax,%rdi
  8004212a3f:	48 b8 cf 28 21 04 80 	movabs $0x80042128cf,%rax
  8004212a46:	00 00 00 
  8004212a49:	ff d0                	callq  *%rax
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004212a4b:	84 c0                	test   %al,%al
  8004212a4d:	75 06                	jne    8004212a55 <mpsearch1+0x140>
			return mp;
  8004212a4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a53:	eb 14                	jmp    8004212a69 <mpsearch1+0x154>
	for (; mp < end; mp++)
  8004212a55:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004212a5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a5e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212a62:	72 a9                	jb     8004212a0d <mpsearch1+0xf8>
	return NULL;
  8004212a64:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212a69:	c9                   	leaveq 
  8004212a6a:	c3                   	retq   

0000008004212a6b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004212a6b:	55                   	push   %rbp
  8004212a6c:	48 89 e5             	mov    %rsp,%rbp
  8004212a6f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004212a73:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004212a7a:	00 
  8004212a7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a7f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004212a83:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004212a86:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212a89:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004212a90:	00 00 00 
  8004212a93:	48 8b 00             	mov    (%rax),%rax
  8004212a96:	48 39 c2             	cmp    %rax,%rdx
  8004212a99:	72 32                	jb     8004212acd <mpsearch+0x62>
  8004212a9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a9f:	48 89 c1             	mov    %rax,%rcx
  8004212aa2:	48 ba d0 6f 21 04 80 	movabs $0x8004216fd0,%rdx
  8004212aa9:	00 00 00 
  8004212aac:	be 70 00 00 00       	mov    $0x70,%esi
  8004212ab1:	48 bf f3 6f 21 04 80 	movabs $0x8004216ff3,%rdi
  8004212ab8:	00 00 00 
  8004212abb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212ac0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004212ac7:	00 00 00 
  8004212aca:	41 ff d0             	callq  *%r8
  8004212acd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004212ad4:	00 00 00 
  8004212ad7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212adb:	48 01 d0             	add    %rdx,%rax
  8004212ade:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004212ae2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ae6:	48 83 c0 0e          	add    $0xe,%rax
  8004212aea:	0f b7 00             	movzwl (%rax),%eax
  8004212aed:	0f b7 c0             	movzwl %ax,%eax
  8004212af0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212af3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212af7:	74 2c                	je     8004212b25 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004212af9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004212afd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212b00:	be 00 04 00 00       	mov    $0x400,%esi
  8004212b05:	48 89 c7             	mov    %rax,%rdi
  8004212b08:	48 b8 15 29 21 04 80 	movabs $0x8004212915,%rax
  8004212b0f:	00 00 00 
  8004212b12:	ff d0                	callq  *%rax
  8004212b14:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004212b18:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212b1d:	74 49                	je     8004212b68 <mpsearch+0xfd>
			return mp;
  8004212b1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212b23:	eb 59                	jmp    8004212b7e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004212b25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b29:	48 83 c0 13          	add    $0x13,%rax
  8004212b2d:	0f b7 00             	movzwl (%rax),%eax
  8004212b30:	0f b7 c0             	movzwl %ax,%eax
  8004212b33:	c1 e0 0a             	shl    $0xa,%eax
  8004212b36:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004212b39:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212b3c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004212b41:	89 c0                	mov    %eax,%eax
  8004212b43:	be 00 04 00 00       	mov    $0x400,%esi
  8004212b48:	48 89 c7             	mov    %rax,%rdi
  8004212b4b:	48 b8 15 29 21 04 80 	movabs $0x8004212915,%rax
  8004212b52:	00 00 00 
  8004212b55:	ff d0                	callq  *%rax
  8004212b57:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004212b5b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212b60:	74 06                	je     8004212b68 <mpsearch+0xfd>
			return mp;
  8004212b62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212b66:	eb 16                	jmp    8004212b7e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004212b68:	be 00 00 01 00       	mov    $0x10000,%esi
  8004212b6d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004212b72:	48 b8 15 29 21 04 80 	movabs $0x8004212915,%rax
  8004212b79:	00 00 00 
  8004212b7c:	ff d0                	callq  *%rax
}
  8004212b7e:	c9                   	leaveq 
  8004212b7f:	c3                   	retq   

0000008004212b80 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004212b80:	55                   	push   %rbp
  8004212b81:	48 89 e5             	mov    %rsp,%rbp
  8004212b84:	48 83 ec 30          	sub    $0x30,%rsp
  8004212b88:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  8004212b8c:	48 b8 6b 2a 21 04 80 	movabs $0x8004212a6b,%rax
  8004212b93:	00 00 00 
  8004212b96:	ff d0                	callq  *%rax
  8004212b98:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212b9c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004212ba1:	75 0a                	jne    8004212bad <mpconfig+0x2d>
		return NULL;
  8004212ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212ba8:	e9 f8 01 00 00       	jmpq   8004212da5 <mpconfig+0x225>
	if (mp->physaddr == 0 || mp->type != 0) {
  8004212bad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212bb1:	8b 40 04             	mov    0x4(%rax),%eax
  8004212bb4:	85 c0                	test   %eax,%eax
  8004212bb6:	74 0c                	je     8004212bc4 <mpconfig+0x44>
  8004212bb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212bbc:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004212bc0:	84 c0                	test   %al,%al
  8004212bc2:	74 25                	je     8004212be9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004212bc4:	48 bf 08 70 21 04 80 	movabs $0x8004217008,%rdi
  8004212bcb:	00 00 00 
  8004212bce:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212bd3:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212bda:	00 00 00 
  8004212bdd:	ff d2                	callq  *%rdx
		return NULL;
  8004212bdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212be4:	e9 bc 01 00 00       	jmpq   8004212da5 <mpconfig+0x225>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004212be9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212bed:	8b 40 04             	mov    0x4(%rax),%eax
  8004212bf0:	89 c0                	mov    %eax,%eax
  8004212bf2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004212bf6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212bfa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004212bfe:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004212c01:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004212c04:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  8004212c0b:	00 00 00 
  8004212c0e:	48 8b 00             	mov    (%rax),%rax
  8004212c11:	48 39 c2             	cmp    %rax,%rdx
  8004212c14:	72 32                	jb     8004212c48 <mpconfig+0xc8>
  8004212c16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212c1a:	48 89 c1             	mov    %rax,%rcx
  8004212c1d:	48 ba d0 6f 21 04 80 	movabs $0x8004216fd0,%rdx
  8004212c24:	00 00 00 
  8004212c27:	be 91 00 00 00       	mov    $0x91,%esi
  8004212c2c:	48 bf f3 6f 21 04 80 	movabs $0x8004216ff3,%rdi
  8004212c33:	00 00 00 
  8004212c36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212c3b:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004212c42:	00 00 00 
  8004212c45:	41 ff d0             	callq  *%r8
  8004212c48:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004212c4f:	00 00 00 
  8004212c52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212c56:	48 01 d0             	add    %rdx,%rax
  8004212c59:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  8004212c5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212c61:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212c66:	48 be 35 70 21 04 80 	movabs $0x8004217035,%rsi
  8004212c6d:	00 00 00 
  8004212c70:	48 89 c7             	mov    %rax,%rdi
  8004212c73:	48 b8 be c6 20 04 80 	movabs $0x800420c6be,%rax
  8004212c7a:	00 00 00 
  8004212c7d:	ff d0                	callq  *%rax
  8004212c7f:	85 c0                	test   %eax,%eax
  8004212c81:	74 25                	je     8004212ca8 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004212c83:	48 bf 40 70 21 04 80 	movabs $0x8004217040,%rdi
  8004212c8a:	00 00 00 
  8004212c8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212c92:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212c99:	00 00 00 
  8004212c9c:	ff d2                	callq  *%rdx
		return NULL;
  8004212c9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212ca3:	e9 fd 00 00 00       	jmpq   8004212da5 <mpconfig+0x225>
	}
	if (sum(conf, conf->length) != 0) {
  8004212ca8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212cac:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004212cb0:	0f b7 d0             	movzwl %ax,%edx
  8004212cb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212cb7:	89 d6                	mov    %edx,%esi
  8004212cb9:	48 89 c7             	mov    %rax,%rdi
  8004212cbc:	48 b8 cf 28 21 04 80 	movabs $0x80042128cf,%rax
  8004212cc3:	00 00 00 
  8004212cc6:	ff d0                	callq  *%rax
  8004212cc8:	84 c0                	test   %al,%al
  8004212cca:	74 25                	je     8004212cf1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  8004212ccc:	48 bf 78 70 21 04 80 	movabs $0x8004217078,%rdi
  8004212cd3:	00 00 00 
  8004212cd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212cdb:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212ce2:	00 00 00 
  8004212ce5:	ff d2                	callq  *%rdx
		return NULL;
  8004212ce7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212cec:	e9 b4 00 00 00       	jmpq   8004212da5 <mpconfig+0x225>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004212cf1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212cf5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004212cf9:	3c 01                	cmp    $0x1,%al
  8004212cfb:	74 3b                	je     8004212d38 <mpconfig+0x1b8>
  8004212cfd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212d01:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004212d05:	3c 04                	cmp    $0x4,%al
  8004212d07:	74 2f                	je     8004212d38 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004212d09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212d0d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004212d11:	0f b6 c0             	movzbl %al,%eax
  8004212d14:	89 c6                	mov    %eax,%esi
  8004212d16:	48 bf a0 70 21 04 80 	movabs $0x80042170a0,%rdi
  8004212d1d:	00 00 00 
  8004212d20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d25:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212d2c:	00 00 00 
  8004212d2f:	ff d2                	callq  *%rdx
		return NULL;
  8004212d31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d36:	eb 6d                	jmp    8004212da5 <mpconfig+0x225>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004212d38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212d3c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004212d40:	0f b7 c0             	movzwl %ax,%eax
  8004212d43:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212d47:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  8004212d4b:	0f b7 ca             	movzwl %dx,%ecx
  8004212d4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212d52:	48 01 ca             	add    %rcx,%rdx
  8004212d55:	89 c6                	mov    %eax,%esi
  8004212d57:	48 89 d7             	mov    %rdx,%rdi
  8004212d5a:	48 b8 cf 28 21 04 80 	movabs $0x80042128cf,%rax
  8004212d61:	00 00 00 
  8004212d64:	ff d0                	callq  *%rax
  8004212d66:	89 c2                	mov    %eax,%edx
  8004212d68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212d6c:	0f b6 40 2a          	movzbl 0x2a(%rax),%eax
  8004212d70:	38 c2                	cmp    %al,%dl
  8004212d72:	74 22                	je     8004212d96 <mpconfig+0x216>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004212d74:	48 bf c0 70 21 04 80 	movabs $0x80042170c0,%rdi
  8004212d7b:	00 00 00 
  8004212d7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d83:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212d8a:	00 00 00 
  8004212d8d:	ff d2                	callq  *%rdx
		return NULL;
  8004212d8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d94:	eb 0f                	jmp    8004212da5 <mpconfig+0x225>
	}
	*pmp = mp;
  8004212d96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212d9a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212d9e:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004212da1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004212da5:	c9                   	leaveq 
  8004212da6:	c3                   	retq   

0000008004212da7 <mp_init>:

void
mp_init(void)
{
  8004212da7:	55                   	push   %rbp
  8004212da8:	48 89 e5             	mov    %rsp,%rbp
  8004212dab:	48 83 ec 40          	sub    $0x40,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004212daf:	48 b8 60 e2 57 04 80 	movabs $0x800457e260,%rax
  8004212db6:	00 00 00 
  8004212db9:	48 be 40 e0 57 04 80 	movabs $0x800457e040,%rsi
  8004212dc0:	00 00 00 
  8004212dc3:	48 89 30             	mov    %rsi,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004212dc6:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8004212dca:	48 89 c7             	mov    %rax,%rdi
  8004212dcd:	48 b8 80 2b 21 04 80 	movabs $0x8004212b80,%rax
  8004212dd4:	00 00 00 
  8004212dd7:	ff d0                	callq  *%rax
  8004212dd9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004212ddd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212de2:	75 05                	jne    8004212de9 <mp_init+0x42>
		return;
  8004212de4:	e9 d2 03 00 00       	jmpq   80042131bb <mp_init+0x414>
	ismp = 1;
  8004212de9:	48 b8 00 e0 57 04 80 	movabs $0x800457e000,%rax
  8004212df0:	00 00 00 
  8004212df3:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004212df9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dfd:	8b 40 24             	mov    0x24(%rax),%eax
  8004212e00:	89 c2                	mov    %eax,%edx
  8004212e02:	48 b8 00 f0 5b 04 80 	movabs $0x80045bf000,%rax
  8004212e09:	00 00 00 
  8004212e0c:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004212e0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e13:	48 83 c0 2c          	add    $0x2c,%rax
  8004212e17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212e1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004212e22:	e9 17 02 00 00       	jmpq   800421303e <mp_init+0x297>
		switch (*p) {
  8004212e27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212e2b:	0f b6 00             	movzbl (%rax),%eax
  8004212e2e:	0f b6 c0             	movzbl %al,%eax
  8004212e31:	85 c0                	test   %eax,%eax
  8004212e33:	74 16                	je     8004212e4b <mp_init+0xa4>
  8004212e35:	85 c0                	test   %eax,%eax
  8004212e37:	0f 88 b8 01 00 00    	js     8004212ff5 <mp_init+0x24e>
  8004212e3d:	83 f8 04             	cmp    $0x4,%eax
  8004212e40:	0f 8f af 01 00 00    	jg     8004212ff5 <mp_init+0x24e>
  8004212e46:	e9 a3 01 00 00       	jmpq   8004212fee <mp_init+0x247>
		case MPPROC:
			proc = (struct mpproc *)p;
  8004212e4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212e4f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  8004212e53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212e57:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004212e5b:	0f b6 c0             	movzbl %al,%eax
  8004212e5e:	83 e0 02             	and    $0x2,%eax
  8004212e61:	85 c0                	test   %eax,%eax
  8004212e63:	74 51                	je     8004212eb6 <mp_init+0x10f>
				bootcpu = &cpus[ncpu];
  8004212e65:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004212e6c:	00 00 00 
  8004212e6f:	8b 00                	mov    (%rax),%eax
  8004212e71:	48 98                	cltq   
  8004212e73:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e77:	48 89 c2             	mov    %rax,%rdx
  8004212e7a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004212e7e:	48 01 d0             	add    %rdx,%rax
  8004212e81:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004212e88:	00 00 00 
  8004212e8b:	48 01 c2             	add    %rax,%rdx
  8004212e8e:	48 b8 60 e2 57 04 80 	movabs $0x800457e260,%rax
  8004212e95:	00 00 00 
  8004212e98:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  8004212e9b:	48 bf ed 70 21 04 80 	movabs $0x80042170ed,%rdi
  8004212ea2:	00 00 00 
  8004212ea5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212eaa:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212eb1:	00 00 00 
  8004212eb4:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004212eb6:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004212ebd:	00 00 00 
  8004212ec0:	8b 00                	mov    (%rax),%eax
  8004212ec2:	83 f8 03             	cmp    $0x3,%eax
  8004212ec5:	0f 8f f4 00 00 00    	jg     8004212fbf <mp_init+0x218>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  8004212ecb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ecf:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004212ed3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ed7:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004212edb:	0f b6 f0             	movzbl %al,%esi
  8004212ede:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ee2:	8b 78 08             	mov    0x8(%rax),%edi
  8004212ee5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ee9:	4c 8d 50 04          	lea    0x4(%rax),%r10
  8004212eed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ef1:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004212ef5:	0f b6 c8             	movzbl %al,%ecx
  8004212ef8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212efc:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004212f00:	0f b6 d0             	movzbl %al,%edx
  8004212f03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212f07:	0f b6 00             	movzbl (%rax),%eax
  8004212f0a:	0f b6 c0             	movzbl %al,%eax
  8004212f0d:	41 50                	push   %r8
  8004212f0f:	56                   	push   %rsi
  8004212f10:	41 89 f9             	mov    %edi,%r9d
  8004212f13:	4d 89 d0             	mov    %r10,%r8
  8004212f16:	89 c6                	mov    %eax,%esi
  8004212f18:	48 bf 00 71 21 04 80 	movabs $0x8004217100,%rdi
  8004212f1f:	00 00 00 
  8004212f22:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212f27:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  8004212f2e:	00 00 00 
  8004212f31:	41 ff d2             	callq  *%r10
  8004212f34:	48 83 c4 10          	add    $0x10,%rsp
				if (proc->flags & MPROC_EN) {
  8004212f38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212f3c:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004212f40:	0f b6 c0             	movzbl %al,%eax
  8004212f43:	83 e0 01             	and    $0x1,%eax
  8004212f46:	85 c0                	test   %eax,%eax
  8004212f48:	74 58                	je     8004212fa2 <mp_init+0x1fb>
					cpus[ncpu].cpu_id = ncpu;
  8004212f4a:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004212f51:	00 00 00 
  8004212f54:	8b 08                	mov    (%rax),%ecx
  8004212f56:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004212f5d:	00 00 00 
  8004212f60:	8b 00                	mov    (%rax),%eax
  8004212f62:	89 c6                	mov    %eax,%esi
  8004212f64:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004212f6b:	00 00 00 
  8004212f6e:	48 63 c1             	movslq %ecx,%rax
  8004212f71:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f75:	48 89 c1             	mov    %rax,%rcx
  8004212f78:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212f7c:	48 01 c8             	add    %rcx,%rax
  8004212f7f:	48 01 d0             	add    %rdx,%rax
  8004212f82:	40 88 30             	mov    %sil,(%rax)
					ncpu++;
  8004212f85:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004212f8c:	00 00 00 
  8004212f8f:	8b 00                	mov    (%rax),%eax
  8004212f91:	8d 50 01             	lea    0x1(%rax),%edx
  8004212f94:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004212f9b:	00 00 00 
  8004212f9e:	89 10                	mov    %edx,(%rax)
  8004212fa0:	eb 45                	jmp    8004212fe7 <mp_init+0x240>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004212fa2:	48 bf 50 71 21 04 80 	movabs $0x8004217150,%rdi
  8004212fa9:	00 00 00 
  8004212fac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fb1:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212fb8:	00 00 00 
  8004212fbb:	ff d2                	callq  *%rdx
  8004212fbd:	eb 28                	jmp    8004212fe7 <mp_init+0x240>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004212fbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212fc3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004212fc7:	0f b6 c0             	movzbl %al,%eax
  8004212fca:	89 c6                	mov    %eax,%esi
  8004212fcc:	48 bf 80 71 21 04 80 	movabs $0x8004217180,%rdi
  8004212fd3:	00 00 00 
  8004212fd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fdb:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004212fe2:	00 00 00 
  8004212fe5:	ff d2                	callq  *%rdx
			}
			p += sizeof(struct mpproc);
  8004212fe7:	48 83 45 f8 14       	addq   $0x14,-0x8(%rbp)
			continue;
  8004212fec:	eb 4c                	jmp    800421303a <mp_init+0x293>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  8004212fee:	48 83 45 f8 08       	addq   $0x8,-0x8(%rbp)
		continue;
  8004212ff3:	eb 45                	jmp    800421303a <mp_init+0x293>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004212ff5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212ff9:	0f b6 00             	movzbl (%rax),%eax
  8004212ffc:	0f b6 c0             	movzbl %al,%eax
  8004212fff:	89 c6                	mov    %eax,%esi
  8004213001:	48 bf a8 71 21 04 80 	movabs $0x80042171a8,%rdi
  8004213008:	00 00 00 
  800421300b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213010:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004213017:	00 00 00 
  800421301a:	ff d2                	callq  *%rdx
			ismp = 0;
  800421301c:	48 b8 00 e0 57 04 80 	movabs $0x800457e000,%rax
  8004213023:	00 00 00 
  8004213026:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  800421302c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213030:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004213034:	0f b7 c0             	movzwl %ax,%eax
  8004213037:	89 45 f4             	mov    %eax,-0xc(%rbp)
	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421303a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421303e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213042:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004213046:	0f b7 c0             	movzwl %ax,%eax
  8004213049:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800421304c:	0f 87 d5 fd ff ff    	ja     8004212e27 <mp_init+0x80>
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004213052:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004213059:	eb 53                	jmp    80042130ae <mp_init+0x307>
		cpus[i].is_vmx_root = false;
  800421305b:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004213062:	00 00 00 
  8004213065:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213068:	48 c1 e0 03          	shl    $0x3,%rax
  800421306c:	48 89 c1             	mov    %rax,%rcx
  800421306f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213073:	48 01 c8             	add    %rcx,%rax
  8004213076:	48 01 d0             	add    %rdx,%rax
  8004213079:	48 83 c0 70          	add    $0x70,%rax
  800421307d:	c6 40 08 00          	movb   $0x0,0x8(%rax)
		cpus[i].vmxon_region = 0;
  8004213081:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004213088:	00 00 00 
  800421308b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421308e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213092:	48 89 c1             	mov    %rax,%rcx
  8004213095:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213099:	48 01 c8             	add    %rcx,%rax
  800421309c:	48 01 d0             	add    %rdx,%rax
  800421309f:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  80042130a3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	for (i=0; i< NCPU; ++i) {
  80042130aa:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042130ae:	83 7d f4 03          	cmpl   $0x3,-0xc(%rbp)
  80042130b2:	76 a7                	jbe    800421305b <mp_init+0x2b4>
	}

	bootcpu->cpu_status = CPU_STARTED;
  80042130b4:	48 b8 60 e2 57 04 80 	movabs $0x800457e260,%rax
  80042130bb:	00 00 00 
  80042130be:	48 8b 00             	mov    (%rax),%rax
  80042130c1:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  80042130c8:	48 b8 00 e0 57 04 80 	movabs $0x800457e000,%rax
  80042130cf:	00 00 00 
  80042130d2:	8b 00                	mov    (%rax),%eax
  80042130d4:	85 c0                	test   %eax,%eax
  80042130d6:	75 41                	jne    8004213119 <mp_init+0x372>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  80042130d8:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  80042130df:	00 00 00 
  80042130e2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  80042130e8:	48 b8 00 f0 5b 04 80 	movabs $0x80045bf000,%rax
  80042130ef:	00 00 00 
  80042130f2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  80042130f9:	48 bf c8 71 21 04 80 	movabs $0x80042171c8,%rdi
  8004213100:	00 00 00 
  8004213103:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213108:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  800421310f:	00 00 00 
  8004213112:	ff d2                	callq  *%rdx
		return;
  8004213114:	e9 a2 00 00 00       	jmpq   80042131bb <mp_init+0x414>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004213119:	48 b8 68 e2 57 04 80 	movabs $0x800457e268,%rax
  8004213120:	00 00 00 
  8004213123:	8b 10                	mov    (%rax),%edx
  8004213125:	48 b8 60 e2 57 04 80 	movabs $0x800457e260,%rax
  800421312c:	00 00 00 
  800421312f:	48 8b 00             	mov    (%rax),%rax
  8004213132:	0f b6 00             	movzbl (%rax),%eax
  8004213135:	0f b6 c0             	movzbl %al,%eax
  8004213138:	89 c6                	mov    %eax,%esi
  800421313a:	48 bf f4 71 21 04 80 	movabs $0x80042171f4,%rdi
  8004213141:	00 00 00 
  8004213144:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213149:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  8004213150:	00 00 00 
  8004213153:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004213155:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213159:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421315d:	84 c0                	test   %al,%al
  800421315f:	74 5a                	je     80042131bb <mp_init+0x414>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004213161:	48 bf 18 72 21 04 80 	movabs $0x8004217218,%rdi
  8004213168:	00 00 00 
  800421316b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213170:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004213177:	00 00 00 
  800421317a:	ff d2                	callq  *%rdx
  800421317c:	c7 45 dc 22 00 00 00 	movl   $0x22,-0x24(%rbp)
  8004213183:	c6 45 db 70          	movb   $0x70,-0x25(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004213187:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800421318b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421318e:	ee                   	out    %al,(%dx)
  800421318f:	c7 45 d4 23 00 00 00 	movl   $0x23,-0x2c(%rbp)
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004213196:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004213199:	89 c2                	mov    %eax,%edx
  800421319b:	ec                   	in     (%dx),%al
  800421319c:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  800421319f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  80042131a3:	83 c8 01             	or     $0x1,%eax
  80042131a6:	0f b6 c0             	movzbl %al,%eax
  80042131a9:	c7 45 cc 23 00 00 00 	movl   $0x23,-0x34(%rbp)
  80042131b0:	88 45 cb             	mov    %al,-0x35(%rbp)
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042131b3:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042131b7:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042131ba:	ee                   	out    %al,(%dx)
	}
}
  80042131bb:	c9                   	leaveq 
  80042131bc:	c3                   	retq   

00000080042131bd <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  80042131bd:	55                   	push   %rbp
  80042131be:	48 89 e5             	mov    %rsp,%rbp
  80042131c1:	48 83 ec 08          	sub    $0x8,%rsp
  80042131c5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042131c8:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042131cb:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  80042131d2:	00 00 00 
  80042131d5:	48 8b 00             	mov    (%rax),%rax
  80042131d8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042131db:	48 63 d2             	movslq %edx,%rdx
  80042131de:	48 c1 e2 02          	shl    $0x2,%rdx
  80042131e2:	48 01 c2             	add    %rax,%rdx
  80042131e5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042131e8:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  80042131ea:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  80042131f1:	00 00 00 
  80042131f4:	48 8b 00             	mov    (%rax),%rax
  80042131f7:	48 83 c0 20          	add    $0x20,%rax
  80042131fb:	8b 00                	mov    (%rax),%eax
}
  80042131fd:	c9                   	leaveq 
  80042131fe:	c3                   	retq   

00000080042131ff <lapic_init>:

void
lapic_init(void)
{
  80042131ff:	55                   	push   %rbp
  8004213200:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004213203:	48 b8 00 f0 5b 04 80 	movabs $0x80045bf000,%rax
  800421320a:	00 00 00 
  800421320d:	48 8b 00             	mov    (%rax),%rax
  8004213210:	48 85 c0             	test   %rax,%rax
  8004213213:	75 05                	jne    800421321a <lapic_init+0x1b>
		return;
  8004213215:	e9 dd 01 00 00       	jmpq   80042133f7 <lapic_init+0x1f8>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  800421321a:	48 b8 00 f0 5b 04 80 	movabs $0x80045bf000,%rax
  8004213221:	00 00 00 
  8004213224:	48 8b 00             	mov    (%rax),%rax
  8004213227:	be 00 10 00 00       	mov    $0x1000,%esi
  800421322c:	48 89 c7             	mov    %rax,%rdi
  800421322f:	48 b8 50 40 20 04 80 	movabs $0x8004204050,%rax
  8004213236:	00 00 00 
  8004213239:	ff d0                	callq  *%rax
  800421323b:	48 89 c2             	mov    %rax,%rdx
  800421323e:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  8004213245:	00 00 00 
  8004213248:	48 89 10             	mov    %rdx,(%rax)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  800421324b:	be 27 01 00 00       	mov    $0x127,%esi
  8004213250:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004213255:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421325c:	00 00 00 
  800421325f:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004213261:	be 0b 00 00 00       	mov    $0xb,%esi
  8004213266:	bf f8 00 00 00       	mov    $0xf8,%edi
  800421326b:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213272:	00 00 00 
  8004213275:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004213277:	be 20 00 02 00       	mov    $0x20020,%esi
  800421327c:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004213281:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213288:	00 00 00 
  800421328b:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  800421328d:	be 80 96 98 00       	mov    $0x989680,%esi
  8004213292:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004213297:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421329e:	00 00 00 
  80042132a1:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  80042132a3:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042132aa:	00 00 00 
  80042132ad:	ff d0                	callq  *%rax
  80042132af:	48 98                	cltq   
  80042132b1:	48 c1 e0 03          	shl    $0x3,%rax
  80042132b5:	48 89 c2             	mov    %rax,%rdx
  80042132b8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042132bc:	48 01 d0             	add    %rdx,%rax
  80042132bf:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  80042132c6:	00 00 00 
  80042132c9:	48 01 c2             	add    %rax,%rdx
  80042132cc:	48 b8 60 e2 57 04 80 	movabs $0x800457e260,%rax
  80042132d3:	00 00 00 
  80042132d6:	48 8b 00             	mov    (%rax),%rax
  80042132d9:	48 39 c2             	cmp    %rax,%rdx
  80042132dc:	74 16                	je     80042132f4 <lapic_init+0xf5>
		lapicw(LINT0, MASKED);
  80042132de:	be 00 00 01 00       	mov    $0x10000,%esi
  80042132e3:	bf d4 00 00 00       	mov    $0xd4,%edi
  80042132e8:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  80042132ef:	00 00 00 
  80042132f2:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  80042132f4:	be 00 00 01 00       	mov    $0x10000,%esi
  80042132f9:	bf d8 00 00 00       	mov    $0xd8,%edi
  80042132fe:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213305:	00 00 00 
  8004213308:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  800421330a:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  8004213311:	00 00 00 
  8004213314:	48 8b 00             	mov    (%rax),%rax
  8004213317:	48 83 c0 30          	add    $0x30,%rax
  800421331b:	8b 00                	mov    (%rax),%eax
  800421331d:	c1 e8 10             	shr    $0x10,%eax
  8004213320:	0f b6 c0             	movzbl %al,%eax
  8004213323:	83 f8 03             	cmp    $0x3,%eax
  8004213326:	76 16                	jbe    800421333e <lapic_init+0x13f>
		lapicw(PCINT, MASKED);
  8004213328:	be 00 00 01 00       	mov    $0x10000,%esi
  800421332d:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004213332:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213339:	00 00 00 
  800421333c:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  800421333e:	be 33 00 00 00       	mov    $0x33,%esi
  8004213343:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004213348:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421334f:	00 00 00 
  8004213352:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004213354:	be 00 00 00 00       	mov    $0x0,%esi
  8004213359:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421335e:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213365:	00 00 00 
  8004213368:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  800421336a:	be 00 00 00 00       	mov    $0x0,%esi
  800421336f:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004213374:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421337b:	00 00 00 
  800421337e:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004213380:	be 00 00 00 00       	mov    $0x0,%esi
  8004213385:	bf 2c 00 00 00       	mov    $0x2c,%edi
  800421338a:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213391:	00 00 00 
  8004213394:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004213396:	be 00 00 00 00       	mov    $0x0,%esi
  800421339b:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042133a0:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  80042133a7:	00 00 00 
  80042133aa:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  80042133ac:	be 00 85 08 00       	mov    $0x88500,%esi
  80042133b1:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042133b6:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  80042133bd:	00 00 00 
  80042133c0:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  80042133c2:	90                   	nop
  80042133c3:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  80042133ca:	00 00 00 
  80042133cd:	48 8b 00             	mov    (%rax),%rax
  80042133d0:	48 05 00 03 00 00    	add    $0x300,%rax
  80042133d6:	8b 00                	mov    (%rax),%eax
  80042133d8:	25 00 10 00 00       	and    $0x1000,%eax
  80042133dd:	85 c0                	test   %eax,%eax
  80042133df:	75 e2                	jne    80042133c3 <lapic_init+0x1c4>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  80042133e1:	be 00 00 00 00       	mov    $0x0,%esi
  80042133e6:	bf 20 00 00 00       	mov    $0x20,%edi
  80042133eb:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  80042133f2:	00 00 00 
  80042133f5:	ff d0                	callq  *%rax
}
  80042133f7:	5d                   	pop    %rbp
  80042133f8:	c3                   	retq   

00000080042133f9 <cpunum>:

int
cpunum(void)
{
  80042133f9:	55                   	push   %rbp
  80042133fa:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  80042133fd:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  8004213404:	00 00 00 
  8004213407:	48 8b 00             	mov    (%rax),%rax
  800421340a:	48 85 c0             	test   %rax,%rax
  800421340d:	74 18                	je     8004213427 <cpunum+0x2e>
		return lapic[ID] >> 24;
  800421340f:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  8004213416:	00 00 00 
  8004213419:	48 8b 00             	mov    (%rax),%rax
  800421341c:	48 83 c0 20          	add    $0x20,%rax
  8004213420:	8b 00                	mov    (%rax),%eax
  8004213422:	c1 e8 18             	shr    $0x18,%eax
  8004213425:	eb 05                	jmp    800421342c <cpunum+0x33>
	return 0;
  8004213427:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421342c:	5d                   	pop    %rbp
  800421342d:	c3                   	retq   

000000800421342e <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  800421342e:	55                   	push   %rbp
  800421342f:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004213432:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  8004213439:	00 00 00 
  800421343c:	48 8b 00             	mov    (%rax),%rax
  800421343f:	48 85 c0             	test   %rax,%rax
  8004213442:	74 16                	je     800421345a <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004213444:	be 00 00 00 00       	mov    $0x0,%esi
  8004213449:	bf 2c 00 00 00       	mov    $0x2c,%edi
  800421344e:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213455:	00 00 00 
  8004213458:	ff d0                	callq  *%rax
}
  800421345a:	5d                   	pop    %rbp
  800421345b:	c3                   	retq   

000000800421345c <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  800421345c:	55                   	push   %rbp
  800421345d:	48 89 e5             	mov    %rsp,%rbp
  8004213460:	48 83 ec 08          	sub    $0x8,%rsp
  8004213464:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004213467:	c9                   	leaveq 
  8004213468:	c3                   	retq   

0000008004213469 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004213469:	55                   	push   %rbp
  800421346a:	48 89 e5             	mov    %rsp,%rbp
  800421346d:	48 83 ec 40          	sub    $0x40,%rsp
  8004213471:	89 f8                	mov    %edi,%eax
  8004213473:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004213476:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004213479:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004213480:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004213484:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004213488:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421348b:	ee                   	out    %al,(%dx)
  800421348c:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004213493:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004213497:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800421349b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800421349e:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  800421349f:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  80042134a6:	00 
  80042134a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042134ab:	48 c1 e8 0c          	shr    $0xc,%rax
  80042134af:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042134b2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042134b5:	48 b8 d0 c7 57 04 80 	movabs $0x800457c7d0,%rax
  80042134bc:	00 00 00 
  80042134bf:	48 8b 00             	mov    (%rax),%rax
  80042134c2:	48 39 c2             	cmp    %rax,%rdx
  80042134c5:	72 32                	jb     80042134f9 <lapic_startap+0x90>
  80042134c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042134cb:	48 89 c1             	mov    %rax,%rcx
  80042134ce:	48 ba 60 72 21 04 80 	movabs $0x8004217260,%rdx
  80042134d5:	00 00 00 
  80042134d8:	be 98 00 00 00       	mov    $0x98,%esi
  80042134dd:	48 bf 83 72 21 04 80 	movabs $0x8004217283,%rdi
  80042134e4:	00 00 00 
  80042134e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042134ec:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  80042134f3:	00 00 00 
  80042134f6:	41 ff d0             	callq  *%r8
  80042134f9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004213500:	00 00 00 
  8004213503:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213507:	48 01 d0             	add    %rdx,%rax
  800421350a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  800421350e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213512:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004213517:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421351b:	48 83 c0 02          	add    $0x2,%rax
  800421351f:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213522:	c1 ea 04             	shr    $0x4,%edx
  8004213525:	66 89 10             	mov    %dx,(%rax)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004213528:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421352c:	c1 e0 18             	shl    $0x18,%eax
  800421352f:	89 c6                	mov    %eax,%esi
  8004213531:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004213536:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421353d:	00 00 00 
  8004213540:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004213542:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004213547:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421354c:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  8004213553:	00 00 00 
  8004213556:	ff d0                	callq  *%rax
	microdelay(200);
  8004213558:	bf c8 00 00 00       	mov    $0xc8,%edi
  800421355d:	48 b8 5c 34 21 04 80 	movabs $0x800421345c,%rax
  8004213564:	00 00 00 
  8004213567:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004213569:	be 00 85 00 00       	mov    $0x8500,%esi
  800421356e:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004213573:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421357a:	00 00 00 
  800421357d:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  800421357f:	bf 64 00 00 00       	mov    $0x64,%edi
  8004213584:	48 b8 5c 34 21 04 80 	movabs $0x800421345c,%rax
  800421358b:	00 00 00 
  800421358e:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004213590:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213597:	eb 4b                	jmp    80042135e4 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004213599:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421359d:	c1 e0 18             	shl    $0x18,%eax
  80042135a0:	89 c6                	mov    %eax,%esi
  80042135a2:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042135a7:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  80042135ae:	00 00 00 
  80042135b1:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  80042135b3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80042135b6:	c1 e8 0c             	shr    $0xc,%eax
  80042135b9:	80 cc 06             	or     $0x6,%ah
  80042135bc:	89 c6                	mov    %eax,%esi
  80042135be:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042135c3:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  80042135ca:	00 00 00 
  80042135cd:	ff d0                	callq  *%rax
		microdelay(200);
  80042135cf:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042135d4:	48 b8 5c 34 21 04 80 	movabs $0x800421345c,%rax
  80042135db:	00 00 00 
  80042135de:	ff d0                	callq  *%rax
	for (i = 0; i < 2; i++) {
  80042135e0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042135e4:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  80042135e8:	7e af                	jle    8004213599 <lapic_startap+0x130>
	}
}
  80042135ea:	c9                   	leaveq 
  80042135eb:	c3                   	retq   

00000080042135ec <lapic_ipi>:

void
lapic_ipi(int vector)
{
  80042135ec:	55                   	push   %rbp
  80042135ed:	48 89 e5             	mov    %rsp,%rbp
  80042135f0:	48 83 ec 08          	sub    $0x8,%rsp
  80042135f4:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  80042135f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042135fa:	0d 00 00 0c 00       	or     $0xc0000,%eax
  80042135ff:	89 c6                	mov    %eax,%esi
  8004213601:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004213606:	48 b8 bd 31 21 04 80 	movabs $0x80042131bd,%rax
  800421360d:	00 00 00 
  8004213610:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004213612:	90                   	nop
  8004213613:	48 b8 08 f0 5b 04 80 	movabs $0x80045bf008,%rax
  800421361a:	00 00 00 
  800421361d:	48 8b 00             	mov    (%rax),%rax
  8004213620:	48 05 00 03 00 00    	add    $0x300,%rax
  8004213626:	8b 00                	mov    (%rax),%eax
  8004213628:	25 00 10 00 00       	and    $0x1000,%eax
  800421362d:	85 c0                	test   %eax,%eax
  800421362f:	75 e2                	jne    8004213613 <lapic_ipi+0x27>
		;
}
  8004213631:	c9                   	leaveq 
  8004213632:	c3                   	retq   

0000008004213633 <xchg>:
xchg(volatile uint32_t *addr,uint32_t newval){
  8004213633:	55                   	push   %rbp
  8004213634:	48 89 e5             	mov    %rsp,%rbp
  8004213637:	48 83 ec 20          	sub    $0x20,%rsp
  800421363b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421363f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	__asm __volatile("lock; xchgl %0, %1":
  8004213642:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213646:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213649:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421364d:	f0 87 02             	lock xchg %eax,(%rdx)
  8004213650:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return result;
  8004213653:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004213656:	c9                   	leaveq 
  8004213657:	c3                   	retq   

0000008004213658 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004213658:	55                   	push   %rbp
  8004213659:	48 89 e5             	mov    %rsp,%rbp
  800421365c:	48 83 ec 28          	sub    $0x28,%rsp
  8004213660:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004213664:	48 89 e8             	mov    %rbp,%rax
  8004213667:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  800421366b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  800421366f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004213673:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421367a:	eb 45                	jmp    80042136c1 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  800421367c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213681:	74 44                	je     80042136c7 <get_caller_pcs+0x6f>
  8004213683:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800421368a:	00 00 00 
  800421368d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213691:	76 34                	jbe    80042136c7 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004213693:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213696:	48 98                	cltq   
  8004213698:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421369f:	00 
  80042136a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042136a4:	48 01 c2             	add    %rax,%rdx
  80042136a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042136ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042136af:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  80042136b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042136b6:	48 8b 00             	mov    (%rax),%rax
  80042136b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  80042136bd:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042136c1:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  80042136c5:	7e b5                	jle    800421367c <get_caller_pcs+0x24>
	}
	for (; i < 10; i++)
  80042136c7:	eb 1f                	jmp    80042136e8 <get_caller_pcs+0x90>
		pcs[i] = 0;
  80042136c9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042136cc:	48 98                	cltq   
  80042136ce:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042136d5:	00 
  80042136d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042136da:	48 01 d0             	add    %rdx,%rax
  80042136dd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	for (; i < 10; i++)
  80042136e4:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042136e8:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  80042136ec:	7e db                	jle    80042136c9 <get_caller_pcs+0x71>
}
  80042136ee:	c9                   	leaveq 
  80042136ef:	c3                   	retq   

00000080042136f0 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  80042136f0:	55                   	push   %rbp
  80042136f1:	48 89 e5             	mov    %rsp,%rbp
  80042136f4:	53                   	push   %rbx
  80042136f5:	48 83 ec 18          	sub    $0x18,%rsp
  80042136f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  80042136fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213701:	8b 00                	mov    (%rax),%eax
  8004213703:	85 c0                	test   %eax,%eax
  8004213705:	74 3d                	je     8004213744 <holding+0x54>
  8004213707:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421370b:	48 8b 58 10          	mov    0x10(%rax),%rbx
  800421370f:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004213716:	00 00 00 
  8004213719:	ff d0                	callq  *%rax
  800421371b:	48 98                	cltq   
  800421371d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213721:	48 89 c2             	mov    %rax,%rdx
  8004213724:	48 c1 e2 04          	shl    $0x4,%rdx
  8004213728:	48 01 d0             	add    %rdx,%rax
  800421372b:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  8004213732:	00 00 00 
  8004213735:	48 01 d0             	add    %rdx,%rax
  8004213738:	48 39 c3             	cmp    %rax,%rbx
  800421373b:	75 07                	jne    8004213744 <holding+0x54>
  800421373d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213742:	eb 05                	jmp    8004213749 <holding+0x59>
  8004213744:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213749:	48 83 c4 18          	add    $0x18,%rsp
  800421374d:	5b                   	pop    %rbx
  800421374e:	5d                   	pop    %rbp
  800421374f:	c3                   	retq   

0000008004213750 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004213750:	55                   	push   %rbp
  8004213751:	48 89 e5             	mov    %rsp,%rbp
  8004213754:	48 83 ec 10          	sub    $0x10,%rsp
  8004213758:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421375c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004213760:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213764:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  800421376a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421376e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213772:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004213776:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421377a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004213781:	00 
#endif
}
  8004213782:	c9                   	leaveq 
  8004213783:	c3                   	retq   

0000008004213784 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004213784:	55                   	push   %rbp
  8004213785:	48 89 e5             	mov    %rsp,%rbp
  8004213788:	53                   	push   %rbx
  8004213789:	48 83 ec 18          	sub    $0x18,%rsp
  800421378d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004213791:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213795:	48 89 c7             	mov    %rax,%rdi
  8004213798:	48 b8 f0 36 21 04 80 	movabs $0x80042136f0,%rax
  800421379f:	00 00 00 
  80042137a2:	ff d0                	callq  *%rax
  80042137a4:	85 c0                	test   %eax,%eax
  80042137a6:	74 44                	je     80042137ec <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  80042137a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137ac:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042137b0:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042137b7:	00 00 00 
  80042137ba:	ff d0                	callq  *%rax
  80042137bc:	49 89 d8             	mov    %rbx,%r8
  80042137bf:	89 c1                	mov    %eax,%ecx
  80042137c1:	48 ba a0 72 21 04 80 	movabs $0x80042172a0,%rdx
  80042137c8:	00 00 00 
  80042137cb:	be 41 00 00 00       	mov    $0x41,%esi
  80042137d0:	48 bf ca 72 21 04 80 	movabs $0x80042172ca,%rdi
  80042137d7:	00 00 00 
  80042137da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042137df:	49 b9 a6 05 20 04 80 	movabs $0x80042005a6,%r9
  80042137e6:	00 00 00 
  80042137e9:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  80042137ec:	eb 02                	jmp    80042137f0 <spin_lock+0x6c>
		asm volatile ("pause");
  80042137ee:	f3 90                	pause  
	while (xchg(&lk->locked, 1) != 0)
  80042137f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137f4:	be 01 00 00 00       	mov    $0x1,%esi
  80042137f9:	48 89 c7             	mov    %rax,%rdi
  80042137fc:	48 b8 33 36 21 04 80 	movabs $0x8004213633,%rax
  8004213803:	00 00 00 
  8004213806:	ff d0                	callq  *%rax
  8004213808:	85 c0                	test   %eax,%eax
  800421380a:	75 e2                	jne    80042137ee <spin_lock+0x6a>

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  800421380c:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004213813:	00 00 00 
  8004213816:	ff d0                	callq  *%rax
  8004213818:	48 98                	cltq   
  800421381a:	48 c1 e0 03          	shl    $0x3,%rax
  800421381e:	48 89 c2             	mov    %rax,%rdx
  8004213821:	48 c1 e2 04          	shl    $0x4,%rdx
  8004213825:	48 01 d0             	add    %rdx,%rax
  8004213828:	48 ba 40 e0 57 04 80 	movabs $0x800457e040,%rdx
  800421382f:	00 00 00 
  8004213832:	48 01 c2             	add    %rax,%rdx
  8004213835:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213839:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  800421383d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213841:	48 83 c0 18          	add    $0x18,%rax
  8004213845:	48 89 c7             	mov    %rax,%rdi
  8004213848:	48 b8 58 36 21 04 80 	movabs $0x8004213658,%rax
  800421384f:	00 00 00 
  8004213852:	ff d0                	callq  *%rax
#endif
}
  8004213854:	48 83 c4 18          	add    $0x18,%rsp
  8004213858:	5b                   	pop    %rbx
  8004213859:	5d                   	pop    %rbp
  800421385a:	c3                   	retq   

000000800421385b <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  800421385b:	55                   	push   %rbp
  800421385c:	48 89 e5             	mov    %rsp,%rbp
  800421385f:	41 54                	push   %r12
  8004213861:	53                   	push   %rbx
  8004213862:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004213869:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004213870:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213877:	48 89 c7             	mov    %rax,%rdi
  800421387a:	48 b8 f0 36 21 04 80 	movabs $0x80042136f0,%rax
  8004213881:	00 00 00 
  8004213884:	ff d0                	callq  *%rax
  8004213886:	85 c0                	test   %eax,%eax
  8004213888:	0f 85 d8 01 00 00    	jne    8004213a66 <spin_unlock+0x20b>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  800421388e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213895:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004213899:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  80042138a0:	ba 28 00 00 00       	mov    $0x28,%edx
  80042138a5:	48 89 ce             	mov    %rcx,%rsi
  80042138a8:	48 89 c7             	mov    %rax,%rdi
  80042138ab:	48 b8 73 c5 20 04 80 	movabs $0x800420c573,%rax
  80042138b2:	00 00 00 
  80042138b5:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  80042138b7:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042138be:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042138c2:	48 85 c0             	test   %rax,%rax
  80042138c5:	75 39                	jne    8004213900 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  80042138c7:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042138ce:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042138d2:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  80042138d9:	00 00 00 
  80042138dc:	ff d0                	callq  *%rax
  80042138de:	48 89 da             	mov    %rbx,%rdx
  80042138e1:	89 c6                	mov    %eax,%esi
  80042138e3:	48 bf e0 72 21 04 80 	movabs $0x80042172e0,%rdi
  80042138ea:	00 00 00 
  80042138ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042138f2:	48 b9 4a 95 20 04 80 	movabs $0x800420954a,%rcx
  80042138f9:	00 00 00 
  80042138fc:	ff d1                	callq  *%rcx
  80042138fe:	eb 4d                	jmp    800421394d <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004213900:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213907:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421390b:	0f b6 00             	movzbl (%rax),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  800421390e:	44 0f b6 e0          	movzbl %al,%r12d
  8004213912:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213919:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421391d:	48 b8 f9 33 21 04 80 	movabs $0x80042133f9,%rax
  8004213924:	00 00 00 
  8004213927:	ff d0                	callq  *%rax
  8004213929:	44 89 e1             	mov    %r12d,%ecx
  800421392c:	48 89 da             	mov    %rbx,%rdx
  800421392f:	89 c6                	mov    %eax,%esi
  8004213931:	48 bf 20 73 21 04 80 	movabs $0x8004217320,%rdi
  8004213938:	00 00 00 
  800421393b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213940:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  8004213947:	00 00 00 
  800421394a:	41 ff d0             	callq  *%r8
		for (i = 0; i < 10 && pcs[i]; i++) {
  800421394d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004213954:	e9 c9 00 00 00       	jmpq   8004213a22 <spin_unlock+0x1c7>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004213959:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421395c:	48 98                	cltq   
  800421395e:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004213965:	89 c2                	mov    %eax,%edx
  8004213967:	48 8d 85 10 fb ff ff 	lea    -0x4f0(%rbp),%rax
  800421396e:	48 89 c6             	mov    %rax,%rsi
  8004213971:	48 89 d7             	mov    %rdx,%rdi
  8004213974:	48 b8 88 b1 20 04 80 	movabs $0x800420b188,%rax
  800421397b:	00 00 00 
  800421397e:	ff d0                	callq  *%rax
  8004213980:	85 c0                	test   %eax,%eax
  8004213982:	78 71                	js     80042139f5 <spin_unlock+0x19a>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004213984:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004213987:	48 98                	cltq   
  8004213989:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004213990:	89 c2                	mov    %eax,%edx
					pcs[i] - info.rip_fn_addr);
  8004213992:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004213999:	48 29 c2             	sub    %rax,%rdx
  800421399c:	49 89 d0             	mov    %rdx,%r8
  800421399f:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  80042139a6:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  80042139ac:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  80042139b2:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  80042139b9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042139bc:	48 98                	cltq   
  80042139be:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042139c5:	48 83 ec 08          	sub    $0x8,%rsp
  80042139c9:	41 50                	push   %r8
  80042139cb:	49 89 f9             	mov    %rdi,%r9
  80042139ce:	41 89 f0             	mov    %esi,%r8d
  80042139d1:	89 c6                	mov    %eax,%esi
  80042139d3:	48 bf 56 73 21 04 80 	movabs $0x8004217356,%rdi
  80042139da:	00 00 00 
  80042139dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042139e2:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  80042139e9:	00 00 00 
  80042139ec:	41 ff d2             	callq  *%r10
  80042139ef:	48 83 c4 10          	add    $0x10,%rsp
  80042139f3:	eb 29                	jmp    8004213a1e <spin_unlock+0x1c3>
			else
				cprintf("  %08x\n", pcs[i]);
  80042139f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042139f8:	48 98                	cltq   
  80042139fa:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004213a01:	89 c6                	mov    %eax,%esi
  8004213a03:	48 bf 6d 73 21 04 80 	movabs $0x800421736d,%rdi
  8004213a0a:	00 00 00 
  8004213a0d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a12:	48 ba 4a 95 20 04 80 	movabs $0x800420954a,%rdx
  8004213a19:	00 00 00 
  8004213a1c:	ff d2                	callq  *%rdx
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004213a1e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004213a22:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004213a26:	7f 14                	jg     8004213a3c <spin_unlock+0x1e1>
  8004213a28:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004213a2b:	48 98                	cltq   
  8004213a2d:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004213a34:	85 c0                	test   %eax,%eax
  8004213a36:	0f 85 1d ff ff ff    	jne    8004213959 <spin_unlock+0xfe>
		}
		panic("spin_unlock");
  8004213a3c:	48 ba 75 73 21 04 80 	movabs $0x8004217375,%rdx
  8004213a43:	00 00 00 
  8004213a46:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004213a4b:	48 bf ca 72 21 04 80 	movabs $0x80042172ca,%rdi
  8004213a52:	00 00 00 
  8004213a55:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a5a:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  8004213a61:	00 00 00 
  8004213a64:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004213a66:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213a6d:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004213a74:	00 
	lk->cpu = 0;
  8004213a75:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213a7c:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004213a83:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004213a84:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004213a8b:	be 00 00 00 00       	mov    $0x0,%esi
  8004213a90:	48 89 c7             	mov    %rax,%rdi
  8004213a93:	48 b8 33 36 21 04 80 	movabs $0x8004213633,%rax
  8004213a9a:	00 00 00 
  8004213a9d:	ff d0                	callq  *%rax
}
  8004213a9f:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004213aa3:	5b                   	pop    %rbx
  8004213aa4:	41 5c                	pop    %r12
  8004213aa6:	5d                   	pop    %rbp
  8004213aa7:	c3                   	retq   

0000008004213aa8 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004213aa8:	55                   	push   %rbp
  8004213aa9:	48 89 e5             	mov    %rsp,%rbp
  8004213aac:	48 83 ec 20          	sub    $0x20,%rsp
  8004213ab0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004213ab3:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004213ab6:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004213ab9:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  8004213abc:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004213ac3:	76 35                	jbe    8004213afa <pci_conf1_set_addr+0x52>
  8004213ac5:	48 b9 88 73 21 04 80 	movabs $0x8004217388,%rcx
  8004213acc:	00 00 00 
  8004213acf:	48 ba 92 73 21 04 80 	movabs $0x8004217392,%rdx
  8004213ad6:	00 00 00 
  8004213ad9:	be 29 00 00 00       	mov    $0x29,%esi
  8004213ade:	48 bf a7 73 21 04 80 	movabs $0x80042173a7,%rdi
  8004213ae5:	00 00 00 
  8004213ae8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213aed:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004213af4:	00 00 00 
  8004213af7:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004213afa:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004213afe:	76 35                	jbe    8004213b35 <pci_conf1_set_addr+0x8d>
  8004213b00:	48 b9 b2 73 21 04 80 	movabs $0x80042173b2,%rcx
  8004213b07:	00 00 00 
  8004213b0a:	48 ba 92 73 21 04 80 	movabs $0x8004217392,%rdx
  8004213b11:	00 00 00 
  8004213b14:	be 2a 00 00 00       	mov    $0x2a,%esi
  8004213b19:	48 bf a7 73 21 04 80 	movabs $0x80042173a7,%rdi
  8004213b20:	00 00 00 
  8004213b23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213b28:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004213b2f:	00 00 00 
  8004213b32:	41 ff d0             	callq  *%r8
	assert(func < 8);
  8004213b35:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004213b39:	76 35                	jbe    8004213b70 <pci_conf1_set_addr+0xc8>
  8004213b3b:	48 b9 bb 73 21 04 80 	movabs $0x80042173bb,%rcx
  8004213b42:	00 00 00 
  8004213b45:	48 ba 92 73 21 04 80 	movabs $0x8004217392,%rdx
  8004213b4c:	00 00 00 
  8004213b4f:	be 2b 00 00 00       	mov    $0x2b,%esi
  8004213b54:	48 bf a7 73 21 04 80 	movabs $0x80042173a7,%rdi
  8004213b5b:	00 00 00 
  8004213b5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213b63:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004213b6a:	00 00 00 
  8004213b6d:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  8004213b70:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004213b77:	76 35                	jbe    8004213bae <pci_conf1_set_addr+0x106>
  8004213b79:	48 b9 c4 73 21 04 80 	movabs $0x80042173c4,%rcx
  8004213b80:	00 00 00 
  8004213b83:	48 ba 92 73 21 04 80 	movabs $0x8004217392,%rdx
  8004213b8a:	00 00 00 
  8004213b8d:	be 2c 00 00 00       	mov    $0x2c,%esi
  8004213b92:	48 bf a7 73 21 04 80 	movabs $0x80042173a7,%rdi
  8004213b99:	00 00 00 
  8004213b9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213ba1:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004213ba8:	00 00 00 
  8004213bab:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  8004213bae:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004213bb1:	83 e0 03             	and    $0x3,%eax
  8004213bb4:	85 c0                	test   %eax,%eax
  8004213bb6:	74 35                	je     8004213bed <pci_conf1_set_addr+0x145>
  8004213bb8:	48 b9 d1 73 21 04 80 	movabs $0x80042173d1,%rcx
  8004213bbf:	00 00 00 
  8004213bc2:	48 ba 92 73 21 04 80 	movabs $0x8004217392,%rdx
  8004213bc9:	00 00 00 
  8004213bcc:	be 2d 00 00 00       	mov    $0x2d,%esi
  8004213bd1:	48 bf a7 73 21 04 80 	movabs $0x80042173a7,%rdi
  8004213bd8:	00 00 00 
  8004213bdb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213be0:	49 b8 a6 05 20 04 80 	movabs $0x80042005a6,%r8
  8004213be7:	00 00 00 
  8004213bea:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004213bed:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004213bf0:	c1 e0 10             	shl    $0x10,%eax
  8004213bf3:	89 c2                	mov    %eax,%edx
  8004213bf5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004213bf8:	c1 e0 0b             	shl    $0xb,%eax
  8004213bfb:	09 c2                	or     %eax,%edx
  8004213bfd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213c00:	c1 e0 08             	shl    $0x8,%eax
  8004213c03:	09 d0                	or     %edx,%eax
  8004213c05:	0b 45 e0             	or     -0x20(%rbp),%eax
	uint32_t v = (1 << 31) |		// config-space
  8004213c08:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004213c0d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	outl(pci_conf1_addr_ioport, v);
  8004213c10:	48 b8 44 88 22 04 80 	movabs $0x8004228844,%rax
  8004213c17:	00 00 00 
  8004213c1a:	8b 00                	mov    (%rax),%eax
  8004213c1c:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004213c1f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213c22:	89 45 f4             	mov    %eax,-0xc(%rbp)
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004213c25:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213c28:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004213c2b:	ef                   	out    %eax,(%dx)
}
  8004213c2c:	c9                   	leaveq 
  8004213c2d:	c3                   	retq   

0000008004213c2e <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  8004213c2e:	55                   	push   %rbp
  8004213c2f:	48 89 e5             	mov    %rsp,%rbp
  8004213c32:	48 83 ec 20          	sub    $0x20,%rsp
  8004213c36:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213c3a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004213c3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c41:	8b 50 0c             	mov    0xc(%rax),%edx
  8004213c44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c48:	8b 70 08             	mov    0x8(%rax),%esi
  8004213c4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c4f:	48 8b 00             	mov    (%rax),%rax
  8004213c52:	8b 40 08             	mov    0x8(%rax),%eax
  8004213c55:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004213c58:	89 c7                	mov    %eax,%edi
  8004213c5a:	48 b8 a8 3a 21 04 80 	movabs $0x8004213aa8,%rax
  8004213c61:	00 00 00 
  8004213c64:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  8004213c66:	48 b8 48 88 22 04 80 	movabs $0x8004228848,%rax
  8004213c6d:	00 00 00 
  8004213c70:	8b 00                	mov    (%rax),%eax
  8004213c72:	89 45 fc             	mov    %eax,-0x4(%rbp)
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004213c75:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213c78:	89 c2                	mov    %eax,%edx
  8004213c7a:	ed                   	in     (%dx),%eax
  8004213c7b:	89 45 f8             	mov    %eax,-0x8(%rbp)
	return data;
  8004213c7e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004213c81:	90                   	nop
}
  8004213c82:	c9                   	leaveq 
  8004213c83:	c3                   	retq   

0000008004213c84 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004213c84:	55                   	push   %rbp
  8004213c85:	48 89 e5             	mov    %rsp,%rbp
  8004213c88:	48 83 ec 20          	sub    $0x20,%rsp
  8004213c8c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213c90:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004213c93:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004213c96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c9a:	8b 50 0c             	mov    0xc(%rax),%edx
  8004213c9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ca1:	8b 70 08             	mov    0x8(%rax),%esi
  8004213ca4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ca8:	48 8b 00             	mov    (%rax),%rax
  8004213cab:	8b 40 08             	mov    0x8(%rax),%eax
  8004213cae:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004213cb1:	89 c7                	mov    %eax,%edi
  8004213cb3:	48 b8 a8 3a 21 04 80 	movabs $0x8004213aa8,%rax
  8004213cba:	00 00 00 
  8004213cbd:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  8004213cbf:	48 b8 48 88 22 04 80 	movabs $0x8004228848,%rax
  8004213cc6:	00 00 00 
  8004213cc9:	8b 00                	mov    (%rax),%eax
  8004213ccb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004213cce:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004213cd1:	89 45 f8             	mov    %eax,-0x8(%rbp)
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004213cd4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004213cd7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004213cda:	ef                   	out    %eax,(%dx)
}
  8004213cdb:	c9                   	leaveq 
  8004213cdc:	c3                   	retq   

0000008004213cdd <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004213cdd:	55                   	push   %rbp
  8004213cde:	48 89 e5             	mov    %rsp,%rbp
  8004213ce1:	48 83 ec 30          	sub    $0x30,%rsp
  8004213ce5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004213ce8:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004213ceb:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004213cef:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004213cf3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213cfa:	e9 aa 00 00 00       	jmpq   8004213da9 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  8004213cff:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d02:	48 c1 e0 04          	shl    $0x4,%rax
  8004213d06:	48 89 c2             	mov    %rax,%rdx
  8004213d09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213d0d:	48 01 d0             	add    %rdx,%rax
  8004213d10:	8b 00                	mov    (%rax),%eax
  8004213d12:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004213d15:	0f 85 8a 00 00 00    	jne    8004213da5 <pci_attach_match+0xc8>
  8004213d1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d1e:	48 c1 e0 04          	shl    $0x4,%rax
  8004213d22:	48 89 c2             	mov    %rax,%rdx
  8004213d25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213d29:	48 01 d0             	add    %rdx,%rax
  8004213d2c:	8b 40 04             	mov    0x4(%rax),%eax
  8004213d2f:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004213d32:	75 71                	jne    8004213da5 <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  8004213d34:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d37:	48 c1 e0 04          	shl    $0x4,%rax
  8004213d3b:	48 89 c2             	mov    %rax,%rdx
  8004213d3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213d42:	48 01 d0             	add    %rdx,%rax
  8004213d45:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213d49:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213d4d:	48 89 d7             	mov    %rdx,%rdi
  8004213d50:	ff d0                	callq  *%rax
  8004213d52:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  8004213d55:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004213d59:	7e 05                	jle    8004213d60 <pci_attach_match+0x83>
				return r;
  8004213d5b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004213d5e:	eb 6c                	jmp    8004213dcc <pci_attach_match+0xef>
			if (r < 0)
  8004213d60:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004213d64:	79 3f                	jns    8004213da5 <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  8004213d66:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d69:	48 c1 e0 04          	shl    $0x4,%rax
  8004213d6d:	48 89 c2             	mov    %rax,%rdx
  8004213d70:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213d74:	48 01 d0             	add    %rdx,%rax
				cprintf("pci_attach_match: attaching "
  8004213d77:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004213d7b:	8b 75 f8             	mov    -0x8(%rbp),%esi
  8004213d7e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004213d81:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004213d84:	41 89 f0             	mov    %esi,%r8d
  8004213d87:	89 c6                	mov    %eax,%esi
  8004213d89:	48 bf e8 73 21 04 80 	movabs $0x80042173e8,%rdi
  8004213d90:	00 00 00 
  8004213d93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213d98:	49 b9 4a 95 20 04 80 	movabs $0x800420954a,%r9
  8004213d9f:	00 00 00 
  8004213da2:	41 ff d1             	callq  *%r9
	for (i = 0; list[i].attachfn; i++) {
  8004213da5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004213da9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213dac:	48 c1 e0 04          	shl    $0x4,%rax
  8004213db0:	48 89 c2             	mov    %rax,%rdx
  8004213db3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213db7:	48 01 d0             	add    %rdx,%rax
  8004213dba:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213dbe:	48 85 c0             	test   %rax,%rax
  8004213dc1:	0f 85 38 ff ff ff    	jne    8004213cff <pci_attach_match+0x22>
		}
	}
	return 0;
  8004213dc7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213dcc:	c9                   	leaveq 
  8004213dcd:	c3                   	retq   

0000008004213dce <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004213dce:	55                   	push   %rbp
  8004213dcf:	48 89 e5             	mov    %rsp,%rbp
  8004213dd2:	48 83 ec 10          	sub    $0x10,%rsp
  8004213dd6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004213dda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213dde:	8b 40 14             	mov    0x14(%rax),%eax
  8004213de1:	c1 e8 10             	shr    $0x10,%eax
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004213de4:	0f b6 c0             	movzbl %al,%eax
  8004213de7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213deb:	8b 52 14             	mov    0x14(%rdx),%edx
  8004213dee:	89 d7                	mov    %edx,%edi
  8004213df0:	c1 ef 18             	shr    $0x18,%edi
  8004213df3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213df7:	48 89 d1             	mov    %rdx,%rcx
  8004213dfa:	48 ba 60 88 22 04 80 	movabs $0x8004228860,%rdx
  8004213e01:	00 00 00 
  8004213e04:	89 c6                	mov    %eax,%esi
  8004213e06:	48 b8 dd 3c 21 04 80 	movabs $0x8004213cdd,%rax
  8004213e0d:	00 00 00 
  8004213e10:	ff d0                	callq  *%rax
				 &pci_attach_class[0], f) ||
  8004213e12:	85 c0                	test   %eax,%eax
  8004213e14:	75 39                	jne    8004213e4f <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  8004213e16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213e1a:	8b 40 10             	mov    0x10(%rax),%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
  8004213e1d:	c1 e8 10             	shr    $0x10,%eax
  8004213e20:	89 c6                	mov    %eax,%esi
  8004213e22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213e26:	8b 40 10             	mov    0x10(%rax),%eax
  8004213e29:	0f b7 c0             	movzwl %ax,%eax
  8004213e2c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213e30:	48 89 d1             	mov    %rdx,%rcx
  8004213e33:	48 ba 70 c7 57 04 80 	movabs $0x800457c770,%rdx
  8004213e3a:	00 00 00 
  8004213e3d:	89 c7                	mov    %eax,%edi
  8004213e3f:	48 b8 dd 3c 21 04 80 	movabs $0x8004213cdd,%rax
  8004213e46:	00 00 00 
  8004213e49:	ff d0                	callq  *%rax
				 &pci_attach_class[0], f) ||
  8004213e4b:	85 c0                	test   %eax,%eax
  8004213e4d:	74 07                	je     8004213e56 <pci_attach+0x88>
  8004213e4f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213e54:	eb 05                	jmp    8004213e5b <pci_attach+0x8d>
  8004213e56:	b8 00 00 00 00       	mov    $0x0,%eax
				 &pci_attach_vendor[0], f);
}
  8004213e5b:	c9                   	leaveq 
  8004213e5c:	c3                   	retq   

0000008004213e5d <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  8004213e5d:	55                   	push   %rbp
  8004213e5e:	48 89 e5             	mov    %rsp,%rbp
  8004213e61:	48 83 ec 20          	sub    $0x20,%rsp
  8004213e65:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  8004213e69:	48 b8 80 88 22 04 80 	movabs $0x8004228880,%rax
  8004213e70:	00 00 00 
  8004213e73:	48 8b 00             	mov    (%rax),%rax
  8004213e76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004213e7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e7e:	8b 40 14             	mov    0x14(%rax),%eax
  8004213e81:	c1 e8 18             	shr    $0x18,%eax
  8004213e84:	83 f8 06             	cmp    $0x6,%eax
  8004213e87:	77 20                	ja     8004213ea9 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004213e89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e8d:	8b 40 14             	mov    0x14(%rax),%eax
  8004213e90:	c1 e8 18             	shr    $0x18,%eax
  8004213e93:	89 c2                	mov    %eax,%edx
  8004213e95:	48 b8 80 88 22 04 80 	movabs $0x8004228880,%rax
  8004213e9c:	00 00 00 
  8004213e9f:	89 d2                	mov    %edx,%edx
  8004213ea1:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004213ea5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004213ea9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ead:	0f b6 40 48          	movzbl 0x48(%rax),%eax
	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004213eb1:	0f b6 f8             	movzbl %al,%edi
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004213eb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213eb8:	8b 40 14             	mov    0x14(%rax),%eax
  8004213ebb:	c1 e8 10             	shr    $0x10,%eax
	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004213ebe:	0f b6 f0             	movzbl %al,%esi
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004213ec1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ec5:	8b 40 14             	mov    0x14(%rax),%eax
	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004213ec8:	c1 e8 18             	shr    $0x18,%eax
  8004213ecb:	41 89 c1             	mov    %eax,%r9d
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004213ece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ed2:	8b 40 10             	mov    0x10(%rax),%eax
	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004213ed5:	c1 e8 10             	shr    $0x10,%eax
  8004213ed8:	41 89 c2             	mov    %eax,%r10d
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004213edb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213edf:	8b 40 10             	mov    0x10(%rax),%eax
	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004213ee2:	44 0f b7 c0          	movzwl %ax,%r8d
  8004213ee6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213eea:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004213eed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ef1:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004213ef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ef8:	48 8b 00             	mov    (%rax),%rax
	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004213efb:	8b 40 08             	mov    0x8(%rax),%eax
  8004213efe:	57                   	push   %rdi
  8004213eff:	ff 75 f8             	pushq  -0x8(%rbp)
  8004213f02:	56                   	push   %rsi
  8004213f03:	41 51                	push   %r9
  8004213f05:	45 89 d1             	mov    %r10d,%r9d
  8004213f08:	89 c6                	mov    %eax,%esi
  8004213f0a:	48 bf 88 74 21 04 80 	movabs $0x8004217488,%rdi
  8004213f11:	00 00 00 
  8004213f14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213f19:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  8004213f20:	00 00 00 
  8004213f23:	41 ff d2             	callq  *%r10
  8004213f26:	48 83 c4 20          	add    $0x20,%rsp
}
  8004213f2a:	c9                   	leaveq 
  8004213f2b:	c3                   	retq   

0000008004213f2c <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  8004213f2c:	55                   	push   %rbp
  8004213f2d:	48 89 e5             	mov    %rsp,%rbp
  8004213f30:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004213f37:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  8004213f3e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  8004213f45:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213f49:	ba 50 00 00 00       	mov    $0x50,%edx
  8004213f4e:	be 00 00 00 00       	mov    $0x0,%esi
  8004213f53:	48 89 c7             	mov    %rax,%rdi
  8004213f56:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004213f5d:	00 00 00 
  8004213f60:	ff d0                	callq  *%rax
	df.bus = bus;
  8004213f62:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004213f69:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004213f6d:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  8004213f74:	e9 23 02 00 00       	jmpq   800421419c <pci_scan_bus+0x270>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004213f79:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213f7d:	be 0c 00 00 00       	mov    $0xc,%esi
  8004213f82:	48 89 c7             	mov    %rax,%rdi
  8004213f85:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  8004213f8c:	00 00 00 
  8004213f8f:	ff d0                	callq  *%rax
  8004213f91:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  8004213f94:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004213f97:	c1 e8 10             	shr    $0x10,%eax
  8004213f9a:	83 e0 7f             	and    $0x7f,%eax
  8004213f9d:	83 f8 01             	cmp    $0x1,%eax
  8004213fa0:	0f 87 ed 01 00 00    	ja     8004214193 <pci_scan_bus+0x267>
			continue;

		totaldev++;
  8004213fa6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004213faa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213fae:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004213fb5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213fb9:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004213fc0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fc4:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004213fcb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213fcf:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004213fd6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213fda:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004213fe1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213fe5:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004213fec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213ff0:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004213ff7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213ffb:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004214002:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214006:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800421400d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214011:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004214018:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  800421401f:	00 00 00 
  8004214022:	e9 45 01 00 00       	jmpq   800421416c <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  8004214027:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800421402e:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004214035:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421403c:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004214043:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800421404a:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004214051:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004214058:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  800421405f:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004214066:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  800421406d:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214074:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421407b:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004214082:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004214086:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421408d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004214091:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004214098:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421409c:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042140a3:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  80042140a7:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  80042140ae:	be 00 00 00 00       	mov    $0x0,%esi
  80042140b3:	48 89 c7             	mov    %rax,%rdi
  80042140b6:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  80042140bd:	00 00 00 
  80042140c0:	ff d0                	callq  *%rax
  80042140c2:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  80042140c8:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  80042140ce:	0f b7 c0             	movzwl %ax,%eax
  80042140d1:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80042140d6:	0f 84 81 00 00 00    	je     800421415d <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  80042140dc:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042140e3:	be 3c 00 00 00       	mov    $0x3c,%esi
  80042140e8:	48 89 c7             	mov    %rax,%rdi
  80042140eb:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  80042140f2:	00 00 00 
  80042140f5:	ff d0                	callq  *%rax
  80042140f7:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  80042140fa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042140fd:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004214100:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004214107:	be 08 00 00 00       	mov    $0x8,%esi
  800421410c:	48 89 c7             	mov    %rax,%rdi
  800421410f:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  8004214116:	00 00 00 
  8004214119:	ff d0                	callq  *%rax
  800421411b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004214121:	48 b8 40 88 22 04 80 	movabs $0x8004228840,%rax
  8004214128:	00 00 00 
  800421412b:	8b 00                	mov    (%rax),%eax
  800421412d:	85 c0                	test   %eax,%eax
  800421412f:	74 16                	je     8004214147 <pci_scan_bus+0x21b>
				pci_print_func(&af);
  8004214131:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004214138:	48 89 c7             	mov    %rax,%rdi
  800421413b:	48 b8 5d 3e 21 04 80 	movabs $0x8004213e5d,%rax
  8004214142:	00 00 00 
  8004214145:	ff d0                	callq  *%rax
			pci_attach(&af);
  8004214147:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421414e:	48 89 c7             	mov    %rax,%rdi
  8004214151:	48 b8 ce 3d 21 04 80 	movabs $0x8004213dce,%rax
  8004214158:	00 00 00 
  800421415b:	ff d0                	callq  *%rax
		     f.func++) {
  800421415d:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004214163:	83 c0 01             	add    $0x1,%eax
  8004214166:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  800421416c:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004214172:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004214175:	81 e2 00 00 80 00    	and    $0x800000,%edx
  800421417b:	85 d2                	test   %edx,%edx
  800421417d:	74 07                	je     8004214186 <pci_scan_bus+0x25a>
  800421417f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214184:	eb 05                	jmp    800421418b <pci_scan_bus+0x25f>
  8004214186:	ba 01 00 00 00       	mov    $0x1,%edx
  800421418b:	39 d0                	cmp    %edx,%eax
  800421418d:	0f 82 94 fe ff ff    	jb     8004214027 <pci_scan_bus+0xfb>
	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004214193:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004214196:	83 c0 01             	add    $0x1,%eax
  8004214199:	89 45 a8             	mov    %eax,-0x58(%rbp)
  800421419c:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421419f:	83 f8 1f             	cmp    $0x1f,%eax
  80042141a2:	0f 86 d1 fd ff ff    	jbe    8004213f79 <pci_scan_bus+0x4d>
		}
	}

	return totaldev;
  80042141a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042141ab:	c9                   	leaveq 
  80042141ac:	c3                   	retq   

00000080042141ad <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  80042141ad:	55                   	push   %rbp
  80042141ae:	48 89 e5             	mov    %rsp,%rbp
  80042141b1:	48 83 ec 30          	sub    $0x30,%rsp
  80042141b5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  80042141b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042141bd:	be 1c 00 00 00       	mov    $0x1c,%esi
  80042141c2:	48 89 c7             	mov    %rax,%rdi
  80042141c5:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  80042141cc:	00 00 00 
  80042141cf:	ff d0                	callq  *%rax
  80042141d1:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  80042141d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042141d8:	be 18 00 00 00       	mov    $0x18,%esi
  80042141dd:	48 89 c7             	mov    %rax,%rdi
  80042141e0:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  80042141e7:	00 00 00 
  80042141ea:	ff d0                	callq  *%rax
  80042141ec:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  80042141ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042141f2:	83 e0 0f             	and    $0xf,%eax
  80042141f5:	83 f8 01             	cmp    $0x1,%eax
  80042141f8:	75 40                	jne    800421423a <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  80042141fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042141fe:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004214201:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214205:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004214208:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421420c:	48 8b 00             	mov    (%rax),%rax
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  800421420f:	8b 40 08             	mov    0x8(%rax),%eax
  8004214212:	89 c6                	mov    %eax,%esi
  8004214214:	48 bf c8 74 21 04 80 	movabs $0x80042174c8,%rdi
  800421421b:	00 00 00 
  800421421e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214223:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  800421422a:	00 00 00 
  800421422d:	41 ff d0             	callq  *%r8
		return 0;
  8004214230:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214235:	e9 a1 00 00 00       	jmpq   80042142db <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  800421423a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421423e:	ba 10 00 00 00       	mov    $0x10,%edx
  8004214243:	be 00 00 00 00       	mov    $0x0,%esi
  8004214248:	48 89 c7             	mov    %rax,%rdi
  800421424b:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  8004214252:	00 00 00 
  8004214255:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  8004214257:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421425b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  800421425f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004214262:	c1 e8 08             	shr    $0x8,%eax
  8004214265:	0f b6 c0             	movzbl %al,%eax
  8004214268:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  800421426b:	48 b8 40 88 22 04 80 	movabs $0x8004228840,%rax
  8004214272:	00 00 00 
  8004214275:	8b 00                	mov    (%rax),%eax
  8004214277:	85 c0                	test   %eax,%eax
  8004214279:	74 48                	je     80042142c3 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  800421427b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421427e:	c1 e8 10             	shr    $0x10,%eax
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004214281:	0f b6 f8             	movzbl %al,%edi
  8004214284:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8004214287:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421428b:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421428e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214292:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  8004214295:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214299:	48 8b 00             	mov    (%rax),%rax
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  800421429c:	8b 40 08             	mov    0x8(%rax),%eax
  800421429f:	41 89 f9             	mov    %edi,%r9d
  80042142a2:	41 89 f0             	mov    %esi,%r8d
  80042142a5:	89 c6                	mov    %eax,%esi
  80042142a7:	48 bf 00 75 21 04 80 	movabs $0x8004217500,%rdi
  80042142ae:	00 00 00 
  80042142b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042142b6:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  80042142bd:	00 00 00 
  80042142c0:	41 ff d2             	callq  *%r10

	pci_scan_bus(&nbus);
  80042142c3:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042142c7:	48 89 c7             	mov    %rax,%rdi
  80042142ca:	48 b8 2c 3f 21 04 80 	movabs $0x8004213f2c,%rax
  80042142d1:	00 00 00 
  80042142d4:	ff d0                	callq  *%rax
	return 1;
  80042142d6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042142db:	c9                   	leaveq 
  80042142dc:	c3                   	retq   

00000080042142dd <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  80042142dd:	55                   	push   %rbp
  80042142de:	48 89 e5             	mov    %rsp,%rbp
  80042142e1:	48 83 ec 30          	sub    $0x30,%rsp
  80042142e5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  80042142e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042142ed:	ba 07 00 00 00       	mov    $0x7,%edx
  80042142f2:	be 04 00 00 00       	mov    $0x4,%esi
  80042142f7:	48 89 c7             	mov    %rax,%rdi
  80042142fa:	48 b8 84 3c 21 04 80 	movabs $0x8004213c84,%rax
  8004214301:	00 00 00 
  8004214304:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004214306:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  800421430d:	e9 ee 01 00 00       	jmpq   8004214500 <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004214312:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004214315:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214319:	89 d6                	mov    %edx,%esi
  800421431b:	48 89 c7             	mov    %rax,%rdi
  800421431e:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  8004214325:	00 00 00 
  8004214328:	ff d0                	callq  *%rax
  800421432a:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  800421432d:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004214334:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004214337:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421433b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004214340:	89 ce                	mov    %ecx,%esi
  8004214342:	48 89 c7             	mov    %rax,%rdi
  8004214345:	48 b8 84 3c 21 04 80 	movabs $0x8004213c84,%rax
  800421434c:	00 00 00 
  800421434f:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004214351:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004214354:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214358:	89 d6                	mov    %edx,%esi
  800421435a:	48 89 c7             	mov    %rax,%rdi
  800421435d:	48 b8 2e 3c 21 04 80 	movabs $0x8004213c2e,%rax
  8004214364:	00 00 00 
  8004214367:	ff d0                	callq  *%rax
  8004214369:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  800421436c:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004214370:	75 05                	jne    8004214377 <pci_func_enable+0x9a>
			continue;
  8004214372:	e9 83 01 00 00       	jmpq   80042144fa <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  8004214377:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421437a:	83 e8 10             	sub    $0x10,%eax
  800421437d:	c1 e8 02             	shr    $0x2,%eax
  8004214380:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004214383:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004214386:	83 e0 01             	and    $0x1,%eax
  8004214389:	85 c0                	test   %eax,%eax
  800421438b:	75 65                	jne    80042143f2 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  800421438d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004214390:	83 e0 06             	and    $0x6,%eax
  8004214393:	83 f8 04             	cmp    $0x4,%eax
  8004214396:	75 07                	jne    800421439f <pci_func_enable+0xc2>
				bar_width = 8;
  8004214398:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  800421439f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042143a2:	83 e0 f0             	and    $0xfffffff0,%eax
  80042143a5:	f7 d8                	neg    %eax
  80042143a7:	23 45 e8             	and    -0x18(%rbp),%eax
  80042143aa:	83 e0 f0             	and    $0xfffffff0,%eax
  80042143ad:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  80042143b0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042143b3:	83 e0 f0             	and    $0xfffffff0,%eax
  80042143b6:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  80042143b9:	48 b8 80 c7 57 04 80 	movabs $0x800457c780,%rax
  80042143c0:	00 00 00 
  80042143c3:	8b 00                	mov    (%rax),%eax
  80042143c5:	85 c0                	test   %eax,%eax
  80042143c7:	74 7a                	je     8004214443 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  80042143c9:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80042143cc:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042143cf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042143d2:	89 c6                	mov    %eax,%esi
  80042143d4:	48 bf 30 75 21 04 80 	movabs $0x8004217530,%rdi
  80042143db:	00 00 00 
  80042143de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143e3:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  80042143ea:	00 00 00 
  80042143ed:	41 ff d0             	callq  *%r8
  80042143f0:	eb 51                	jmp    8004214443 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  80042143f2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042143f5:	83 e0 fc             	and    $0xfffffffc,%eax
  80042143f8:	f7 d8                	neg    %eax
  80042143fa:	23 45 e8             	and    -0x18(%rbp),%eax
  80042143fd:	83 e0 fc             	and    $0xfffffffc,%eax
  8004214400:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004214403:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004214406:	83 e0 fc             	and    $0xfffffffc,%eax
  8004214409:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  800421440c:	48 b8 80 c7 57 04 80 	movabs $0x800457c780,%rax
  8004214413:	00 00 00 
  8004214416:	8b 00                	mov    (%rax),%eax
  8004214418:	85 c0                	test   %eax,%eax
  800421441a:	74 27                	je     8004214443 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  800421441c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421441f:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004214422:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214425:	89 c6                	mov    %eax,%esi
  8004214427:	48 bf 58 75 21 04 80 	movabs $0x8004217558,%rdi
  800421442e:	00 00 00 
  8004214431:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214436:	49 b8 4a 95 20 04 80 	movabs $0x800420954a,%r8
  800421443d:	00 00 00 
  8004214440:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004214443:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214446:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004214449:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421444d:	89 ce                	mov    %ecx,%esi
  800421444f:	48 89 c7             	mov    %rax,%rdi
  8004214452:	48 b8 84 3c 21 04 80 	movabs $0x8004213c84,%rax
  8004214459:	00 00 00 
  800421445c:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  800421445e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214462:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214465:	48 63 d2             	movslq %edx,%rdx
  8004214468:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  800421446c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421446f:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004214473:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214477:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421447a:	48 63 d2             	movslq %edx,%rdx
  800421447d:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004214481:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004214484:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004214487:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  800421448b:	74 6d                	je     80042144fa <pci_func_enable+0x21d>
  800421448d:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004214491:	75 67                	jne    80042144fa <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004214493:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214497:	8b 40 10             	mov    0x10(%rax),%eax
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  800421449a:	c1 e8 10             	shr    $0x10,%eax
  800421449d:	41 89 c0             	mov    %eax,%r8d
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  80042144a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042144a4:	8b 40 10             	mov    0x10(%rax),%eax
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042144a7:	0f b7 f8             	movzwl %ax,%edi
  80042144aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042144ae:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042144b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042144b5:	8b 50 08             	mov    0x8(%rax),%edx
				f->bus->busno, f->dev, f->func,
  80042144b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042144bc:	48 8b 00             	mov    (%rax),%rax
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042144bf:	8b 40 08             	mov    0x8(%rax),%eax
  80042144c2:	48 83 ec 08          	sub    $0x8,%rsp
  80042144c6:	8b 75 f0             	mov    -0x10(%rbp),%esi
  80042144c9:	56                   	push   %rsi
  80042144ca:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80042144cd:	56                   	push   %rsi
  80042144ce:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  80042144d1:	56                   	push   %rsi
  80042144d2:	45 89 c1             	mov    %r8d,%r9d
  80042144d5:	41 89 f8             	mov    %edi,%r8d
  80042144d8:	89 c6                	mov    %eax,%esi
  80042144da:	48 bf 80 75 21 04 80 	movabs $0x8004217580,%rdi
  80042144e1:	00 00 00 
  80042144e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042144e9:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  80042144f0:	00 00 00 
  80042144f3:	41 ff d2             	callq  *%r10
  80042144f6:	48 83 c4 20          	add    $0x20,%rsp
	     bar += bar_width)
  80042144fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042144fd:	01 45 f8             	add    %eax,-0x8(%rbp)
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004214500:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004214504:	0f 86 08 fe ff ff    	jbe    8004214312 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  800421450a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421450e:	8b 40 10             	mov    0x10(%rax),%eax
	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004214511:	c1 e8 10             	shr    $0x10,%eax
  8004214514:	89 c7                	mov    %eax,%edi
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004214516:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421451a:	8b 40 10             	mov    0x10(%rax),%eax
	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  800421451d:	0f b7 f0             	movzwl %ax,%esi
  8004214520:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214524:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004214527:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421452b:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  800421452e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214532:	48 8b 00             	mov    (%rax),%rax
	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004214535:	8b 40 08             	mov    0x8(%rax),%eax
  8004214538:	41 89 f9             	mov    %edi,%r9d
  800421453b:	41 89 f0             	mov    %esi,%r8d
  800421453e:	89 c6                	mov    %eax,%esi
  8004214540:	48 bf e0 75 21 04 80 	movabs $0x80042175e0,%rdi
  8004214547:	00 00 00 
  800421454a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421454f:	49 ba 4a 95 20 04 80 	movabs $0x800420954a,%r10
  8004214556:	00 00 00 
  8004214559:	41 ff d2             	callq  *%r10
}
  800421455c:	c9                   	leaveq 
  800421455d:	c3                   	retq   

000000800421455e <pci_init>:

int
pci_init(void)
{
  800421455e:	55                   	push   %rbp
  800421455f:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004214562:	ba 10 00 00 00       	mov    $0x10,%edx
  8004214567:	be 00 00 00 00       	mov    $0x0,%esi
  800421456c:	48 bf 90 c7 57 04 80 	movabs $0x800457c790,%rdi
  8004214573:	00 00 00 
  8004214576:	48 b8 e8 c4 20 04 80 	movabs $0x800420c4e8,%rax
  800421457d:	00 00 00 
  8004214580:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004214582:	48 bf 90 c7 57 04 80 	movabs $0x800457c790,%rdi
  8004214589:	00 00 00 
  800421458c:	48 b8 2c 3f 21 04 80 	movabs $0x8004213f2c,%rax
  8004214593:	00 00 00 
  8004214596:	ff d0                	callq  *%rax
}
  8004214598:	5d                   	pop    %rbp
  8004214599:	c3                   	retq   

000000800421459a <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  800421459a:	55                   	push   %rbp
  800421459b:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  800421459e:	48 b8 a0 c7 57 04 80 	movabs $0x800457c7a0,%rax
  80042145a5:	00 00 00 
  80042145a8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  80042145ae:	5d                   	pop    %rbp
  80042145af:	c3                   	retq   

00000080042145b0 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  80042145b0:	55                   	push   %rbp
  80042145b1:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  80042145b4:	48 b8 a0 c7 57 04 80 	movabs $0x800457c7a0,%rax
  80042145bb:	00 00 00 
  80042145be:	8b 00                	mov    (%rax),%eax
  80042145c0:	8d 50 01             	lea    0x1(%rax),%edx
  80042145c3:	48 b8 a0 c7 57 04 80 	movabs $0x800457c7a0,%rax
  80042145ca:	00 00 00 
  80042145cd:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  80042145cf:	48 b8 a0 c7 57 04 80 	movabs $0x800457c7a0,%rax
  80042145d6:	00 00 00 
  80042145d9:	8b 10                	mov    (%rax),%edx
  80042145db:	89 d0                	mov    %edx,%eax
  80042145dd:	c1 e0 02             	shl    $0x2,%eax
  80042145e0:	01 d0                	add    %edx,%eax
  80042145e2:	01 c0                	add    %eax,%eax
  80042145e4:	89 c2                	mov    %eax,%edx
  80042145e6:	48 b8 a0 c7 57 04 80 	movabs $0x800457c7a0,%rax
  80042145ed:	00 00 00 
  80042145f0:	8b 00                	mov    (%rax),%eax
  80042145f2:	39 c2                	cmp    %eax,%edx
  80042145f4:	73 2a                	jae    8004214620 <time_tick+0x70>
		panic("time_tick: time overflowed");
  80042145f6:	48 ba 0f 76 21 04 80 	movabs $0x800421760f,%rdx
  80042145fd:	00 00 00 
  8004214600:	be 13 00 00 00       	mov    $0x13,%esi
  8004214605:	48 bf 2a 76 21 04 80 	movabs $0x800421762a,%rdi
  800421460c:	00 00 00 
  800421460f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214614:	48 b9 a6 05 20 04 80 	movabs $0x80042005a6,%rcx
  800421461b:	00 00 00 
  800421461e:	ff d1                	callq  *%rcx
}
  8004214620:	5d                   	pop    %rbp
  8004214621:	c3                   	retq   

0000008004214622 <time_msec>:

unsigned int
time_msec(void)
{
  8004214622:	55                   	push   %rbp
  8004214623:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004214626:	48 b8 a0 c7 57 04 80 	movabs $0x800457c7a0,%rax
  800421462d:	00 00 00 
  8004214630:	8b 10                	mov    (%rax),%edx
  8004214632:	89 d0                	mov    %edx,%eax
  8004214634:	c1 e0 02             	shl    $0x2,%eax
  8004214637:	01 d0                	add    %edx,%eax
  8004214639:	01 c0                	add    %eax,%eax
}
  800421463b:	5d                   	pop    %rbp
  800421463c:	c3                   	retq   
